
Discovery-FreeRTOS-LwIP-DP83848.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000e59c  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000ceac  0800e72c  0800e72c  0001e72c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0801b5d8  0801b5d8  0002b5d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0801b5dc  0801b5dc  0002b5dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000005c  20000000  0801b5e0  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .co_stack     00000800  2000005c  0801b63c  0003005c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  0003085c  2**0
                  CONTENTS
  8 .bss          00009b38  2000085c  2000085c  0003085c  2**2
                  ALLOC
  9 ._user_heap_stack 00000400  2000a394  2000a394  0003085c  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  0003085c  2**0
                  CONTENTS, READONLY
 11 .debug_info   0002c39f  00000000  00000000  0003088c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000062f3  00000000  00000000  0005cc2b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001760  00000000  00000000  00062f1e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000014d8  00000000  00000000  0006467e  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000bdbf  00000000  00000000  00065b56  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000072cd  00000000  00000000  00071915  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  00078be2  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00005f34  00000000  00000000  00078c60  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	2000085c 	.word	0x2000085c
 80001ac:	00000000 	.word	0x00000000
 80001b0:	0800e714 	.word	0x0800e714

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000860 	.word	0x20000860
 80001cc:	0800e714 	.word	0x0800e714

080001d0 <strcmp>:
 80001d0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001d4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001d8:	2a01      	cmp	r2, #1
 80001da:	bf28      	it	cs
 80001dc:	429a      	cmpcs	r2, r3
 80001de:	d0f7      	beq.n	80001d0 <strcmp>
 80001e0:	1ad0      	subs	r0, r2, r3
 80001e2:	4770      	bx	lr

080001e4 <strlen>:
 80001e4:	4603      	mov	r3, r0
 80001e6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001ea:	2a00      	cmp	r2, #0
 80001ec:	d1fb      	bne.n	80001e6 <strlen+0x2>
 80001ee:	1a18      	subs	r0, r3, r0
 80001f0:	3801      	subs	r0, #1
 80001f2:	4770      	bx	lr

080001f4 <__aeabi_drsub>:
 80001f4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80001f8:	e002      	b.n	8000200 <__adddf3>
 80001fa:	bf00      	nop

080001fc <__aeabi_dsub>:
 80001fc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000200 <__adddf3>:
 8000200:	b530      	push	{r4, r5, lr}
 8000202:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000206:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800020a:	ea94 0f05 	teq	r4, r5
 800020e:	bf08      	it	eq
 8000210:	ea90 0f02 	teqeq	r0, r2
 8000214:	bf1f      	itttt	ne
 8000216:	ea54 0c00 	orrsne.w	ip, r4, r0
 800021a:	ea55 0c02 	orrsne.w	ip, r5, r2
 800021e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000222:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000226:	f000 80e2 	beq.w	80003ee <__adddf3+0x1ee>
 800022a:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800022e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000232:	bfb8      	it	lt
 8000234:	426d      	neglt	r5, r5
 8000236:	dd0c      	ble.n	8000252 <__adddf3+0x52>
 8000238:	442c      	add	r4, r5
 800023a:	ea80 0202 	eor.w	r2, r0, r2
 800023e:	ea81 0303 	eor.w	r3, r1, r3
 8000242:	ea82 0000 	eor.w	r0, r2, r0
 8000246:	ea83 0101 	eor.w	r1, r3, r1
 800024a:	ea80 0202 	eor.w	r2, r0, r2
 800024e:	ea81 0303 	eor.w	r3, r1, r3
 8000252:	2d36      	cmp	r5, #54	; 0x36
 8000254:	bf88      	it	hi
 8000256:	bd30      	pophi	{r4, r5, pc}
 8000258:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800025c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000260:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000264:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000268:	d002      	beq.n	8000270 <__adddf3+0x70>
 800026a:	4240      	negs	r0, r0
 800026c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000270:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000274:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000278:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800027c:	d002      	beq.n	8000284 <__adddf3+0x84>
 800027e:	4252      	negs	r2, r2
 8000280:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000284:	ea94 0f05 	teq	r4, r5
 8000288:	f000 80a7 	beq.w	80003da <__adddf3+0x1da>
 800028c:	f1a4 0401 	sub.w	r4, r4, #1
 8000290:	f1d5 0e20 	rsbs	lr, r5, #32
 8000294:	db0d      	blt.n	80002b2 <__adddf3+0xb2>
 8000296:	fa02 fc0e 	lsl.w	ip, r2, lr
 800029a:	fa22 f205 	lsr.w	r2, r2, r5
 800029e:	1880      	adds	r0, r0, r2
 80002a0:	f141 0100 	adc.w	r1, r1, #0
 80002a4:	fa03 f20e 	lsl.w	r2, r3, lr
 80002a8:	1880      	adds	r0, r0, r2
 80002aa:	fa43 f305 	asr.w	r3, r3, r5
 80002ae:	4159      	adcs	r1, r3
 80002b0:	e00e      	b.n	80002d0 <__adddf3+0xd0>
 80002b2:	f1a5 0520 	sub.w	r5, r5, #32
 80002b6:	f10e 0e20 	add.w	lr, lr, #32
 80002ba:	2a01      	cmp	r2, #1
 80002bc:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002c0:	bf28      	it	cs
 80002c2:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002c6:	fa43 f305 	asr.w	r3, r3, r5
 80002ca:	18c0      	adds	r0, r0, r3
 80002cc:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002d0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80002d4:	d507      	bpl.n	80002e6 <__adddf3+0xe6>
 80002d6:	f04f 0e00 	mov.w	lr, #0
 80002da:	f1dc 0c00 	rsbs	ip, ip, #0
 80002de:	eb7e 0000 	sbcs.w	r0, lr, r0
 80002e2:	eb6e 0101 	sbc.w	r1, lr, r1
 80002e6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80002ea:	d31b      	bcc.n	8000324 <__adddf3+0x124>
 80002ec:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80002f0:	d30c      	bcc.n	800030c <__adddf3+0x10c>
 80002f2:	0849      	lsrs	r1, r1, #1
 80002f4:	ea5f 0030 	movs.w	r0, r0, rrx
 80002f8:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80002fc:	f104 0401 	add.w	r4, r4, #1
 8000300:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000304:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000308:	f080 809a 	bcs.w	8000440 <__adddf3+0x240>
 800030c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000310:	bf08      	it	eq
 8000312:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000316:	f150 0000 	adcs.w	r0, r0, #0
 800031a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800031e:	ea41 0105 	orr.w	r1, r1, r5
 8000322:	bd30      	pop	{r4, r5, pc}
 8000324:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000328:	4140      	adcs	r0, r0
 800032a:	eb41 0101 	adc.w	r1, r1, r1
 800032e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000332:	f1a4 0401 	sub.w	r4, r4, #1
 8000336:	d1e9      	bne.n	800030c <__adddf3+0x10c>
 8000338:	f091 0f00 	teq	r1, #0
 800033c:	bf04      	itt	eq
 800033e:	4601      	moveq	r1, r0
 8000340:	2000      	moveq	r0, #0
 8000342:	fab1 f381 	clz	r3, r1
 8000346:	bf08      	it	eq
 8000348:	3320      	addeq	r3, #32
 800034a:	f1a3 030b 	sub.w	r3, r3, #11
 800034e:	f1b3 0220 	subs.w	r2, r3, #32
 8000352:	da0c      	bge.n	800036e <__adddf3+0x16e>
 8000354:	320c      	adds	r2, #12
 8000356:	dd08      	ble.n	800036a <__adddf3+0x16a>
 8000358:	f102 0c14 	add.w	ip, r2, #20
 800035c:	f1c2 020c 	rsb	r2, r2, #12
 8000360:	fa01 f00c 	lsl.w	r0, r1, ip
 8000364:	fa21 f102 	lsr.w	r1, r1, r2
 8000368:	e00c      	b.n	8000384 <__adddf3+0x184>
 800036a:	f102 0214 	add.w	r2, r2, #20
 800036e:	bfd8      	it	le
 8000370:	f1c2 0c20 	rsble	ip, r2, #32
 8000374:	fa01 f102 	lsl.w	r1, r1, r2
 8000378:	fa20 fc0c 	lsr.w	ip, r0, ip
 800037c:	bfdc      	itt	le
 800037e:	ea41 010c 	orrle.w	r1, r1, ip
 8000382:	4090      	lslle	r0, r2
 8000384:	1ae4      	subs	r4, r4, r3
 8000386:	bfa2      	ittt	ge
 8000388:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800038c:	4329      	orrge	r1, r5
 800038e:	bd30      	popge	{r4, r5, pc}
 8000390:	ea6f 0404 	mvn.w	r4, r4
 8000394:	3c1f      	subs	r4, #31
 8000396:	da1c      	bge.n	80003d2 <__adddf3+0x1d2>
 8000398:	340c      	adds	r4, #12
 800039a:	dc0e      	bgt.n	80003ba <__adddf3+0x1ba>
 800039c:	f104 0414 	add.w	r4, r4, #20
 80003a0:	f1c4 0220 	rsb	r2, r4, #32
 80003a4:	fa20 f004 	lsr.w	r0, r0, r4
 80003a8:	fa01 f302 	lsl.w	r3, r1, r2
 80003ac:	ea40 0003 	orr.w	r0, r0, r3
 80003b0:	fa21 f304 	lsr.w	r3, r1, r4
 80003b4:	ea45 0103 	orr.w	r1, r5, r3
 80003b8:	bd30      	pop	{r4, r5, pc}
 80003ba:	f1c4 040c 	rsb	r4, r4, #12
 80003be:	f1c4 0220 	rsb	r2, r4, #32
 80003c2:	fa20 f002 	lsr.w	r0, r0, r2
 80003c6:	fa01 f304 	lsl.w	r3, r1, r4
 80003ca:	ea40 0003 	orr.w	r0, r0, r3
 80003ce:	4629      	mov	r1, r5
 80003d0:	bd30      	pop	{r4, r5, pc}
 80003d2:	fa21 f004 	lsr.w	r0, r1, r4
 80003d6:	4629      	mov	r1, r5
 80003d8:	bd30      	pop	{r4, r5, pc}
 80003da:	f094 0f00 	teq	r4, #0
 80003de:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80003e2:	bf06      	itte	eq
 80003e4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80003e8:	3401      	addeq	r4, #1
 80003ea:	3d01      	subne	r5, #1
 80003ec:	e74e      	b.n	800028c <__adddf3+0x8c>
 80003ee:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003f2:	bf18      	it	ne
 80003f4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80003f8:	d029      	beq.n	800044e <__adddf3+0x24e>
 80003fa:	ea94 0f05 	teq	r4, r5
 80003fe:	bf08      	it	eq
 8000400:	ea90 0f02 	teqeq	r0, r2
 8000404:	d005      	beq.n	8000412 <__adddf3+0x212>
 8000406:	ea54 0c00 	orrs.w	ip, r4, r0
 800040a:	bf04      	itt	eq
 800040c:	4619      	moveq	r1, r3
 800040e:	4610      	moveq	r0, r2
 8000410:	bd30      	pop	{r4, r5, pc}
 8000412:	ea91 0f03 	teq	r1, r3
 8000416:	bf1e      	ittt	ne
 8000418:	2100      	movne	r1, #0
 800041a:	2000      	movne	r0, #0
 800041c:	bd30      	popne	{r4, r5, pc}
 800041e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000422:	d105      	bne.n	8000430 <__adddf3+0x230>
 8000424:	0040      	lsls	r0, r0, #1
 8000426:	4149      	adcs	r1, r1
 8000428:	bf28      	it	cs
 800042a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800042e:	bd30      	pop	{r4, r5, pc}
 8000430:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000434:	bf3c      	itt	cc
 8000436:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800043a:	bd30      	popcc	{r4, r5, pc}
 800043c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000440:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000444:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000448:	f04f 0000 	mov.w	r0, #0
 800044c:	bd30      	pop	{r4, r5, pc}
 800044e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000452:	bf1a      	itte	ne
 8000454:	4619      	movne	r1, r3
 8000456:	4610      	movne	r0, r2
 8000458:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800045c:	bf1c      	itt	ne
 800045e:	460b      	movne	r3, r1
 8000460:	4602      	movne	r2, r0
 8000462:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000466:	bf06      	itte	eq
 8000468:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800046c:	ea91 0f03 	teqeq	r1, r3
 8000470:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	bf00      	nop

08000478 <__aeabi_ui2d>:
 8000478:	f090 0f00 	teq	r0, #0
 800047c:	bf04      	itt	eq
 800047e:	2100      	moveq	r1, #0
 8000480:	4770      	bxeq	lr
 8000482:	b530      	push	{r4, r5, lr}
 8000484:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000488:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800048c:	f04f 0500 	mov.w	r5, #0
 8000490:	f04f 0100 	mov.w	r1, #0
 8000494:	e750      	b.n	8000338 <__adddf3+0x138>
 8000496:	bf00      	nop

08000498 <__aeabi_i2d>:
 8000498:	f090 0f00 	teq	r0, #0
 800049c:	bf04      	itt	eq
 800049e:	2100      	moveq	r1, #0
 80004a0:	4770      	bxeq	lr
 80004a2:	b530      	push	{r4, r5, lr}
 80004a4:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004a8:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004ac:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80004b0:	bf48      	it	mi
 80004b2:	4240      	negmi	r0, r0
 80004b4:	f04f 0100 	mov.w	r1, #0
 80004b8:	e73e      	b.n	8000338 <__adddf3+0x138>
 80004ba:	bf00      	nop

080004bc <__aeabi_f2d>:
 80004bc:	0042      	lsls	r2, r0, #1
 80004be:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004c2:	ea4f 0131 	mov.w	r1, r1, rrx
 80004c6:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004ca:	bf1f      	itttt	ne
 80004cc:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80004d0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80004d4:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80004d8:	4770      	bxne	lr
 80004da:	f092 0f00 	teq	r2, #0
 80004de:	bf14      	ite	ne
 80004e0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80004e4:	4770      	bxeq	lr
 80004e6:	b530      	push	{r4, r5, lr}
 80004e8:	f44f 7460 	mov.w	r4, #896	; 0x380
 80004ec:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004f0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80004f4:	e720      	b.n	8000338 <__adddf3+0x138>
 80004f6:	bf00      	nop

080004f8 <__aeabi_ul2d>:
 80004f8:	ea50 0201 	orrs.w	r2, r0, r1
 80004fc:	bf08      	it	eq
 80004fe:	4770      	bxeq	lr
 8000500:	b530      	push	{r4, r5, lr}
 8000502:	f04f 0500 	mov.w	r5, #0
 8000506:	e00a      	b.n	800051e <__aeabi_l2d+0x16>

08000508 <__aeabi_l2d>:
 8000508:	ea50 0201 	orrs.w	r2, r0, r1
 800050c:	bf08      	it	eq
 800050e:	4770      	bxeq	lr
 8000510:	b530      	push	{r4, r5, lr}
 8000512:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000516:	d502      	bpl.n	800051e <__aeabi_l2d+0x16>
 8000518:	4240      	negs	r0, r0
 800051a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800051e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000522:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000526:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800052a:	f43f aedc 	beq.w	80002e6 <__adddf3+0xe6>
 800052e:	f04f 0203 	mov.w	r2, #3
 8000532:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000536:	bf18      	it	ne
 8000538:	3203      	addne	r2, #3
 800053a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800053e:	bf18      	it	ne
 8000540:	3203      	addne	r2, #3
 8000542:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000546:	f1c2 0320 	rsb	r3, r2, #32
 800054a:	fa00 fc03 	lsl.w	ip, r0, r3
 800054e:	fa20 f002 	lsr.w	r0, r0, r2
 8000552:	fa01 fe03 	lsl.w	lr, r1, r3
 8000556:	ea40 000e 	orr.w	r0, r0, lr
 800055a:	fa21 f102 	lsr.w	r1, r1, r2
 800055e:	4414      	add	r4, r2
 8000560:	e6c1      	b.n	80002e6 <__adddf3+0xe6>
 8000562:	bf00      	nop

08000564 <__aeabi_dmul>:
 8000564:	b570      	push	{r4, r5, r6, lr}
 8000566:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800056a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800056e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000572:	bf1d      	ittte	ne
 8000574:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000578:	ea94 0f0c 	teqne	r4, ip
 800057c:	ea95 0f0c 	teqne	r5, ip
 8000580:	f000 f8de 	bleq	8000740 <__aeabi_dmul+0x1dc>
 8000584:	442c      	add	r4, r5
 8000586:	ea81 0603 	eor.w	r6, r1, r3
 800058a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800058e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000592:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000596:	bf18      	it	ne
 8000598:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800059c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80005a0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80005a4:	d038      	beq.n	8000618 <__aeabi_dmul+0xb4>
 80005a6:	fba0 ce02 	umull	ip, lr, r0, r2
 80005aa:	f04f 0500 	mov.w	r5, #0
 80005ae:	fbe1 e502 	umlal	lr, r5, r1, r2
 80005b2:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80005b6:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005ba:	f04f 0600 	mov.w	r6, #0
 80005be:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005c2:	f09c 0f00 	teq	ip, #0
 80005c6:	bf18      	it	ne
 80005c8:	f04e 0e01 	orrne.w	lr, lr, #1
 80005cc:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80005d0:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80005d4:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80005d8:	d204      	bcs.n	80005e4 <__aeabi_dmul+0x80>
 80005da:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80005de:	416d      	adcs	r5, r5
 80005e0:	eb46 0606 	adc.w	r6, r6, r6
 80005e4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80005e8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80005ec:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80005f0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80005f4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80005f8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80005fc:	bf88      	it	hi
 80005fe:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000602:	d81e      	bhi.n	8000642 <__aeabi_dmul+0xde>
 8000604:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000608:	bf08      	it	eq
 800060a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800060e:	f150 0000 	adcs.w	r0, r0, #0
 8000612:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000616:	bd70      	pop	{r4, r5, r6, pc}
 8000618:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800061c:	ea46 0101 	orr.w	r1, r6, r1
 8000620:	ea40 0002 	orr.w	r0, r0, r2
 8000624:	ea81 0103 	eor.w	r1, r1, r3
 8000628:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800062c:	bfc2      	ittt	gt
 800062e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000632:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000636:	bd70      	popgt	{r4, r5, r6, pc}
 8000638:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800063c:	f04f 0e00 	mov.w	lr, #0
 8000640:	3c01      	subs	r4, #1
 8000642:	f300 80ab 	bgt.w	800079c <__aeabi_dmul+0x238>
 8000646:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800064a:	bfde      	ittt	le
 800064c:	2000      	movle	r0, #0
 800064e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000652:	bd70      	pople	{r4, r5, r6, pc}
 8000654:	f1c4 0400 	rsb	r4, r4, #0
 8000658:	3c20      	subs	r4, #32
 800065a:	da35      	bge.n	80006c8 <__aeabi_dmul+0x164>
 800065c:	340c      	adds	r4, #12
 800065e:	dc1b      	bgt.n	8000698 <__aeabi_dmul+0x134>
 8000660:	f104 0414 	add.w	r4, r4, #20
 8000664:	f1c4 0520 	rsb	r5, r4, #32
 8000668:	fa00 f305 	lsl.w	r3, r0, r5
 800066c:	fa20 f004 	lsr.w	r0, r0, r4
 8000670:	fa01 f205 	lsl.w	r2, r1, r5
 8000674:	ea40 0002 	orr.w	r0, r0, r2
 8000678:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800067c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000680:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000684:	fa21 f604 	lsr.w	r6, r1, r4
 8000688:	eb42 0106 	adc.w	r1, r2, r6
 800068c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000690:	bf08      	it	eq
 8000692:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000696:	bd70      	pop	{r4, r5, r6, pc}
 8000698:	f1c4 040c 	rsb	r4, r4, #12
 800069c:	f1c4 0520 	rsb	r5, r4, #32
 80006a0:	fa00 f304 	lsl.w	r3, r0, r4
 80006a4:	fa20 f005 	lsr.w	r0, r0, r5
 80006a8:	fa01 f204 	lsl.w	r2, r1, r4
 80006ac:	ea40 0002 	orr.w	r0, r0, r2
 80006b0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006b4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006b8:	f141 0100 	adc.w	r1, r1, #0
 80006bc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006c0:	bf08      	it	eq
 80006c2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006c6:	bd70      	pop	{r4, r5, r6, pc}
 80006c8:	f1c4 0520 	rsb	r5, r4, #32
 80006cc:	fa00 f205 	lsl.w	r2, r0, r5
 80006d0:	ea4e 0e02 	orr.w	lr, lr, r2
 80006d4:	fa20 f304 	lsr.w	r3, r0, r4
 80006d8:	fa01 f205 	lsl.w	r2, r1, r5
 80006dc:	ea43 0302 	orr.w	r3, r3, r2
 80006e0:	fa21 f004 	lsr.w	r0, r1, r4
 80006e4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006e8:	fa21 f204 	lsr.w	r2, r1, r4
 80006ec:	ea20 0002 	bic.w	r0, r0, r2
 80006f0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80006f4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006f8:	bf08      	it	eq
 80006fa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006fe:	bd70      	pop	{r4, r5, r6, pc}
 8000700:	f094 0f00 	teq	r4, #0
 8000704:	d10f      	bne.n	8000726 <__aeabi_dmul+0x1c2>
 8000706:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800070a:	0040      	lsls	r0, r0, #1
 800070c:	eb41 0101 	adc.w	r1, r1, r1
 8000710:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000714:	bf08      	it	eq
 8000716:	3c01      	subeq	r4, #1
 8000718:	d0f7      	beq.n	800070a <__aeabi_dmul+0x1a6>
 800071a:	ea41 0106 	orr.w	r1, r1, r6
 800071e:	f095 0f00 	teq	r5, #0
 8000722:	bf18      	it	ne
 8000724:	4770      	bxne	lr
 8000726:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800072a:	0052      	lsls	r2, r2, #1
 800072c:	eb43 0303 	adc.w	r3, r3, r3
 8000730:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000734:	bf08      	it	eq
 8000736:	3d01      	subeq	r5, #1
 8000738:	d0f7      	beq.n	800072a <__aeabi_dmul+0x1c6>
 800073a:	ea43 0306 	orr.w	r3, r3, r6
 800073e:	4770      	bx	lr
 8000740:	ea94 0f0c 	teq	r4, ip
 8000744:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000748:	bf18      	it	ne
 800074a:	ea95 0f0c 	teqne	r5, ip
 800074e:	d00c      	beq.n	800076a <__aeabi_dmul+0x206>
 8000750:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000754:	bf18      	it	ne
 8000756:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800075a:	d1d1      	bne.n	8000700 <__aeabi_dmul+0x19c>
 800075c:	ea81 0103 	eor.w	r1, r1, r3
 8000760:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000764:	f04f 0000 	mov.w	r0, #0
 8000768:	bd70      	pop	{r4, r5, r6, pc}
 800076a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800076e:	bf06      	itte	eq
 8000770:	4610      	moveq	r0, r2
 8000772:	4619      	moveq	r1, r3
 8000774:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000778:	d019      	beq.n	80007ae <__aeabi_dmul+0x24a>
 800077a:	ea94 0f0c 	teq	r4, ip
 800077e:	d102      	bne.n	8000786 <__aeabi_dmul+0x222>
 8000780:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000784:	d113      	bne.n	80007ae <__aeabi_dmul+0x24a>
 8000786:	ea95 0f0c 	teq	r5, ip
 800078a:	d105      	bne.n	8000798 <__aeabi_dmul+0x234>
 800078c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000790:	bf1c      	itt	ne
 8000792:	4610      	movne	r0, r2
 8000794:	4619      	movne	r1, r3
 8000796:	d10a      	bne.n	80007ae <__aeabi_dmul+0x24a>
 8000798:	ea81 0103 	eor.w	r1, r1, r3
 800079c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007a0:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007a4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80007a8:	f04f 0000 	mov.w	r0, #0
 80007ac:	bd70      	pop	{r4, r5, r6, pc}
 80007ae:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007b2:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80007b6:	bd70      	pop	{r4, r5, r6, pc}

080007b8 <__aeabi_ddiv>:
 80007b8:	b570      	push	{r4, r5, r6, lr}
 80007ba:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80007be:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80007c2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007c6:	bf1d      	ittte	ne
 80007c8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007cc:	ea94 0f0c 	teqne	r4, ip
 80007d0:	ea95 0f0c 	teqne	r5, ip
 80007d4:	f000 f8a7 	bleq	8000926 <__aeabi_ddiv+0x16e>
 80007d8:	eba4 0405 	sub.w	r4, r4, r5
 80007dc:	ea81 0e03 	eor.w	lr, r1, r3
 80007e0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80007e4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80007e8:	f000 8088 	beq.w	80008fc <__aeabi_ddiv+0x144>
 80007ec:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80007f0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80007f4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80007f8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80007fc:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000800:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000804:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000808:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800080c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000810:	429d      	cmp	r5, r3
 8000812:	bf08      	it	eq
 8000814:	4296      	cmpeq	r6, r2
 8000816:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800081a:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800081e:	d202      	bcs.n	8000826 <__aeabi_ddiv+0x6e>
 8000820:	085b      	lsrs	r3, r3, #1
 8000822:	ea4f 0232 	mov.w	r2, r2, rrx
 8000826:	1ab6      	subs	r6, r6, r2
 8000828:	eb65 0503 	sbc.w	r5, r5, r3
 800082c:	085b      	lsrs	r3, r3, #1
 800082e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000832:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000836:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800083a:	ebb6 0e02 	subs.w	lr, r6, r2
 800083e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000842:	bf22      	ittt	cs
 8000844:	1ab6      	subcs	r6, r6, r2
 8000846:	4675      	movcs	r5, lr
 8000848:	ea40 000c 	orrcs.w	r0, r0, ip
 800084c:	085b      	lsrs	r3, r3, #1
 800084e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000852:	ebb6 0e02 	subs.w	lr, r6, r2
 8000856:	eb75 0e03 	sbcs.w	lr, r5, r3
 800085a:	bf22      	ittt	cs
 800085c:	1ab6      	subcs	r6, r6, r2
 800085e:	4675      	movcs	r5, lr
 8000860:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000864:	085b      	lsrs	r3, r3, #1
 8000866:	ea4f 0232 	mov.w	r2, r2, rrx
 800086a:	ebb6 0e02 	subs.w	lr, r6, r2
 800086e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000872:	bf22      	ittt	cs
 8000874:	1ab6      	subcs	r6, r6, r2
 8000876:	4675      	movcs	r5, lr
 8000878:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800087c:	085b      	lsrs	r3, r3, #1
 800087e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000882:	ebb6 0e02 	subs.w	lr, r6, r2
 8000886:	eb75 0e03 	sbcs.w	lr, r5, r3
 800088a:	bf22      	ittt	cs
 800088c:	1ab6      	subcs	r6, r6, r2
 800088e:	4675      	movcs	r5, lr
 8000890:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000894:	ea55 0e06 	orrs.w	lr, r5, r6
 8000898:	d018      	beq.n	80008cc <__aeabi_ddiv+0x114>
 800089a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800089e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80008a2:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80008a6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80008aa:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80008ae:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80008b2:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008b6:	d1c0      	bne.n	800083a <__aeabi_ddiv+0x82>
 80008b8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008bc:	d10b      	bne.n	80008d6 <__aeabi_ddiv+0x11e>
 80008be:	ea41 0100 	orr.w	r1, r1, r0
 80008c2:	f04f 0000 	mov.w	r0, #0
 80008c6:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80008ca:	e7b6      	b.n	800083a <__aeabi_ddiv+0x82>
 80008cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008d0:	bf04      	itt	eq
 80008d2:	4301      	orreq	r1, r0
 80008d4:	2000      	moveq	r0, #0
 80008d6:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80008da:	bf88      	it	hi
 80008dc:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80008e0:	f63f aeaf 	bhi.w	8000642 <__aeabi_dmul+0xde>
 80008e4:	ebb5 0c03 	subs.w	ip, r5, r3
 80008e8:	bf04      	itt	eq
 80008ea:	ebb6 0c02 	subseq.w	ip, r6, r2
 80008ee:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80008f2:	f150 0000 	adcs.w	r0, r0, #0
 80008f6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80008fa:	bd70      	pop	{r4, r5, r6, pc}
 80008fc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000900:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000904:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000908:	bfc2      	ittt	gt
 800090a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800090e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000912:	bd70      	popgt	{r4, r5, r6, pc}
 8000914:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000918:	f04f 0e00 	mov.w	lr, #0
 800091c:	3c01      	subs	r4, #1
 800091e:	e690      	b.n	8000642 <__aeabi_dmul+0xde>
 8000920:	ea45 0e06 	orr.w	lr, r5, r6
 8000924:	e68d      	b.n	8000642 <__aeabi_dmul+0xde>
 8000926:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800092a:	ea94 0f0c 	teq	r4, ip
 800092e:	bf08      	it	eq
 8000930:	ea95 0f0c 	teqeq	r5, ip
 8000934:	f43f af3b 	beq.w	80007ae <__aeabi_dmul+0x24a>
 8000938:	ea94 0f0c 	teq	r4, ip
 800093c:	d10a      	bne.n	8000954 <__aeabi_ddiv+0x19c>
 800093e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000942:	f47f af34 	bne.w	80007ae <__aeabi_dmul+0x24a>
 8000946:	ea95 0f0c 	teq	r5, ip
 800094a:	f47f af25 	bne.w	8000798 <__aeabi_dmul+0x234>
 800094e:	4610      	mov	r0, r2
 8000950:	4619      	mov	r1, r3
 8000952:	e72c      	b.n	80007ae <__aeabi_dmul+0x24a>
 8000954:	ea95 0f0c 	teq	r5, ip
 8000958:	d106      	bne.n	8000968 <__aeabi_ddiv+0x1b0>
 800095a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800095e:	f43f aefd 	beq.w	800075c <__aeabi_dmul+0x1f8>
 8000962:	4610      	mov	r0, r2
 8000964:	4619      	mov	r1, r3
 8000966:	e722      	b.n	80007ae <__aeabi_dmul+0x24a>
 8000968:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800096c:	bf18      	it	ne
 800096e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000972:	f47f aec5 	bne.w	8000700 <__aeabi_dmul+0x19c>
 8000976:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800097a:	f47f af0d 	bne.w	8000798 <__aeabi_dmul+0x234>
 800097e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000982:	f47f aeeb 	bne.w	800075c <__aeabi_dmul+0x1f8>
 8000986:	e712      	b.n	80007ae <__aeabi_dmul+0x24a>

08000988 <__aeabi_d2uiz>:
 8000988:	004a      	lsls	r2, r1, #1
 800098a:	d211      	bcs.n	80009b0 <__aeabi_d2uiz+0x28>
 800098c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000990:	d211      	bcs.n	80009b6 <__aeabi_d2uiz+0x2e>
 8000992:	d50d      	bpl.n	80009b0 <__aeabi_d2uiz+0x28>
 8000994:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000998:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800099c:	d40e      	bmi.n	80009bc <__aeabi_d2uiz+0x34>
 800099e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80009a2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80009a6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80009aa:	fa23 f002 	lsr.w	r0, r3, r2
 80009ae:	4770      	bx	lr
 80009b0:	f04f 0000 	mov.w	r0, #0
 80009b4:	4770      	bx	lr
 80009b6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80009ba:	d102      	bne.n	80009c2 <__aeabi_d2uiz+0x3a>
 80009bc:	f04f 30ff 	mov.w	r0, #4294967295
 80009c0:	4770      	bx	lr
 80009c2:	f04f 0000 	mov.w	r0, #0
 80009c6:	4770      	bx	lr

080009c8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 80009c8:	b480      	push	{r7}
 80009ca:	b083      	sub	sp, #12
 80009cc:	af00      	add	r7, sp, #0
 80009ce:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80009d0:	687b      	ldr	r3, [r7, #4]
 80009d2:	f103 0208 	add.w	r2, r3, #8
 80009d6:	687b      	ldr	r3, [r7, #4]
 80009d8:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80009da:	687b      	ldr	r3, [r7, #4]
 80009dc:	f04f 32ff 	mov.w	r2, #4294967295
 80009e0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80009e2:	687b      	ldr	r3, [r7, #4]
 80009e4:	f103 0208 	add.w	r2, r3, #8
 80009e8:	687b      	ldr	r3, [r7, #4]
 80009ea:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80009ec:	687b      	ldr	r3, [r7, #4]
 80009ee:	f103 0208 	add.w	r2, r3, #8
 80009f2:	687b      	ldr	r3, [r7, #4]
 80009f4:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80009f6:	687b      	ldr	r3, [r7, #4]
 80009f8:	2200      	movs	r2, #0
 80009fa:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 80009fc:	bf00      	nop
 80009fe:	370c      	adds	r7, #12
 8000a00:	46bd      	mov	sp, r7
 8000a02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a06:	4770      	bx	lr

08000a08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 8000a08:	b480      	push	{r7}
 8000a0a:	b083      	sub	sp, #12
 8000a0c:	af00      	add	r7, sp, #0
 8000a0e:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8000a10:	687b      	ldr	r3, [r7, #4]
 8000a12:	2200      	movs	r2, #0
 8000a14:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8000a16:	bf00      	nop
 8000a18:	370c      	adds	r7, #12
 8000a1a:	46bd      	mov	sp, r7
 8000a1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a20:	4770      	bx	lr

08000a22 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8000a22:	b480      	push	{r7}
 8000a24:	b085      	sub	sp, #20
 8000a26:	af00      	add	r7, sp, #0
 8000a28:	6078      	str	r0, [r7, #4]
 8000a2a:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 8000a2c:	687b      	ldr	r3, [r7, #4]
 8000a2e:	685b      	ldr	r3, [r3, #4]
 8000a30:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8000a32:	683b      	ldr	r3, [r7, #0]
 8000a34:	68fa      	ldr	r2, [r7, #12]
 8000a36:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8000a38:	68fb      	ldr	r3, [r7, #12]
 8000a3a:	689a      	ldr	r2, [r3, #8]
 8000a3c:	683b      	ldr	r3, [r7, #0]
 8000a3e:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8000a40:	68fb      	ldr	r3, [r7, #12]
 8000a42:	689b      	ldr	r3, [r3, #8]
 8000a44:	683a      	ldr	r2, [r7, #0]
 8000a46:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8000a48:	68fb      	ldr	r3, [r7, #12]
 8000a4a:	683a      	ldr	r2, [r7, #0]
 8000a4c:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000a4e:	683b      	ldr	r3, [r7, #0]
 8000a50:	687a      	ldr	r2, [r7, #4]
 8000a52:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000a54:	687b      	ldr	r3, [r7, #4]
 8000a56:	681b      	ldr	r3, [r3, #0]
 8000a58:	1c5a      	adds	r2, r3, #1
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	601a      	str	r2, [r3, #0]
}
 8000a5e:	bf00      	nop
 8000a60:	3714      	adds	r7, #20
 8000a62:	46bd      	mov	sp, r7
 8000a64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a68:	4770      	bx	lr

08000a6a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8000a6a:	b480      	push	{r7}
 8000a6c:	b085      	sub	sp, #20
 8000a6e:	af00      	add	r7, sp, #0
 8000a70:	6078      	str	r0, [r7, #4]
 8000a72:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8000a74:	683b      	ldr	r3, [r7, #0]
 8000a76:	681b      	ldr	r3, [r3, #0]
 8000a78:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8000a7a:	68bb      	ldr	r3, [r7, #8]
 8000a7c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000a80:	d103      	bne.n	8000a8a <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8000a82:	687b      	ldr	r3, [r7, #4]
 8000a84:	691b      	ldr	r3, [r3, #16]
 8000a86:	60fb      	str	r3, [r7, #12]
 8000a88:	e00c      	b.n	8000aa4 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000a8a:	687b      	ldr	r3, [r7, #4]
 8000a8c:	3308      	adds	r3, #8
 8000a8e:	60fb      	str	r3, [r7, #12]
 8000a90:	e002      	b.n	8000a98 <vListInsert+0x2e>
 8000a92:	68fb      	ldr	r3, [r7, #12]
 8000a94:	685b      	ldr	r3, [r3, #4]
 8000a96:	60fb      	str	r3, [r7, #12]
 8000a98:	68fb      	ldr	r3, [r7, #12]
 8000a9a:	685b      	ldr	r3, [r3, #4]
 8000a9c:	681a      	ldr	r2, [r3, #0]
 8000a9e:	68bb      	ldr	r3, [r7, #8]
 8000aa0:	429a      	cmp	r2, r3
 8000aa2:	d9f6      	bls.n	8000a92 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8000aa4:	68fb      	ldr	r3, [r7, #12]
 8000aa6:	685a      	ldr	r2, [r3, #4]
 8000aa8:	683b      	ldr	r3, [r7, #0]
 8000aaa:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8000aac:	683b      	ldr	r3, [r7, #0]
 8000aae:	685b      	ldr	r3, [r3, #4]
 8000ab0:	683a      	ldr	r2, [r7, #0]
 8000ab2:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8000ab4:	683b      	ldr	r3, [r7, #0]
 8000ab6:	68fa      	ldr	r2, [r7, #12]
 8000ab8:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 8000aba:	68fb      	ldr	r3, [r7, #12]
 8000abc:	683a      	ldr	r2, [r7, #0]
 8000abe:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000ac0:	683b      	ldr	r3, [r7, #0]
 8000ac2:	687a      	ldr	r2, [r7, #4]
 8000ac4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000ac6:	687b      	ldr	r3, [r7, #4]
 8000ac8:	681b      	ldr	r3, [r3, #0]
 8000aca:	1c5a      	adds	r2, r3, #1
 8000acc:	687b      	ldr	r3, [r7, #4]
 8000ace:	601a      	str	r2, [r3, #0]
}
 8000ad0:	bf00      	nop
 8000ad2:	3714      	adds	r7, #20
 8000ad4:	46bd      	mov	sp, r7
 8000ad6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ada:	4770      	bx	lr

08000adc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8000adc:	b480      	push	{r7}
 8000ade:	b085      	sub	sp, #20
 8000ae0:	af00      	add	r7, sp, #0
 8000ae2:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8000ae4:	687b      	ldr	r3, [r7, #4]
 8000ae6:	691b      	ldr	r3, [r3, #16]
 8000ae8:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000aea:	687b      	ldr	r3, [r7, #4]
 8000aec:	685b      	ldr	r3, [r3, #4]
 8000aee:	687a      	ldr	r2, [r7, #4]
 8000af0:	6892      	ldr	r2, [r2, #8]
 8000af2:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000af4:	687b      	ldr	r3, [r7, #4]
 8000af6:	689b      	ldr	r3, [r3, #8]
 8000af8:	687a      	ldr	r2, [r7, #4]
 8000afa:	6852      	ldr	r2, [r2, #4]
 8000afc:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000afe:	68fb      	ldr	r3, [r7, #12]
 8000b00:	685a      	ldr	r2, [r3, #4]
 8000b02:	687b      	ldr	r3, [r7, #4]
 8000b04:	429a      	cmp	r2, r3
 8000b06:	d103      	bne.n	8000b10 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000b08:	687b      	ldr	r3, [r7, #4]
 8000b0a:	689a      	ldr	r2, [r3, #8]
 8000b0c:	68fb      	ldr	r3, [r7, #12]
 8000b0e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8000b10:	687b      	ldr	r3, [r7, #4]
 8000b12:	2200      	movs	r2, #0
 8000b14:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8000b16:	68fb      	ldr	r3, [r7, #12]
 8000b18:	681b      	ldr	r3, [r3, #0]
 8000b1a:	1e5a      	subs	r2, r3, #1
 8000b1c:	68fb      	ldr	r3, [r7, #12]
 8000b1e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8000b20:	68fb      	ldr	r3, [r7, #12]
 8000b22:	681b      	ldr	r3, [r3, #0]
}
 8000b24:	4618      	mov	r0, r3
 8000b26:	3714      	adds	r7, #20
 8000b28:	46bd      	mov	sp, r7
 8000b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b2e:	4770      	bx	lr

08000b30 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 8000b30:	b480      	push	{r7}
 8000b32:	b085      	sub	sp, #20
 8000b34:	af00      	add	r7, sp, #0
 8000b36:	60f8      	str	r0, [r7, #12]
 8000b38:	60b9      	str	r1, [r7, #8]
 8000b3a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 8000b3c:	68fb      	ldr	r3, [r7, #12]
 8000b3e:	3b04      	subs	r3, #4
 8000b40:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8000b42:	68fb      	ldr	r3, [r7, #12]
 8000b44:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000b48:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000b4a:	68fb      	ldr	r3, [r7, #12]
 8000b4c:	3b04      	subs	r3, #4
 8000b4e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8000b50:	68bb      	ldr	r3, [r7, #8]
 8000b52:	f023 0201 	bic.w	r2, r3, #1
 8000b56:	68fb      	ldr	r3, [r7, #12]
 8000b58:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000b5a:	68fb      	ldr	r3, [r7, #12]
 8000b5c:	3b04      	subs	r3, #4
 8000b5e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8000b60:	4a0c      	ldr	r2, [pc, #48]	; (8000b94 <pxPortInitialiseStack+0x64>)
 8000b62:	68fb      	ldr	r3, [r7, #12]
 8000b64:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8000b66:	68fb      	ldr	r3, [r7, #12]
 8000b68:	3b14      	subs	r3, #20
 8000b6a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8000b6c:	687a      	ldr	r2, [r7, #4]
 8000b6e:	68fb      	ldr	r3, [r7, #12]
 8000b70:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 8000b72:	68fb      	ldr	r3, [r7, #12]
 8000b74:	3b04      	subs	r3, #4
 8000b76:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8000b78:	68fb      	ldr	r3, [r7, #12]
 8000b7a:	f06f 0202 	mvn.w	r2, #2
 8000b7e:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8000b80:	68fb      	ldr	r3, [r7, #12]
 8000b82:	3b20      	subs	r3, #32
 8000b84:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8000b86:	68fb      	ldr	r3, [r7, #12]
}
 8000b88:	4618      	mov	r0, r3
 8000b8a:	3714      	adds	r7, #20
 8000b8c:	46bd      	mov	sp, r7
 8000b8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b92:	4770      	bx	lr
 8000b94:	08000b99 	.word	0x08000b99

08000b98 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8000b98:	b480      	push	{r7}
 8000b9a:	b083      	sub	sp, #12
 8000b9c:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8000b9e:	4b0c      	ldr	r3, [pc, #48]	; (8000bd0 <prvTaskExitError+0x38>)
 8000ba0:	681b      	ldr	r3, [r3, #0]
 8000ba2:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000ba6:	d009      	beq.n	8000bbc <prvTaskExitError+0x24>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8000ba8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000bac:	f383 8811 	msr	BASEPRI, r3
 8000bb0:	f3bf 8f6f 	isb	sy
 8000bb4:	f3bf 8f4f 	dsb	sy
 8000bb8:	607b      	str	r3, [r7, #4]
 8000bba:	e7fe      	b.n	8000bba <prvTaskExitError+0x22>
 8000bbc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000bc0:	f383 8811 	msr	BASEPRI, r3
 8000bc4:	f3bf 8f6f 	isb	sy
 8000bc8:	f3bf 8f4f 	dsb	sy
 8000bcc:	603b      	str	r3, [r7, #0]
	portDISABLE_INTERRUPTS();
	for( ;; );
 8000bce:	e7fe      	b.n	8000bce <prvTaskExitError+0x36>
 8000bd0:	20000000 	.word	0x20000000
	...

08000be0 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8000be0:	4b07      	ldr	r3, [pc, #28]	; (8000c00 <pxCurrentTCBConst2>)
 8000be2:	6819      	ldr	r1, [r3, #0]
 8000be4:	6808      	ldr	r0, [r1, #0]
 8000be6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000bea:	f380 8809 	msr	PSP, r0
 8000bee:	f3bf 8f6f 	isb	sy
 8000bf2:	f04f 0000 	mov.w	r0, #0
 8000bf6:	f380 8811 	msr	BASEPRI, r0
 8000bfa:	4770      	bx	lr
 8000bfc:	f3af 8000 	nop.w

08000c00 <pxCurrentTCBConst2>:
 8000c00:	2000248c 	.word	0x2000248c
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 8000c04:	bf00      	nop
 8000c06:	bf00      	nop

08000c08 <prvPortStartFirstTask>:
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8000c08:	4806      	ldr	r0, [pc, #24]	; (8000c24 <prvPortStartFirstTask+0x1c>)
 8000c0a:	6800      	ldr	r0, [r0, #0]
 8000c0c:	6800      	ldr	r0, [r0, #0]
 8000c0e:	f380 8808 	msr	MSP, r0
 8000c12:	b662      	cpsie	i
 8000c14:	b661      	cpsie	f
 8000c16:	f3bf 8f4f 	dsb	sy
 8000c1a:	f3bf 8f6f 	isb	sy
 8000c1e:	df00      	svc	0
 8000c20:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8000c22:	bf00      	nop
 8000c24:	e000ed08 	.word	0xe000ed08

08000c28 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8000c28:	b580      	push	{r7, lr}
 8000c2a:	b086      	sub	sp, #24
 8000c2c:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* This port can be used on all revisions of the Cortex-M7 core other than
	the r0p1 parts.  r0p1 parts should use the port from the
	/source/portable/GCC/ARM_CM7/r0p1 directory. */
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8000c2e:	4b3b      	ldr	r3, [pc, #236]	; (8000d1c <xPortStartScheduler+0xf4>)
 8000c30:	681b      	ldr	r3, [r3, #0]
 8000c32:	4a3b      	ldr	r2, [pc, #236]	; (8000d20 <xPortStartScheduler+0xf8>)
 8000c34:	4293      	cmp	r3, r2
 8000c36:	d109      	bne.n	8000c4c <xPortStartScheduler+0x24>
 8000c38:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000c3c:	f383 8811 	msr	BASEPRI, r3
 8000c40:	f3bf 8f6f 	isb	sy
 8000c44:	f3bf 8f4f 	dsb	sy
 8000c48:	613b      	str	r3, [r7, #16]
 8000c4a:	e7fe      	b.n	8000c4a <xPortStartScheduler+0x22>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8000c4c:	4b33      	ldr	r3, [pc, #204]	; (8000d1c <xPortStartScheduler+0xf4>)
 8000c4e:	681b      	ldr	r3, [r3, #0]
 8000c50:	4a34      	ldr	r2, [pc, #208]	; (8000d24 <xPortStartScheduler+0xfc>)
 8000c52:	4293      	cmp	r3, r2
 8000c54:	d109      	bne.n	8000c6a <xPortStartScheduler+0x42>
 8000c56:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000c5a:	f383 8811 	msr	BASEPRI, r3
 8000c5e:	f3bf 8f6f 	isb	sy
 8000c62:	f3bf 8f4f 	dsb	sy
 8000c66:	60fb      	str	r3, [r7, #12]
 8000c68:	e7fe      	b.n	8000c68 <xPortStartScheduler+0x40>

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
 8000c6a:	4b2f      	ldr	r3, [pc, #188]	; (8000d28 <xPortStartScheduler+0x100>)
 8000c6c:	617b      	str	r3, [r7, #20]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8000c6e:	697b      	ldr	r3, [r7, #20]
 8000c70:	781b      	ldrb	r3, [r3, #0]
 8000c72:	b2db      	uxtb	r3, r3
 8000c74:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8000c76:	697b      	ldr	r3, [r7, #20]
 8000c78:	22ff      	movs	r2, #255	; 0xff
 8000c7a:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8000c7c:	697b      	ldr	r3, [r7, #20]
 8000c7e:	781b      	ldrb	r3, [r3, #0]
 8000c80:	b2db      	uxtb	r3, r3
 8000c82:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8000c84:	79fb      	ldrb	r3, [r7, #7]
 8000c86:	b2db      	uxtb	r3, r3
 8000c88:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8000c8c:	b2da      	uxtb	r2, r3
 8000c8e:	4b27      	ldr	r3, [pc, #156]	; (8000d2c <xPortStartScheduler+0x104>)
 8000c90:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8000c92:	4b27      	ldr	r3, [pc, #156]	; (8000d30 <xPortStartScheduler+0x108>)
 8000c94:	2207      	movs	r2, #7
 8000c96:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8000c98:	e009      	b.n	8000cae <xPortStartScheduler+0x86>
		{
			ulMaxPRIGROUPValue--;
 8000c9a:	4b25      	ldr	r3, [pc, #148]	; (8000d30 <xPortStartScheduler+0x108>)
 8000c9c:	681b      	ldr	r3, [r3, #0]
 8000c9e:	3b01      	subs	r3, #1
 8000ca0:	4a23      	ldr	r2, [pc, #140]	; (8000d30 <xPortStartScheduler+0x108>)
 8000ca2:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8000ca4:	79fb      	ldrb	r3, [r7, #7]
 8000ca6:	b2db      	uxtb	r3, r3
 8000ca8:	005b      	lsls	r3, r3, #1
 8000caa:	b2db      	uxtb	r3, r3
 8000cac:	71fb      	strb	r3, [r7, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8000cae:	79fb      	ldrb	r3, [r7, #7]
 8000cb0:	b2db      	uxtb	r3, r3
 8000cb2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000cb6:	2b80      	cmp	r3, #128	; 0x80
 8000cb8:	d0ef      	beq.n	8000c9a <xPortStartScheduler+0x72>
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8000cba:	4b1d      	ldr	r3, [pc, #116]	; (8000d30 <xPortStartScheduler+0x108>)
 8000cbc:	681b      	ldr	r3, [r3, #0]
 8000cbe:	021b      	lsls	r3, r3, #8
 8000cc0:	4a1b      	ldr	r2, [pc, #108]	; (8000d30 <xPortStartScheduler+0x108>)
 8000cc2:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8000cc4:	4b1a      	ldr	r3, [pc, #104]	; (8000d30 <xPortStartScheduler+0x108>)
 8000cc6:	681b      	ldr	r3, [r3, #0]
 8000cc8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8000ccc:	4a18      	ldr	r2, [pc, #96]	; (8000d30 <xPortStartScheduler+0x108>)
 8000cce:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8000cd0:	68bb      	ldr	r3, [r7, #8]
 8000cd2:	b2da      	uxtb	r2, r3
 8000cd4:	697b      	ldr	r3, [r7, #20]
 8000cd6:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8000cd8:	4a16      	ldr	r2, [pc, #88]	; (8000d34 <xPortStartScheduler+0x10c>)
 8000cda:	4b16      	ldr	r3, [pc, #88]	; (8000d34 <xPortStartScheduler+0x10c>)
 8000cdc:	681b      	ldr	r3, [r3, #0]
 8000cde:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000ce2:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8000ce4:	4a13      	ldr	r2, [pc, #76]	; (8000d34 <xPortStartScheduler+0x10c>)
 8000ce6:	4b13      	ldr	r3, [pc, #76]	; (8000d34 <xPortStartScheduler+0x10c>)
 8000ce8:	681b      	ldr	r3, [r3, #0]
 8000cea:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 8000cee:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8000cf0:	f000 f8e2 	bl	8000eb8 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8000cf4:	4b10      	ldr	r3, [pc, #64]	; (8000d38 <xPortStartScheduler+0x110>)
 8000cf6:	2200      	movs	r2, #0
 8000cf8:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8000cfa:	f000 f8f9 	bl	8000ef0 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8000cfe:	4a0f      	ldr	r2, [pc, #60]	; (8000d3c <xPortStartScheduler+0x114>)
 8000d00:	4b0e      	ldr	r3, [pc, #56]	; (8000d3c <xPortStartScheduler+0x114>)
 8000d02:	681b      	ldr	r3, [r3, #0]
 8000d04:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8000d08:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8000d0a:	f7ff ff7d 	bl	8000c08 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8000d0e:	f7ff ff43 	bl	8000b98 <prvTaskExitError>

	/* Should not get here! */
	return 0;
 8000d12:	2300      	movs	r3, #0
}
 8000d14:	4618      	mov	r0, r3
 8000d16:	3718      	adds	r7, #24
 8000d18:	46bd      	mov	sp, r7
 8000d1a:	bd80      	pop	{r7, pc}
 8000d1c:	e000ed00 	.word	0xe000ed00
 8000d20:	410fc271 	.word	0x410fc271
 8000d24:	410fc270 	.word	0x410fc270
 8000d28:	e000e400 	.word	0xe000e400
 8000d2c:	20000878 	.word	0x20000878
 8000d30:	2000087c 	.word	0x2000087c
 8000d34:	e000ed20 	.word	0xe000ed20
 8000d38:	20000000 	.word	0x20000000
 8000d3c:	e000ef34 	.word	0xe000ef34

08000d40 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8000d40:	b480      	push	{r7}
 8000d42:	b083      	sub	sp, #12
 8000d44:	af00      	add	r7, sp, #0
 8000d46:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000d4a:	f383 8811 	msr	BASEPRI, r3
 8000d4e:	f3bf 8f6f 	isb	sy
 8000d52:	f3bf 8f4f 	dsb	sy
 8000d56:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8000d58:	4b0e      	ldr	r3, [pc, #56]	; (8000d94 <vPortEnterCritical+0x54>)
 8000d5a:	681b      	ldr	r3, [r3, #0]
 8000d5c:	3301      	adds	r3, #1
 8000d5e:	4a0d      	ldr	r2, [pc, #52]	; (8000d94 <vPortEnterCritical+0x54>)
 8000d60:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 8000d62:	4b0c      	ldr	r3, [pc, #48]	; (8000d94 <vPortEnterCritical+0x54>)
 8000d64:	681b      	ldr	r3, [r3, #0]
 8000d66:	2b01      	cmp	r3, #1
 8000d68:	d10e      	bne.n	8000d88 <vPortEnterCritical+0x48>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8000d6a:	4b0b      	ldr	r3, [pc, #44]	; (8000d98 <vPortEnterCritical+0x58>)
 8000d6c:	681b      	ldr	r3, [r3, #0]
 8000d6e:	b2db      	uxtb	r3, r3
 8000d70:	2b00      	cmp	r3, #0
 8000d72:	d009      	beq.n	8000d88 <vPortEnterCritical+0x48>
 8000d74:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000d78:	f383 8811 	msr	BASEPRI, r3
 8000d7c:	f3bf 8f6f 	isb	sy
 8000d80:	f3bf 8f4f 	dsb	sy
 8000d84:	603b      	str	r3, [r7, #0]
 8000d86:	e7fe      	b.n	8000d86 <vPortEnterCritical+0x46>
	}
}
 8000d88:	bf00      	nop
 8000d8a:	370c      	adds	r7, #12
 8000d8c:	46bd      	mov	sp, r7
 8000d8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000d92:	4770      	bx	lr
 8000d94:	20000000 	.word	0x20000000
 8000d98:	e000ed04 	.word	0xe000ed04

08000d9c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8000d9c:	b480      	push	{r7}
 8000d9e:	b083      	sub	sp, #12
 8000da0:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 8000da2:	4b11      	ldr	r3, [pc, #68]	; (8000de8 <vPortExitCritical+0x4c>)
 8000da4:	681b      	ldr	r3, [r3, #0]
 8000da6:	2b00      	cmp	r3, #0
 8000da8:	d109      	bne.n	8000dbe <vPortExitCritical+0x22>
 8000daa:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000dae:	f383 8811 	msr	BASEPRI, r3
 8000db2:	f3bf 8f6f 	isb	sy
 8000db6:	f3bf 8f4f 	dsb	sy
 8000dba:	607b      	str	r3, [r7, #4]
 8000dbc:	e7fe      	b.n	8000dbc <vPortExitCritical+0x20>
	uxCriticalNesting--;
 8000dbe:	4b0a      	ldr	r3, [pc, #40]	; (8000de8 <vPortExitCritical+0x4c>)
 8000dc0:	681b      	ldr	r3, [r3, #0]
 8000dc2:	3b01      	subs	r3, #1
 8000dc4:	4a08      	ldr	r2, [pc, #32]	; (8000de8 <vPortExitCritical+0x4c>)
 8000dc6:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8000dc8:	4b07      	ldr	r3, [pc, #28]	; (8000de8 <vPortExitCritical+0x4c>)
 8000dca:	681b      	ldr	r3, [r3, #0]
 8000dcc:	2b00      	cmp	r3, #0
 8000dce:	d104      	bne.n	8000dda <vPortExitCritical+0x3e>
 8000dd0:	2300      	movs	r3, #0
 8000dd2:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8000dd4:	683b      	ldr	r3, [r7, #0]
 8000dd6:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 8000dda:	bf00      	nop
 8000ddc:	370c      	adds	r7, #12
 8000dde:	46bd      	mov	sp, r7
 8000de0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000de4:	4770      	bx	lr
 8000de6:	bf00      	nop
 8000de8:	20000000 	.word	0x20000000
 8000dec:	00000000 	.word	0x00000000

08000df0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8000df0:	f3ef 8009 	mrs	r0, PSP
 8000df4:	f3bf 8f6f 	isb	sy
 8000df8:	4b15      	ldr	r3, [pc, #84]	; (8000e50 <pxCurrentTCBConst>)
 8000dfa:	681a      	ldr	r2, [r3, #0]
 8000dfc:	f01e 0f10 	tst.w	lr, #16
 8000e00:	bf08      	it	eq
 8000e02:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8000e06:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e0a:	6010      	str	r0, [r2, #0]
 8000e0c:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8000e10:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000e14:	f380 8811 	msr	BASEPRI, r0
 8000e18:	f3bf 8f4f 	dsb	sy
 8000e1c:	f3bf 8f6f 	isb	sy
 8000e20:	f001 f900 	bl	8002024 <vTaskSwitchContext>
 8000e24:	f04f 0000 	mov.w	r0, #0
 8000e28:	f380 8811 	msr	BASEPRI, r0
 8000e2c:	bc08      	pop	{r3}
 8000e2e:	6819      	ldr	r1, [r3, #0]
 8000e30:	6808      	ldr	r0, [r1, #0]
 8000e32:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e36:	f01e 0f10 	tst.w	lr, #16
 8000e3a:	bf08      	it	eq
 8000e3c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8000e40:	f380 8809 	msr	PSP, r0
 8000e44:	f3bf 8f6f 	isb	sy
 8000e48:	4770      	bx	lr
 8000e4a:	bf00      	nop
 8000e4c:	f3af 8000 	nop.w

08000e50 <pxCurrentTCBConst>:
 8000e50:	2000248c 	.word	0x2000248c
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 8000e54:	bf00      	nop
 8000e56:	bf00      	nop

08000e58 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8000e58:	b580      	push	{r7, lr}
 8000e5a:	b082      	sub	sp, #8
 8000e5c:	af00      	add	r7, sp, #0
	__asm volatile
 8000e5e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000e62:	f383 8811 	msr	BASEPRI, r3
 8000e66:	f3bf 8f6f 	isb	sy
 8000e6a:	f3bf 8f4f 	dsb	sy
 8000e6e:	607b      	str	r3, [r7, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8000e70:	f001 f814 	bl	8001e9c <xTaskIncrementTick>
 8000e74:	4603      	mov	r3, r0
 8000e76:	2b00      	cmp	r3, #0
 8000e78:	d003      	beq.n	8000e82 <SysTick_Handler+0x2a>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8000e7a:	4b0d      	ldr	r3, [pc, #52]	; (8000eb0 <SysTick_Handler+0x58>)
 8000e7c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000e80:	601a      	str	r2, [r3, #0]
 8000e82:	2300      	movs	r3, #0
 8000e84:	603b      	str	r3, [r7, #0]
	__asm volatile
 8000e86:	683b      	ldr	r3, [r7, #0]
 8000e88:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();

	static int temporizado=0;
	++temporizado;
 8000e8c:	4b09      	ldr	r3, [pc, #36]	; (8000eb4 <SysTick_Handler+0x5c>)
 8000e8e:	681b      	ldr	r3, [r3, #0]
 8000e90:	3301      	adds	r3, #1
 8000e92:	4a08      	ldr	r2, [pc, #32]	; (8000eb4 <SysTick_Handler+0x5c>)
 8000e94:	6013      	str	r3, [r2, #0]
	if(temporizado==10)
 8000e96:	4b07      	ldr	r3, [pc, #28]	; (8000eb4 <SysTick_Handler+0x5c>)
 8000e98:	681b      	ldr	r3, [r3, #0]
 8000e9a:	2b0a      	cmp	r3, #10
 8000e9c:	d104      	bne.n	8000ea8 <SysTick_Handler+0x50>
	{
		Time_Update();
 8000e9e:	f00c ffa9 	bl	800ddf4 <Time_Update>
		temporizado = 0;
 8000ea2:	4b04      	ldr	r3, [pc, #16]	; (8000eb4 <SysTick_Handler+0x5c>)
 8000ea4:	2200      	movs	r2, #0
 8000ea6:	601a      	str	r2, [r3, #0]
	}
}
 8000ea8:	bf00      	nop
 8000eaa:	3708      	adds	r7, #8
 8000eac:	46bd      	mov	sp, r7
 8000eae:	bd80      	pop	{r7, pc}
 8000eb0:	e000ed04 	.word	0xe000ed04
 8000eb4:	20000880 	.word	0x20000880

08000eb8 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 8000eb8:	b480      	push	{r7}
 8000eba:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8000ebc:	4a08      	ldr	r2, [pc, #32]	; (8000ee0 <vPortSetupTimerInterrupt+0x28>)
 8000ebe:	4b09      	ldr	r3, [pc, #36]	; (8000ee4 <vPortSetupTimerInterrupt+0x2c>)
 8000ec0:	681b      	ldr	r3, [r3, #0]
 8000ec2:	4909      	ldr	r1, [pc, #36]	; (8000ee8 <vPortSetupTimerInterrupt+0x30>)
 8000ec4:	fba1 1303 	umull	r1, r3, r1, r3
 8000ec8:	099b      	lsrs	r3, r3, #6
 8000eca:	3b01      	subs	r3, #1
 8000ecc:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8000ece:	4b07      	ldr	r3, [pc, #28]	; (8000eec <vPortSetupTimerInterrupt+0x34>)
 8000ed0:	2207      	movs	r2, #7
 8000ed2:	601a      	str	r2, [r3, #0]
}
 8000ed4:	bf00      	nop
 8000ed6:	46bd      	mov	sp, r7
 8000ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000edc:	4770      	bx	lr
 8000ede:	bf00      	nop
 8000ee0:	e000e014 	.word	0xe000e014
 8000ee4:	20000004 	.word	0x20000004
 8000ee8:	10624dd3 	.word	0x10624dd3
 8000eec:	e000e010 	.word	0xe000e010

08000ef0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8000ef0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8000f00 <vPortEnableVFP+0x10>
 8000ef4:	6801      	ldr	r1, [r0, #0]
 8000ef6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000efa:	6001      	str	r1, [r0, #0]
 8000efc:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 8000efe:	bf00      	nop
 8000f00:	e000ed88 	.word	0xe000ed88

08000f04 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 8000f04:	b480      	push	{r7}
 8000f06:	b085      	sub	sp, #20
 8000f08:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8000f0a:	f3ef 8305 	mrs	r3, IPSR
 8000f0e:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8000f10:	68fb      	ldr	r3, [r7, #12]
 8000f12:	2b0f      	cmp	r3, #15
 8000f14:	d913      	bls.n	8000f3e <vPortValidateInterruptPriority+0x3a>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8000f16:	4a16      	ldr	r2, [pc, #88]	; (8000f70 <vPortValidateInterruptPriority+0x6c>)
 8000f18:	68fb      	ldr	r3, [r7, #12]
 8000f1a:	4413      	add	r3, r2
 8000f1c:	781b      	ldrb	r3, [r3, #0]
 8000f1e:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8000f20:	4b14      	ldr	r3, [pc, #80]	; (8000f74 <vPortValidateInterruptPriority+0x70>)
 8000f22:	781b      	ldrb	r3, [r3, #0]
 8000f24:	7afa      	ldrb	r2, [r7, #11]
 8000f26:	429a      	cmp	r2, r3
 8000f28:	d209      	bcs.n	8000f3e <vPortValidateInterruptPriority+0x3a>
	__asm volatile
 8000f2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000f2e:	f383 8811 	msr	BASEPRI, r3
 8000f32:	f3bf 8f6f 	isb	sy
 8000f36:	f3bf 8f4f 	dsb	sy
 8000f3a:	607b      	str	r3, [r7, #4]
 8000f3c:	e7fe      	b.n	8000f3c <vPortValidateInterruptPriority+0x38>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8000f3e:	4b0e      	ldr	r3, [pc, #56]	; (8000f78 <vPortValidateInterruptPriority+0x74>)
 8000f40:	681b      	ldr	r3, [r3, #0]
 8000f42:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 8000f46:	4b0d      	ldr	r3, [pc, #52]	; (8000f7c <vPortValidateInterruptPriority+0x78>)
 8000f48:	681b      	ldr	r3, [r3, #0]
 8000f4a:	429a      	cmp	r2, r3
 8000f4c:	d909      	bls.n	8000f62 <vPortValidateInterruptPriority+0x5e>
 8000f4e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000f52:	f383 8811 	msr	BASEPRI, r3
 8000f56:	f3bf 8f6f 	isb	sy
 8000f5a:	f3bf 8f4f 	dsb	sy
 8000f5e:	603b      	str	r3, [r7, #0]
 8000f60:	e7fe      	b.n	8000f60 <vPortValidateInterruptPriority+0x5c>
	}
 8000f62:	bf00      	nop
 8000f64:	3714      	adds	r7, #20
 8000f66:	46bd      	mov	sp, r7
 8000f68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f6c:	4770      	bx	lr
 8000f6e:	bf00      	nop
 8000f70:	e000e3f0 	.word	0xe000e3f0
 8000f74:	20000878 	.word	0x20000878
 8000f78:	e000ed0c 	.word	0xe000ed0c
 8000f7c:	2000087c 	.word	0x2000087c

08000f80 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8000f80:	b580      	push	{r7, lr}
 8000f82:	b084      	sub	sp, #16
 8000f84:	af00      	add	r7, sp, #0
 8000f86:	6078      	str	r0, [r7, #4]
void *pvReturn = NULL;
 8000f88:	2300      	movs	r3, #0
 8000f8a:	60fb      	str	r3, [r7, #12]
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8000f8c:	687b      	ldr	r3, [r7, #4]
 8000f8e:	f003 0307 	and.w	r3, r3, #7
 8000f92:	2b00      	cmp	r3, #0
 8000f94:	d004      	beq.n	8000fa0 <pvPortMalloc+0x20>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8000f96:	687b      	ldr	r3, [r7, #4]
 8000f98:	f023 0307 	bic.w	r3, r3, #7
 8000f9c:	3308      	adds	r3, #8
 8000f9e:	607b      	str	r3, [r7, #4]
		}
	}
	#endif

	vTaskSuspendAll();
 8000fa0:	f000 fec2 	bl	8001d28 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 8000fa4:	4b16      	ldr	r3, [pc, #88]	; (8001000 <pvPortMalloc+0x80>)
 8000fa6:	681b      	ldr	r3, [r3, #0]
 8000fa8:	2b00      	cmp	r3, #0
 8000faa:	d105      	bne.n	8000fb8 <pvPortMalloc+0x38>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8000fac:	4b15      	ldr	r3, [pc, #84]	; (8001004 <pvPortMalloc+0x84>)
 8000fae:	f023 0307 	bic.w	r3, r3, #7
 8000fb2:	461a      	mov	r2, r3
 8000fb4:	4b12      	ldr	r3, [pc, #72]	; (8001000 <pvPortMalloc+0x80>)
 8000fb6:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8000fb8:	4b13      	ldr	r3, [pc, #76]	; (8001008 <pvPortMalloc+0x88>)
 8000fba:	681a      	ldr	r2, [r3, #0]
 8000fbc:	687b      	ldr	r3, [r7, #4]
 8000fbe:	4413      	add	r3, r2
 8000fc0:	f641 32f7 	movw	r2, #7159	; 0x1bf7
 8000fc4:	4293      	cmp	r3, r2
 8000fc6:	d813      	bhi.n	8000ff0 <pvPortMalloc+0x70>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 8000fc8:	4b0f      	ldr	r3, [pc, #60]	; (8001008 <pvPortMalloc+0x88>)
 8000fca:	681a      	ldr	r2, [r3, #0]
 8000fcc:	687b      	ldr	r3, [r7, #4]
 8000fce:	441a      	add	r2, r3
 8000fd0:	4b0d      	ldr	r3, [pc, #52]	; (8001008 <pvPortMalloc+0x88>)
 8000fd2:	681b      	ldr	r3, [r3, #0]
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8000fd4:	429a      	cmp	r2, r3
 8000fd6:	d90b      	bls.n	8000ff0 <pvPortMalloc+0x70>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8000fd8:	4b09      	ldr	r3, [pc, #36]	; (8001000 <pvPortMalloc+0x80>)
 8000fda:	681a      	ldr	r2, [r3, #0]
 8000fdc:	4b0a      	ldr	r3, [pc, #40]	; (8001008 <pvPortMalloc+0x88>)
 8000fde:	681b      	ldr	r3, [r3, #0]
 8000fe0:	4413      	add	r3, r2
 8000fe2:	60fb      	str	r3, [r7, #12]
			xNextFreeByte += xWantedSize;
 8000fe4:	4b08      	ldr	r3, [pc, #32]	; (8001008 <pvPortMalloc+0x88>)
 8000fe6:	681a      	ldr	r2, [r3, #0]
 8000fe8:	687b      	ldr	r3, [r7, #4]
 8000fea:	4413      	add	r3, r2
 8000fec:	4a06      	ldr	r2, [pc, #24]	; (8001008 <pvPortMalloc+0x88>)
 8000fee:	6013      	str	r3, [r2, #0]
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8000ff0:	f000 fea8 	bl	8001d44 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 8000ff4:	68fb      	ldr	r3, [r7, #12]
}
 8000ff6:	4618      	mov	r0, r3
 8000ff8:	3710      	adds	r7, #16
 8000ffa:	46bd      	mov	sp, r7
 8000ffc:	bd80      	pop	{r7, pc}
 8000ffe:	bf00      	nop
 8001000:	20002488 	.word	0x20002488
 8001004:	2000088c 	.word	0x2000088c
 8001008:	20002484 	.word	0x20002484

0800100c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800100c:	b480      	push	{r7}
 800100e:	b085      	sub	sp, #20
 8001010:	af00      	add	r7, sp, #0
 8001012:	6078      	str	r0, [r7, #4]
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 8001014:	687b      	ldr	r3, [r7, #4]
 8001016:	2b00      	cmp	r3, #0
 8001018:	d009      	beq.n	800102e <vPortFree+0x22>
 800101a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800101e:	f383 8811 	msr	BASEPRI, r3
 8001022:	f3bf 8f6f 	isb	sy
 8001026:	f3bf 8f4f 	dsb	sy
 800102a:	60fb      	str	r3, [r7, #12]
 800102c:	e7fe      	b.n	800102c <vPortFree+0x20>
}
 800102e:	bf00      	nop
 8001030:	3714      	adds	r7, #20
 8001032:	46bd      	mov	sp, r7
 8001034:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001038:	4770      	bx	lr
	...

0800103c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 800103c:	b580      	push	{r7, lr}
 800103e:	b084      	sub	sp, #16
 8001040:	af00      	add	r7, sp, #0
 8001042:	6078      	str	r0, [r7, #4]
 8001044:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 8001046:	687b      	ldr	r3, [r7, #4]
 8001048:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 800104a:	68fb      	ldr	r3, [r7, #12]
 800104c:	2b00      	cmp	r3, #0
 800104e:	d109      	bne.n	8001064 <xQueueGenericReset+0x28>
 8001050:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001054:	f383 8811 	msr	BASEPRI, r3
 8001058:	f3bf 8f6f 	isb	sy
 800105c:	f3bf 8f4f 	dsb	sy
 8001060:	60bb      	str	r3, [r7, #8]
 8001062:	e7fe      	b.n	8001062 <xQueueGenericReset+0x26>

	taskENTER_CRITICAL();
 8001064:	f7ff fe6c 	bl	8000d40 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001068:	68fb      	ldr	r3, [r7, #12]
 800106a:	681a      	ldr	r2, [r3, #0]
 800106c:	68fb      	ldr	r3, [r7, #12]
 800106e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001070:	68f9      	ldr	r1, [r7, #12]
 8001072:	6c09      	ldr	r1, [r1, #64]	; 0x40
 8001074:	fb01 f303 	mul.w	r3, r1, r3
 8001078:	441a      	add	r2, r3
 800107a:	68fb      	ldr	r3, [r7, #12]
 800107c:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800107e:	68fb      	ldr	r3, [r7, #12]
 8001080:	2200      	movs	r2, #0
 8001082:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8001084:	68fb      	ldr	r3, [r7, #12]
 8001086:	681a      	ldr	r2, [r3, #0]
 8001088:	68fb      	ldr	r3, [r7, #12]
 800108a:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800108c:	68fb      	ldr	r3, [r7, #12]
 800108e:	681a      	ldr	r2, [r3, #0]
 8001090:	68fb      	ldr	r3, [r7, #12]
 8001092:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001094:	3b01      	subs	r3, #1
 8001096:	68f9      	ldr	r1, [r7, #12]
 8001098:	6c09      	ldr	r1, [r1, #64]	; 0x40
 800109a:	fb01 f303 	mul.w	r3, r1, r3
 800109e:	441a      	add	r2, r3
 80010a0:	68fb      	ldr	r3, [r7, #12]
 80010a2:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 80010a4:	68fb      	ldr	r3, [r7, #12]
 80010a6:	22ff      	movs	r2, #255	; 0xff
 80010a8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 80010ac:	68fb      	ldr	r3, [r7, #12]
 80010ae:	22ff      	movs	r2, #255	; 0xff
 80010b0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
 80010b4:	683b      	ldr	r3, [r7, #0]
 80010b6:	2b00      	cmp	r3, #0
 80010b8:	d114      	bne.n	80010e4 <xQueueGenericReset+0xa8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80010ba:	68fb      	ldr	r3, [r7, #12]
 80010bc:	691b      	ldr	r3, [r3, #16]
 80010be:	2b00      	cmp	r3, #0
 80010c0:	d01a      	beq.n	80010f8 <xQueueGenericReset+0xbc>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80010c2:	68fb      	ldr	r3, [r7, #12]
 80010c4:	3310      	adds	r3, #16
 80010c6:	4618      	mov	r0, r3
 80010c8:	f001 f854 	bl	8002174 <xTaskRemoveFromEventList>
 80010cc:	4603      	mov	r3, r0
 80010ce:	2b00      	cmp	r3, #0
 80010d0:	d012      	beq.n	80010f8 <xQueueGenericReset+0xbc>
				{
					queueYIELD_IF_USING_PREEMPTION();
 80010d2:	4b0d      	ldr	r3, [pc, #52]	; (8001108 <xQueueGenericReset+0xcc>)
 80010d4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80010d8:	601a      	str	r2, [r3, #0]
 80010da:	f3bf 8f4f 	dsb	sy
 80010de:	f3bf 8f6f 	isb	sy
 80010e2:	e009      	b.n	80010f8 <xQueueGenericReset+0xbc>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80010e4:	68fb      	ldr	r3, [r7, #12]
 80010e6:	3310      	adds	r3, #16
 80010e8:	4618      	mov	r0, r3
 80010ea:	f7ff fc6d 	bl	80009c8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80010ee:	68fb      	ldr	r3, [r7, #12]
 80010f0:	3324      	adds	r3, #36	; 0x24
 80010f2:	4618      	mov	r0, r3
 80010f4:	f7ff fc68 	bl	80009c8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 80010f8:	f7ff fe50 	bl	8000d9c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 80010fc:	2301      	movs	r3, #1
}
 80010fe:	4618      	mov	r0, r3
 8001100:	3710      	adds	r7, #16
 8001102:	46bd      	mov	sp, r7
 8001104:	bd80      	pop	{r7, pc}
 8001106:	bf00      	nop
 8001108:	e000ed04 	.word	0xe000ed04

0800110c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 800110c:	b580      	push	{r7, lr}
 800110e:	b08a      	sub	sp, #40	; 0x28
 8001110:	af02      	add	r7, sp, #8
 8001112:	60f8      	str	r0, [r7, #12]
 8001114:	60b9      	str	r1, [r7, #8]
 8001116:	4613      	mov	r3, r2
 8001118:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800111a:	68fb      	ldr	r3, [r7, #12]
 800111c:	2b00      	cmp	r3, #0
 800111e:	d109      	bne.n	8001134 <xQueueGenericCreate+0x28>
 8001120:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001124:	f383 8811 	msr	BASEPRI, r3
 8001128:	f3bf 8f6f 	isb	sy
 800112c:	f3bf 8f4f 	dsb	sy
 8001130:	613b      	str	r3, [r7, #16]
 8001132:	e7fe      	b.n	8001132 <xQueueGenericCreate+0x26>

		if( uxItemSize == ( UBaseType_t ) 0 )
 8001134:	68bb      	ldr	r3, [r7, #8]
 8001136:	2b00      	cmp	r3, #0
 8001138:	d102      	bne.n	8001140 <xQueueGenericCreate+0x34>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
 800113a:	2300      	movs	r3, #0
 800113c:	61fb      	str	r3, [r7, #28]
 800113e:	e004      	b.n	800114a <xQueueGenericCreate+0x3e>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001140:	68fb      	ldr	r3, [r7, #12]
 8001142:	68ba      	ldr	r2, [r7, #8]
 8001144:	fb02 f303 	mul.w	r3, r2, r3
 8001148:	61fb      	str	r3, [r7, #28]
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800114a:	69fb      	ldr	r3, [r7, #28]
 800114c:	3348      	adds	r3, #72	; 0x48
 800114e:	4618      	mov	r0, r3
 8001150:	f7ff ff16 	bl	8000f80 <pvPortMalloc>
 8001154:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
 8001156:	69bb      	ldr	r3, [r7, #24]
 8001158:	2b00      	cmp	r3, #0
 800115a:	d00b      	beq.n	8001174 <xQueueGenericCreate+0x68>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 800115c:	69bb      	ldr	r3, [r7, #24]
 800115e:	3348      	adds	r3, #72	; 0x48
 8001160:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 8001162:	79fa      	ldrb	r2, [r7, #7]
 8001164:	69bb      	ldr	r3, [r7, #24]
 8001166:	9300      	str	r3, [sp, #0]
 8001168:	4613      	mov	r3, r2
 800116a:	697a      	ldr	r2, [r7, #20]
 800116c:	68b9      	ldr	r1, [r7, #8]
 800116e:	68f8      	ldr	r0, [r7, #12]
 8001170:	f000 f805 	bl	800117e <prvInitialiseNewQueue>
		}

		return pxNewQueue;
 8001174:	69bb      	ldr	r3, [r7, #24]
	}
 8001176:	4618      	mov	r0, r3
 8001178:	3720      	adds	r7, #32
 800117a:	46bd      	mov	sp, r7
 800117c:	bd80      	pop	{r7, pc}

0800117e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 800117e:	b580      	push	{r7, lr}
 8001180:	b084      	sub	sp, #16
 8001182:	af00      	add	r7, sp, #0
 8001184:	60f8      	str	r0, [r7, #12]
 8001186:	60b9      	str	r1, [r7, #8]
 8001188:	607a      	str	r2, [r7, #4]
 800118a:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 800118c:	68bb      	ldr	r3, [r7, #8]
 800118e:	2b00      	cmp	r3, #0
 8001190:	d103      	bne.n	800119a <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8001192:	69bb      	ldr	r3, [r7, #24]
 8001194:	69ba      	ldr	r2, [r7, #24]
 8001196:	601a      	str	r2, [r3, #0]
 8001198:	e002      	b.n	80011a0 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800119a:	69bb      	ldr	r3, [r7, #24]
 800119c:	687a      	ldr	r2, [r7, #4]
 800119e:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 80011a0:	69bb      	ldr	r3, [r7, #24]
 80011a2:	68fa      	ldr	r2, [r7, #12]
 80011a4:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 80011a6:	69bb      	ldr	r3, [r7, #24]
 80011a8:	68ba      	ldr	r2, [r7, #8]
 80011aa:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80011ac:	2101      	movs	r1, #1
 80011ae:	69b8      	ldr	r0, [r7, #24]
 80011b0:	f7ff ff44 	bl	800103c <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 80011b4:	bf00      	nop
 80011b6:	3710      	adds	r7, #16
 80011b8:	46bd      	mov	sp, r7
 80011ba:	bd80      	pop	{r7, pc}

080011bc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 80011bc:	b580      	push	{r7, lr}
 80011be:	b08e      	sub	sp, #56	; 0x38
 80011c0:	af00      	add	r7, sp, #0
 80011c2:	60f8      	str	r0, [r7, #12]
 80011c4:	60b9      	str	r1, [r7, #8]
 80011c6:	607a      	str	r2, [r7, #4]
 80011c8:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 80011ca:	2300      	movs	r3, #0
 80011cc:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 80011ce:	68fb      	ldr	r3, [r7, #12]
 80011d0:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 80011d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80011d4:	2b00      	cmp	r3, #0
 80011d6:	d109      	bne.n	80011ec <xQueueGenericSend+0x30>
 80011d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80011dc:	f383 8811 	msr	BASEPRI, r3
 80011e0:	f3bf 8f6f 	isb	sy
 80011e4:	f3bf 8f4f 	dsb	sy
 80011e8:	62bb      	str	r3, [r7, #40]	; 0x28
 80011ea:	e7fe      	b.n	80011ea <xQueueGenericSend+0x2e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80011ec:	68bb      	ldr	r3, [r7, #8]
 80011ee:	2b00      	cmp	r3, #0
 80011f0:	d103      	bne.n	80011fa <xQueueGenericSend+0x3e>
 80011f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80011f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80011f6:	2b00      	cmp	r3, #0
 80011f8:	d101      	bne.n	80011fe <xQueueGenericSend+0x42>
 80011fa:	2301      	movs	r3, #1
 80011fc:	e000      	b.n	8001200 <xQueueGenericSend+0x44>
 80011fe:	2300      	movs	r3, #0
 8001200:	2b00      	cmp	r3, #0
 8001202:	d109      	bne.n	8001218 <xQueueGenericSend+0x5c>
 8001204:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001208:	f383 8811 	msr	BASEPRI, r3
 800120c:	f3bf 8f6f 	isb	sy
 8001210:	f3bf 8f4f 	dsb	sy
 8001214:	627b      	str	r3, [r7, #36]	; 0x24
 8001216:	e7fe      	b.n	8001216 <xQueueGenericSend+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8001218:	683b      	ldr	r3, [r7, #0]
 800121a:	2b02      	cmp	r3, #2
 800121c:	d103      	bne.n	8001226 <xQueueGenericSend+0x6a>
 800121e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001220:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001222:	2b01      	cmp	r3, #1
 8001224:	d101      	bne.n	800122a <xQueueGenericSend+0x6e>
 8001226:	2301      	movs	r3, #1
 8001228:	e000      	b.n	800122c <xQueueGenericSend+0x70>
 800122a:	2300      	movs	r3, #0
 800122c:	2b00      	cmp	r3, #0
 800122e:	d109      	bne.n	8001244 <xQueueGenericSend+0x88>
 8001230:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001234:	f383 8811 	msr	BASEPRI, r3
 8001238:	f3bf 8f6f 	isb	sy
 800123c:	f3bf 8f4f 	dsb	sy
 8001240:	623b      	str	r3, [r7, #32]
 8001242:	e7fe      	b.n	8001242 <xQueueGenericSend+0x86>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001244:	f001 f950 	bl	80024e8 <xTaskGetSchedulerState>
 8001248:	4603      	mov	r3, r0
 800124a:	2b00      	cmp	r3, #0
 800124c:	d102      	bne.n	8001254 <xQueueGenericSend+0x98>
 800124e:	687b      	ldr	r3, [r7, #4]
 8001250:	2b00      	cmp	r3, #0
 8001252:	d101      	bne.n	8001258 <xQueueGenericSend+0x9c>
 8001254:	2301      	movs	r3, #1
 8001256:	e000      	b.n	800125a <xQueueGenericSend+0x9e>
 8001258:	2300      	movs	r3, #0
 800125a:	2b00      	cmp	r3, #0
 800125c:	d109      	bne.n	8001272 <xQueueGenericSend+0xb6>
 800125e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001262:	f383 8811 	msr	BASEPRI, r3
 8001266:	f3bf 8f6f 	isb	sy
 800126a:	f3bf 8f4f 	dsb	sy
 800126e:	61fb      	str	r3, [r7, #28]
 8001270:	e7fe      	b.n	8001270 <xQueueGenericSend+0xb4>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8001272:	f7ff fd65 	bl	8000d40 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001276:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001278:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800127a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800127c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800127e:	429a      	cmp	r2, r3
 8001280:	d302      	bcc.n	8001288 <xQueueGenericSend+0xcc>
 8001282:	683b      	ldr	r3, [r7, #0]
 8001284:	2b02      	cmp	r3, #2
 8001286:	d129      	bne.n	80012dc <xQueueGenericSend+0x120>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001288:	683a      	ldr	r2, [r7, #0]
 800128a:	68b9      	ldr	r1, [r7, #8]
 800128c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800128e:	f000 fa35 	bl	80016fc <prvCopyDataToQueue>
 8001292:	62f8      	str	r0, [r7, #44]	; 0x2c
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001294:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001296:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001298:	2b00      	cmp	r3, #0
 800129a:	d010      	beq.n	80012be <xQueueGenericSend+0x102>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800129c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800129e:	3324      	adds	r3, #36	; 0x24
 80012a0:	4618      	mov	r0, r3
 80012a2:	f000 ff67 	bl	8002174 <xTaskRemoveFromEventList>
 80012a6:	4603      	mov	r3, r0
 80012a8:	2b00      	cmp	r3, #0
 80012aa:	d013      	beq.n	80012d4 <xQueueGenericSend+0x118>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 80012ac:	4b3f      	ldr	r3, [pc, #252]	; (80013ac <xQueueGenericSend+0x1f0>)
 80012ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80012b2:	601a      	str	r2, [r3, #0]
 80012b4:	f3bf 8f4f 	dsb	sy
 80012b8:	f3bf 8f6f 	isb	sy
 80012bc:	e00a      	b.n	80012d4 <xQueueGenericSend+0x118>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 80012be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80012c0:	2b00      	cmp	r3, #0
 80012c2:	d007      	beq.n	80012d4 <xQueueGenericSend+0x118>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 80012c4:	4b39      	ldr	r3, [pc, #228]	; (80013ac <xQueueGenericSend+0x1f0>)
 80012c6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80012ca:	601a      	str	r2, [r3, #0]
 80012cc:	f3bf 8f4f 	dsb	sy
 80012d0:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 80012d4:	f7ff fd62 	bl	8000d9c <vPortExitCritical>
				return pdPASS;
 80012d8:	2301      	movs	r3, #1
 80012da:	e063      	b.n	80013a4 <xQueueGenericSend+0x1e8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 80012dc:	687b      	ldr	r3, [r7, #4]
 80012de:	2b00      	cmp	r3, #0
 80012e0:	d103      	bne.n	80012ea <xQueueGenericSend+0x12e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 80012e2:	f7ff fd5b 	bl	8000d9c <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 80012e6:	2300      	movs	r3, #0
 80012e8:	e05c      	b.n	80013a4 <xQueueGenericSend+0x1e8>
				}
				else if( xEntryTimeSet == pdFALSE )
 80012ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80012ec:	2b00      	cmp	r3, #0
 80012ee:	d106      	bne.n	80012fe <xQueueGenericSend+0x142>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 80012f0:	f107 0314 	add.w	r3, r7, #20
 80012f4:	4618      	mov	r0, r3
 80012f6:	f000 ff9f 	bl	8002238 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80012fa:	2301      	movs	r3, #1
 80012fc:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 80012fe:	f7ff fd4d 	bl	8000d9c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8001302:	f000 fd11 	bl	8001d28 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8001306:	f7ff fd1b 	bl	8000d40 <vPortEnterCritical>
 800130a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800130c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8001310:	b25b      	sxtb	r3, r3
 8001312:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001316:	d103      	bne.n	8001320 <xQueueGenericSend+0x164>
 8001318:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800131a:	2200      	movs	r2, #0
 800131c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8001320:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001322:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8001326:	b25b      	sxtb	r3, r3
 8001328:	f1b3 3fff 	cmp.w	r3, #4294967295
 800132c:	d103      	bne.n	8001336 <xQueueGenericSend+0x17a>
 800132e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001330:	2200      	movs	r2, #0
 8001332:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8001336:	f7ff fd31 	bl	8000d9c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800133a:	1d3a      	adds	r2, r7, #4
 800133c:	f107 0314 	add.w	r3, r7, #20
 8001340:	4611      	mov	r1, r2
 8001342:	4618      	mov	r0, r3
 8001344:	f000 ff9c 	bl	8002280 <xTaskCheckForTimeOut>
 8001348:	4603      	mov	r3, r0
 800134a:	2b00      	cmp	r3, #0
 800134c:	d124      	bne.n	8001398 <xQueueGenericSend+0x1dc>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800134e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8001350:	f000 facc 	bl	80018ec <prvIsQueueFull>
 8001354:	4603      	mov	r3, r0
 8001356:	2b00      	cmp	r3, #0
 8001358:	d018      	beq.n	800138c <xQueueGenericSend+0x1d0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800135a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800135c:	3310      	adds	r3, #16
 800135e:	687a      	ldr	r2, [r7, #4]
 8001360:	4611      	mov	r1, r2
 8001362:	4618      	mov	r0, r3
 8001364:	f000 feb8 	bl	80020d8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8001368:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800136a:	f000 fa57 	bl	800181c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 800136e:	f000 fce9 	bl	8001d44 <xTaskResumeAll>
 8001372:	4603      	mov	r3, r0
 8001374:	2b00      	cmp	r3, #0
 8001376:	f47f af7c 	bne.w	8001272 <xQueueGenericSend+0xb6>
				{
					portYIELD_WITHIN_API();
 800137a:	4b0c      	ldr	r3, [pc, #48]	; (80013ac <xQueueGenericSend+0x1f0>)
 800137c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001380:	601a      	str	r2, [r3, #0]
 8001382:	f3bf 8f4f 	dsb	sy
 8001386:	f3bf 8f6f 	isb	sy
 800138a:	e772      	b.n	8001272 <xQueueGenericSend+0xb6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800138c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800138e:	f000 fa45 	bl	800181c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8001392:	f000 fcd7 	bl	8001d44 <xTaskResumeAll>
 8001396:	e76c      	b.n	8001272 <xQueueGenericSend+0xb6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8001398:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800139a:	f000 fa3f 	bl	800181c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800139e:	f000 fcd1 	bl	8001d44 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 80013a2:	2300      	movs	r3, #0
		}
	}
}
 80013a4:	4618      	mov	r0, r3
 80013a6:	3738      	adds	r7, #56	; 0x38
 80013a8:	46bd      	mov	sp, r7
 80013aa:	bd80      	pop	{r7, pc}
 80013ac:	e000ed04 	.word	0xe000ed04

080013b0 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 80013b0:	b580      	push	{r7, lr}
 80013b2:	b08e      	sub	sp, #56	; 0x38
 80013b4:	af00      	add	r7, sp, #0
 80013b6:	60f8      	str	r0, [r7, #12]
 80013b8:	60b9      	str	r1, [r7, #8]
 80013ba:	607a      	str	r2, [r7, #4]
 80013bc:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 80013be:	68fb      	ldr	r3, [r7, #12]
 80013c0:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 80013c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80013c4:	2b00      	cmp	r3, #0
 80013c6:	d109      	bne.n	80013dc <xQueueGenericSendFromISR+0x2c>
 80013c8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80013cc:	f383 8811 	msr	BASEPRI, r3
 80013d0:	f3bf 8f6f 	isb	sy
 80013d4:	f3bf 8f4f 	dsb	sy
 80013d8:	627b      	str	r3, [r7, #36]	; 0x24
 80013da:	e7fe      	b.n	80013da <xQueueGenericSendFromISR+0x2a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80013dc:	68bb      	ldr	r3, [r7, #8]
 80013de:	2b00      	cmp	r3, #0
 80013e0:	d103      	bne.n	80013ea <xQueueGenericSendFromISR+0x3a>
 80013e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80013e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80013e6:	2b00      	cmp	r3, #0
 80013e8:	d101      	bne.n	80013ee <xQueueGenericSendFromISR+0x3e>
 80013ea:	2301      	movs	r3, #1
 80013ec:	e000      	b.n	80013f0 <xQueueGenericSendFromISR+0x40>
 80013ee:	2300      	movs	r3, #0
 80013f0:	2b00      	cmp	r3, #0
 80013f2:	d109      	bne.n	8001408 <xQueueGenericSendFromISR+0x58>
 80013f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80013f8:	f383 8811 	msr	BASEPRI, r3
 80013fc:	f3bf 8f6f 	isb	sy
 8001400:	f3bf 8f4f 	dsb	sy
 8001404:	623b      	str	r3, [r7, #32]
 8001406:	e7fe      	b.n	8001406 <xQueueGenericSendFromISR+0x56>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8001408:	683b      	ldr	r3, [r7, #0]
 800140a:	2b02      	cmp	r3, #2
 800140c:	d103      	bne.n	8001416 <xQueueGenericSendFromISR+0x66>
 800140e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001410:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001412:	2b01      	cmp	r3, #1
 8001414:	d101      	bne.n	800141a <xQueueGenericSendFromISR+0x6a>
 8001416:	2301      	movs	r3, #1
 8001418:	e000      	b.n	800141c <xQueueGenericSendFromISR+0x6c>
 800141a:	2300      	movs	r3, #0
 800141c:	2b00      	cmp	r3, #0
 800141e:	d109      	bne.n	8001434 <xQueueGenericSendFromISR+0x84>
 8001420:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001424:	f383 8811 	msr	BASEPRI, r3
 8001428:	f3bf 8f6f 	isb	sy
 800142c:	f3bf 8f4f 	dsb	sy
 8001430:	61fb      	str	r3, [r7, #28]
 8001432:	e7fe      	b.n	8001432 <xQueueGenericSendFromISR+0x82>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8001434:	f7ff fd66 	bl	8000f04 <vPortValidateInterruptPriority>
	__asm volatile
 8001438:	f3ef 8211 	mrs	r2, BASEPRI
 800143c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001440:	f383 8811 	msr	BASEPRI, r3
 8001444:	f3bf 8f6f 	isb	sy
 8001448:	f3bf 8f4f 	dsb	sy
 800144c:	61ba      	str	r2, [r7, #24]
 800144e:	617b      	str	r3, [r7, #20]
	return ulOriginalBASEPRI;
 8001450:	69bb      	ldr	r3, [r7, #24]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001452:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001454:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001456:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001458:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800145a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800145c:	429a      	cmp	r2, r3
 800145e:	d302      	bcc.n	8001466 <xQueueGenericSendFromISR+0xb6>
 8001460:	683b      	ldr	r3, [r7, #0]
 8001462:	2b02      	cmp	r3, #2
 8001464:	d12c      	bne.n	80014c0 <xQueueGenericSendFromISR+0x110>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 8001466:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001468:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800146c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001470:	683a      	ldr	r2, [r7, #0]
 8001472:	68b9      	ldr	r1, [r7, #8]
 8001474:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8001476:	f000 f941 	bl	80016fc <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 800147a:	f997 302b 	ldrsb.w	r3, [r7, #43]	; 0x2b
 800147e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001482:	d112      	bne.n	80014aa <xQueueGenericSendFromISR+0xfa>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001484:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001486:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001488:	2b00      	cmp	r3, #0
 800148a:	d016      	beq.n	80014ba <xQueueGenericSendFromISR+0x10a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800148c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800148e:	3324      	adds	r3, #36	; 0x24
 8001490:	4618      	mov	r0, r3
 8001492:	f000 fe6f 	bl	8002174 <xTaskRemoveFromEventList>
 8001496:	4603      	mov	r3, r0
 8001498:	2b00      	cmp	r3, #0
 800149a:	d00e      	beq.n	80014ba <xQueueGenericSendFromISR+0x10a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800149c:	687b      	ldr	r3, [r7, #4]
 800149e:	2b00      	cmp	r3, #0
 80014a0:	d00b      	beq.n	80014ba <xQueueGenericSendFromISR+0x10a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 80014a2:	687b      	ldr	r3, [r7, #4]
 80014a4:	2201      	movs	r2, #1
 80014a6:	601a      	str	r2, [r3, #0]
 80014a8:	e007      	b.n	80014ba <xQueueGenericSendFromISR+0x10a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80014aa:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80014ae:	3301      	adds	r3, #1
 80014b0:	b2db      	uxtb	r3, r3
 80014b2:	b25a      	sxtb	r2, r3
 80014b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80014b6:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
 80014ba:	2301      	movs	r3, #1
 80014bc:	637b      	str	r3, [r7, #52]	; 0x34
		{
 80014be:	e001      	b.n	80014c4 <xQueueGenericSendFromISR+0x114>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 80014c0:	2300      	movs	r3, #0
 80014c2:	637b      	str	r3, [r7, #52]	; 0x34
 80014c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80014c6:	613b      	str	r3, [r7, #16]
	__asm volatile
 80014c8:	693b      	ldr	r3, [r7, #16]
 80014ca:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 80014ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 80014d0:	4618      	mov	r0, r3
 80014d2:	3738      	adds	r7, #56	; 0x38
 80014d4:	46bd      	mov	sp, r7
 80014d6:	bd80      	pop	{r7, pc}

080014d8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 80014d8:	b580      	push	{r7, lr}
 80014da:	b08e      	sub	sp, #56	; 0x38
 80014dc:	af00      	add	r7, sp, #0
 80014de:	60f8      	str	r0, [r7, #12]
 80014e0:	60b9      	str	r1, [r7, #8]
 80014e2:	607a      	str	r2, [r7, #4]
 80014e4:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
 80014e6:	2300      	movs	r3, #0
 80014e8:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 80014ea:	68fb      	ldr	r3, [r7, #12]
 80014ec:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 80014ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80014f0:	2b00      	cmp	r3, #0
 80014f2:	d109      	bne.n	8001508 <xQueueGenericReceive+0x30>
	__asm volatile
 80014f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80014f8:	f383 8811 	msr	BASEPRI, r3
 80014fc:	f3bf 8f6f 	isb	sy
 8001500:	f3bf 8f4f 	dsb	sy
 8001504:	627b      	str	r3, [r7, #36]	; 0x24
 8001506:	e7fe      	b.n	8001506 <xQueueGenericReceive+0x2e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8001508:	68bb      	ldr	r3, [r7, #8]
 800150a:	2b00      	cmp	r3, #0
 800150c:	d103      	bne.n	8001516 <xQueueGenericReceive+0x3e>
 800150e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001510:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001512:	2b00      	cmp	r3, #0
 8001514:	d101      	bne.n	800151a <xQueueGenericReceive+0x42>
 8001516:	2301      	movs	r3, #1
 8001518:	e000      	b.n	800151c <xQueueGenericReceive+0x44>
 800151a:	2300      	movs	r3, #0
 800151c:	2b00      	cmp	r3, #0
 800151e:	d109      	bne.n	8001534 <xQueueGenericReceive+0x5c>
 8001520:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001524:	f383 8811 	msr	BASEPRI, r3
 8001528:	f3bf 8f6f 	isb	sy
 800152c:	f3bf 8f4f 	dsb	sy
 8001530:	623b      	str	r3, [r7, #32]
 8001532:	e7fe      	b.n	8001532 <xQueueGenericReceive+0x5a>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001534:	f000 ffd8 	bl	80024e8 <xTaskGetSchedulerState>
 8001538:	4603      	mov	r3, r0
 800153a:	2b00      	cmp	r3, #0
 800153c:	d102      	bne.n	8001544 <xQueueGenericReceive+0x6c>
 800153e:	687b      	ldr	r3, [r7, #4]
 8001540:	2b00      	cmp	r3, #0
 8001542:	d101      	bne.n	8001548 <xQueueGenericReceive+0x70>
 8001544:	2301      	movs	r3, #1
 8001546:	e000      	b.n	800154a <xQueueGenericReceive+0x72>
 8001548:	2300      	movs	r3, #0
 800154a:	2b00      	cmp	r3, #0
 800154c:	d109      	bne.n	8001562 <xQueueGenericReceive+0x8a>
 800154e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001552:	f383 8811 	msr	BASEPRI, r3
 8001556:	f3bf 8f6f 	isb	sy
 800155a:	f3bf 8f4f 	dsb	sy
 800155e:	61fb      	str	r3, [r7, #28]
 8001560:	e7fe      	b.n	8001560 <xQueueGenericReceive+0x88>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8001562:	f7ff fbed 	bl	8000d40 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001566:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001568:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800156a:	62fb      	str	r3, [r7, #44]	; 0x2c

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800156c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800156e:	2b00      	cmp	r3, #0
 8001570:	d046      	beq.n	8001600 <xQueueGenericReceive+0x128>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8001572:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001574:	68db      	ldr	r3, [r3, #12]
 8001576:	62bb      	str	r3, [r7, #40]	; 0x28

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001578:	68b9      	ldr	r1, [r7, #8]
 800157a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800157c:	f000 f928 	bl	80017d0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8001580:	683b      	ldr	r3, [r7, #0]
 8001582:	2b00      	cmp	r3, #0
 8001584:	d121      	bne.n	80015ca <xQueueGenericReceive+0xf2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8001586:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001588:	1e5a      	subs	r2, r3, #1
 800158a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800158c:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800158e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001590:	681b      	ldr	r3, [r3, #0]
 8001592:	2b00      	cmp	r3, #0
 8001594:	d104      	bne.n	80015a0 <xQueueGenericReceive+0xc8>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8001596:	f001 f8bf 	bl	8002718 <pvTaskIncrementMutexHeldCount>
 800159a:	4602      	mov	r2, r0
 800159c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800159e:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80015a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80015a2:	691b      	ldr	r3, [r3, #16]
 80015a4:	2b00      	cmp	r3, #0
 80015a6:	d027      	beq.n	80015f8 <xQueueGenericReceive+0x120>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80015a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80015aa:	3310      	adds	r3, #16
 80015ac:	4618      	mov	r0, r3
 80015ae:	f000 fde1 	bl	8002174 <xTaskRemoveFromEventList>
 80015b2:	4603      	mov	r3, r0
 80015b4:	2b00      	cmp	r3, #0
 80015b6:	d01f      	beq.n	80015f8 <xQueueGenericReceive+0x120>
						{
							queueYIELD_IF_USING_PREEMPTION();
 80015b8:	4b4f      	ldr	r3, [pc, #316]	; (80016f8 <xQueueGenericReceive+0x220>)
 80015ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80015be:	601a      	str	r2, [r3, #0]
 80015c0:	f3bf 8f4f 	dsb	sy
 80015c4:	f3bf 8f6f 	isb	sy
 80015c8:	e016      	b.n	80015f8 <xQueueGenericReceive+0x120>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 80015ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80015cc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80015ce:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80015d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80015d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80015d4:	2b00      	cmp	r3, #0
 80015d6:	d00f      	beq.n	80015f8 <xQueueGenericReceive+0x120>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80015d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80015da:	3324      	adds	r3, #36	; 0x24
 80015dc:	4618      	mov	r0, r3
 80015de:	f000 fdc9 	bl	8002174 <xTaskRemoveFromEventList>
 80015e2:	4603      	mov	r3, r0
 80015e4:	2b00      	cmp	r3, #0
 80015e6:	d007      	beq.n	80015f8 <xQueueGenericReceive+0x120>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
 80015e8:	4b43      	ldr	r3, [pc, #268]	; (80016f8 <xQueueGenericReceive+0x220>)
 80015ea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80015ee:	601a      	str	r2, [r3, #0]
 80015f0:	f3bf 8f4f 	dsb	sy
 80015f4:	f3bf 8f6f 	isb	sy
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 80015f8:	f7ff fbd0 	bl	8000d9c <vPortExitCritical>
				return pdPASS;
 80015fc:	2301      	movs	r3, #1
 80015fe:	e077      	b.n	80016f0 <xQueueGenericReceive+0x218>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8001600:	687b      	ldr	r3, [r7, #4]
 8001602:	2b00      	cmp	r3, #0
 8001604:	d103      	bne.n	800160e <xQueueGenericReceive+0x136>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8001606:	f7ff fbc9 	bl	8000d9c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800160a:	2300      	movs	r3, #0
 800160c:	e070      	b.n	80016f0 <xQueueGenericReceive+0x218>
				}
				else if( xEntryTimeSet == pdFALSE )
 800160e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001610:	2b00      	cmp	r3, #0
 8001612:	d106      	bne.n	8001622 <xQueueGenericReceive+0x14a>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8001614:	f107 0314 	add.w	r3, r7, #20
 8001618:	4618      	mov	r0, r3
 800161a:	f000 fe0d 	bl	8002238 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800161e:	2301      	movs	r3, #1
 8001620:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8001622:	f7ff fbbb 	bl	8000d9c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8001626:	f000 fb7f 	bl	8001d28 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800162a:	f7ff fb89 	bl	8000d40 <vPortEnterCritical>
 800162e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001630:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8001634:	b25b      	sxtb	r3, r3
 8001636:	f1b3 3fff 	cmp.w	r3, #4294967295
 800163a:	d103      	bne.n	8001644 <xQueueGenericReceive+0x16c>
 800163c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800163e:	2200      	movs	r2, #0
 8001640:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8001644:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001646:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800164a:	b25b      	sxtb	r3, r3
 800164c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001650:	d103      	bne.n	800165a <xQueueGenericReceive+0x182>
 8001652:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001654:	2200      	movs	r2, #0
 8001656:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800165a:	f7ff fb9f 	bl	8000d9c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800165e:	1d3a      	adds	r2, r7, #4
 8001660:	f107 0314 	add.w	r3, r7, #20
 8001664:	4611      	mov	r1, r2
 8001666:	4618      	mov	r0, r3
 8001668:	f000 fe0a 	bl	8002280 <xTaskCheckForTimeOut>
 800166c:	4603      	mov	r3, r0
 800166e:	2b00      	cmp	r3, #0
 8001670:	d131      	bne.n	80016d6 <xQueueGenericReceive+0x1fe>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001672:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8001674:	f000 f924 	bl	80018c0 <prvIsQueueEmpty>
 8001678:	4603      	mov	r3, r0
 800167a:	2b00      	cmp	r3, #0
 800167c:	d025      	beq.n	80016ca <xQueueGenericReceive+0x1f2>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800167e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001680:	681b      	ldr	r3, [r3, #0]
 8001682:	2b00      	cmp	r3, #0
 8001684:	d108      	bne.n	8001698 <xQueueGenericReceive+0x1c0>
					{
						taskENTER_CRITICAL();
 8001686:	f7ff fb5b 	bl	8000d40 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800168a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800168c:	685b      	ldr	r3, [r3, #4]
 800168e:	4618      	mov	r0, r3
 8001690:	f000 ff48 	bl	8002524 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 8001694:	f7ff fb82 	bl	8000d9c <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001698:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800169a:	3324      	adds	r3, #36	; 0x24
 800169c:	687a      	ldr	r2, [r7, #4]
 800169e:	4611      	mov	r1, r2
 80016a0:	4618      	mov	r0, r3
 80016a2:	f000 fd19 	bl	80020d8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80016a6:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80016a8:	f000 f8b8 	bl	800181c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80016ac:	f000 fb4a 	bl	8001d44 <xTaskResumeAll>
 80016b0:	4603      	mov	r3, r0
 80016b2:	2b00      	cmp	r3, #0
 80016b4:	f47f af55 	bne.w	8001562 <xQueueGenericReceive+0x8a>
				{
					portYIELD_WITHIN_API();
 80016b8:	4b0f      	ldr	r3, [pc, #60]	; (80016f8 <xQueueGenericReceive+0x220>)
 80016ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80016be:	601a      	str	r2, [r3, #0]
 80016c0:	f3bf 8f4f 	dsb	sy
 80016c4:	f3bf 8f6f 	isb	sy
 80016c8:	e74b      	b.n	8001562 <xQueueGenericReceive+0x8a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80016ca:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80016cc:	f000 f8a6 	bl	800181c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80016d0:	f000 fb38 	bl	8001d44 <xTaskResumeAll>
 80016d4:	e745      	b.n	8001562 <xQueueGenericReceive+0x8a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 80016d6:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80016d8:	f000 f8a0 	bl	800181c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80016dc:	f000 fb32 	bl	8001d44 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80016e0:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80016e2:	f000 f8ed 	bl	80018c0 <prvIsQueueEmpty>
 80016e6:	4603      	mov	r3, r0
 80016e8:	2b00      	cmp	r3, #0
 80016ea:	f43f af3a 	beq.w	8001562 <xQueueGenericReceive+0x8a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 80016ee:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
 80016f0:	4618      	mov	r0, r3
 80016f2:	3738      	adds	r7, #56	; 0x38
 80016f4:	46bd      	mov	sp, r7
 80016f6:	bd80      	pop	{r7, pc}
 80016f8:	e000ed04 	.word	0xe000ed04

080016fc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 80016fc:	b580      	push	{r7, lr}
 80016fe:	b086      	sub	sp, #24
 8001700:	af00      	add	r7, sp, #0
 8001702:	60f8      	str	r0, [r7, #12]
 8001704:	60b9      	str	r1, [r7, #8]
 8001706:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
 8001708:	2300      	movs	r3, #0
 800170a:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800170c:	68fb      	ldr	r3, [r7, #12]
 800170e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001710:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8001712:	68fb      	ldr	r3, [r7, #12]
 8001714:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001716:	2b00      	cmp	r3, #0
 8001718:	d10d      	bne.n	8001736 <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800171a:	68fb      	ldr	r3, [r7, #12]
 800171c:	681b      	ldr	r3, [r3, #0]
 800171e:	2b00      	cmp	r3, #0
 8001720:	d14d      	bne.n	80017be <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8001722:	68fb      	ldr	r3, [r7, #12]
 8001724:	685b      	ldr	r3, [r3, #4]
 8001726:	4618      	mov	r0, r3
 8001728:	f000 ff72 	bl	8002610 <xTaskPriorityDisinherit>
 800172c:	6178      	str	r0, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
 800172e:	68fb      	ldr	r3, [r7, #12]
 8001730:	2200      	movs	r2, #0
 8001732:	605a      	str	r2, [r3, #4]
 8001734:	e043      	b.n	80017be <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8001736:	687b      	ldr	r3, [r7, #4]
 8001738:	2b00      	cmp	r3, #0
 800173a:	d119      	bne.n	8001770 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800173c:	68fb      	ldr	r3, [r7, #12]
 800173e:	6898      	ldr	r0, [r3, #8]
 8001740:	68fb      	ldr	r3, [r7, #12]
 8001742:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001744:	461a      	mov	r2, r3
 8001746:	68b9      	ldr	r1, [r7, #8]
 8001748:	f00c ff8d 	bl	800e666 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800174c:	68fb      	ldr	r3, [r7, #12]
 800174e:	689a      	ldr	r2, [r3, #8]
 8001750:	68fb      	ldr	r3, [r7, #12]
 8001752:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001754:	441a      	add	r2, r3
 8001756:	68fb      	ldr	r3, [r7, #12]
 8001758:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800175a:	68fb      	ldr	r3, [r7, #12]
 800175c:	689a      	ldr	r2, [r3, #8]
 800175e:	68fb      	ldr	r3, [r7, #12]
 8001760:	685b      	ldr	r3, [r3, #4]
 8001762:	429a      	cmp	r2, r3
 8001764:	d32b      	bcc.n	80017be <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8001766:	68fb      	ldr	r3, [r7, #12]
 8001768:	681a      	ldr	r2, [r3, #0]
 800176a:	68fb      	ldr	r3, [r7, #12]
 800176c:	609a      	str	r2, [r3, #8]
 800176e:	e026      	b.n	80017be <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001770:	68fb      	ldr	r3, [r7, #12]
 8001772:	68d8      	ldr	r0, [r3, #12]
 8001774:	68fb      	ldr	r3, [r7, #12]
 8001776:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001778:	461a      	mov	r2, r3
 800177a:	68b9      	ldr	r1, [r7, #8]
 800177c:	f00c ff73 	bl	800e666 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8001780:	68fb      	ldr	r3, [r7, #12]
 8001782:	68da      	ldr	r2, [r3, #12]
 8001784:	68fb      	ldr	r3, [r7, #12]
 8001786:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001788:	425b      	negs	r3, r3
 800178a:	441a      	add	r2, r3
 800178c:	68fb      	ldr	r3, [r7, #12]
 800178e:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001790:	68fb      	ldr	r3, [r7, #12]
 8001792:	68da      	ldr	r2, [r3, #12]
 8001794:	68fb      	ldr	r3, [r7, #12]
 8001796:	681b      	ldr	r3, [r3, #0]
 8001798:	429a      	cmp	r2, r3
 800179a:	d207      	bcs.n	80017ac <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800179c:	68fb      	ldr	r3, [r7, #12]
 800179e:	685a      	ldr	r2, [r3, #4]
 80017a0:	68fb      	ldr	r3, [r7, #12]
 80017a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80017a4:	425b      	negs	r3, r3
 80017a6:	441a      	add	r2, r3
 80017a8:	68fb      	ldr	r3, [r7, #12]
 80017aa:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 80017ac:	687b      	ldr	r3, [r7, #4]
 80017ae:	2b02      	cmp	r3, #2
 80017b0:	d105      	bne.n	80017be <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80017b2:	693b      	ldr	r3, [r7, #16]
 80017b4:	2b00      	cmp	r3, #0
 80017b6:	d002      	beq.n	80017be <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 80017b8:	693b      	ldr	r3, [r7, #16]
 80017ba:	3b01      	subs	r3, #1
 80017bc:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 80017be:	693b      	ldr	r3, [r7, #16]
 80017c0:	1c5a      	adds	r2, r3, #1
 80017c2:	68fb      	ldr	r3, [r7, #12]
 80017c4:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
 80017c6:	697b      	ldr	r3, [r7, #20]
}
 80017c8:	4618      	mov	r0, r3
 80017ca:	3718      	adds	r7, #24
 80017cc:	46bd      	mov	sp, r7
 80017ce:	bd80      	pop	{r7, pc}

080017d0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 80017d0:	b580      	push	{r7, lr}
 80017d2:	b082      	sub	sp, #8
 80017d4:	af00      	add	r7, sp, #0
 80017d6:	6078      	str	r0, [r7, #4]
 80017d8:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80017da:	687b      	ldr	r3, [r7, #4]
 80017dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80017de:	2b00      	cmp	r3, #0
 80017e0:	d018      	beq.n	8001814 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80017e2:	687b      	ldr	r3, [r7, #4]
 80017e4:	68da      	ldr	r2, [r3, #12]
 80017e6:	687b      	ldr	r3, [r7, #4]
 80017e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80017ea:	441a      	add	r2, r3
 80017ec:	687b      	ldr	r3, [r7, #4]
 80017ee:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80017f0:	687b      	ldr	r3, [r7, #4]
 80017f2:	68da      	ldr	r2, [r3, #12]
 80017f4:	687b      	ldr	r3, [r7, #4]
 80017f6:	685b      	ldr	r3, [r3, #4]
 80017f8:	429a      	cmp	r2, r3
 80017fa:	d303      	bcc.n	8001804 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 80017fc:	687b      	ldr	r3, [r7, #4]
 80017fe:	681a      	ldr	r2, [r3, #0]
 8001800:	687b      	ldr	r3, [r7, #4]
 8001802:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8001804:	687b      	ldr	r3, [r7, #4]
 8001806:	68d9      	ldr	r1, [r3, #12]
 8001808:	687b      	ldr	r3, [r7, #4]
 800180a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800180c:	461a      	mov	r2, r3
 800180e:	6838      	ldr	r0, [r7, #0]
 8001810:	f00c ff29 	bl	800e666 <memcpy>
	}
}
 8001814:	bf00      	nop
 8001816:	3708      	adds	r7, #8
 8001818:	46bd      	mov	sp, r7
 800181a:	bd80      	pop	{r7, pc}

0800181c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800181c:	b580      	push	{r7, lr}
 800181e:	b084      	sub	sp, #16
 8001820:	af00      	add	r7, sp, #0
 8001822:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8001824:	f7ff fa8c 	bl	8000d40 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8001828:	687b      	ldr	r3, [r7, #4]
 800182a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800182e:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8001830:	e011      	b.n	8001856 <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001832:	687b      	ldr	r3, [r7, #4]
 8001834:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001836:	2b00      	cmp	r3, #0
 8001838:	d012      	beq.n	8001860 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800183a:	687b      	ldr	r3, [r7, #4]
 800183c:	3324      	adds	r3, #36	; 0x24
 800183e:	4618      	mov	r0, r3
 8001840:	f000 fc98 	bl	8002174 <xTaskRemoveFromEventList>
 8001844:	4603      	mov	r3, r0
 8001846:	2b00      	cmp	r3, #0
 8001848:	d001      	beq.n	800184e <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 800184a:	f000 fd77 	bl	800233c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 800184e:	7bfb      	ldrb	r3, [r7, #15]
 8001850:	3b01      	subs	r3, #1
 8001852:	b2db      	uxtb	r3, r3
 8001854:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8001856:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800185a:	2b00      	cmp	r3, #0
 800185c:	dce9      	bgt.n	8001832 <prvUnlockQueue+0x16>
 800185e:	e000      	b.n	8001862 <prvUnlockQueue+0x46>
					break;
 8001860:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8001862:	687b      	ldr	r3, [r7, #4]
 8001864:	22ff      	movs	r2, #255	; 0xff
 8001866:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 800186a:	f7ff fa97 	bl	8000d9c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800186e:	f7ff fa67 	bl	8000d40 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8001872:	687b      	ldr	r3, [r7, #4]
 8001874:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8001878:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
 800187a:	e011      	b.n	80018a0 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800187c:	687b      	ldr	r3, [r7, #4]
 800187e:	691b      	ldr	r3, [r3, #16]
 8001880:	2b00      	cmp	r3, #0
 8001882:	d012      	beq.n	80018aa <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001884:	687b      	ldr	r3, [r7, #4]
 8001886:	3310      	adds	r3, #16
 8001888:	4618      	mov	r0, r3
 800188a:	f000 fc73 	bl	8002174 <xTaskRemoveFromEventList>
 800188e:	4603      	mov	r3, r0
 8001890:	2b00      	cmp	r3, #0
 8001892:	d001      	beq.n	8001898 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
 8001894:	f000 fd52 	bl	800233c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 8001898:	7bbb      	ldrb	r3, [r7, #14]
 800189a:	3b01      	subs	r3, #1
 800189c:	b2db      	uxtb	r3, r3
 800189e:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80018a0:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80018a4:	2b00      	cmp	r3, #0
 80018a6:	dce9      	bgt.n	800187c <prvUnlockQueue+0x60>
 80018a8:	e000      	b.n	80018ac <prvUnlockQueue+0x90>
			}
			else
			{
				break;
 80018aa:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 80018ac:	687b      	ldr	r3, [r7, #4]
 80018ae:	22ff      	movs	r2, #255	; 0xff
 80018b0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 80018b4:	f7ff fa72 	bl	8000d9c <vPortExitCritical>
}
 80018b8:	bf00      	nop
 80018ba:	3710      	adds	r7, #16
 80018bc:	46bd      	mov	sp, r7
 80018be:	bd80      	pop	{r7, pc}

080018c0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 80018c0:	b580      	push	{r7, lr}
 80018c2:	b084      	sub	sp, #16
 80018c4:	af00      	add	r7, sp, #0
 80018c6:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80018c8:	f7ff fa3a 	bl	8000d40 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80018cc:	687b      	ldr	r3, [r7, #4]
 80018ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80018d0:	2b00      	cmp	r3, #0
 80018d2:	d102      	bne.n	80018da <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 80018d4:	2301      	movs	r3, #1
 80018d6:	60fb      	str	r3, [r7, #12]
 80018d8:	e001      	b.n	80018de <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 80018da:	2300      	movs	r3, #0
 80018dc:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 80018de:	f7ff fa5d 	bl	8000d9c <vPortExitCritical>

	return xReturn;
 80018e2:	68fb      	ldr	r3, [r7, #12]
}
 80018e4:	4618      	mov	r0, r3
 80018e6:	3710      	adds	r7, #16
 80018e8:	46bd      	mov	sp, r7
 80018ea:	bd80      	pop	{r7, pc}

080018ec <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 80018ec:	b580      	push	{r7, lr}
 80018ee:	b084      	sub	sp, #16
 80018f0:	af00      	add	r7, sp, #0
 80018f2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80018f4:	f7ff fa24 	bl	8000d40 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80018f8:	687b      	ldr	r3, [r7, #4]
 80018fa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80018fc:	687b      	ldr	r3, [r7, #4]
 80018fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001900:	429a      	cmp	r2, r3
 8001902:	d102      	bne.n	800190a <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 8001904:	2301      	movs	r3, #1
 8001906:	60fb      	str	r3, [r7, #12]
 8001908:	e001      	b.n	800190e <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 800190a:	2300      	movs	r3, #0
 800190c:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 800190e:	f7ff fa45 	bl	8000d9c <vPortExitCritical>

	return xReturn;
 8001912:	68fb      	ldr	r3, [r7, #12]
}
 8001914:	4618      	mov	r0, r3
 8001916:	3710      	adds	r7, #16
 8001918:	46bd      	mov	sp, r7
 800191a:	bd80      	pop	{r7, pc}

0800191c <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 800191c:	b480      	push	{r7}
 800191e:	b085      	sub	sp, #20
 8001920:	af00      	add	r7, sp, #0
 8001922:	6078      	str	r0, [r7, #4]
 8001924:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001926:	2300      	movs	r3, #0
 8001928:	60fb      	str	r3, [r7, #12]
 800192a:	e014      	b.n	8001956 <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 800192c:	4a0e      	ldr	r2, [pc, #56]	; (8001968 <vQueueAddToRegistry+0x4c>)
 800192e:	68fb      	ldr	r3, [r7, #12]
 8001930:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8001934:	2b00      	cmp	r3, #0
 8001936:	d10b      	bne.n	8001950 <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8001938:	490b      	ldr	r1, [pc, #44]	; (8001968 <vQueueAddToRegistry+0x4c>)
 800193a:	68fb      	ldr	r3, [r7, #12]
 800193c:	683a      	ldr	r2, [r7, #0]
 800193e:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8001942:	4a09      	ldr	r2, [pc, #36]	; (8001968 <vQueueAddToRegistry+0x4c>)
 8001944:	68fb      	ldr	r3, [r7, #12]
 8001946:	00db      	lsls	r3, r3, #3
 8001948:	4413      	add	r3, r2
 800194a:	687a      	ldr	r2, [r7, #4]
 800194c:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 800194e:	e005      	b.n	800195c <vQueueAddToRegistry+0x40>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001950:	68fb      	ldr	r3, [r7, #12]
 8001952:	3301      	adds	r3, #1
 8001954:	60fb      	str	r3, [r7, #12]
 8001956:	68fb      	ldr	r3, [r7, #12]
 8001958:	2b07      	cmp	r3, #7
 800195a:	d9e7      	bls.n	800192c <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 800195c:	bf00      	nop
 800195e:	3714      	adds	r7, #20
 8001960:	46bd      	mov	sp, r7
 8001962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001966:	4770      	bx	lr
 8001968:	20007d44 	.word	0x20007d44

0800196c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800196c:	b580      	push	{r7, lr}
 800196e:	b086      	sub	sp, #24
 8001970:	af00      	add	r7, sp, #0
 8001972:	60f8      	str	r0, [r7, #12]
 8001974:	60b9      	str	r1, [r7, #8]
 8001976:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 8001978:	68fb      	ldr	r3, [r7, #12]
 800197a:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 800197c:	f7ff f9e0 	bl	8000d40 <vPortEnterCritical>
 8001980:	697b      	ldr	r3, [r7, #20]
 8001982:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8001986:	b25b      	sxtb	r3, r3
 8001988:	f1b3 3fff 	cmp.w	r3, #4294967295
 800198c:	d103      	bne.n	8001996 <vQueueWaitForMessageRestricted+0x2a>
 800198e:	697b      	ldr	r3, [r7, #20]
 8001990:	2200      	movs	r2, #0
 8001992:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8001996:	697b      	ldr	r3, [r7, #20]
 8001998:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800199c:	b25b      	sxtb	r3, r3
 800199e:	f1b3 3fff 	cmp.w	r3, #4294967295
 80019a2:	d103      	bne.n	80019ac <vQueueWaitForMessageRestricted+0x40>
 80019a4:	697b      	ldr	r3, [r7, #20]
 80019a6:	2200      	movs	r2, #0
 80019a8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80019ac:	f7ff f9f6 	bl	8000d9c <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 80019b0:	697b      	ldr	r3, [r7, #20]
 80019b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80019b4:	2b00      	cmp	r3, #0
 80019b6:	d106      	bne.n	80019c6 <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 80019b8:	697b      	ldr	r3, [r7, #20]
 80019ba:	3324      	adds	r3, #36	; 0x24
 80019bc:	687a      	ldr	r2, [r7, #4]
 80019be:	68b9      	ldr	r1, [r7, #8]
 80019c0:	4618      	mov	r0, r3
 80019c2:	f000 fbad 	bl	8002120 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 80019c6:	6978      	ldr	r0, [r7, #20]
 80019c8:	f7ff ff28 	bl	800181c <prvUnlockQueue>
	}
 80019cc:	bf00      	nop
 80019ce:	3718      	adds	r7, #24
 80019d0:	46bd      	mov	sp, r7
 80019d2:	bd80      	pop	{r7, pc}

080019d4 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 80019d4:	b580      	push	{r7, lr}
 80019d6:	b08c      	sub	sp, #48	; 0x30
 80019d8:	af04      	add	r7, sp, #16
 80019da:	60f8      	str	r0, [r7, #12]
 80019dc:	60b9      	str	r1, [r7, #8]
 80019de:	603b      	str	r3, [r7, #0]
 80019e0:	4613      	mov	r3, r2
 80019e2:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80019e4:	88fb      	ldrh	r3, [r7, #6]
 80019e6:	009b      	lsls	r3, r3, #2
 80019e8:	4618      	mov	r0, r3
 80019ea:	f7ff fac9 	bl	8000f80 <pvPortMalloc>
 80019ee:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
 80019f0:	697b      	ldr	r3, [r7, #20]
 80019f2:	2b00      	cmp	r3, #0
 80019f4:	d00e      	beq.n	8001a14 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 80019f6:	2050      	movs	r0, #80	; 0x50
 80019f8:	f7ff fac2 	bl	8000f80 <pvPortMalloc>
 80019fc:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
 80019fe:	69fb      	ldr	r3, [r7, #28]
 8001a00:	2b00      	cmp	r3, #0
 8001a02:	d003      	beq.n	8001a0c <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 8001a04:	69fb      	ldr	r3, [r7, #28]
 8001a06:	697a      	ldr	r2, [r7, #20]
 8001a08:	631a      	str	r2, [r3, #48]	; 0x30
 8001a0a:	e005      	b.n	8001a18 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 8001a0c:	6978      	ldr	r0, [r7, #20]
 8001a0e:	f7ff fafd 	bl	800100c <vPortFree>
 8001a12:	e001      	b.n	8001a18 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
 8001a14:	2300      	movs	r3, #0
 8001a16:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 8001a18:	69fb      	ldr	r3, [r7, #28]
 8001a1a:	2b00      	cmp	r3, #0
 8001a1c:	d013      	beq.n	8001a46 <xTaskCreate+0x72>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8001a1e:	88fa      	ldrh	r2, [r7, #6]
 8001a20:	2300      	movs	r3, #0
 8001a22:	9303      	str	r3, [sp, #12]
 8001a24:	69fb      	ldr	r3, [r7, #28]
 8001a26:	9302      	str	r3, [sp, #8]
 8001a28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001a2a:	9301      	str	r3, [sp, #4]
 8001a2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001a2e:	9300      	str	r3, [sp, #0]
 8001a30:	683b      	ldr	r3, [r7, #0]
 8001a32:	68b9      	ldr	r1, [r7, #8]
 8001a34:	68f8      	ldr	r0, [r7, #12]
 8001a36:	f000 f80e 	bl	8001a56 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8001a3a:	69f8      	ldr	r0, [r7, #28]
 8001a3c:	f000 f88a 	bl	8001b54 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8001a40:	2301      	movs	r3, #1
 8001a42:	61bb      	str	r3, [r7, #24]
 8001a44:	e002      	b.n	8001a4c <xTaskCreate+0x78>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001a46:	f04f 33ff 	mov.w	r3, #4294967295
 8001a4a:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 8001a4c:	69bb      	ldr	r3, [r7, #24]
	}
 8001a4e:	4618      	mov	r0, r3
 8001a50:	3720      	adds	r7, #32
 8001a52:	46bd      	mov	sp, r7
 8001a54:	bd80      	pop	{r7, pc}

08001a56 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8001a56:	b580      	push	{r7, lr}
 8001a58:	b088      	sub	sp, #32
 8001a5a:	af00      	add	r7, sp, #0
 8001a5c:	60f8      	str	r0, [r7, #12]
 8001a5e:	60b9      	str	r1, [r7, #8]
 8001a60:	607a      	str	r2, [r7, #4]
 8001a62:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8001a64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a66:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001a68:	687b      	ldr	r3, [r7, #4]
 8001a6a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001a6e:	3b01      	subs	r3, #1
 8001a70:	009b      	lsls	r3, r3, #2
 8001a72:	4413      	add	r3, r2
 8001a74:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8001a76:	69bb      	ldr	r3, [r7, #24]
 8001a78:	f023 0307 	bic.w	r3, r3, #7
 8001a7c:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 8001a7e:	69bb      	ldr	r3, [r7, #24]
 8001a80:	f003 0307 	and.w	r3, r3, #7
 8001a84:	2b00      	cmp	r3, #0
 8001a86:	d009      	beq.n	8001a9c <prvInitialiseNewTask+0x46>
 8001a88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001a8c:	f383 8811 	msr	BASEPRI, r3
 8001a90:	f3bf 8f6f 	isb	sy
 8001a94:	f3bf 8f4f 	dsb	sy
 8001a98:	617b      	str	r3, [r7, #20]
 8001a9a:	e7fe      	b.n	8001a9a <prvInitialiseNewTask+0x44>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001a9c:	2300      	movs	r3, #0
 8001a9e:	61fb      	str	r3, [r7, #28]
 8001aa0:	e012      	b.n	8001ac8 <prvInitialiseNewTask+0x72>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001aa2:	68ba      	ldr	r2, [r7, #8]
 8001aa4:	69fb      	ldr	r3, [r7, #28]
 8001aa6:	4413      	add	r3, r2
 8001aa8:	7819      	ldrb	r1, [r3, #0]
 8001aaa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001aac:	69fb      	ldr	r3, [r7, #28]
 8001aae:	4413      	add	r3, r2
 8001ab0:	3334      	adds	r3, #52	; 0x34
 8001ab2:	460a      	mov	r2, r1
 8001ab4:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8001ab6:	68ba      	ldr	r2, [r7, #8]
 8001ab8:	69fb      	ldr	r3, [r7, #28]
 8001aba:	4413      	add	r3, r2
 8001abc:	781b      	ldrb	r3, [r3, #0]
 8001abe:	2b00      	cmp	r3, #0
 8001ac0:	d006      	beq.n	8001ad0 <prvInitialiseNewTask+0x7a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001ac2:	69fb      	ldr	r3, [r7, #28]
 8001ac4:	3301      	adds	r3, #1
 8001ac6:	61fb      	str	r3, [r7, #28]
 8001ac8:	69fb      	ldr	r3, [r7, #28]
 8001aca:	2b09      	cmp	r3, #9
 8001acc:	d9e9      	bls.n	8001aa2 <prvInitialiseNewTask+0x4c>
 8001ace:	e000      	b.n	8001ad2 <prvInitialiseNewTask+0x7c>
		{
			break;
 8001ad0:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8001ad2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ad4:	2200      	movs	r2, #0
 8001ad6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8001ada:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001adc:	2b04      	cmp	r3, #4
 8001ade:	d901      	bls.n	8001ae4 <prvInitialiseNewTask+0x8e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8001ae0:	2304      	movs	r3, #4
 8001ae2:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 8001ae4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ae6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001ae8:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 8001aea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001aec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001aee:	641a      	str	r2, [r3, #64]	; 0x40
		pxNewTCB->uxMutexesHeld = 0;
 8001af0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001af2:	2200      	movs	r2, #0
 8001af4:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001af6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001af8:	3304      	adds	r3, #4
 8001afa:	4618      	mov	r0, r3
 8001afc:	f7fe ff84 	bl	8000a08 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8001b00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b02:	3318      	adds	r3, #24
 8001b04:	4618      	mov	r0, r3
 8001b06:	f7fe ff7f 	bl	8000a08 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8001b0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b0c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001b0e:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001b10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001b12:	f1c3 0205 	rsb	r2, r3, #5
 8001b16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b18:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8001b1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b1c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001b1e:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 8001b20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b22:	2200      	movs	r2, #0
 8001b24:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8001b26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b28:	2200      	movs	r2, #0
 8001b2a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001b2e:	683a      	ldr	r2, [r7, #0]
 8001b30:	68f9      	ldr	r1, [r7, #12]
 8001b32:	69b8      	ldr	r0, [r7, #24]
 8001b34:	f7fe fffc 	bl	8000b30 <pxPortInitialiseStack>
 8001b38:	4602      	mov	r2, r0
 8001b3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b3c:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 8001b3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001b40:	2b00      	cmp	r3, #0
 8001b42:	d002      	beq.n	8001b4a <prvInitialiseNewTask+0xf4>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8001b44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001b46:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001b48:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8001b4a:	bf00      	nop
 8001b4c:	3720      	adds	r7, #32
 8001b4e:	46bd      	mov	sp, r7
 8001b50:	bd80      	pop	{r7, pc}
	...

08001b54 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 8001b54:	b580      	push	{r7, lr}
 8001b56:	b082      	sub	sp, #8
 8001b58:	af00      	add	r7, sp, #0
 8001b5a:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 8001b5c:	f7ff f8f0 	bl	8000d40 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 8001b60:	4b2a      	ldr	r3, [pc, #168]	; (8001c0c <prvAddNewTaskToReadyList+0xb8>)
 8001b62:	681b      	ldr	r3, [r3, #0]
 8001b64:	3301      	adds	r3, #1
 8001b66:	4a29      	ldr	r2, [pc, #164]	; (8001c0c <prvAddNewTaskToReadyList+0xb8>)
 8001b68:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8001b6a:	4b29      	ldr	r3, [pc, #164]	; (8001c10 <prvAddNewTaskToReadyList+0xbc>)
 8001b6c:	681b      	ldr	r3, [r3, #0]
 8001b6e:	2b00      	cmp	r3, #0
 8001b70:	d109      	bne.n	8001b86 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 8001b72:	4a27      	ldr	r2, [pc, #156]	; (8001c10 <prvAddNewTaskToReadyList+0xbc>)
 8001b74:	687b      	ldr	r3, [r7, #4]
 8001b76:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8001b78:	4b24      	ldr	r3, [pc, #144]	; (8001c0c <prvAddNewTaskToReadyList+0xb8>)
 8001b7a:	681b      	ldr	r3, [r3, #0]
 8001b7c:	2b01      	cmp	r3, #1
 8001b7e:	d110      	bne.n	8001ba2 <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 8001b80:	f000 fc00 	bl	8002384 <prvInitialiseTaskLists>
 8001b84:	e00d      	b.n	8001ba2 <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 8001b86:	4b23      	ldr	r3, [pc, #140]	; (8001c14 <prvAddNewTaskToReadyList+0xc0>)
 8001b88:	681b      	ldr	r3, [r3, #0]
 8001b8a:	2b00      	cmp	r3, #0
 8001b8c:	d109      	bne.n	8001ba2 <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8001b8e:	4b20      	ldr	r3, [pc, #128]	; (8001c10 <prvAddNewTaskToReadyList+0xbc>)
 8001b90:	681b      	ldr	r3, [r3, #0]
 8001b92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001b94:	687b      	ldr	r3, [r7, #4]
 8001b96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001b98:	429a      	cmp	r2, r3
 8001b9a:	d802      	bhi.n	8001ba2 <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 8001b9c:	4a1c      	ldr	r2, [pc, #112]	; (8001c10 <prvAddNewTaskToReadyList+0xbc>)
 8001b9e:	687b      	ldr	r3, [r7, #4]
 8001ba0:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 8001ba2:	4b1d      	ldr	r3, [pc, #116]	; (8001c18 <prvAddNewTaskToReadyList+0xc4>)
 8001ba4:	681b      	ldr	r3, [r3, #0]
 8001ba6:	3301      	adds	r3, #1
 8001ba8:	4a1b      	ldr	r2, [pc, #108]	; (8001c18 <prvAddNewTaskToReadyList+0xc4>)
 8001baa:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8001bac:	687b      	ldr	r3, [r7, #4]
 8001bae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001bb0:	2201      	movs	r2, #1
 8001bb2:	409a      	lsls	r2, r3
 8001bb4:	4b19      	ldr	r3, [pc, #100]	; (8001c1c <prvAddNewTaskToReadyList+0xc8>)
 8001bb6:	681b      	ldr	r3, [r3, #0]
 8001bb8:	4313      	orrs	r3, r2
 8001bba:	4a18      	ldr	r2, [pc, #96]	; (8001c1c <prvAddNewTaskToReadyList+0xc8>)
 8001bbc:	6013      	str	r3, [r2, #0]
 8001bbe:	687b      	ldr	r3, [r7, #4]
 8001bc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001bc2:	4613      	mov	r3, r2
 8001bc4:	009b      	lsls	r3, r3, #2
 8001bc6:	4413      	add	r3, r2
 8001bc8:	009b      	lsls	r3, r3, #2
 8001bca:	4a15      	ldr	r2, [pc, #84]	; (8001c20 <prvAddNewTaskToReadyList+0xcc>)
 8001bcc:	441a      	add	r2, r3
 8001bce:	687b      	ldr	r3, [r7, #4]
 8001bd0:	3304      	adds	r3, #4
 8001bd2:	4619      	mov	r1, r3
 8001bd4:	4610      	mov	r0, r2
 8001bd6:	f7fe ff24 	bl	8000a22 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 8001bda:	f7ff f8df 	bl	8000d9c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8001bde:	4b0d      	ldr	r3, [pc, #52]	; (8001c14 <prvAddNewTaskToReadyList+0xc0>)
 8001be0:	681b      	ldr	r3, [r3, #0]
 8001be2:	2b00      	cmp	r3, #0
 8001be4:	d00e      	beq.n	8001c04 <prvAddNewTaskToReadyList+0xb0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8001be6:	4b0a      	ldr	r3, [pc, #40]	; (8001c10 <prvAddNewTaskToReadyList+0xbc>)
 8001be8:	681b      	ldr	r3, [r3, #0]
 8001bea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001bec:	687b      	ldr	r3, [r7, #4]
 8001bee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001bf0:	429a      	cmp	r2, r3
 8001bf2:	d207      	bcs.n	8001c04 <prvAddNewTaskToReadyList+0xb0>
		{
			taskYIELD_IF_USING_PREEMPTION();
 8001bf4:	4b0b      	ldr	r3, [pc, #44]	; (8001c24 <prvAddNewTaskToReadyList+0xd0>)
 8001bf6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001bfa:	601a      	str	r2, [r3, #0]
 8001bfc:	f3bf 8f4f 	dsb	sy
 8001c00:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8001c04:	bf00      	nop
 8001c06:	3708      	adds	r7, #8
 8001c08:	46bd      	mov	sp, r7
 8001c0a:	bd80      	pop	{r7, pc}
 8001c0c:	20002564 	.word	0x20002564
 8001c10:	2000248c 	.word	0x2000248c
 8001c14:	20002570 	.word	0x20002570
 8001c18:	20002580 	.word	0x20002580
 8001c1c:	2000256c 	.word	0x2000256c
 8001c20:	20002490 	.word	0x20002490
 8001c24:	e000ed04 	.word	0xe000ed04

08001c28 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8001c28:	b580      	push	{r7, lr}
 8001c2a:	b084      	sub	sp, #16
 8001c2c:	af00      	add	r7, sp, #0
 8001c2e:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 8001c30:	2300      	movs	r3, #0
 8001c32:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8001c34:	687b      	ldr	r3, [r7, #4]
 8001c36:	2b00      	cmp	r3, #0
 8001c38:	d016      	beq.n	8001c68 <vTaskDelay+0x40>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 8001c3a:	4b13      	ldr	r3, [pc, #76]	; (8001c88 <vTaskDelay+0x60>)
 8001c3c:	681b      	ldr	r3, [r3, #0]
 8001c3e:	2b00      	cmp	r3, #0
 8001c40:	d009      	beq.n	8001c56 <vTaskDelay+0x2e>
 8001c42:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001c46:	f383 8811 	msr	BASEPRI, r3
 8001c4a:	f3bf 8f6f 	isb	sy
 8001c4e:	f3bf 8f4f 	dsb	sy
 8001c52:	60bb      	str	r3, [r7, #8]
 8001c54:	e7fe      	b.n	8001c54 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8001c56:	f000 f867 	bl	8001d28 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8001c5a:	2100      	movs	r1, #0
 8001c5c:	6878      	ldr	r0, [r7, #4]
 8001c5e:	f000 fd6f 	bl	8002740 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8001c62:	f000 f86f 	bl	8001d44 <xTaskResumeAll>
 8001c66:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8001c68:	68fb      	ldr	r3, [r7, #12]
 8001c6a:	2b00      	cmp	r3, #0
 8001c6c:	d107      	bne.n	8001c7e <vTaskDelay+0x56>
		{
			portYIELD_WITHIN_API();
 8001c6e:	4b07      	ldr	r3, [pc, #28]	; (8001c8c <vTaskDelay+0x64>)
 8001c70:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001c74:	601a      	str	r2, [r3, #0]
 8001c76:	f3bf 8f4f 	dsb	sy
 8001c7a:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8001c7e:	bf00      	nop
 8001c80:	3710      	adds	r7, #16
 8001c82:	46bd      	mov	sp, r7
 8001c84:	bd80      	pop	{r7, pc}
 8001c86:	bf00      	nop
 8001c88:	2000258c 	.word	0x2000258c
 8001c8c:	e000ed04 	.word	0xe000ed04

08001c90 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8001c90:	b580      	push	{r7, lr}
 8001c92:	b086      	sub	sp, #24
 8001c94:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 8001c96:	4b1e      	ldr	r3, [pc, #120]	; (8001d10 <vTaskStartScheduler+0x80>)
 8001c98:	9301      	str	r3, [sp, #4]
 8001c9a:	2300      	movs	r3, #0
 8001c9c:	9300      	str	r3, [sp, #0]
 8001c9e:	2300      	movs	r3, #0
 8001ca0:	2282      	movs	r2, #130	; 0x82
 8001ca2:	491c      	ldr	r1, [pc, #112]	; (8001d14 <vTaskStartScheduler+0x84>)
 8001ca4:	481c      	ldr	r0, [pc, #112]	; (8001d18 <vTaskStartScheduler+0x88>)
 8001ca6:	f7ff fe95 	bl	80019d4 <xTaskCreate>
 8001caa:	60f8      	str	r0, [r7, #12]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 8001cac:	68fb      	ldr	r3, [r7, #12]
 8001cae:	2b01      	cmp	r3, #1
 8001cb0:	d102      	bne.n	8001cb8 <vTaskStartScheduler+0x28>
		{
			xReturn = xTimerCreateTimerTask();
 8001cb2:	f000 fdab 	bl	800280c <xTimerCreateTimerTask>
 8001cb6:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8001cb8:	68fb      	ldr	r3, [r7, #12]
 8001cba:	2b01      	cmp	r3, #1
 8001cbc:	d115      	bne.n	8001cea <vTaskStartScheduler+0x5a>
 8001cbe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001cc2:	f383 8811 	msr	BASEPRI, r3
 8001cc6:	f3bf 8f6f 	isb	sy
 8001cca:	f3bf 8f4f 	dsb	sy
 8001cce:	60bb      	str	r3, [r7, #8]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 8001cd0:	4b12      	ldr	r3, [pc, #72]	; (8001d1c <vTaskStartScheduler+0x8c>)
 8001cd2:	f04f 32ff 	mov.w	r2, #4294967295
 8001cd6:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8001cd8:	4b11      	ldr	r3, [pc, #68]	; (8001d20 <vTaskStartScheduler+0x90>)
 8001cda:	2201      	movs	r2, #1
 8001cdc:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8001cde:	4b11      	ldr	r3, [pc, #68]	; (8001d24 <vTaskStartScheduler+0x94>)
 8001ce0:	2200      	movs	r2, #0
 8001ce2:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 8001ce4:	f7fe ffa0 	bl	8000c28 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 8001ce8:	e00d      	b.n	8001d06 <vTaskStartScheduler+0x76>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8001cea:	68fb      	ldr	r3, [r7, #12]
 8001cec:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001cf0:	d109      	bne.n	8001d06 <vTaskStartScheduler+0x76>
 8001cf2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001cf6:	f383 8811 	msr	BASEPRI, r3
 8001cfa:	f3bf 8f6f 	isb	sy
 8001cfe:	f3bf 8f4f 	dsb	sy
 8001d02:	607b      	str	r3, [r7, #4]
 8001d04:	e7fe      	b.n	8001d04 <vTaskStartScheduler+0x74>
}
 8001d06:	bf00      	nop
 8001d08:	3710      	adds	r7, #16
 8001d0a:	46bd      	mov	sp, r7
 8001d0c:	bd80      	pop	{r7, pc}
 8001d0e:	bf00      	nop
 8001d10:	20002588 	.word	0x20002588
 8001d14:	0800e72c 	.word	0x0800e72c
 8001d18:	08002355 	.word	0x08002355
 8001d1c:	20002584 	.word	0x20002584
 8001d20:	20002570 	.word	0x20002570
 8001d24:	20002568 	.word	0x20002568

08001d28 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8001d28:	b480      	push	{r7}
 8001d2a:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8001d2c:	4b04      	ldr	r3, [pc, #16]	; (8001d40 <vTaskSuspendAll+0x18>)
 8001d2e:	681b      	ldr	r3, [r3, #0]
 8001d30:	3301      	adds	r3, #1
 8001d32:	4a03      	ldr	r2, [pc, #12]	; (8001d40 <vTaskSuspendAll+0x18>)
 8001d34:	6013      	str	r3, [r2, #0]
}
 8001d36:	bf00      	nop
 8001d38:	46bd      	mov	sp, r7
 8001d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d3e:	4770      	bx	lr
 8001d40:	2000258c 	.word	0x2000258c

08001d44 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8001d44:	b580      	push	{r7, lr}
 8001d46:	b084      	sub	sp, #16
 8001d48:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 8001d4a:	2300      	movs	r3, #0
 8001d4c:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 8001d4e:	2300      	movs	r3, #0
 8001d50:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 8001d52:	4b41      	ldr	r3, [pc, #260]	; (8001e58 <xTaskResumeAll+0x114>)
 8001d54:	681b      	ldr	r3, [r3, #0]
 8001d56:	2b00      	cmp	r3, #0
 8001d58:	d109      	bne.n	8001d6e <xTaskResumeAll+0x2a>
 8001d5a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001d5e:	f383 8811 	msr	BASEPRI, r3
 8001d62:	f3bf 8f6f 	isb	sy
 8001d66:	f3bf 8f4f 	dsb	sy
 8001d6a:	603b      	str	r3, [r7, #0]
 8001d6c:	e7fe      	b.n	8001d6c <xTaskResumeAll+0x28>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8001d6e:	f7fe ffe7 	bl	8000d40 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8001d72:	4b39      	ldr	r3, [pc, #228]	; (8001e58 <xTaskResumeAll+0x114>)
 8001d74:	681b      	ldr	r3, [r3, #0]
 8001d76:	3b01      	subs	r3, #1
 8001d78:	4a37      	ldr	r2, [pc, #220]	; (8001e58 <xTaskResumeAll+0x114>)
 8001d7a:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001d7c:	4b36      	ldr	r3, [pc, #216]	; (8001e58 <xTaskResumeAll+0x114>)
 8001d7e:	681b      	ldr	r3, [r3, #0]
 8001d80:	2b00      	cmp	r3, #0
 8001d82:	d161      	bne.n	8001e48 <xTaskResumeAll+0x104>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8001d84:	4b35      	ldr	r3, [pc, #212]	; (8001e5c <xTaskResumeAll+0x118>)
 8001d86:	681b      	ldr	r3, [r3, #0]
 8001d88:	2b00      	cmp	r3, #0
 8001d8a:	d05d      	beq.n	8001e48 <xTaskResumeAll+0x104>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001d8c:	e02e      	b.n	8001dec <xTaskResumeAll+0xa8>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8001d8e:	4b34      	ldr	r3, [pc, #208]	; (8001e60 <xTaskResumeAll+0x11c>)
 8001d90:	68db      	ldr	r3, [r3, #12]
 8001d92:	68db      	ldr	r3, [r3, #12]
 8001d94:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001d96:	68fb      	ldr	r3, [r7, #12]
 8001d98:	3318      	adds	r3, #24
 8001d9a:	4618      	mov	r0, r3
 8001d9c:	f7fe fe9e 	bl	8000adc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001da0:	68fb      	ldr	r3, [r7, #12]
 8001da2:	3304      	adds	r3, #4
 8001da4:	4618      	mov	r0, r3
 8001da6:	f7fe fe99 	bl	8000adc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001daa:	68fb      	ldr	r3, [r7, #12]
 8001dac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001dae:	2201      	movs	r2, #1
 8001db0:	409a      	lsls	r2, r3
 8001db2:	4b2c      	ldr	r3, [pc, #176]	; (8001e64 <xTaskResumeAll+0x120>)
 8001db4:	681b      	ldr	r3, [r3, #0]
 8001db6:	4313      	orrs	r3, r2
 8001db8:	4a2a      	ldr	r2, [pc, #168]	; (8001e64 <xTaskResumeAll+0x120>)
 8001dba:	6013      	str	r3, [r2, #0]
 8001dbc:	68fb      	ldr	r3, [r7, #12]
 8001dbe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001dc0:	4613      	mov	r3, r2
 8001dc2:	009b      	lsls	r3, r3, #2
 8001dc4:	4413      	add	r3, r2
 8001dc6:	009b      	lsls	r3, r3, #2
 8001dc8:	4a27      	ldr	r2, [pc, #156]	; (8001e68 <xTaskResumeAll+0x124>)
 8001dca:	441a      	add	r2, r3
 8001dcc:	68fb      	ldr	r3, [r7, #12]
 8001dce:	3304      	adds	r3, #4
 8001dd0:	4619      	mov	r1, r3
 8001dd2:	4610      	mov	r0, r2
 8001dd4:	f7fe fe25 	bl	8000a22 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001dd8:	68fb      	ldr	r3, [r7, #12]
 8001dda:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001ddc:	4b23      	ldr	r3, [pc, #140]	; (8001e6c <xTaskResumeAll+0x128>)
 8001dde:	681b      	ldr	r3, [r3, #0]
 8001de0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001de2:	429a      	cmp	r2, r3
 8001de4:	d302      	bcc.n	8001dec <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
 8001de6:	4b22      	ldr	r3, [pc, #136]	; (8001e70 <xTaskResumeAll+0x12c>)
 8001de8:	2201      	movs	r2, #1
 8001dea:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001dec:	4b1c      	ldr	r3, [pc, #112]	; (8001e60 <xTaskResumeAll+0x11c>)
 8001dee:	681b      	ldr	r3, [r3, #0]
 8001df0:	2b00      	cmp	r3, #0
 8001df2:	d1cc      	bne.n	8001d8e <xTaskResumeAll+0x4a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 8001df4:	68fb      	ldr	r3, [r7, #12]
 8001df6:	2b00      	cmp	r3, #0
 8001df8:	d001      	beq.n	8001dfe <xTaskResumeAll+0xba>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 8001dfa:	f000 fb4f 	bl	800249c <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8001dfe:	4b1d      	ldr	r3, [pc, #116]	; (8001e74 <xTaskResumeAll+0x130>)
 8001e00:	681b      	ldr	r3, [r3, #0]
 8001e02:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8001e04:	687b      	ldr	r3, [r7, #4]
 8001e06:	2b00      	cmp	r3, #0
 8001e08:	d010      	beq.n	8001e2c <xTaskResumeAll+0xe8>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 8001e0a:	f000 f847 	bl	8001e9c <xTaskIncrementTick>
 8001e0e:	4603      	mov	r3, r0
 8001e10:	2b00      	cmp	r3, #0
 8001e12:	d002      	beq.n	8001e1a <xTaskResumeAll+0xd6>
							{
								xYieldPending = pdTRUE;
 8001e14:	4b16      	ldr	r3, [pc, #88]	; (8001e70 <xTaskResumeAll+0x12c>)
 8001e16:	2201      	movs	r2, #1
 8001e18:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 8001e1a:	687b      	ldr	r3, [r7, #4]
 8001e1c:	3b01      	subs	r3, #1
 8001e1e:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8001e20:	687b      	ldr	r3, [r7, #4]
 8001e22:	2b00      	cmp	r3, #0
 8001e24:	d1f1      	bne.n	8001e0a <xTaskResumeAll+0xc6>

						uxPendedTicks = 0;
 8001e26:	4b13      	ldr	r3, [pc, #76]	; (8001e74 <xTaskResumeAll+0x130>)
 8001e28:	2200      	movs	r2, #0
 8001e2a:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 8001e2c:	4b10      	ldr	r3, [pc, #64]	; (8001e70 <xTaskResumeAll+0x12c>)
 8001e2e:	681b      	ldr	r3, [r3, #0]
 8001e30:	2b00      	cmp	r3, #0
 8001e32:	d009      	beq.n	8001e48 <xTaskResumeAll+0x104>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 8001e34:	2301      	movs	r3, #1
 8001e36:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8001e38:	4b0f      	ldr	r3, [pc, #60]	; (8001e78 <xTaskResumeAll+0x134>)
 8001e3a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001e3e:	601a      	str	r2, [r3, #0]
 8001e40:	f3bf 8f4f 	dsb	sy
 8001e44:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8001e48:	f7fe ffa8 	bl	8000d9c <vPortExitCritical>

	return xAlreadyYielded;
 8001e4c:	68bb      	ldr	r3, [r7, #8]
}
 8001e4e:	4618      	mov	r0, r3
 8001e50:	3710      	adds	r7, #16
 8001e52:	46bd      	mov	sp, r7
 8001e54:	bd80      	pop	{r7, pc}
 8001e56:	bf00      	nop
 8001e58:	2000258c 	.word	0x2000258c
 8001e5c:	20002564 	.word	0x20002564
 8001e60:	20002524 	.word	0x20002524
 8001e64:	2000256c 	.word	0x2000256c
 8001e68:	20002490 	.word	0x20002490
 8001e6c:	2000248c 	.word	0x2000248c
 8001e70:	20002578 	.word	0x20002578
 8001e74:	20002574 	.word	0x20002574
 8001e78:	e000ed04 	.word	0xe000ed04

08001e7c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 8001e7c:	b480      	push	{r7}
 8001e7e:	b083      	sub	sp, #12
 8001e80:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 8001e82:	4b05      	ldr	r3, [pc, #20]	; (8001e98 <xTaskGetTickCount+0x1c>)
 8001e84:	681b      	ldr	r3, [r3, #0]
 8001e86:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 8001e88:	687b      	ldr	r3, [r7, #4]
}
 8001e8a:	4618      	mov	r0, r3
 8001e8c:	370c      	adds	r7, #12
 8001e8e:	46bd      	mov	sp, r7
 8001e90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e94:	4770      	bx	lr
 8001e96:	bf00      	nop
 8001e98:	20002568 	.word	0x20002568

08001e9c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8001e9c:	b580      	push	{r7, lr}
 8001e9e:	b086      	sub	sp, #24
 8001ea0:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8001ea2:	2300      	movs	r3, #0
 8001ea4:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001ea6:	4b54      	ldr	r3, [pc, #336]	; (8001ff8 <xTaskIncrementTick+0x15c>)
 8001ea8:	681b      	ldr	r3, [r3, #0]
 8001eaa:	2b00      	cmp	r3, #0
 8001eac:	f040 8092 	bne.w	8001fd4 <xTaskIncrementTick+0x138>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 8001eb0:	4b52      	ldr	r3, [pc, #328]	; (8001ffc <xTaskIncrementTick+0x160>)
 8001eb2:	681b      	ldr	r3, [r3, #0]
 8001eb4:	3301      	adds	r3, #1
 8001eb6:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8001eb8:	4a50      	ldr	r2, [pc, #320]	; (8001ffc <xTaskIncrementTick+0x160>)
 8001eba:	693b      	ldr	r3, [r7, #16]
 8001ebc:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
 8001ebe:	693b      	ldr	r3, [r7, #16]
 8001ec0:	2b00      	cmp	r3, #0
 8001ec2:	d11f      	bne.n	8001f04 <xTaskIncrementTick+0x68>
		{
			taskSWITCH_DELAYED_LISTS();
 8001ec4:	4b4e      	ldr	r3, [pc, #312]	; (8002000 <xTaskIncrementTick+0x164>)
 8001ec6:	681b      	ldr	r3, [r3, #0]
 8001ec8:	681b      	ldr	r3, [r3, #0]
 8001eca:	2b00      	cmp	r3, #0
 8001ecc:	d009      	beq.n	8001ee2 <xTaskIncrementTick+0x46>
 8001ece:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001ed2:	f383 8811 	msr	BASEPRI, r3
 8001ed6:	f3bf 8f6f 	isb	sy
 8001eda:	f3bf 8f4f 	dsb	sy
 8001ede:	603b      	str	r3, [r7, #0]
 8001ee0:	e7fe      	b.n	8001ee0 <xTaskIncrementTick+0x44>
 8001ee2:	4b47      	ldr	r3, [pc, #284]	; (8002000 <xTaskIncrementTick+0x164>)
 8001ee4:	681b      	ldr	r3, [r3, #0]
 8001ee6:	60fb      	str	r3, [r7, #12]
 8001ee8:	4b46      	ldr	r3, [pc, #280]	; (8002004 <xTaskIncrementTick+0x168>)
 8001eea:	681b      	ldr	r3, [r3, #0]
 8001eec:	4a44      	ldr	r2, [pc, #272]	; (8002000 <xTaskIncrementTick+0x164>)
 8001eee:	6013      	str	r3, [r2, #0]
 8001ef0:	4a44      	ldr	r2, [pc, #272]	; (8002004 <xTaskIncrementTick+0x168>)
 8001ef2:	68fb      	ldr	r3, [r7, #12]
 8001ef4:	6013      	str	r3, [r2, #0]
 8001ef6:	4b44      	ldr	r3, [pc, #272]	; (8002008 <xTaskIncrementTick+0x16c>)
 8001ef8:	681b      	ldr	r3, [r3, #0]
 8001efa:	3301      	adds	r3, #1
 8001efc:	4a42      	ldr	r2, [pc, #264]	; (8002008 <xTaskIncrementTick+0x16c>)
 8001efe:	6013      	str	r3, [r2, #0]
 8001f00:	f000 facc 	bl	800249c <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 8001f04:	4b41      	ldr	r3, [pc, #260]	; (800200c <xTaskIncrementTick+0x170>)
 8001f06:	681b      	ldr	r3, [r3, #0]
 8001f08:	693a      	ldr	r2, [r7, #16]
 8001f0a:	429a      	cmp	r2, r3
 8001f0c:	d34d      	bcc.n	8001faa <xTaskIncrementTick+0x10e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001f0e:	4b3c      	ldr	r3, [pc, #240]	; (8002000 <xTaskIncrementTick+0x164>)
 8001f10:	681b      	ldr	r3, [r3, #0]
 8001f12:	681b      	ldr	r3, [r3, #0]
 8001f14:	2b00      	cmp	r3, #0
 8001f16:	d101      	bne.n	8001f1c <xTaskIncrementTick+0x80>
 8001f18:	2301      	movs	r3, #1
 8001f1a:	e000      	b.n	8001f1e <xTaskIncrementTick+0x82>
 8001f1c:	2300      	movs	r3, #0
 8001f1e:	2b00      	cmp	r3, #0
 8001f20:	d004      	beq.n	8001f2c <xTaskIncrementTick+0x90>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001f22:	4b3a      	ldr	r3, [pc, #232]	; (800200c <xTaskIncrementTick+0x170>)
 8001f24:	f04f 32ff 	mov.w	r2, #4294967295
 8001f28:	601a      	str	r2, [r3, #0]
					break;
 8001f2a:	e03e      	b.n	8001faa <xTaskIncrementTick+0x10e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001f2c:	4b34      	ldr	r3, [pc, #208]	; (8002000 <xTaskIncrementTick+0x164>)
 8001f2e:	681b      	ldr	r3, [r3, #0]
 8001f30:	68db      	ldr	r3, [r3, #12]
 8001f32:	68db      	ldr	r3, [r3, #12]
 8001f34:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001f36:	68bb      	ldr	r3, [r7, #8]
 8001f38:	685b      	ldr	r3, [r3, #4]
 8001f3a:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 8001f3c:	693a      	ldr	r2, [r7, #16]
 8001f3e:	687b      	ldr	r3, [r7, #4]
 8001f40:	429a      	cmp	r2, r3
 8001f42:	d203      	bcs.n	8001f4c <xTaskIncrementTick+0xb0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 8001f44:	4a31      	ldr	r2, [pc, #196]	; (800200c <xTaskIncrementTick+0x170>)
 8001f46:	687b      	ldr	r3, [r7, #4]
 8001f48:	6013      	str	r3, [r2, #0]
						break;
 8001f4a:	e02e      	b.n	8001faa <xTaskIncrementTick+0x10e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001f4c:	68bb      	ldr	r3, [r7, #8]
 8001f4e:	3304      	adds	r3, #4
 8001f50:	4618      	mov	r0, r3
 8001f52:	f7fe fdc3 	bl	8000adc <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001f56:	68bb      	ldr	r3, [r7, #8]
 8001f58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001f5a:	2b00      	cmp	r3, #0
 8001f5c:	d004      	beq.n	8001f68 <xTaskIncrementTick+0xcc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001f5e:	68bb      	ldr	r3, [r7, #8]
 8001f60:	3318      	adds	r3, #24
 8001f62:	4618      	mov	r0, r3
 8001f64:	f7fe fdba 	bl	8000adc <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 8001f68:	68bb      	ldr	r3, [r7, #8]
 8001f6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001f6c:	2201      	movs	r2, #1
 8001f6e:	409a      	lsls	r2, r3
 8001f70:	4b27      	ldr	r3, [pc, #156]	; (8002010 <xTaskIncrementTick+0x174>)
 8001f72:	681b      	ldr	r3, [r3, #0]
 8001f74:	4313      	orrs	r3, r2
 8001f76:	4a26      	ldr	r2, [pc, #152]	; (8002010 <xTaskIncrementTick+0x174>)
 8001f78:	6013      	str	r3, [r2, #0]
 8001f7a:	68bb      	ldr	r3, [r7, #8]
 8001f7c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001f7e:	4613      	mov	r3, r2
 8001f80:	009b      	lsls	r3, r3, #2
 8001f82:	4413      	add	r3, r2
 8001f84:	009b      	lsls	r3, r3, #2
 8001f86:	4a23      	ldr	r2, [pc, #140]	; (8002014 <xTaskIncrementTick+0x178>)
 8001f88:	441a      	add	r2, r3
 8001f8a:	68bb      	ldr	r3, [r7, #8]
 8001f8c:	3304      	adds	r3, #4
 8001f8e:	4619      	mov	r1, r3
 8001f90:	4610      	mov	r0, r2
 8001f92:	f7fe fd46 	bl	8000a22 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001f96:	68bb      	ldr	r3, [r7, #8]
 8001f98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001f9a:	4b1f      	ldr	r3, [pc, #124]	; (8002018 <xTaskIncrementTick+0x17c>)
 8001f9c:	681b      	ldr	r3, [r3, #0]
 8001f9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001fa0:	429a      	cmp	r2, r3
 8001fa2:	d3b4      	bcc.n	8001f0e <xTaskIncrementTick+0x72>
						{
							xSwitchRequired = pdTRUE;
 8001fa4:	2301      	movs	r3, #1
 8001fa6:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001fa8:	e7b1      	b.n	8001f0e <xTaskIncrementTick+0x72>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8001faa:	4b1b      	ldr	r3, [pc, #108]	; (8002018 <xTaskIncrementTick+0x17c>)
 8001fac:	681b      	ldr	r3, [r3, #0]
 8001fae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001fb0:	4918      	ldr	r1, [pc, #96]	; (8002014 <xTaskIncrementTick+0x178>)
 8001fb2:	4613      	mov	r3, r2
 8001fb4:	009b      	lsls	r3, r3, #2
 8001fb6:	4413      	add	r3, r2
 8001fb8:	009b      	lsls	r3, r3, #2
 8001fba:	440b      	add	r3, r1
 8001fbc:	681b      	ldr	r3, [r3, #0]
 8001fbe:	2b01      	cmp	r3, #1
 8001fc0:	d901      	bls.n	8001fc6 <xTaskIncrementTick+0x12a>
			{
				xSwitchRequired = pdTRUE;
 8001fc2:	2301      	movs	r3, #1
 8001fc4:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
 8001fc6:	4b15      	ldr	r3, [pc, #84]	; (800201c <xTaskIncrementTick+0x180>)
 8001fc8:	681b      	ldr	r3, [r3, #0]
 8001fca:	2b00      	cmp	r3, #0
 8001fcc:	d109      	bne.n	8001fe2 <xTaskIncrementTick+0x146>
			{
				vApplicationTickHook();
 8001fce:	f00b ff09 	bl	800dde4 <vApplicationTickHook>
 8001fd2:	e006      	b.n	8001fe2 <xTaskIncrementTick+0x146>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8001fd4:	4b11      	ldr	r3, [pc, #68]	; (800201c <xTaskIncrementTick+0x180>)
 8001fd6:	681b      	ldr	r3, [r3, #0]
 8001fd8:	3301      	adds	r3, #1
 8001fda:	4a10      	ldr	r2, [pc, #64]	; (800201c <xTaskIncrementTick+0x180>)
 8001fdc:	6013      	str	r3, [r2, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
 8001fde:	f00b ff01 	bl	800dde4 <vApplicationTickHook>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8001fe2:	4b0f      	ldr	r3, [pc, #60]	; (8002020 <xTaskIncrementTick+0x184>)
 8001fe4:	681b      	ldr	r3, [r3, #0]
 8001fe6:	2b00      	cmp	r3, #0
 8001fe8:	d001      	beq.n	8001fee <xTaskIncrementTick+0x152>
		{
			xSwitchRequired = pdTRUE;
 8001fea:	2301      	movs	r3, #1
 8001fec:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 8001fee:	697b      	ldr	r3, [r7, #20]
}
 8001ff0:	4618      	mov	r0, r3
 8001ff2:	3718      	adds	r7, #24
 8001ff4:	46bd      	mov	sp, r7
 8001ff6:	bd80      	pop	{r7, pc}
 8001ff8:	2000258c 	.word	0x2000258c
 8001ffc:	20002568 	.word	0x20002568
 8002000:	2000251c 	.word	0x2000251c
 8002004:	20002520 	.word	0x20002520
 8002008:	2000257c 	.word	0x2000257c
 800200c:	20002584 	.word	0x20002584
 8002010:	2000256c 	.word	0x2000256c
 8002014:	20002490 	.word	0x20002490
 8002018:	2000248c 	.word	0x2000248c
 800201c:	20002574 	.word	0x20002574
 8002020:	20002578 	.word	0x20002578

08002024 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8002024:	b480      	push	{r7}
 8002026:	b087      	sub	sp, #28
 8002028:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800202a:	4b26      	ldr	r3, [pc, #152]	; (80020c4 <vTaskSwitchContext+0xa0>)
 800202c:	681b      	ldr	r3, [r3, #0]
 800202e:	2b00      	cmp	r3, #0
 8002030:	d003      	beq.n	800203a <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8002032:	4b25      	ldr	r3, [pc, #148]	; (80020c8 <vTaskSwitchContext+0xa4>)
 8002034:	2201      	movs	r2, #1
 8002036:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8002038:	e03e      	b.n	80020b8 <vTaskSwitchContext+0x94>
		xYieldPending = pdFALSE;
 800203a:	4b23      	ldr	r3, [pc, #140]	; (80020c8 <vTaskSwitchContext+0xa4>)
 800203c:	2200      	movs	r2, #0
 800203e:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8002040:	4b22      	ldr	r3, [pc, #136]	; (80020cc <vTaskSwitchContext+0xa8>)
 8002042:	681b      	ldr	r3, [r3, #0]
 8002044:	60fb      	str	r3, [r7, #12]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8002046:	68fb      	ldr	r3, [r7, #12]
 8002048:	fab3 f383 	clz	r3, r3
 800204c:	72fb      	strb	r3, [r7, #11]
		return ucReturn;
 800204e:	7afb      	ldrb	r3, [r7, #11]
 8002050:	f1c3 031f 	rsb	r3, r3, #31
 8002054:	617b      	str	r3, [r7, #20]
 8002056:	491e      	ldr	r1, [pc, #120]	; (80020d0 <vTaskSwitchContext+0xac>)
 8002058:	697a      	ldr	r2, [r7, #20]
 800205a:	4613      	mov	r3, r2
 800205c:	009b      	lsls	r3, r3, #2
 800205e:	4413      	add	r3, r2
 8002060:	009b      	lsls	r3, r3, #2
 8002062:	440b      	add	r3, r1
 8002064:	681b      	ldr	r3, [r3, #0]
 8002066:	2b00      	cmp	r3, #0
 8002068:	d109      	bne.n	800207e <vTaskSwitchContext+0x5a>
	__asm volatile
 800206a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800206e:	f383 8811 	msr	BASEPRI, r3
 8002072:	f3bf 8f6f 	isb	sy
 8002076:	f3bf 8f4f 	dsb	sy
 800207a:	607b      	str	r3, [r7, #4]
 800207c:	e7fe      	b.n	800207c <vTaskSwitchContext+0x58>
 800207e:	697a      	ldr	r2, [r7, #20]
 8002080:	4613      	mov	r3, r2
 8002082:	009b      	lsls	r3, r3, #2
 8002084:	4413      	add	r3, r2
 8002086:	009b      	lsls	r3, r3, #2
 8002088:	4a11      	ldr	r2, [pc, #68]	; (80020d0 <vTaskSwitchContext+0xac>)
 800208a:	4413      	add	r3, r2
 800208c:	613b      	str	r3, [r7, #16]
 800208e:	693b      	ldr	r3, [r7, #16]
 8002090:	685b      	ldr	r3, [r3, #4]
 8002092:	685a      	ldr	r2, [r3, #4]
 8002094:	693b      	ldr	r3, [r7, #16]
 8002096:	605a      	str	r2, [r3, #4]
 8002098:	693b      	ldr	r3, [r7, #16]
 800209a:	685a      	ldr	r2, [r3, #4]
 800209c:	693b      	ldr	r3, [r7, #16]
 800209e:	3308      	adds	r3, #8
 80020a0:	429a      	cmp	r2, r3
 80020a2:	d104      	bne.n	80020ae <vTaskSwitchContext+0x8a>
 80020a4:	693b      	ldr	r3, [r7, #16]
 80020a6:	685b      	ldr	r3, [r3, #4]
 80020a8:	685a      	ldr	r2, [r3, #4]
 80020aa:	693b      	ldr	r3, [r7, #16]
 80020ac:	605a      	str	r2, [r3, #4]
 80020ae:	693b      	ldr	r3, [r7, #16]
 80020b0:	685b      	ldr	r3, [r3, #4]
 80020b2:	68db      	ldr	r3, [r3, #12]
 80020b4:	4a07      	ldr	r2, [pc, #28]	; (80020d4 <vTaskSwitchContext+0xb0>)
 80020b6:	6013      	str	r3, [r2, #0]
}
 80020b8:	bf00      	nop
 80020ba:	371c      	adds	r7, #28
 80020bc:	46bd      	mov	sp, r7
 80020be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020c2:	4770      	bx	lr
 80020c4:	2000258c 	.word	0x2000258c
 80020c8:	20002578 	.word	0x20002578
 80020cc:	2000256c 	.word	0x2000256c
 80020d0:	20002490 	.word	0x20002490
 80020d4:	2000248c 	.word	0x2000248c

080020d8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 80020d8:	b580      	push	{r7, lr}
 80020da:	b084      	sub	sp, #16
 80020dc:	af00      	add	r7, sp, #0
 80020de:	6078      	str	r0, [r7, #4]
 80020e0:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
 80020e2:	687b      	ldr	r3, [r7, #4]
 80020e4:	2b00      	cmp	r3, #0
 80020e6:	d109      	bne.n	80020fc <vTaskPlaceOnEventList+0x24>
 80020e8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80020ec:	f383 8811 	msr	BASEPRI, r3
 80020f0:	f3bf 8f6f 	isb	sy
 80020f4:	f3bf 8f4f 	dsb	sy
 80020f8:	60fb      	str	r3, [r7, #12]
 80020fa:	e7fe      	b.n	80020fa <vTaskPlaceOnEventList+0x22>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80020fc:	4b07      	ldr	r3, [pc, #28]	; (800211c <vTaskPlaceOnEventList+0x44>)
 80020fe:	681b      	ldr	r3, [r3, #0]
 8002100:	3318      	adds	r3, #24
 8002102:	4619      	mov	r1, r3
 8002104:	6878      	ldr	r0, [r7, #4]
 8002106:	f7fe fcb0 	bl	8000a6a <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800210a:	2101      	movs	r1, #1
 800210c:	6838      	ldr	r0, [r7, #0]
 800210e:	f000 fb17 	bl	8002740 <prvAddCurrentTaskToDelayedList>
}
 8002112:	bf00      	nop
 8002114:	3710      	adds	r7, #16
 8002116:	46bd      	mov	sp, r7
 8002118:	bd80      	pop	{r7, pc}
 800211a:	bf00      	nop
 800211c:	2000248c 	.word	0x2000248c

08002120 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8002120:	b580      	push	{r7, lr}
 8002122:	b086      	sub	sp, #24
 8002124:	af00      	add	r7, sp, #0
 8002126:	60f8      	str	r0, [r7, #12]
 8002128:	60b9      	str	r1, [r7, #8]
 800212a:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
 800212c:	68fb      	ldr	r3, [r7, #12]
 800212e:	2b00      	cmp	r3, #0
 8002130:	d109      	bne.n	8002146 <vTaskPlaceOnEventListRestricted+0x26>
 8002132:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002136:	f383 8811 	msr	BASEPRI, r3
 800213a:	f3bf 8f6f 	isb	sy
 800213e:	f3bf 8f4f 	dsb	sy
 8002142:	617b      	str	r3, [r7, #20]
 8002144:	e7fe      	b.n	8002144 <vTaskPlaceOnEventListRestricted+0x24>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8002146:	4b0a      	ldr	r3, [pc, #40]	; (8002170 <vTaskPlaceOnEventListRestricted+0x50>)
 8002148:	681b      	ldr	r3, [r3, #0]
 800214a:	3318      	adds	r3, #24
 800214c:	4619      	mov	r1, r3
 800214e:	68f8      	ldr	r0, [r7, #12]
 8002150:	f7fe fc67 	bl	8000a22 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 8002154:	687b      	ldr	r3, [r7, #4]
 8002156:	2b00      	cmp	r3, #0
 8002158:	d002      	beq.n	8002160 <vTaskPlaceOnEventListRestricted+0x40>
		{
			xTicksToWait = portMAX_DELAY;
 800215a:	f04f 33ff 	mov.w	r3, #4294967295
 800215e:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8002160:	6879      	ldr	r1, [r7, #4]
 8002162:	68b8      	ldr	r0, [r7, #8]
 8002164:	f000 faec 	bl	8002740 <prvAddCurrentTaskToDelayedList>
	}
 8002168:	bf00      	nop
 800216a:	3718      	adds	r7, #24
 800216c:	46bd      	mov	sp, r7
 800216e:	bd80      	pop	{r7, pc}
 8002170:	2000248c 	.word	0x2000248c

08002174 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 8002174:	b580      	push	{r7, lr}
 8002176:	b086      	sub	sp, #24
 8002178:	af00      	add	r7, sp, #0
 800217a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800217c:	687b      	ldr	r3, [r7, #4]
 800217e:	68db      	ldr	r3, [r3, #12]
 8002180:	68db      	ldr	r3, [r3, #12]
 8002182:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 8002184:	693b      	ldr	r3, [r7, #16]
 8002186:	2b00      	cmp	r3, #0
 8002188:	d109      	bne.n	800219e <xTaskRemoveFromEventList+0x2a>
 800218a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800218e:	f383 8811 	msr	BASEPRI, r3
 8002192:	f3bf 8f6f 	isb	sy
 8002196:	f3bf 8f4f 	dsb	sy
 800219a:	60fb      	str	r3, [r7, #12]
 800219c:	e7fe      	b.n	800219c <xTaskRemoveFromEventList+0x28>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800219e:	693b      	ldr	r3, [r7, #16]
 80021a0:	3318      	adds	r3, #24
 80021a2:	4618      	mov	r0, r3
 80021a4:	f7fe fc9a 	bl	8000adc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80021a8:	4b1d      	ldr	r3, [pc, #116]	; (8002220 <xTaskRemoveFromEventList+0xac>)
 80021aa:	681b      	ldr	r3, [r3, #0]
 80021ac:	2b00      	cmp	r3, #0
 80021ae:	d11c      	bne.n	80021ea <xTaskRemoveFromEventList+0x76>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 80021b0:	693b      	ldr	r3, [r7, #16]
 80021b2:	3304      	adds	r3, #4
 80021b4:	4618      	mov	r0, r3
 80021b6:	f7fe fc91 	bl	8000adc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 80021ba:	693b      	ldr	r3, [r7, #16]
 80021bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80021be:	2201      	movs	r2, #1
 80021c0:	409a      	lsls	r2, r3
 80021c2:	4b18      	ldr	r3, [pc, #96]	; (8002224 <xTaskRemoveFromEventList+0xb0>)
 80021c4:	681b      	ldr	r3, [r3, #0]
 80021c6:	4313      	orrs	r3, r2
 80021c8:	4a16      	ldr	r2, [pc, #88]	; (8002224 <xTaskRemoveFromEventList+0xb0>)
 80021ca:	6013      	str	r3, [r2, #0]
 80021cc:	693b      	ldr	r3, [r7, #16]
 80021ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80021d0:	4613      	mov	r3, r2
 80021d2:	009b      	lsls	r3, r3, #2
 80021d4:	4413      	add	r3, r2
 80021d6:	009b      	lsls	r3, r3, #2
 80021d8:	4a13      	ldr	r2, [pc, #76]	; (8002228 <xTaskRemoveFromEventList+0xb4>)
 80021da:	441a      	add	r2, r3
 80021dc:	693b      	ldr	r3, [r7, #16]
 80021de:	3304      	adds	r3, #4
 80021e0:	4619      	mov	r1, r3
 80021e2:	4610      	mov	r0, r2
 80021e4:	f7fe fc1d 	bl	8000a22 <vListInsertEnd>
 80021e8:	e005      	b.n	80021f6 <xTaskRemoveFromEventList+0x82>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80021ea:	693b      	ldr	r3, [r7, #16]
 80021ec:	3318      	adds	r3, #24
 80021ee:	4619      	mov	r1, r3
 80021f0:	480e      	ldr	r0, [pc, #56]	; (800222c <xTaskRemoveFromEventList+0xb8>)
 80021f2:	f7fe fc16 	bl	8000a22 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80021f6:	693b      	ldr	r3, [r7, #16]
 80021f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80021fa:	4b0d      	ldr	r3, [pc, #52]	; (8002230 <xTaskRemoveFromEventList+0xbc>)
 80021fc:	681b      	ldr	r3, [r3, #0]
 80021fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002200:	429a      	cmp	r2, r3
 8002202:	d905      	bls.n	8002210 <xTaskRemoveFromEventList+0x9c>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 8002204:	2301      	movs	r3, #1
 8002206:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8002208:	4b0a      	ldr	r3, [pc, #40]	; (8002234 <xTaskRemoveFromEventList+0xc0>)
 800220a:	2201      	movs	r2, #1
 800220c:	601a      	str	r2, [r3, #0]
 800220e:	e001      	b.n	8002214 <xTaskRemoveFromEventList+0xa0>
	}
	else
	{
		xReturn = pdFALSE;
 8002210:	2300      	movs	r3, #0
 8002212:	617b      	str	r3, [r7, #20]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
 8002214:	697b      	ldr	r3, [r7, #20]
}
 8002216:	4618      	mov	r0, r3
 8002218:	3718      	adds	r7, #24
 800221a:	46bd      	mov	sp, r7
 800221c:	bd80      	pop	{r7, pc}
 800221e:	bf00      	nop
 8002220:	2000258c 	.word	0x2000258c
 8002224:	2000256c 	.word	0x2000256c
 8002228:	20002490 	.word	0x20002490
 800222c:	20002524 	.word	0x20002524
 8002230:	2000248c 	.word	0x2000248c
 8002234:	20002578 	.word	0x20002578

08002238 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 8002238:	b480      	push	{r7}
 800223a:	b085      	sub	sp, #20
 800223c:	af00      	add	r7, sp, #0
 800223e:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
 8002240:	687b      	ldr	r3, [r7, #4]
 8002242:	2b00      	cmp	r3, #0
 8002244:	d109      	bne.n	800225a <vTaskSetTimeOutState+0x22>
 8002246:	f04f 0350 	mov.w	r3, #80	; 0x50
 800224a:	f383 8811 	msr	BASEPRI, r3
 800224e:	f3bf 8f6f 	isb	sy
 8002252:	f3bf 8f4f 	dsb	sy
 8002256:	60fb      	str	r3, [r7, #12]
 8002258:	e7fe      	b.n	8002258 <vTaskSetTimeOutState+0x20>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800225a:	4b07      	ldr	r3, [pc, #28]	; (8002278 <vTaskSetTimeOutState+0x40>)
 800225c:	681a      	ldr	r2, [r3, #0]
 800225e:	687b      	ldr	r3, [r7, #4]
 8002260:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8002262:	4b06      	ldr	r3, [pc, #24]	; (800227c <vTaskSetTimeOutState+0x44>)
 8002264:	681a      	ldr	r2, [r3, #0]
 8002266:	687b      	ldr	r3, [r7, #4]
 8002268:	605a      	str	r2, [r3, #4]
}
 800226a:	bf00      	nop
 800226c:	3714      	adds	r7, #20
 800226e:	46bd      	mov	sp, r7
 8002270:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002274:	4770      	bx	lr
 8002276:	bf00      	nop
 8002278:	2000257c 	.word	0x2000257c
 800227c:	20002568 	.word	0x20002568

08002280 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 8002280:	b580      	push	{r7, lr}
 8002282:	b086      	sub	sp, #24
 8002284:	af00      	add	r7, sp, #0
 8002286:	6078      	str	r0, [r7, #4]
 8002288:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 800228a:	687b      	ldr	r3, [r7, #4]
 800228c:	2b00      	cmp	r3, #0
 800228e:	d109      	bne.n	80022a4 <xTaskCheckForTimeOut+0x24>
 8002290:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002294:	f383 8811 	msr	BASEPRI, r3
 8002298:	f3bf 8f6f 	isb	sy
 800229c:	f3bf 8f4f 	dsb	sy
 80022a0:	60fb      	str	r3, [r7, #12]
 80022a2:	e7fe      	b.n	80022a2 <xTaskCheckForTimeOut+0x22>
	configASSERT( pxTicksToWait );
 80022a4:	683b      	ldr	r3, [r7, #0]
 80022a6:	2b00      	cmp	r3, #0
 80022a8:	d109      	bne.n	80022be <xTaskCheckForTimeOut+0x3e>
 80022aa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80022ae:	f383 8811 	msr	BASEPRI, r3
 80022b2:	f3bf 8f6f 	isb	sy
 80022b6:	f3bf 8f4f 	dsb	sy
 80022ba:	60bb      	str	r3, [r7, #8]
 80022bc:	e7fe      	b.n	80022bc <xTaskCheckForTimeOut+0x3c>

	taskENTER_CRITICAL();
 80022be:	f7fe fd3f 	bl	8000d40 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 80022c2:	4b1c      	ldr	r3, [pc, #112]	; (8002334 <xTaskCheckForTimeOut+0xb4>)
 80022c4:	681b      	ldr	r3, [r3, #0]
 80022c6:	613b      	str	r3, [r7, #16]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 80022c8:	683b      	ldr	r3, [r7, #0]
 80022ca:	681b      	ldr	r3, [r3, #0]
 80022cc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80022d0:	d102      	bne.n	80022d8 <xTaskCheckForTimeOut+0x58>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 80022d2:	2300      	movs	r3, #0
 80022d4:	617b      	str	r3, [r7, #20]
 80022d6:	e026      	b.n	8002326 <xTaskCheckForTimeOut+0xa6>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80022d8:	687b      	ldr	r3, [r7, #4]
 80022da:	681a      	ldr	r2, [r3, #0]
 80022dc:	4b16      	ldr	r3, [pc, #88]	; (8002338 <xTaskCheckForTimeOut+0xb8>)
 80022de:	681b      	ldr	r3, [r3, #0]
 80022e0:	429a      	cmp	r2, r3
 80022e2:	d007      	beq.n	80022f4 <xTaskCheckForTimeOut+0x74>
 80022e4:	687b      	ldr	r3, [r7, #4]
 80022e6:	685a      	ldr	r2, [r3, #4]
 80022e8:	693b      	ldr	r3, [r7, #16]
 80022ea:	429a      	cmp	r2, r3
 80022ec:	d802      	bhi.n	80022f4 <xTaskCheckForTimeOut+0x74>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 80022ee:	2301      	movs	r3, #1
 80022f0:	617b      	str	r3, [r7, #20]
 80022f2:	e018      	b.n	8002326 <xTaskCheckForTimeOut+0xa6>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 80022f4:	687b      	ldr	r3, [r7, #4]
 80022f6:	685b      	ldr	r3, [r3, #4]
 80022f8:	693a      	ldr	r2, [r7, #16]
 80022fa:	1ad2      	subs	r2, r2, r3
 80022fc:	683b      	ldr	r3, [r7, #0]
 80022fe:	681b      	ldr	r3, [r3, #0]
 8002300:	429a      	cmp	r2, r3
 8002302:	d20e      	bcs.n	8002322 <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8002304:	683b      	ldr	r3, [r7, #0]
 8002306:	681a      	ldr	r2, [r3, #0]
 8002308:	687b      	ldr	r3, [r7, #4]
 800230a:	6859      	ldr	r1, [r3, #4]
 800230c:	693b      	ldr	r3, [r7, #16]
 800230e:	1acb      	subs	r3, r1, r3
 8002310:	441a      	add	r2, r3
 8002312:	683b      	ldr	r3, [r7, #0]
 8002314:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8002316:	6878      	ldr	r0, [r7, #4]
 8002318:	f7ff ff8e 	bl	8002238 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800231c:	2300      	movs	r3, #0
 800231e:	617b      	str	r3, [r7, #20]
 8002320:	e001      	b.n	8002326 <xTaskCheckForTimeOut+0xa6>
		}
		else
		{
			xReturn = pdTRUE;
 8002322:	2301      	movs	r3, #1
 8002324:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
 8002326:	f7fe fd39 	bl	8000d9c <vPortExitCritical>

	return xReturn;
 800232a:	697b      	ldr	r3, [r7, #20]
}
 800232c:	4618      	mov	r0, r3
 800232e:	3718      	adds	r7, #24
 8002330:	46bd      	mov	sp, r7
 8002332:	bd80      	pop	{r7, pc}
 8002334:	20002568 	.word	0x20002568
 8002338:	2000257c 	.word	0x2000257c

0800233c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 800233c:	b480      	push	{r7}
 800233e:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 8002340:	4b03      	ldr	r3, [pc, #12]	; (8002350 <vTaskMissedYield+0x14>)
 8002342:	2201      	movs	r2, #1
 8002344:	601a      	str	r2, [r3, #0]
}
 8002346:	bf00      	nop
 8002348:	46bd      	mov	sp, r7
 800234a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800234e:	4770      	bx	lr
 8002350:	20002578 	.word	0x20002578

08002354 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8002354:	b580      	push	{r7, lr}
 8002356:	b082      	sub	sp, #8
 8002358:	af00      	add	r7, sp, #0
 800235a:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 800235c:	f000 f852 	bl	8002404 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8002360:	4b06      	ldr	r3, [pc, #24]	; (800237c <prvIdleTask+0x28>)
 8002362:	681b      	ldr	r3, [r3, #0]
 8002364:	2b01      	cmp	r3, #1
 8002366:	d9f9      	bls.n	800235c <prvIdleTask+0x8>
			{
				taskYIELD();
 8002368:	4b05      	ldr	r3, [pc, #20]	; (8002380 <prvIdleTask+0x2c>)
 800236a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800236e:	601a      	str	r2, [r3, #0]
 8002370:	f3bf 8f4f 	dsb	sy
 8002374:	f3bf 8f6f 	isb	sy
		prvCheckTasksWaitingTermination();
 8002378:	e7f0      	b.n	800235c <prvIdleTask+0x8>
 800237a:	bf00      	nop
 800237c:	20002490 	.word	0x20002490
 8002380:	e000ed04 	.word	0xe000ed04

08002384 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 8002384:	b580      	push	{r7, lr}
 8002386:	b082      	sub	sp, #8
 8002388:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800238a:	2300      	movs	r3, #0
 800238c:	607b      	str	r3, [r7, #4]
 800238e:	e00c      	b.n	80023aa <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002390:	687a      	ldr	r2, [r7, #4]
 8002392:	4613      	mov	r3, r2
 8002394:	009b      	lsls	r3, r3, #2
 8002396:	4413      	add	r3, r2
 8002398:	009b      	lsls	r3, r3, #2
 800239a:	4a12      	ldr	r2, [pc, #72]	; (80023e4 <prvInitialiseTaskLists+0x60>)
 800239c:	4413      	add	r3, r2
 800239e:	4618      	mov	r0, r3
 80023a0:	f7fe fb12 	bl	80009c8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80023a4:	687b      	ldr	r3, [r7, #4]
 80023a6:	3301      	adds	r3, #1
 80023a8:	607b      	str	r3, [r7, #4]
 80023aa:	687b      	ldr	r3, [r7, #4]
 80023ac:	2b04      	cmp	r3, #4
 80023ae:	d9ef      	bls.n	8002390 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
 80023b0:	480d      	ldr	r0, [pc, #52]	; (80023e8 <prvInitialiseTaskLists+0x64>)
 80023b2:	f7fe fb09 	bl	80009c8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80023b6:	480d      	ldr	r0, [pc, #52]	; (80023ec <prvInitialiseTaskLists+0x68>)
 80023b8:	f7fe fb06 	bl	80009c8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 80023bc:	480c      	ldr	r0, [pc, #48]	; (80023f0 <prvInitialiseTaskLists+0x6c>)
 80023be:	f7fe fb03 	bl	80009c8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 80023c2:	480c      	ldr	r0, [pc, #48]	; (80023f4 <prvInitialiseTaskLists+0x70>)
 80023c4:	f7fe fb00 	bl	80009c8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 80023c8:	480b      	ldr	r0, [pc, #44]	; (80023f8 <prvInitialiseTaskLists+0x74>)
 80023ca:	f7fe fafd 	bl	80009c8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80023ce:	4b0b      	ldr	r3, [pc, #44]	; (80023fc <prvInitialiseTaskLists+0x78>)
 80023d0:	4a05      	ldr	r2, [pc, #20]	; (80023e8 <prvInitialiseTaskLists+0x64>)
 80023d2:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80023d4:	4b0a      	ldr	r3, [pc, #40]	; (8002400 <prvInitialiseTaskLists+0x7c>)
 80023d6:	4a05      	ldr	r2, [pc, #20]	; (80023ec <prvInitialiseTaskLists+0x68>)
 80023d8:	601a      	str	r2, [r3, #0]
}
 80023da:	bf00      	nop
 80023dc:	3708      	adds	r7, #8
 80023de:	46bd      	mov	sp, r7
 80023e0:	bd80      	pop	{r7, pc}
 80023e2:	bf00      	nop
 80023e4:	20002490 	.word	0x20002490
 80023e8:	200024f4 	.word	0x200024f4
 80023ec:	20002508 	.word	0x20002508
 80023f0:	20002524 	.word	0x20002524
 80023f4:	20002538 	.word	0x20002538
 80023f8:	20002550 	.word	0x20002550
 80023fc:	2000251c 	.word	0x2000251c
 8002400:	20002520 	.word	0x20002520

08002404 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8002404:	b580      	push	{r7, lr}
 8002406:	b082      	sub	sp, #8
 8002408:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800240a:	e028      	b.n	800245e <prvCheckTasksWaitingTermination+0x5a>
		{
			vTaskSuspendAll();
 800240c:	f7ff fc8c 	bl	8001d28 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8002410:	4b17      	ldr	r3, [pc, #92]	; (8002470 <prvCheckTasksWaitingTermination+0x6c>)
 8002412:	681b      	ldr	r3, [r3, #0]
 8002414:	2b00      	cmp	r3, #0
 8002416:	bf0c      	ite	eq
 8002418:	2301      	moveq	r3, #1
 800241a:	2300      	movne	r3, #0
 800241c:	b2db      	uxtb	r3, r3
 800241e:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
 8002420:	f7ff fc90 	bl	8001d44 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8002424:	687b      	ldr	r3, [r7, #4]
 8002426:	2b00      	cmp	r3, #0
 8002428:	d119      	bne.n	800245e <prvCheckTasksWaitingTermination+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 800242a:	f7fe fc89 	bl	8000d40 <vPortEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800242e:	4b10      	ldr	r3, [pc, #64]	; (8002470 <prvCheckTasksWaitingTermination+0x6c>)
 8002430:	68db      	ldr	r3, [r3, #12]
 8002432:	68db      	ldr	r3, [r3, #12]
 8002434:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002436:	683b      	ldr	r3, [r7, #0]
 8002438:	3304      	adds	r3, #4
 800243a:	4618      	mov	r0, r3
 800243c:	f7fe fb4e 	bl	8000adc <uxListRemove>
					--uxCurrentNumberOfTasks;
 8002440:	4b0c      	ldr	r3, [pc, #48]	; (8002474 <prvCheckTasksWaitingTermination+0x70>)
 8002442:	681b      	ldr	r3, [r3, #0]
 8002444:	3b01      	subs	r3, #1
 8002446:	4a0b      	ldr	r2, [pc, #44]	; (8002474 <prvCheckTasksWaitingTermination+0x70>)
 8002448:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 800244a:	4b0b      	ldr	r3, [pc, #44]	; (8002478 <prvCheckTasksWaitingTermination+0x74>)
 800244c:	681b      	ldr	r3, [r3, #0]
 800244e:	3b01      	subs	r3, #1
 8002450:	4a09      	ldr	r2, [pc, #36]	; (8002478 <prvCheckTasksWaitingTermination+0x74>)
 8002452:	6013      	str	r3, [r2, #0]
				}
				taskEXIT_CRITICAL();
 8002454:	f7fe fca2 	bl	8000d9c <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 8002458:	6838      	ldr	r0, [r7, #0]
 800245a:	f000 f80f 	bl	800247c <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800245e:	4b06      	ldr	r3, [pc, #24]	; (8002478 <prvCheckTasksWaitingTermination+0x74>)
 8002460:	681b      	ldr	r3, [r3, #0]
 8002462:	2b00      	cmp	r3, #0
 8002464:	d1d2      	bne.n	800240c <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 8002466:	bf00      	nop
 8002468:	3708      	adds	r7, #8
 800246a:	46bd      	mov	sp, r7
 800246c:	bd80      	pop	{r7, pc}
 800246e:	bf00      	nop
 8002470:	20002538 	.word	0x20002538
 8002474:	20002564 	.word	0x20002564
 8002478:	2000254c 	.word	0x2000254c

0800247c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 800247c:	b580      	push	{r7, lr}
 800247e:	b082      	sub	sp, #8
 8002480:	af00      	add	r7, sp, #0
 8002482:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 8002484:	687b      	ldr	r3, [r7, #4]
 8002486:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002488:	4618      	mov	r0, r3
 800248a:	f7fe fdbf 	bl	800100c <vPortFree>
			vPortFree( pxTCB );
 800248e:	6878      	ldr	r0, [r7, #4]
 8002490:	f7fe fdbc 	bl	800100c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 8002494:	bf00      	nop
 8002496:	3708      	adds	r7, #8
 8002498:	46bd      	mov	sp, r7
 800249a:	bd80      	pop	{r7, pc}

0800249c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 800249c:	b480      	push	{r7}
 800249e:	b083      	sub	sp, #12
 80024a0:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80024a2:	4b0f      	ldr	r3, [pc, #60]	; (80024e0 <prvResetNextTaskUnblockTime+0x44>)
 80024a4:	681b      	ldr	r3, [r3, #0]
 80024a6:	681b      	ldr	r3, [r3, #0]
 80024a8:	2b00      	cmp	r3, #0
 80024aa:	d101      	bne.n	80024b0 <prvResetNextTaskUnblockTime+0x14>
 80024ac:	2301      	movs	r3, #1
 80024ae:	e000      	b.n	80024b2 <prvResetNextTaskUnblockTime+0x16>
 80024b0:	2300      	movs	r3, #0
 80024b2:	2b00      	cmp	r3, #0
 80024b4:	d004      	beq.n	80024c0 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 80024b6:	4b0b      	ldr	r3, [pc, #44]	; (80024e4 <prvResetNextTaskUnblockTime+0x48>)
 80024b8:	f04f 32ff 	mov.w	r2, #4294967295
 80024bc:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 80024be:	e008      	b.n	80024d2 <prvResetNextTaskUnblockTime+0x36>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80024c0:	4b07      	ldr	r3, [pc, #28]	; (80024e0 <prvResetNextTaskUnblockTime+0x44>)
 80024c2:	681b      	ldr	r3, [r3, #0]
 80024c4:	68db      	ldr	r3, [r3, #12]
 80024c6:	68db      	ldr	r3, [r3, #12]
 80024c8:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80024ca:	687b      	ldr	r3, [r7, #4]
 80024cc:	685b      	ldr	r3, [r3, #4]
 80024ce:	4a05      	ldr	r2, [pc, #20]	; (80024e4 <prvResetNextTaskUnblockTime+0x48>)
 80024d0:	6013      	str	r3, [r2, #0]
}
 80024d2:	bf00      	nop
 80024d4:	370c      	adds	r7, #12
 80024d6:	46bd      	mov	sp, r7
 80024d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024dc:	4770      	bx	lr
 80024de:	bf00      	nop
 80024e0:	2000251c 	.word	0x2000251c
 80024e4:	20002584 	.word	0x20002584

080024e8 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 80024e8:	b480      	push	{r7}
 80024ea:	b083      	sub	sp, #12
 80024ec:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80024ee:	4b0b      	ldr	r3, [pc, #44]	; (800251c <xTaskGetSchedulerState+0x34>)
 80024f0:	681b      	ldr	r3, [r3, #0]
 80024f2:	2b00      	cmp	r3, #0
 80024f4:	d102      	bne.n	80024fc <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 80024f6:	2301      	movs	r3, #1
 80024f8:	607b      	str	r3, [r7, #4]
 80024fa:	e008      	b.n	800250e <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80024fc:	4b08      	ldr	r3, [pc, #32]	; (8002520 <xTaskGetSchedulerState+0x38>)
 80024fe:	681b      	ldr	r3, [r3, #0]
 8002500:	2b00      	cmp	r3, #0
 8002502:	d102      	bne.n	800250a <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 8002504:	2302      	movs	r3, #2
 8002506:	607b      	str	r3, [r7, #4]
 8002508:	e001      	b.n	800250e <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 800250a:	2300      	movs	r3, #0
 800250c:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 800250e:	687b      	ldr	r3, [r7, #4]
	}
 8002510:	4618      	mov	r0, r3
 8002512:	370c      	adds	r7, #12
 8002514:	46bd      	mov	sp, r7
 8002516:	f85d 7b04 	ldr.w	r7, [sp], #4
 800251a:	4770      	bx	lr
 800251c:	20002570 	.word	0x20002570
 8002520:	2000258c 	.word	0x2000258c

08002524 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 8002524:	b580      	push	{r7, lr}
 8002526:	b084      	sub	sp, #16
 8002528:	af00      	add	r7, sp, #0
 800252a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 800252c:	687b      	ldr	r3, [r7, #4]
 800252e:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8002530:	687b      	ldr	r3, [r7, #4]
 8002532:	2b00      	cmp	r3, #0
 8002534:	d062      	beq.n	80025fc <vTaskPriorityInherit+0xd8>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8002536:	68fb      	ldr	r3, [r7, #12]
 8002538:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800253a:	4b32      	ldr	r3, [pc, #200]	; (8002604 <vTaskPriorityInherit+0xe0>)
 800253c:	681b      	ldr	r3, [r3, #0]
 800253e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002540:	429a      	cmp	r2, r3
 8002542:	d25b      	bcs.n	80025fc <vTaskPriorityInherit+0xd8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8002544:	68fb      	ldr	r3, [r7, #12]
 8002546:	699b      	ldr	r3, [r3, #24]
 8002548:	2b00      	cmp	r3, #0
 800254a:	db06      	blt.n	800255a <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800254c:	4b2d      	ldr	r3, [pc, #180]	; (8002604 <vTaskPriorityInherit+0xe0>)
 800254e:	681b      	ldr	r3, [r3, #0]
 8002550:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002552:	f1c3 0205 	rsb	r2, r3, #5
 8002556:	68fb      	ldr	r3, [r7, #12]
 8002558:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800255a:	68fb      	ldr	r3, [r7, #12]
 800255c:	6959      	ldr	r1, [r3, #20]
 800255e:	68fb      	ldr	r3, [r7, #12]
 8002560:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002562:	4613      	mov	r3, r2
 8002564:	009b      	lsls	r3, r3, #2
 8002566:	4413      	add	r3, r2
 8002568:	009b      	lsls	r3, r3, #2
 800256a:	4a27      	ldr	r2, [pc, #156]	; (8002608 <vTaskPriorityInherit+0xe4>)
 800256c:	4413      	add	r3, r2
 800256e:	4299      	cmp	r1, r3
 8002570:	d101      	bne.n	8002576 <vTaskPriorityInherit+0x52>
 8002572:	2301      	movs	r3, #1
 8002574:	e000      	b.n	8002578 <vTaskPriorityInherit+0x54>
 8002576:	2300      	movs	r3, #0
 8002578:	2b00      	cmp	r3, #0
 800257a:	d03a      	beq.n	80025f2 <vTaskPriorityInherit+0xce>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800257c:	68fb      	ldr	r3, [r7, #12]
 800257e:	3304      	adds	r3, #4
 8002580:	4618      	mov	r0, r3
 8002582:	f7fe faab 	bl	8000adc <uxListRemove>
 8002586:	4603      	mov	r3, r0
 8002588:	2b00      	cmp	r3, #0
 800258a:	d115      	bne.n	80025b8 <vTaskPriorityInherit+0x94>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800258c:	68fb      	ldr	r3, [r7, #12]
 800258e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002590:	491d      	ldr	r1, [pc, #116]	; (8002608 <vTaskPriorityInherit+0xe4>)
 8002592:	4613      	mov	r3, r2
 8002594:	009b      	lsls	r3, r3, #2
 8002596:	4413      	add	r3, r2
 8002598:	009b      	lsls	r3, r3, #2
 800259a:	440b      	add	r3, r1
 800259c:	681b      	ldr	r3, [r3, #0]
 800259e:	2b00      	cmp	r3, #0
 80025a0:	d10a      	bne.n	80025b8 <vTaskPriorityInherit+0x94>
 80025a2:	68fb      	ldr	r3, [r7, #12]
 80025a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80025a6:	2201      	movs	r2, #1
 80025a8:	fa02 f303 	lsl.w	r3, r2, r3
 80025ac:	43da      	mvns	r2, r3
 80025ae:	4b17      	ldr	r3, [pc, #92]	; (800260c <vTaskPriorityInherit+0xe8>)
 80025b0:	681b      	ldr	r3, [r3, #0]
 80025b2:	4013      	ands	r3, r2
 80025b4:	4a15      	ldr	r2, [pc, #84]	; (800260c <vTaskPriorityInherit+0xe8>)
 80025b6:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80025b8:	4b12      	ldr	r3, [pc, #72]	; (8002604 <vTaskPriorityInherit+0xe0>)
 80025ba:	681b      	ldr	r3, [r3, #0]
 80025bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80025be:	68fb      	ldr	r3, [r7, #12]
 80025c0:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80025c2:	68fb      	ldr	r3, [r7, #12]
 80025c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80025c6:	2201      	movs	r2, #1
 80025c8:	409a      	lsls	r2, r3
 80025ca:	4b10      	ldr	r3, [pc, #64]	; (800260c <vTaskPriorityInherit+0xe8>)
 80025cc:	681b      	ldr	r3, [r3, #0]
 80025ce:	4313      	orrs	r3, r2
 80025d0:	4a0e      	ldr	r2, [pc, #56]	; (800260c <vTaskPriorityInherit+0xe8>)
 80025d2:	6013      	str	r3, [r2, #0]
 80025d4:	68fb      	ldr	r3, [r7, #12]
 80025d6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80025d8:	4613      	mov	r3, r2
 80025da:	009b      	lsls	r3, r3, #2
 80025dc:	4413      	add	r3, r2
 80025de:	009b      	lsls	r3, r3, #2
 80025e0:	4a09      	ldr	r2, [pc, #36]	; (8002608 <vTaskPriorityInherit+0xe4>)
 80025e2:	441a      	add	r2, r3
 80025e4:	68fb      	ldr	r3, [r7, #12]
 80025e6:	3304      	adds	r3, #4
 80025e8:	4619      	mov	r1, r3
 80025ea:	4610      	mov	r0, r2
 80025ec:	f7fe fa19 	bl	8000a22 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80025f0:	e004      	b.n	80025fc <vTaskPriorityInherit+0xd8>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80025f2:	4b04      	ldr	r3, [pc, #16]	; (8002604 <vTaskPriorityInherit+0xe0>)
 80025f4:	681b      	ldr	r3, [r3, #0]
 80025f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80025f8:	68fb      	ldr	r3, [r7, #12]
 80025fa:	62da      	str	r2, [r3, #44]	; 0x2c
	}
 80025fc:	bf00      	nop
 80025fe:	3710      	adds	r7, #16
 8002600:	46bd      	mov	sp, r7
 8002602:	bd80      	pop	{r7, pc}
 8002604:	2000248c 	.word	0x2000248c
 8002608:	20002490 	.word	0x20002490
 800260c:	2000256c 	.word	0x2000256c

08002610 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 8002610:	b580      	push	{r7, lr}
 8002612:	b086      	sub	sp, #24
 8002614:	af00      	add	r7, sp, #0
 8002616:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 8002618:	687b      	ldr	r3, [r7, #4]
 800261a:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
 800261c:	2300      	movs	r3, #0
 800261e:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 8002620:	687b      	ldr	r3, [r7, #4]
 8002622:	2b00      	cmp	r3, #0
 8002624:	d06c      	beq.n	8002700 <xTaskPriorityDisinherit+0xf0>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 8002626:	4b39      	ldr	r3, [pc, #228]	; (800270c <xTaskPriorityDisinherit+0xfc>)
 8002628:	681b      	ldr	r3, [r3, #0]
 800262a:	693a      	ldr	r2, [r7, #16]
 800262c:	429a      	cmp	r2, r3
 800262e:	d009      	beq.n	8002644 <xTaskPriorityDisinherit+0x34>
 8002630:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002634:	f383 8811 	msr	BASEPRI, r3
 8002638:	f3bf 8f6f 	isb	sy
 800263c:	f3bf 8f4f 	dsb	sy
 8002640:	60fb      	str	r3, [r7, #12]
 8002642:	e7fe      	b.n	8002642 <xTaskPriorityDisinherit+0x32>

			configASSERT( pxTCB->uxMutexesHeld );
 8002644:	693b      	ldr	r3, [r7, #16]
 8002646:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002648:	2b00      	cmp	r3, #0
 800264a:	d109      	bne.n	8002660 <xTaskPriorityDisinherit+0x50>
 800264c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002650:	f383 8811 	msr	BASEPRI, r3
 8002654:	f3bf 8f6f 	isb	sy
 8002658:	f3bf 8f4f 	dsb	sy
 800265c:	60bb      	str	r3, [r7, #8]
 800265e:	e7fe      	b.n	800265e <xTaskPriorityDisinherit+0x4e>
			( pxTCB->uxMutexesHeld )--;
 8002660:	693b      	ldr	r3, [r7, #16]
 8002662:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002664:	1e5a      	subs	r2, r3, #1
 8002666:	693b      	ldr	r3, [r7, #16]
 8002668:	645a      	str	r2, [r3, #68]	; 0x44

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800266a:	693b      	ldr	r3, [r7, #16]
 800266c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800266e:	693b      	ldr	r3, [r7, #16]
 8002670:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002672:	429a      	cmp	r2, r3
 8002674:	d044      	beq.n	8002700 <xTaskPriorityDisinherit+0xf0>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8002676:	693b      	ldr	r3, [r7, #16]
 8002678:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800267a:	2b00      	cmp	r3, #0
 800267c:	d140      	bne.n	8002700 <xTaskPriorityDisinherit+0xf0>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800267e:	693b      	ldr	r3, [r7, #16]
 8002680:	3304      	adds	r3, #4
 8002682:	4618      	mov	r0, r3
 8002684:	f7fe fa2a 	bl	8000adc <uxListRemove>
 8002688:	4603      	mov	r3, r0
 800268a:	2b00      	cmp	r3, #0
 800268c:	d115      	bne.n	80026ba <xTaskPriorityDisinherit+0xaa>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800268e:	693b      	ldr	r3, [r7, #16]
 8002690:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002692:	491f      	ldr	r1, [pc, #124]	; (8002710 <xTaskPriorityDisinherit+0x100>)
 8002694:	4613      	mov	r3, r2
 8002696:	009b      	lsls	r3, r3, #2
 8002698:	4413      	add	r3, r2
 800269a:	009b      	lsls	r3, r3, #2
 800269c:	440b      	add	r3, r1
 800269e:	681b      	ldr	r3, [r3, #0]
 80026a0:	2b00      	cmp	r3, #0
 80026a2:	d10a      	bne.n	80026ba <xTaskPriorityDisinherit+0xaa>
 80026a4:	693b      	ldr	r3, [r7, #16]
 80026a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80026a8:	2201      	movs	r2, #1
 80026aa:	fa02 f303 	lsl.w	r3, r2, r3
 80026ae:	43da      	mvns	r2, r3
 80026b0:	4b18      	ldr	r3, [pc, #96]	; (8002714 <xTaskPriorityDisinherit+0x104>)
 80026b2:	681b      	ldr	r3, [r3, #0]
 80026b4:	4013      	ands	r3, r2
 80026b6:	4a17      	ldr	r2, [pc, #92]	; (8002714 <xTaskPriorityDisinherit+0x104>)
 80026b8:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80026ba:	693b      	ldr	r3, [r7, #16]
 80026bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80026be:	693b      	ldr	r3, [r7, #16]
 80026c0:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80026c2:	693b      	ldr	r3, [r7, #16]
 80026c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80026c6:	f1c3 0205 	rsb	r2, r3, #5
 80026ca:	693b      	ldr	r3, [r7, #16]
 80026cc:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
 80026ce:	693b      	ldr	r3, [r7, #16]
 80026d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80026d2:	2201      	movs	r2, #1
 80026d4:	409a      	lsls	r2, r3
 80026d6:	4b0f      	ldr	r3, [pc, #60]	; (8002714 <xTaskPriorityDisinherit+0x104>)
 80026d8:	681b      	ldr	r3, [r3, #0]
 80026da:	4313      	orrs	r3, r2
 80026dc:	4a0d      	ldr	r2, [pc, #52]	; (8002714 <xTaskPriorityDisinherit+0x104>)
 80026de:	6013      	str	r3, [r2, #0]
 80026e0:	693b      	ldr	r3, [r7, #16]
 80026e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80026e4:	4613      	mov	r3, r2
 80026e6:	009b      	lsls	r3, r3, #2
 80026e8:	4413      	add	r3, r2
 80026ea:	009b      	lsls	r3, r3, #2
 80026ec:	4a08      	ldr	r2, [pc, #32]	; (8002710 <xTaskPriorityDisinherit+0x100>)
 80026ee:	441a      	add	r2, r3
 80026f0:	693b      	ldr	r3, [r7, #16]
 80026f2:	3304      	adds	r3, #4
 80026f4:	4619      	mov	r1, r3
 80026f6:	4610      	mov	r0, r2
 80026f8:	f7fe f993 	bl	8000a22 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 80026fc:	2301      	movs	r3, #1
 80026fe:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 8002700:	697b      	ldr	r3, [r7, #20]
	}
 8002702:	4618      	mov	r0, r3
 8002704:	3718      	adds	r7, #24
 8002706:	46bd      	mov	sp, r7
 8002708:	bd80      	pop	{r7, pc}
 800270a:	bf00      	nop
 800270c:	2000248c 	.word	0x2000248c
 8002710:	20002490 	.word	0x20002490
 8002714:	2000256c 	.word	0x2000256c

08002718 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
 8002718:	b480      	push	{r7}
 800271a:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 800271c:	4b07      	ldr	r3, [pc, #28]	; (800273c <pvTaskIncrementMutexHeldCount+0x24>)
 800271e:	681b      	ldr	r3, [r3, #0]
 8002720:	2b00      	cmp	r3, #0
 8002722:	d004      	beq.n	800272e <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 8002724:	4b05      	ldr	r3, [pc, #20]	; (800273c <pvTaskIncrementMutexHeldCount+0x24>)
 8002726:	681b      	ldr	r3, [r3, #0]
 8002728:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800272a:	3201      	adds	r2, #1
 800272c:	645a      	str	r2, [r3, #68]	; 0x44
		}

		return pxCurrentTCB;
 800272e:	4b03      	ldr	r3, [pc, #12]	; (800273c <pvTaskIncrementMutexHeldCount+0x24>)
 8002730:	681b      	ldr	r3, [r3, #0]
	}
 8002732:	4618      	mov	r0, r3
 8002734:	46bd      	mov	sp, r7
 8002736:	f85d 7b04 	ldr.w	r7, [sp], #4
 800273a:	4770      	bx	lr
 800273c:	2000248c 	.word	0x2000248c

08002740 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8002740:	b580      	push	{r7, lr}
 8002742:	b084      	sub	sp, #16
 8002744:	af00      	add	r7, sp, #0
 8002746:	6078      	str	r0, [r7, #4]
 8002748:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800274a:	4b29      	ldr	r3, [pc, #164]	; (80027f0 <prvAddCurrentTaskToDelayedList+0xb0>)
 800274c:	681b      	ldr	r3, [r3, #0]
 800274e:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002750:	4b28      	ldr	r3, [pc, #160]	; (80027f4 <prvAddCurrentTaskToDelayedList+0xb4>)
 8002752:	681b      	ldr	r3, [r3, #0]
 8002754:	3304      	adds	r3, #4
 8002756:	4618      	mov	r0, r3
 8002758:	f7fe f9c0 	bl	8000adc <uxListRemove>
 800275c:	4603      	mov	r3, r0
 800275e:	2b00      	cmp	r3, #0
 8002760:	d10b      	bne.n	800277a <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8002762:	4b24      	ldr	r3, [pc, #144]	; (80027f4 <prvAddCurrentTaskToDelayedList+0xb4>)
 8002764:	681b      	ldr	r3, [r3, #0]
 8002766:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002768:	2201      	movs	r2, #1
 800276a:	fa02 f303 	lsl.w	r3, r2, r3
 800276e:	43da      	mvns	r2, r3
 8002770:	4b21      	ldr	r3, [pc, #132]	; (80027f8 <prvAddCurrentTaskToDelayedList+0xb8>)
 8002772:	681b      	ldr	r3, [r3, #0]
 8002774:	4013      	ands	r3, r2
 8002776:	4a20      	ldr	r2, [pc, #128]	; (80027f8 <prvAddCurrentTaskToDelayedList+0xb8>)
 8002778:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800277a:	687b      	ldr	r3, [r7, #4]
 800277c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002780:	d10a      	bne.n	8002798 <prvAddCurrentTaskToDelayedList+0x58>
 8002782:	683b      	ldr	r3, [r7, #0]
 8002784:	2b00      	cmp	r3, #0
 8002786:	d007      	beq.n	8002798 <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002788:	4b1a      	ldr	r3, [pc, #104]	; (80027f4 <prvAddCurrentTaskToDelayedList+0xb4>)
 800278a:	681b      	ldr	r3, [r3, #0]
 800278c:	3304      	adds	r3, #4
 800278e:	4619      	mov	r1, r3
 8002790:	481a      	ldr	r0, [pc, #104]	; (80027fc <prvAddCurrentTaskToDelayedList+0xbc>)
 8002792:	f7fe f946 	bl	8000a22 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8002796:	e026      	b.n	80027e6 <prvAddCurrentTaskToDelayedList+0xa6>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8002798:	68fa      	ldr	r2, [r7, #12]
 800279a:	687b      	ldr	r3, [r7, #4]
 800279c:	4413      	add	r3, r2
 800279e:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80027a0:	4b14      	ldr	r3, [pc, #80]	; (80027f4 <prvAddCurrentTaskToDelayedList+0xb4>)
 80027a2:	681b      	ldr	r3, [r3, #0]
 80027a4:	68ba      	ldr	r2, [r7, #8]
 80027a6:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 80027a8:	68ba      	ldr	r2, [r7, #8]
 80027aa:	68fb      	ldr	r3, [r7, #12]
 80027ac:	429a      	cmp	r2, r3
 80027ae:	d209      	bcs.n	80027c4 <prvAddCurrentTaskToDelayedList+0x84>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80027b0:	4b13      	ldr	r3, [pc, #76]	; (8002800 <prvAddCurrentTaskToDelayedList+0xc0>)
 80027b2:	681a      	ldr	r2, [r3, #0]
 80027b4:	4b0f      	ldr	r3, [pc, #60]	; (80027f4 <prvAddCurrentTaskToDelayedList+0xb4>)
 80027b6:	681b      	ldr	r3, [r3, #0]
 80027b8:	3304      	adds	r3, #4
 80027ba:	4619      	mov	r1, r3
 80027bc:	4610      	mov	r0, r2
 80027be:	f7fe f954 	bl	8000a6a <vListInsert>
}
 80027c2:	e010      	b.n	80027e6 <prvAddCurrentTaskToDelayedList+0xa6>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80027c4:	4b0f      	ldr	r3, [pc, #60]	; (8002804 <prvAddCurrentTaskToDelayedList+0xc4>)
 80027c6:	681a      	ldr	r2, [r3, #0]
 80027c8:	4b0a      	ldr	r3, [pc, #40]	; (80027f4 <prvAddCurrentTaskToDelayedList+0xb4>)
 80027ca:	681b      	ldr	r3, [r3, #0]
 80027cc:	3304      	adds	r3, #4
 80027ce:	4619      	mov	r1, r3
 80027d0:	4610      	mov	r0, r2
 80027d2:	f7fe f94a 	bl	8000a6a <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 80027d6:	4b0c      	ldr	r3, [pc, #48]	; (8002808 <prvAddCurrentTaskToDelayedList+0xc8>)
 80027d8:	681b      	ldr	r3, [r3, #0]
 80027da:	68ba      	ldr	r2, [r7, #8]
 80027dc:	429a      	cmp	r2, r3
 80027de:	d202      	bcs.n	80027e6 <prvAddCurrentTaskToDelayedList+0xa6>
					xNextTaskUnblockTime = xTimeToWake;
 80027e0:	4a09      	ldr	r2, [pc, #36]	; (8002808 <prvAddCurrentTaskToDelayedList+0xc8>)
 80027e2:	68bb      	ldr	r3, [r7, #8]
 80027e4:	6013      	str	r3, [r2, #0]
}
 80027e6:	bf00      	nop
 80027e8:	3710      	adds	r7, #16
 80027ea:	46bd      	mov	sp, r7
 80027ec:	bd80      	pop	{r7, pc}
 80027ee:	bf00      	nop
 80027f0:	20002568 	.word	0x20002568
 80027f4:	2000248c 	.word	0x2000248c
 80027f8:	2000256c 	.word	0x2000256c
 80027fc:	20002550 	.word	0x20002550
 8002800:	20002520 	.word	0x20002520
 8002804:	2000251c 	.word	0x2000251c
 8002808:	20002584 	.word	0x20002584

0800280c <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 800280c:	b580      	push	{r7, lr}
 800280e:	b084      	sub	sp, #16
 8002810:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
 8002812:	2300      	movs	r3, #0
 8002814:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 8002816:	f000 fa8f 	bl	8002d38 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 800281a:	4b11      	ldr	r3, [pc, #68]	; (8002860 <xTimerCreateTimerTask+0x54>)
 800281c:	681b      	ldr	r3, [r3, #0]
 800281e:	2b00      	cmp	r3, #0
 8002820:	d00b      	beq.n	800283a <xTimerCreateTimerTask+0x2e>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
 8002822:	4b10      	ldr	r3, [pc, #64]	; (8002864 <xTimerCreateTimerTask+0x58>)
 8002824:	9301      	str	r3, [sp, #4]
 8002826:	2303      	movs	r3, #3
 8002828:	9300      	str	r3, [sp, #0]
 800282a:	2300      	movs	r3, #0
 800282c:	f44f 7282 	mov.w	r2, #260	; 0x104
 8002830:	490d      	ldr	r1, [pc, #52]	; (8002868 <xTimerCreateTimerTask+0x5c>)
 8002832:	480e      	ldr	r0, [pc, #56]	; (800286c <xTimerCreateTimerTask+0x60>)
 8002834:	f7ff f8ce 	bl	80019d4 <xTaskCreate>
 8002838:	6078      	str	r0, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 800283a:	687b      	ldr	r3, [r7, #4]
 800283c:	2b00      	cmp	r3, #0
 800283e:	d109      	bne.n	8002854 <xTimerCreateTimerTask+0x48>
 8002840:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002844:	f383 8811 	msr	BASEPRI, r3
 8002848:	f3bf 8f6f 	isb	sy
 800284c:	f3bf 8f4f 	dsb	sy
 8002850:	603b      	str	r3, [r7, #0]
 8002852:	e7fe      	b.n	8002852 <xTimerCreateTimerTask+0x46>
	return xReturn;
 8002854:	687b      	ldr	r3, [r7, #4]
}
 8002856:	4618      	mov	r0, r3
 8002858:	3708      	adds	r7, #8
 800285a:	46bd      	mov	sp, r7
 800285c:	bd80      	pop	{r7, pc}
 800285e:	bf00      	nop
 8002860:	200025c0 	.word	0x200025c0
 8002864:	200025c4 	.word	0x200025c4
 8002868:	0800e734 	.word	0x0800e734
 800286c:	08002989 	.word	0x08002989

08002870 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8002870:	b580      	push	{r7, lr}
 8002872:	b08a      	sub	sp, #40	; 0x28
 8002874:	af00      	add	r7, sp, #0
 8002876:	60f8      	str	r0, [r7, #12]
 8002878:	60b9      	str	r1, [r7, #8]
 800287a:	607a      	str	r2, [r7, #4]
 800287c:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
 800287e:	2300      	movs	r3, #0
 8002880:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 8002882:	68fb      	ldr	r3, [r7, #12]
 8002884:	2b00      	cmp	r3, #0
 8002886:	d109      	bne.n	800289c <xTimerGenericCommand+0x2c>
 8002888:	f04f 0350 	mov.w	r3, #80	; 0x50
 800288c:	f383 8811 	msr	BASEPRI, r3
 8002890:	f3bf 8f6f 	isb	sy
 8002894:	f3bf 8f4f 	dsb	sy
 8002898:	623b      	str	r3, [r7, #32]
 800289a:	e7fe      	b.n	800289a <xTimerGenericCommand+0x2a>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800289c:	4b19      	ldr	r3, [pc, #100]	; (8002904 <xTimerGenericCommand+0x94>)
 800289e:	681b      	ldr	r3, [r3, #0]
 80028a0:	2b00      	cmp	r3, #0
 80028a2:	d02a      	beq.n	80028fa <xTimerGenericCommand+0x8a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 80028a4:	68bb      	ldr	r3, [r7, #8]
 80028a6:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80028a8:	687b      	ldr	r3, [r7, #4]
 80028aa:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 80028ac:	68fb      	ldr	r3, [r7, #12]
 80028ae:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 80028b0:	68bb      	ldr	r3, [r7, #8]
 80028b2:	2b05      	cmp	r3, #5
 80028b4:	dc18      	bgt.n	80028e8 <xTimerGenericCommand+0x78>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80028b6:	f7ff fe17 	bl	80024e8 <xTaskGetSchedulerState>
 80028ba:	4603      	mov	r3, r0
 80028bc:	2b02      	cmp	r3, #2
 80028be:	d109      	bne.n	80028d4 <xTimerGenericCommand+0x64>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80028c0:	4b10      	ldr	r3, [pc, #64]	; (8002904 <xTimerGenericCommand+0x94>)
 80028c2:	6818      	ldr	r0, [r3, #0]
 80028c4:	f107 0114 	add.w	r1, r7, #20
 80028c8:	2300      	movs	r3, #0
 80028ca:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80028cc:	f7fe fc76 	bl	80011bc <xQueueGenericSend>
 80028d0:	6278      	str	r0, [r7, #36]	; 0x24
 80028d2:	e012      	b.n	80028fa <xTimerGenericCommand+0x8a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 80028d4:	4b0b      	ldr	r3, [pc, #44]	; (8002904 <xTimerGenericCommand+0x94>)
 80028d6:	6818      	ldr	r0, [r3, #0]
 80028d8:	f107 0114 	add.w	r1, r7, #20
 80028dc:	2300      	movs	r3, #0
 80028de:	2200      	movs	r2, #0
 80028e0:	f7fe fc6c 	bl	80011bc <xQueueGenericSend>
 80028e4:	6278      	str	r0, [r7, #36]	; 0x24
 80028e6:	e008      	b.n	80028fa <xTimerGenericCommand+0x8a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 80028e8:	4b06      	ldr	r3, [pc, #24]	; (8002904 <xTimerGenericCommand+0x94>)
 80028ea:	6818      	ldr	r0, [r3, #0]
 80028ec:	f107 0114 	add.w	r1, r7, #20
 80028f0:	2300      	movs	r3, #0
 80028f2:	683a      	ldr	r2, [r7, #0]
 80028f4:	f7fe fd5c 	bl	80013b0 <xQueueGenericSendFromISR>
 80028f8:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 80028fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 80028fc:	4618      	mov	r0, r3
 80028fe:	3728      	adds	r7, #40	; 0x28
 8002900:	46bd      	mov	sp, r7
 8002902:	bd80      	pop	{r7, pc}
 8002904:	200025c0 	.word	0x200025c0

08002908 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 8002908:	b580      	push	{r7, lr}
 800290a:	b088      	sub	sp, #32
 800290c:	af02      	add	r7, sp, #8
 800290e:	6078      	str	r0, [r7, #4]
 8002910:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002912:	4b1c      	ldr	r3, [pc, #112]	; (8002984 <prvProcessExpiredTimer+0x7c>)
 8002914:	681b      	ldr	r3, [r3, #0]
 8002916:	68db      	ldr	r3, [r3, #12]
 8002918:	68db      	ldr	r3, [r3, #12]
 800291a:	617b      	str	r3, [r7, #20]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800291c:	697b      	ldr	r3, [r7, #20]
 800291e:	3304      	adds	r3, #4
 8002920:	4618      	mov	r0, r3
 8002922:	f7fe f8db 	bl	8000adc <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002926:	697b      	ldr	r3, [r7, #20]
 8002928:	69db      	ldr	r3, [r3, #28]
 800292a:	2b01      	cmp	r3, #1
 800292c:	d121      	bne.n	8002972 <prvProcessExpiredTimer+0x6a>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800292e:	697b      	ldr	r3, [r7, #20]
 8002930:	699a      	ldr	r2, [r3, #24]
 8002932:	687b      	ldr	r3, [r7, #4]
 8002934:	18d1      	adds	r1, r2, r3
 8002936:	687b      	ldr	r3, [r7, #4]
 8002938:	683a      	ldr	r2, [r7, #0]
 800293a:	6978      	ldr	r0, [r7, #20]
 800293c:	f000 f8c8 	bl	8002ad0 <prvInsertTimerInActiveList>
 8002940:	4603      	mov	r3, r0
 8002942:	2b00      	cmp	r3, #0
 8002944:	d015      	beq.n	8002972 <prvProcessExpiredTimer+0x6a>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002946:	2300      	movs	r3, #0
 8002948:	9300      	str	r3, [sp, #0]
 800294a:	2300      	movs	r3, #0
 800294c:	687a      	ldr	r2, [r7, #4]
 800294e:	2100      	movs	r1, #0
 8002950:	6978      	ldr	r0, [r7, #20]
 8002952:	f7ff ff8d 	bl	8002870 <xTimerGenericCommand>
 8002956:	6138      	str	r0, [r7, #16]
			configASSERT( xResult );
 8002958:	693b      	ldr	r3, [r7, #16]
 800295a:	2b00      	cmp	r3, #0
 800295c:	d109      	bne.n	8002972 <prvProcessExpiredTimer+0x6a>
 800295e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002962:	f383 8811 	msr	BASEPRI, r3
 8002966:	f3bf 8f6f 	isb	sy
 800296a:	f3bf 8f4f 	dsb	sy
 800296e:	60fb      	str	r3, [r7, #12]
 8002970:	e7fe      	b.n	8002970 <prvProcessExpiredTimer+0x68>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002972:	697b      	ldr	r3, [r7, #20]
 8002974:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002976:	6978      	ldr	r0, [r7, #20]
 8002978:	4798      	blx	r3
}
 800297a:	bf00      	nop
 800297c:	3718      	adds	r7, #24
 800297e:	46bd      	mov	sp, r7
 8002980:	bd80      	pop	{r7, pc}
 8002982:	bf00      	nop
 8002984:	200025b8 	.word	0x200025b8

08002988 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8002988:	b580      	push	{r7, lr}
 800298a:	b084      	sub	sp, #16
 800298c:	af00      	add	r7, sp, #0
 800298e:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 8002990:	f107 0308 	add.w	r3, r7, #8
 8002994:	4618      	mov	r0, r3
 8002996:	f000 f857 	bl	8002a48 <prvGetNextExpireTime>
 800299a:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 800299c:	68bb      	ldr	r3, [r7, #8]
 800299e:	4619      	mov	r1, r3
 80029a0:	68f8      	ldr	r0, [r7, #12]
 80029a2:	f000 f803 	bl	80029ac <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 80029a6:	f000 f8d5 	bl	8002b54 <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 80029aa:	e7f1      	b.n	8002990 <prvTimerTask+0x8>

080029ac <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 80029ac:	b580      	push	{r7, lr}
 80029ae:	b084      	sub	sp, #16
 80029b0:	af00      	add	r7, sp, #0
 80029b2:	6078      	str	r0, [r7, #4]
 80029b4:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 80029b6:	f7ff f9b7 	bl	8001d28 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 80029ba:	f107 0308 	add.w	r3, r7, #8
 80029be:	4618      	mov	r0, r3
 80029c0:	f000 f866 	bl	8002a90 <prvSampleTimeNow>
 80029c4:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 80029c6:	68bb      	ldr	r3, [r7, #8]
 80029c8:	2b00      	cmp	r3, #0
 80029ca:	d130      	bne.n	8002a2e <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80029cc:	683b      	ldr	r3, [r7, #0]
 80029ce:	2b00      	cmp	r3, #0
 80029d0:	d10a      	bne.n	80029e8 <prvProcessTimerOrBlockTask+0x3c>
 80029d2:	687a      	ldr	r2, [r7, #4]
 80029d4:	68fb      	ldr	r3, [r7, #12]
 80029d6:	429a      	cmp	r2, r3
 80029d8:	d806      	bhi.n	80029e8 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
 80029da:	f7ff f9b3 	bl	8001d44 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 80029de:	68f9      	ldr	r1, [r7, #12]
 80029e0:	6878      	ldr	r0, [r7, #4]
 80029e2:	f7ff ff91 	bl	8002908 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 80029e6:	e024      	b.n	8002a32 <prvProcessTimerOrBlockTask+0x86>
				if( xListWasEmpty != pdFALSE )
 80029e8:	683b      	ldr	r3, [r7, #0]
 80029ea:	2b00      	cmp	r3, #0
 80029ec:	d008      	beq.n	8002a00 <prvProcessTimerOrBlockTask+0x54>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80029ee:	4b13      	ldr	r3, [pc, #76]	; (8002a3c <prvProcessTimerOrBlockTask+0x90>)
 80029f0:	681b      	ldr	r3, [r3, #0]
 80029f2:	681b      	ldr	r3, [r3, #0]
 80029f4:	2b00      	cmp	r3, #0
 80029f6:	bf0c      	ite	eq
 80029f8:	2301      	moveq	r3, #1
 80029fa:	2300      	movne	r3, #0
 80029fc:	b2db      	uxtb	r3, r3
 80029fe:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8002a00:	4b0f      	ldr	r3, [pc, #60]	; (8002a40 <prvProcessTimerOrBlockTask+0x94>)
 8002a02:	6818      	ldr	r0, [r3, #0]
 8002a04:	687a      	ldr	r2, [r7, #4]
 8002a06:	68fb      	ldr	r3, [r7, #12]
 8002a08:	1ad3      	subs	r3, r2, r3
 8002a0a:	683a      	ldr	r2, [r7, #0]
 8002a0c:	4619      	mov	r1, r3
 8002a0e:	f7fe ffad 	bl	800196c <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8002a12:	f7ff f997 	bl	8001d44 <xTaskResumeAll>
 8002a16:	4603      	mov	r3, r0
 8002a18:	2b00      	cmp	r3, #0
 8002a1a:	d10a      	bne.n	8002a32 <prvProcessTimerOrBlockTask+0x86>
					portYIELD_WITHIN_API();
 8002a1c:	4b09      	ldr	r3, [pc, #36]	; (8002a44 <prvProcessTimerOrBlockTask+0x98>)
 8002a1e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002a22:	601a      	str	r2, [r3, #0]
 8002a24:	f3bf 8f4f 	dsb	sy
 8002a28:	f3bf 8f6f 	isb	sy
}
 8002a2c:	e001      	b.n	8002a32 <prvProcessTimerOrBlockTask+0x86>
			( void ) xTaskResumeAll();
 8002a2e:	f7ff f989 	bl	8001d44 <xTaskResumeAll>
}
 8002a32:	bf00      	nop
 8002a34:	3710      	adds	r7, #16
 8002a36:	46bd      	mov	sp, r7
 8002a38:	bd80      	pop	{r7, pc}
 8002a3a:	bf00      	nop
 8002a3c:	200025bc 	.word	0x200025bc
 8002a40:	200025c0 	.word	0x200025c0
 8002a44:	e000ed04 	.word	0xe000ed04

08002a48 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 8002a48:	b480      	push	{r7}
 8002a4a:	b085      	sub	sp, #20
 8002a4c:	af00      	add	r7, sp, #0
 8002a4e:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8002a50:	4b0e      	ldr	r3, [pc, #56]	; (8002a8c <prvGetNextExpireTime+0x44>)
 8002a52:	681b      	ldr	r3, [r3, #0]
 8002a54:	681b      	ldr	r3, [r3, #0]
 8002a56:	2b00      	cmp	r3, #0
 8002a58:	bf0c      	ite	eq
 8002a5a:	2301      	moveq	r3, #1
 8002a5c:	2300      	movne	r3, #0
 8002a5e:	b2db      	uxtb	r3, r3
 8002a60:	461a      	mov	r2, r3
 8002a62:	687b      	ldr	r3, [r7, #4]
 8002a64:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 8002a66:	687b      	ldr	r3, [r7, #4]
 8002a68:	681b      	ldr	r3, [r3, #0]
 8002a6a:	2b00      	cmp	r3, #0
 8002a6c:	d105      	bne.n	8002a7a <prvGetNextExpireTime+0x32>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002a6e:	4b07      	ldr	r3, [pc, #28]	; (8002a8c <prvGetNextExpireTime+0x44>)
 8002a70:	681b      	ldr	r3, [r3, #0]
 8002a72:	68db      	ldr	r3, [r3, #12]
 8002a74:	681b      	ldr	r3, [r3, #0]
 8002a76:	60fb      	str	r3, [r7, #12]
 8002a78:	e001      	b.n	8002a7e <prvGetNextExpireTime+0x36>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8002a7a:	2300      	movs	r3, #0
 8002a7c:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
 8002a7e:	68fb      	ldr	r3, [r7, #12]
}
 8002a80:	4618      	mov	r0, r3
 8002a82:	3714      	adds	r7, #20
 8002a84:	46bd      	mov	sp, r7
 8002a86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a8a:	4770      	bx	lr
 8002a8c:	200025b8 	.word	0x200025b8

08002a90 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 8002a90:	b580      	push	{r7, lr}
 8002a92:	b084      	sub	sp, #16
 8002a94:	af00      	add	r7, sp, #0
 8002a96:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8002a98:	f7ff f9f0 	bl	8001e7c <xTaskGetTickCount>
 8002a9c:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
 8002a9e:	4b0b      	ldr	r3, [pc, #44]	; (8002acc <prvSampleTimeNow+0x3c>)
 8002aa0:	681b      	ldr	r3, [r3, #0]
 8002aa2:	68fa      	ldr	r2, [r7, #12]
 8002aa4:	429a      	cmp	r2, r3
 8002aa6:	d205      	bcs.n	8002ab4 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
 8002aa8:	f000 f8e6 	bl	8002c78 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 8002aac:	687b      	ldr	r3, [r7, #4]
 8002aae:	2201      	movs	r2, #1
 8002ab0:	601a      	str	r2, [r3, #0]
 8002ab2:	e002      	b.n	8002aba <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 8002ab4:	687b      	ldr	r3, [r7, #4]
 8002ab6:	2200      	movs	r2, #0
 8002ab8:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
 8002aba:	4a04      	ldr	r2, [pc, #16]	; (8002acc <prvSampleTimeNow+0x3c>)
 8002abc:	68fb      	ldr	r3, [r7, #12]
 8002abe:	6013      	str	r3, [r2, #0]

	return xTimeNow;
 8002ac0:	68fb      	ldr	r3, [r7, #12]
}
 8002ac2:	4618      	mov	r0, r3
 8002ac4:	3710      	adds	r7, #16
 8002ac6:	46bd      	mov	sp, r7
 8002ac8:	bd80      	pop	{r7, pc}
 8002aca:	bf00      	nop
 8002acc:	200025c8 	.word	0x200025c8

08002ad0 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 8002ad0:	b580      	push	{r7, lr}
 8002ad2:	b086      	sub	sp, #24
 8002ad4:	af00      	add	r7, sp, #0
 8002ad6:	60f8      	str	r0, [r7, #12]
 8002ad8:	60b9      	str	r1, [r7, #8]
 8002ada:	607a      	str	r2, [r7, #4]
 8002adc:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
 8002ade:	2300      	movs	r3, #0
 8002ae0:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8002ae2:	68fb      	ldr	r3, [r7, #12]
 8002ae4:	68ba      	ldr	r2, [r7, #8]
 8002ae6:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002ae8:	68fb      	ldr	r3, [r7, #12]
 8002aea:	68fa      	ldr	r2, [r7, #12]
 8002aec:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
 8002aee:	68ba      	ldr	r2, [r7, #8]
 8002af0:	687b      	ldr	r3, [r7, #4]
 8002af2:	429a      	cmp	r2, r3
 8002af4:	d812      	bhi.n	8002b1c <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002af6:	687a      	ldr	r2, [r7, #4]
 8002af8:	683b      	ldr	r3, [r7, #0]
 8002afa:	1ad2      	subs	r2, r2, r3
 8002afc:	68fb      	ldr	r3, [r7, #12]
 8002afe:	699b      	ldr	r3, [r3, #24]
 8002b00:	429a      	cmp	r2, r3
 8002b02:	d302      	bcc.n	8002b0a <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8002b04:	2301      	movs	r3, #1
 8002b06:	617b      	str	r3, [r7, #20]
 8002b08:	e01b      	b.n	8002b42 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8002b0a:	4b10      	ldr	r3, [pc, #64]	; (8002b4c <prvInsertTimerInActiveList+0x7c>)
 8002b0c:	681a      	ldr	r2, [r3, #0]
 8002b0e:	68fb      	ldr	r3, [r7, #12]
 8002b10:	3304      	adds	r3, #4
 8002b12:	4619      	mov	r1, r3
 8002b14:	4610      	mov	r0, r2
 8002b16:	f7fd ffa8 	bl	8000a6a <vListInsert>
 8002b1a:	e012      	b.n	8002b42 <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8002b1c:	687a      	ldr	r2, [r7, #4]
 8002b1e:	683b      	ldr	r3, [r7, #0]
 8002b20:	429a      	cmp	r2, r3
 8002b22:	d206      	bcs.n	8002b32 <prvInsertTimerInActiveList+0x62>
 8002b24:	68ba      	ldr	r2, [r7, #8]
 8002b26:	683b      	ldr	r3, [r7, #0]
 8002b28:	429a      	cmp	r2, r3
 8002b2a:	d302      	bcc.n	8002b32 <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 8002b2c:	2301      	movs	r3, #1
 8002b2e:	617b      	str	r3, [r7, #20]
 8002b30:	e007      	b.n	8002b42 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002b32:	4b07      	ldr	r3, [pc, #28]	; (8002b50 <prvInsertTimerInActiveList+0x80>)
 8002b34:	681a      	ldr	r2, [r3, #0]
 8002b36:	68fb      	ldr	r3, [r7, #12]
 8002b38:	3304      	adds	r3, #4
 8002b3a:	4619      	mov	r1, r3
 8002b3c:	4610      	mov	r0, r2
 8002b3e:	f7fd ff94 	bl	8000a6a <vListInsert>
		}
	}

	return xProcessTimerNow;
 8002b42:	697b      	ldr	r3, [r7, #20]
}
 8002b44:	4618      	mov	r0, r3
 8002b46:	3718      	adds	r7, #24
 8002b48:	46bd      	mov	sp, r7
 8002b4a:	bd80      	pop	{r7, pc}
 8002b4c:	200025bc 	.word	0x200025bc
 8002b50:	200025b8 	.word	0x200025b8

08002b54 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 8002b54:	b580      	push	{r7, lr}
 8002b56:	b08c      	sub	sp, #48	; 0x30
 8002b58:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8002b5a:	e07a      	b.n	8002c52 <prvProcessReceivedCommands+0xfe>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8002b5c:	68bb      	ldr	r3, [r7, #8]
 8002b5e:	2b00      	cmp	r3, #0
 8002b60:	db77      	blt.n	8002c52 <prvProcessReceivedCommands+0xfe>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8002b62:	693b      	ldr	r3, [r7, #16]
 8002b64:	627b      	str	r3, [r7, #36]	; 0x24

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 8002b66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002b68:	695b      	ldr	r3, [r3, #20]
 8002b6a:	2b00      	cmp	r3, #0
 8002b6c:	d004      	beq.n	8002b78 <prvProcessReceivedCommands+0x24>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002b6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002b70:	3304      	adds	r3, #4
 8002b72:	4618      	mov	r0, r3
 8002b74:	f7fd ffb2 	bl	8000adc <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8002b78:	1d3b      	adds	r3, r7, #4
 8002b7a:	4618      	mov	r0, r3
 8002b7c:	f7ff ff88 	bl	8002a90 <prvSampleTimeNow>
 8002b80:	6238      	str	r0, [r7, #32]

			switch( xMessage.xMessageID )
 8002b82:	68bb      	ldr	r3, [r7, #8]
 8002b84:	2b09      	cmp	r3, #9
 8002b86:	d863      	bhi.n	8002c50 <prvProcessReceivedCommands+0xfc>
 8002b88:	a201      	add	r2, pc, #4	; (adr r2, 8002b90 <prvProcessReceivedCommands+0x3c>)
 8002b8a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002b8e:	bf00      	nop
 8002b90:	08002bb9 	.word	0x08002bb9
 8002b94:	08002bb9 	.word	0x08002bb9
 8002b98:	08002bb9 	.word	0x08002bb9
 8002b9c:	08002c53 	.word	0x08002c53
 8002ba0:	08002c13 	.word	0x08002c13
 8002ba4:	08002c49 	.word	0x08002c49
 8002ba8:	08002bb9 	.word	0x08002bb9
 8002bac:	08002bb9 	.word	0x08002bb9
 8002bb0:	08002c53 	.word	0x08002c53
 8002bb4:	08002c13 	.word	0x08002c13
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8002bb8:	68fa      	ldr	r2, [r7, #12]
 8002bba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002bbc:	699b      	ldr	r3, [r3, #24]
 8002bbe:	18d1      	adds	r1, r2, r3
 8002bc0:	68fb      	ldr	r3, [r7, #12]
 8002bc2:	6a3a      	ldr	r2, [r7, #32]
 8002bc4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8002bc6:	f7ff ff83 	bl	8002ad0 <prvInsertTimerInActiveList>
 8002bca:	4603      	mov	r3, r0
 8002bcc:	2b00      	cmp	r3, #0
 8002bce:	d040      	beq.n	8002c52 <prvProcessReceivedCommands+0xfe>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002bd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002bd2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002bd4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8002bd6:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002bd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002bda:	69db      	ldr	r3, [r3, #28]
 8002bdc:	2b01      	cmp	r3, #1
 8002bde:	d138      	bne.n	8002c52 <prvProcessReceivedCommands+0xfe>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8002be0:	68fa      	ldr	r2, [r7, #12]
 8002be2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002be4:	699b      	ldr	r3, [r3, #24]
 8002be6:	441a      	add	r2, r3
 8002be8:	2300      	movs	r3, #0
 8002bea:	9300      	str	r3, [sp, #0]
 8002bec:	2300      	movs	r3, #0
 8002bee:	2100      	movs	r1, #0
 8002bf0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8002bf2:	f7ff fe3d 	bl	8002870 <xTimerGenericCommand>
 8002bf6:	61f8      	str	r0, [r7, #28]
							configASSERT( xResult );
 8002bf8:	69fb      	ldr	r3, [r7, #28]
 8002bfa:	2b00      	cmp	r3, #0
 8002bfc:	d129      	bne.n	8002c52 <prvProcessReceivedCommands+0xfe>
 8002bfe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c02:	f383 8811 	msr	BASEPRI, r3
 8002c06:	f3bf 8f6f 	isb	sy
 8002c0a:	f3bf 8f4f 	dsb	sy
 8002c0e:	61bb      	str	r3, [r7, #24]
 8002c10:	e7fe      	b.n	8002c10 <prvProcessReceivedCommands+0xbc>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8002c12:	68fa      	ldr	r2, [r7, #12]
 8002c14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c16:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8002c18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c1a:	699b      	ldr	r3, [r3, #24]
 8002c1c:	2b00      	cmp	r3, #0
 8002c1e:	d109      	bne.n	8002c34 <prvProcessReceivedCommands+0xe0>
 8002c20:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c24:	f383 8811 	msr	BASEPRI, r3
 8002c28:	f3bf 8f6f 	isb	sy
 8002c2c:	f3bf 8f4f 	dsb	sy
 8002c30:	617b      	str	r3, [r7, #20]
 8002c32:	e7fe      	b.n	8002c32 <prvProcessReceivedCommands+0xde>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8002c34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c36:	699a      	ldr	r2, [r3, #24]
 8002c38:	6a3b      	ldr	r3, [r7, #32]
 8002c3a:	18d1      	adds	r1, r2, r3
 8002c3c:	6a3b      	ldr	r3, [r7, #32]
 8002c3e:	6a3a      	ldr	r2, [r7, #32]
 8002c40:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8002c42:	f7ff ff45 	bl	8002ad0 <prvInsertTimerInActiveList>
					break;
 8002c46:	e004      	b.n	8002c52 <prvProcessReceivedCommands+0xfe>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
 8002c48:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8002c4a:	f7fe f9df 	bl	800100c <vPortFree>
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 8002c4e:	e000      	b.n	8002c52 <prvProcessReceivedCommands+0xfe>

				default	:
					/* Don't expect to get here. */
					break;
 8002c50:	bf00      	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8002c52:	4b08      	ldr	r3, [pc, #32]	; (8002c74 <prvProcessReceivedCommands+0x120>)
 8002c54:	6818      	ldr	r0, [r3, #0]
 8002c56:	f107 0108 	add.w	r1, r7, #8
 8002c5a:	2300      	movs	r3, #0
 8002c5c:	2200      	movs	r2, #0
 8002c5e:	f7fe fc3b 	bl	80014d8 <xQueueGenericReceive>
 8002c62:	4603      	mov	r3, r0
 8002c64:	2b00      	cmp	r3, #0
 8002c66:	f47f af79 	bne.w	8002b5c <prvProcessReceivedCommands+0x8>
			}
		}
	}
}
 8002c6a:	bf00      	nop
 8002c6c:	3728      	adds	r7, #40	; 0x28
 8002c6e:	46bd      	mov	sp, r7
 8002c70:	bd80      	pop	{r7, pc}
 8002c72:	bf00      	nop
 8002c74:	200025c0 	.word	0x200025c0

08002c78 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8002c78:	b580      	push	{r7, lr}
 8002c7a:	b088      	sub	sp, #32
 8002c7c:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8002c7e:	e044      	b.n	8002d0a <prvSwitchTimerLists+0x92>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002c80:	4b2b      	ldr	r3, [pc, #172]	; (8002d30 <prvSwitchTimerLists+0xb8>)
 8002c82:	681b      	ldr	r3, [r3, #0]
 8002c84:	68db      	ldr	r3, [r3, #12]
 8002c86:	681b      	ldr	r3, [r3, #0]
 8002c88:	617b      	str	r3, [r7, #20]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002c8a:	4b29      	ldr	r3, [pc, #164]	; (8002d30 <prvSwitchTimerLists+0xb8>)
 8002c8c:	681b      	ldr	r3, [r3, #0]
 8002c8e:	68db      	ldr	r3, [r3, #12]
 8002c90:	68db      	ldr	r3, [r3, #12]
 8002c92:	613b      	str	r3, [r7, #16]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002c94:	693b      	ldr	r3, [r7, #16]
 8002c96:	3304      	adds	r3, #4
 8002c98:	4618      	mov	r0, r3
 8002c9a:	f7fd ff1f 	bl	8000adc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002c9e:	693b      	ldr	r3, [r7, #16]
 8002ca0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002ca2:	6938      	ldr	r0, [r7, #16]
 8002ca4:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002ca6:	693b      	ldr	r3, [r7, #16]
 8002ca8:	69db      	ldr	r3, [r3, #28]
 8002caa:	2b01      	cmp	r3, #1
 8002cac:	d12d      	bne.n	8002d0a <prvSwitchTimerLists+0x92>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8002cae:	693b      	ldr	r3, [r7, #16]
 8002cb0:	699a      	ldr	r2, [r3, #24]
 8002cb2:	697b      	ldr	r3, [r7, #20]
 8002cb4:	4413      	add	r3, r2
 8002cb6:	60fb      	str	r3, [r7, #12]
			if( xReloadTime > xNextExpireTime )
 8002cb8:	68fa      	ldr	r2, [r7, #12]
 8002cba:	697b      	ldr	r3, [r7, #20]
 8002cbc:	429a      	cmp	r2, r3
 8002cbe:	d90e      	bls.n	8002cde <prvSwitchTimerLists+0x66>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8002cc0:	693b      	ldr	r3, [r7, #16]
 8002cc2:	68fa      	ldr	r2, [r7, #12]
 8002cc4:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002cc6:	693b      	ldr	r3, [r7, #16]
 8002cc8:	693a      	ldr	r2, [r7, #16]
 8002cca:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002ccc:	4b18      	ldr	r3, [pc, #96]	; (8002d30 <prvSwitchTimerLists+0xb8>)
 8002cce:	681a      	ldr	r2, [r3, #0]
 8002cd0:	693b      	ldr	r3, [r7, #16]
 8002cd2:	3304      	adds	r3, #4
 8002cd4:	4619      	mov	r1, r3
 8002cd6:	4610      	mov	r0, r2
 8002cd8:	f7fd fec7 	bl	8000a6a <vListInsert>
 8002cdc:	e015      	b.n	8002d0a <prvSwitchTimerLists+0x92>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002cde:	2300      	movs	r3, #0
 8002ce0:	9300      	str	r3, [sp, #0]
 8002ce2:	2300      	movs	r3, #0
 8002ce4:	697a      	ldr	r2, [r7, #20]
 8002ce6:	2100      	movs	r1, #0
 8002ce8:	6938      	ldr	r0, [r7, #16]
 8002cea:	f7ff fdc1 	bl	8002870 <xTimerGenericCommand>
 8002cee:	60b8      	str	r0, [r7, #8]
				configASSERT( xResult );
 8002cf0:	68bb      	ldr	r3, [r7, #8]
 8002cf2:	2b00      	cmp	r3, #0
 8002cf4:	d109      	bne.n	8002d0a <prvSwitchTimerLists+0x92>
 8002cf6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002cfa:	f383 8811 	msr	BASEPRI, r3
 8002cfe:	f3bf 8f6f 	isb	sy
 8002d02:	f3bf 8f4f 	dsb	sy
 8002d06:	603b      	str	r3, [r7, #0]
 8002d08:	e7fe      	b.n	8002d08 <prvSwitchTimerLists+0x90>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8002d0a:	4b09      	ldr	r3, [pc, #36]	; (8002d30 <prvSwitchTimerLists+0xb8>)
 8002d0c:	681b      	ldr	r3, [r3, #0]
 8002d0e:	681b      	ldr	r3, [r3, #0]
 8002d10:	2b00      	cmp	r3, #0
 8002d12:	d1b5      	bne.n	8002c80 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 8002d14:	4b06      	ldr	r3, [pc, #24]	; (8002d30 <prvSwitchTimerLists+0xb8>)
 8002d16:	681b      	ldr	r3, [r3, #0]
 8002d18:	607b      	str	r3, [r7, #4]
	pxCurrentTimerList = pxOverflowTimerList;
 8002d1a:	4b06      	ldr	r3, [pc, #24]	; (8002d34 <prvSwitchTimerLists+0xbc>)
 8002d1c:	681b      	ldr	r3, [r3, #0]
 8002d1e:	4a04      	ldr	r2, [pc, #16]	; (8002d30 <prvSwitchTimerLists+0xb8>)
 8002d20:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
 8002d22:	4a04      	ldr	r2, [pc, #16]	; (8002d34 <prvSwitchTimerLists+0xbc>)
 8002d24:	687b      	ldr	r3, [r7, #4]
 8002d26:	6013      	str	r3, [r2, #0]
}
 8002d28:	bf00      	nop
 8002d2a:	3718      	adds	r7, #24
 8002d2c:	46bd      	mov	sp, r7
 8002d2e:	bd80      	pop	{r7, pc}
 8002d30:	200025b8 	.word	0x200025b8
 8002d34:	200025bc 	.word	0x200025bc

08002d38 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8002d38:	b580      	push	{r7, lr}
 8002d3a:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8002d3c:	f7fe f800 	bl	8000d40 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8002d40:	4b12      	ldr	r3, [pc, #72]	; (8002d8c <prvCheckForValidListAndQueue+0x54>)
 8002d42:	681b      	ldr	r3, [r3, #0]
 8002d44:	2b00      	cmp	r3, #0
 8002d46:	d11d      	bne.n	8002d84 <prvCheckForValidListAndQueue+0x4c>
		{
			vListInitialise( &xActiveTimerList1 );
 8002d48:	4811      	ldr	r0, [pc, #68]	; (8002d90 <prvCheckForValidListAndQueue+0x58>)
 8002d4a:	f7fd fe3d 	bl	80009c8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8002d4e:	4811      	ldr	r0, [pc, #68]	; (8002d94 <prvCheckForValidListAndQueue+0x5c>)
 8002d50:	f7fd fe3a 	bl	80009c8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 8002d54:	4b10      	ldr	r3, [pc, #64]	; (8002d98 <prvCheckForValidListAndQueue+0x60>)
 8002d56:	4a0e      	ldr	r2, [pc, #56]	; (8002d90 <prvCheckForValidListAndQueue+0x58>)
 8002d58:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 8002d5a:	4b10      	ldr	r3, [pc, #64]	; (8002d9c <prvCheckForValidListAndQueue+0x64>)
 8002d5c:	4a0d      	ldr	r2, [pc, #52]	; (8002d94 <prvCheckForValidListAndQueue+0x5c>)
 8002d5e:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002d60:	2200      	movs	r2, #0
 8002d62:	210c      	movs	r1, #12
 8002d64:	2005      	movs	r0, #5
 8002d66:	f7fe f9d1 	bl	800110c <xQueueGenericCreate>
 8002d6a:	4602      	mov	r2, r0
 8002d6c:	4b07      	ldr	r3, [pc, #28]	; (8002d8c <prvCheckForValidListAndQueue+0x54>)
 8002d6e:	601a      	str	r2, [r3, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 8002d70:	4b06      	ldr	r3, [pc, #24]	; (8002d8c <prvCheckForValidListAndQueue+0x54>)
 8002d72:	681b      	ldr	r3, [r3, #0]
 8002d74:	2b00      	cmp	r3, #0
 8002d76:	d005      	beq.n	8002d84 <prvCheckForValidListAndQueue+0x4c>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8002d78:	4b04      	ldr	r3, [pc, #16]	; (8002d8c <prvCheckForValidListAndQueue+0x54>)
 8002d7a:	681b      	ldr	r3, [r3, #0]
 8002d7c:	4908      	ldr	r1, [pc, #32]	; (8002da0 <prvCheckForValidListAndQueue+0x68>)
 8002d7e:	4618      	mov	r0, r3
 8002d80:	f7fe fdcc 	bl	800191c <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8002d84:	f7fe f80a 	bl	8000d9c <vPortExitCritical>
}
 8002d88:	bf00      	nop
 8002d8a:	bd80      	pop	{r7, pc}
 8002d8c:	200025c0 	.word	0x200025c0
 8002d90:	20002590 	.word	0x20002590
 8002d94:	200025a4 	.word	0x200025a4
 8002d98:	200025b8 	.word	0x200025b8
 8002d9c:	200025bc 	.word	0x200025bc
 8002da0:	0800e73c 	.word	0x0800e73c

08002da4 <ETH_Delay>:
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
 8002da4:	b480      	push	{r7}
 8002da6:	b085      	sub	sp, #20
 8002da8:	af00      	add	r7, sp, #0
 8002daa:	6078      	str	r0, [r7, #4]
  __IO uint32_t index = 0; 
 8002dac:	2300      	movs	r3, #0
 8002dae:	60fb      	str	r3, [r7, #12]
  for(index = nCount; index != 0; index--)
 8002db0:	687b      	ldr	r3, [r7, #4]
 8002db2:	60fb      	str	r3, [r7, #12]
 8002db4:	e002      	b.n	8002dbc <ETH_Delay+0x18>
 8002db6:	68fb      	ldr	r3, [r7, #12]
 8002db8:	3b01      	subs	r3, #1
 8002dba:	60fb      	str	r3, [r7, #12]
 8002dbc:	68fb      	ldr	r3, [r7, #12]
 8002dbe:	2b00      	cmp	r3, #0
 8002dc0:	d1f9      	bne.n	8002db6 <ETH_Delay+0x12>
  {
  }
}
 8002dc2:	bf00      	nop
 8002dc4:	3714      	adds	r7, #20
 8002dc6:	46bd      	mov	sp, r7
 8002dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dcc:	4770      	bx	lr

08002dce <ETH_DeInit>:
  * @brief  Deinitializes the ETHERNET peripheral registers to their default reset values.
  * @param  None 
  * @retval None
  */
void ETH_DeInit(void)
{
 8002dce:	b580      	push	{r7, lr}
 8002dd0:	af00      	add	r7, sp, #0
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
 8002dd2:	2101      	movs	r1, #1
 8002dd4:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8002dd8:	f001 fddc 	bl	8004994 <RCC_AHB1PeriphResetCmd>
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
 8002ddc:	2100      	movs	r1, #0
 8002dde:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8002de2:	f001 fdd7 	bl	8004994 <RCC_AHB1PeriphResetCmd>
}
 8002de6:	bf00      	nop
 8002de8:	bd80      	pop	{r7, pc}

08002dea <ETH_StructInit>:
  * @brief  Fills each ETH_InitStruct member with its default value.
  * @param  ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized.
  * @retval None
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
 8002dea:	b480      	push	{r7}
 8002dec:	b083      	sub	sp, #12
 8002dee:	af00      	add	r7, sp, #0
 8002df0:	6078      	str	r0, [r7, #4]
  /* ETH_InitStruct members default value */
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;           
 8002df2:	687b      	ldr	r3, [r7, #4]
 8002df4:	2201      	movs	r2, #1
 8002df6:	601a      	str	r2, [r3, #0]
  /* MAC watchdog enabled: cuts-off long frame */
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
 8002df8:	687b      	ldr	r3, [r7, #4]
 8002dfa:	2200      	movs	r2, #0
 8002dfc:	605a      	str	r2, [r3, #4]
  /* MAC Jabber enabled in Half-duplex mode */
  ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;                                                       
 8002dfe:	687b      	ldr	r3, [r7, #4]
 8002e00:	2200      	movs	r2, #0
 8002e02:	609a      	str	r2, [r3, #8]
  /* Ethernet interframe gap set to 96 bits */
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                             
 8002e04:	687b      	ldr	r3, [r7, #4]
 8002e06:	2200      	movs	r2, #0
 8002e08:	60da      	str	r2, [r3, #12]
  /* Carrier Sense Enabled in Half-Duplex mode */ 
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                                
 8002e0a:	687b      	ldr	r3, [r7, #4]
 8002e0c:	2200      	movs	r2, #0
 8002e0e:	611a      	str	r2, [r3, #16]
  /* PHY speed configured to 100Mbit/s */
  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
 8002e10:	687b      	ldr	r3, [r7, #4]
 8002e12:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8002e16:	615a      	str	r2, [r3, #20]
  /* Receive own Frames in Half-Duplex mode enabled */
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                
 8002e18:	687b      	ldr	r3, [r7, #4]
 8002e1a:	2200      	movs	r2, #0
 8002e1c:	619a      	str	r2, [r3, #24]
  /* MAC MII loopback disabled */ 
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
 8002e1e:	687b      	ldr	r3, [r7, #4]
 8002e20:	2200      	movs	r2, #0
 8002e22:	61da      	str	r2, [r3, #28]
  /* Full-Duplex mode selected */
  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;                      
 8002e24:	687b      	ldr	r3, [r7, #4]
 8002e26:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8002e2a:	621a      	str	r2, [r3, #32]
  /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
  ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;                                                             
 8002e2c:	687b      	ldr	r3, [r7, #4]
 8002e2e:	2200      	movs	r2, #0
 8002e30:	625a      	str	r2, [r3, #36]	; 0x24
  /* Retry Transmission enabled for half-duplex mode */ 
  ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;                                                                                   
 8002e32:	687b      	ldr	r3, [r7, #4]
 8002e34:	2200      	movs	r2, #0
 8002e36:	629a      	str	r2, [r3, #40]	; 0x28
  /* Automatic PAD/CRC strip disabled*/
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                          
 8002e38:	687b      	ldr	r3, [r7, #4]
 8002e3a:	2200      	movs	r2, #0
 8002e3c:	62da      	str	r2, [r3, #44]	; 0x2c
  /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;     
 8002e3e:	687b      	ldr	r3, [r7, #4]
 8002e40:	2200      	movs	r2, #0
 8002e42:	631a      	str	r2, [r3, #48]	; 0x30
  /* half-duplex mode Deferral check disabled */
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
 8002e44:	687b      	ldr	r3, [r7, #4]
 8002e46:	2200      	movs	r2, #0
 8002e48:	635a      	str	r2, [r3, #52]	; 0x34
  /* Receive all frames disabled */ 
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
 8002e4a:	687b      	ldr	r3, [r7, #4]
 8002e4c:	2200      	movs	r2, #0
 8002e4e:	639a      	str	r2, [r3, #56]	; 0x38
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
 8002e50:	687b      	ldr	r3, [r7, #4]
 8002e52:	2200      	movs	r2, #0
 8002e54:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
 8002e56:	687b      	ldr	r3, [r7, #4]
 8002e58:	2240      	movs	r2, #64	; 0x40
 8002e5a:	641a      	str	r2, [r3, #64]	; 0x40
  /* Disable reception of Broadcast frames */
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
 8002e5c:	687b      	ldr	r3, [r7, #4]
 8002e5e:	2220      	movs	r2, #32
 8002e60:	645a      	str	r2, [r3, #68]	; 0x44
  /* Normal Destination address filtering (not reverse addressing) */
  ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;
 8002e62:	687b      	ldr	r3, [r7, #4]
 8002e64:	2200      	movs	r2, #0
 8002e66:	649a      	str	r2, [r3, #72]	; 0x48
  /* Promiscuous address filtering mode disabled */
  ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;                                                             
 8002e68:	687b      	ldr	r3, [r7, #4]
 8002e6a:	2200      	movs	r2, #0
 8002e6c:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Perfect address filtering for multicast addresses */
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;       
 8002e6e:	687b      	ldr	r3, [r7, #4]
 8002e70:	2200      	movs	r2, #0
 8002e72:	651a      	str	r2, [r3, #80]	; 0x50
  /* Perfect address filtering for unicast addresses */
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
 8002e74:	687b      	ldr	r3, [r7, #4]
 8002e76:	2200      	movs	r2, #0
 8002e78:	655a      	str	r2, [r3, #84]	; 0x54
  /* Initialize hash table high and low regs */
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
 8002e7a:	687b      	ldr	r3, [r7, #4]
 8002e7c:	2200      	movs	r2, #0
 8002e7e:	659a      	str	r2, [r3, #88]	; 0x58
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
 8002e80:	687b      	ldr	r3, [r7, #4]
 8002e82:	2200      	movs	r2, #0
 8002e84:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Flow control config (flow control disabled)*/
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
 8002e86:	687b      	ldr	r3, [r7, #4]
 8002e88:	2200      	movs	r2, #0
 8002e8a:	661a      	str	r2, [r3, #96]	; 0x60
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
 8002e8c:	687b      	ldr	r3, [r7, #4]
 8002e8e:	2280      	movs	r2, #128	; 0x80
 8002e90:	665a      	str	r2, [r3, #100]	; 0x64
  ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
 8002e92:	687b      	ldr	r3, [r7, #4]
 8002e94:	2200      	movs	r2, #0
 8002e96:	669a      	str	r2, [r3, #104]	; 0x68
  ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
 8002e98:	687b      	ldr	r3, [r7, #4]
 8002e9a:	2200      	movs	r2, #0
 8002e9c:	66da      	str	r2, [r3, #108]	; 0x6c
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
 8002e9e:	687b      	ldr	r3, [r7, #4]
 8002ea0:	2200      	movs	r2, #0
 8002ea2:	671a      	str	r2, [r3, #112]	; 0x70
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
 8002ea4:	687b      	ldr	r3, [r7, #4]
 8002ea6:	2200      	movs	r2, #0
 8002ea8:	675a      	str	r2, [r3, #116]	; 0x74
  /* VLANtag config (VLAN field not checked) */
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
 8002eaa:	687b      	ldr	r3, [r7, #4]
 8002eac:	2200      	movs	r2, #0
 8002eae:	679a      	str	r2, [r3, #120]	; 0x78
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
 8002eb0:	687b      	ldr	r3, [r7, #4]
 8002eb2:	2200      	movs	r2, #0
 8002eb4:	67da      	str	r2, [r3, #124]	; 0x7c
  
  /*---------------------- DMA Configuration   -------------------------------*/

  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
 8002eb6:	687b      	ldr	r3, [r7, #4]
 8002eb8:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8002ebc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
 8002ec0:	687b      	ldr	r3, [r7, #4]
 8002ec2:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8002ec6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  /* Flush received frame that created FIFO overflow */
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
 8002eca:	687b      	ldr	r3, [r7, #4]
 8002ecc:	2200      	movs	r2, #0
 8002ece:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Store and forward mode enabled for transmit */
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
 8002ed2:	687b      	ldr	r3, [r7, #4]
 8002ed4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8002ed8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
 8002edc:	687b      	ldr	r3, [r7, #4]
 8002ede:	2200      	movs	r2, #0
 8002ee0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  /* Disable forwarding frames with errors (short frames, CRC,...)*/
  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; 
 8002ee4:	687b      	ldr	r3, [r7, #4]
 8002ee6:	2200      	movs	r2, #0
 8002ee8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  /* Disable undersized good frames */
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
 8002eec:	687b      	ldr	r3, [r7, #4]
 8002eee:	2200      	movs	r2, #0
 8002ef0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  /* Threshold RXFIFO level set to 64 bytes (used when Cut-through mode is enabled) */
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;                             
 8002ef4:	687b      	ldr	r3, [r7, #4]
 8002ef6:	2200      	movs	r2, #0
 8002ef8:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  /* Disable Operate on second frame (transmit a second frame to FIFO without 
  waiting status of previous frame*/                           
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
 8002efc:	687b      	ldr	r3, [r7, #4]
 8002efe:	2200      	movs	r2, #0
 8002f00:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  /* DMA works on 32-bit aligned start source and destinations addresses */
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
 8002f04:	687b      	ldr	r3, [r7, #4]
 8002f06:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8002f0a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
 8002f0e:	687b      	ldr	r3, [r7, #4]
 8002f10:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8002f14:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 8002f18:	687b      	ldr	r3, [r7, #4]
 8002f1a:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8002f1e:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8002f28:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  /* DMA Ring mode skip length = 0 */
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
 8002f2c:	687b      	ldr	r3, [r7, #4]
 8002f2e:	2200      	movs	r2, #0
 8002f30:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
  /* Equal priority (round-robin) between transmit and receive DMA engines */
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
 8002f34:	687b      	ldr	r3, [r7, #4]
 8002f36:	2200      	movs	r2, #0
 8002f38:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
 8002f3c:	bf00      	nop
 8002f3e:	370c      	adds	r7, #12
 8002f40:	46bd      	mov	sp, r7
 8002f42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f46:	4770      	bx	lr

08002f48 <ETH_Init>:
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 8002f48:	b580      	push	{r7, lr}
 8002f4a:	b08c      	sub	sp, #48	; 0x30
 8002f4c:	af00      	add	r7, sp, #0
 8002f4e:	6078      	str	r0, [r7, #4]
 8002f50:	460b      	mov	r3, r1
 8002f52:	807b      	strh	r3, [r7, #2]
  uint32_t RegValue = 0, tmpreg = 0;
 8002f54:	2300      	movs	r3, #0
 8002f56:	62bb      	str	r3, [r7, #40]	; 0x28
 8002f58:	2300      	movs	r3, #0
 8002f5a:	62fb      	str	r3, [r7, #44]	; 0x2c
  __IO uint32_t i = 0;
 8002f5c:	2300      	movs	r3, #0
 8002f5e:	623b      	str	r3, [r7, #32]
  RCC_ClocksTypeDef  rcc_clocks;
  uint32_t hclk = 60000000;
 8002f60:	4b68      	ldr	r3, [pc, #416]	; (8003104 <ETH_Init+0x1bc>)
 8002f62:	627b      	str	r3, [r7, #36]	; 0x24
  __IO uint32_t timeout = 0;
 8002f64:	2300      	movs	r3, #0
 8002f66:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8002f68:	4b67      	ldr	r3, [pc, #412]	; (8003108 <ETH_Init+0x1c0>)
 8002f6a:	691b      	ldr	r3, [r3, #16]
 8002f6c:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
 8002f6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002f70:	f023 031c 	bic.w	r3, r3, #28
 8002f74:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8002f76:	f107 0310 	add.w	r3, r7, #16
 8002f7a:	4618      	mov	r0, r3
 8002f7c:	f001 fc22 	bl	80047c4 <RCC_GetClocksFreq>
  hclk = rcc_clocks.HCLK_Frequency;
 8002f80:	697b      	ldr	r3, [r7, #20]
 8002f82:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
 8002f84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002f86:	4a61      	ldr	r2, [pc, #388]	; (800310c <ETH_Init+0x1c4>)
 8002f88:	4293      	cmp	r3, r2
 8002f8a:	d908      	bls.n	8002f9e <ETH_Init+0x56>
 8002f8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002f8e:	4a60      	ldr	r2, [pc, #384]	; (8003110 <ETH_Init+0x1c8>)
 8002f90:	4293      	cmp	r3, r2
 8002f92:	d804      	bhi.n	8002f9e <ETH_Init+0x56>
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 8002f94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002f96:	f043 0308 	orr.w	r3, r3, #8
 8002f9a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002f9c:	e027      	b.n	8002fee <ETH_Init+0xa6>
  }
  else if((hclk >= 35000000)&&(hclk < 60000000))
 8002f9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002fa0:	4a5b      	ldr	r2, [pc, #364]	; (8003110 <ETH_Init+0x1c8>)
 8002fa2:	4293      	cmp	r3, r2
 8002fa4:	d908      	bls.n	8002fb8 <ETH_Init+0x70>
 8002fa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002fa8:	4a5a      	ldr	r2, [pc, #360]	; (8003114 <ETH_Init+0x1cc>)
 8002faa:	4293      	cmp	r3, r2
 8002fac:	d804      	bhi.n	8002fb8 <ETH_Init+0x70>
  {
    /* CSR Clock Range between 35-60 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
 8002fae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002fb0:	f043 030c 	orr.w	r3, r3, #12
 8002fb4:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002fb6:	e01a      	b.n	8002fee <ETH_Init+0xa6>
  }  
  else if((hclk >= 60000000)&&(hclk < 100000000))
 8002fb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002fba:	4a56      	ldr	r2, [pc, #344]	; (8003114 <ETH_Init+0x1cc>)
 8002fbc:	4293      	cmp	r3, r2
 8002fbe:	d903      	bls.n	8002fc8 <ETH_Init+0x80>
 8002fc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002fc2:	4a55      	ldr	r2, [pc, #340]	; (8003118 <ETH_Init+0x1d0>)
 8002fc4:	4293      	cmp	r3, r2
 8002fc6:	d911      	bls.n	8002fec <ETH_Init+0xa4>
  {
    /* CSR Clock Range between 60-100 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
  }  
  else if((hclk >= 100000000)&&(hclk < 150000000))
 8002fc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002fca:	4a53      	ldr	r2, [pc, #332]	; (8003118 <ETH_Init+0x1d0>)
 8002fcc:	4293      	cmp	r3, r2
 8002fce:	d908      	bls.n	8002fe2 <ETH_Init+0x9a>
 8002fd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002fd2:	4a52      	ldr	r2, [pc, #328]	; (800311c <ETH_Init+0x1d4>)
 8002fd4:	4293      	cmp	r3, r2
 8002fd6:	d804      	bhi.n	8002fe2 <ETH_Init+0x9a>
  {
    /* CSR Clock Range between 100-150 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
 8002fd8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002fda:	f043 0304 	orr.w	r3, r3, #4
 8002fde:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002fe0:	e005      	b.n	8002fee <ETH_Init+0xa6>
  }   
  else /* ((hclk >= 150000000)&&(hclk <= 168000000)) */
  {
    /* CSR Clock Range between 150-168 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
 8002fe2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002fe4:	f043 0310 	orr.w	r3, r3, #16
 8002fe8:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002fea:	e000      	b.n	8002fee <ETH_Init+0xa6>
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
 8002fec:	bf00      	nop
  }
  
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
 8002fee:	4a46      	ldr	r2, [pc, #280]	; (8003108 <ETH_Init+0x1c0>)
 8002ff0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002ff2:	6113      	str	r3, [r2, #16]
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
 8002ff4:	887b      	ldrh	r3, [r7, #2]
 8002ff6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002ffa:	2100      	movs	r1, #0
 8002ffc:	4618      	mov	r0, r3
 8002ffe:	f000 fcfb 	bl	80039f8 <ETH_WritePHYRegister>
 8003002:	4603      	mov	r3, r0
 8003004:	2b00      	cmp	r3, #0
 8003006:	d101      	bne.n	800300c <ETH_Init+0xc4>
  {
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
 8003008:	2300      	movs	r3, #0
 800300a:	e16d      	b.n	80032e8 <ETH_Init+0x3a0>
  }
  
  /* Delay to assure PHY reset */
  _eth_delay_(PHY_RESET_DELAY);
 800300c:	4844      	ldr	r0, [pc, #272]	; (8003120 <ETH_Init+0x1d8>)
 800300e:	f7ff fec9 	bl	8002da4 <ETH_Delay>
    
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
 8003012:	687b      	ldr	r3, [r7, #4]
 8003014:	681b      	ldr	r3, [r3, #0]
 8003016:	2b00      	cmp	r3, #0
 8003018:	d05f      	beq.n	80030da <ETH_Init+0x192>
  {  
    /* We wait for linked status... */
    do
    {
      timeout++;
 800301a:	68fb      	ldr	r3, [r7, #12]
 800301c:	3301      	adds	r3, #1
 800301e:	60fb      	str	r3, [r7, #12]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
 8003020:	887b      	ldrh	r3, [r7, #2]
 8003022:	2101      	movs	r1, #1
 8003024:	4618      	mov	r0, r3
 8003026:	f000 fc97 	bl	8003958 <ETH_ReadPHYRegister>
 800302a:	4603      	mov	r3, r0
 800302c:	f003 0304 	and.w	r3, r3, #4
 8003030:	2b00      	cmp	r3, #0
 8003032:	d103      	bne.n	800303c <ETH_Init+0xf4>
 8003034:	68fb      	ldr	r3, [r7, #12]
 8003036:	4a3b      	ldr	r2, [pc, #236]	; (8003124 <ETH_Init+0x1dc>)
 8003038:	4293      	cmp	r3, r2
 800303a:	d9ee      	bls.n	800301a <ETH_Init+0xd2>

    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 800303c:	68fb      	ldr	r3, [r7, #12]
 800303e:	4a3a      	ldr	r2, [pc, #232]	; (8003128 <ETH_Init+0x1e0>)
 8003040:	4293      	cmp	r3, r2
 8003042:	d101      	bne.n	8003048 <ETH_Init+0x100>
    {
      return ETH_ERROR;
 8003044:	2300      	movs	r3, #0
 8003046:	e14f      	b.n	80032e8 <ETH_Init+0x3a0>
    }

    /* Reset Timeout counter */
    timeout = 0; 
 8003048:	2300      	movs	r3, #0
 800304a:	60fb      	str	r3, [r7, #12]
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
 800304c:	887b      	ldrh	r3, [r7, #2]
 800304e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003052:	2100      	movs	r1, #0
 8003054:	4618      	mov	r0, r3
 8003056:	f000 fccf 	bl	80039f8 <ETH_WritePHYRegister>
 800305a:	4603      	mov	r3, r0
 800305c:	2b00      	cmp	r3, #0
 800305e:	d101      	bne.n	8003064 <ETH_Init+0x11c>
    {
      /* Return ERROR in case of write timeout */
      return ETH_ERROR;
 8003060:	2300      	movs	r3, #0
 8003062:	e141      	b.n	80032e8 <ETH_Init+0x3a0>
    }

    /* Wait until the auto-negotiation will be completed */
    do
    {
      timeout++;
 8003064:	68fb      	ldr	r3, [r7, #12]
 8003066:	3301      	adds	r3, #1
 8003068:	60fb      	str	r3, [r7, #12]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
 800306a:	887b      	ldrh	r3, [r7, #2]
 800306c:	2101      	movs	r1, #1
 800306e:	4618      	mov	r0, r3
 8003070:	f000 fc72 	bl	8003958 <ETH_ReadPHYRegister>
 8003074:	4603      	mov	r3, r0
 8003076:	f003 0320 	and.w	r3, r3, #32
 800307a:	2b00      	cmp	r3, #0
 800307c:	d103      	bne.n	8003086 <ETH_Init+0x13e>
 800307e:	68fb      	ldr	r3, [r7, #12]
 8003080:	4a28      	ldr	r2, [pc, #160]	; (8003124 <ETH_Init+0x1dc>)
 8003082:	4293      	cmp	r3, r2
 8003084:	d9ee      	bls.n	8003064 <ETH_Init+0x11c>

    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 8003086:	68fb      	ldr	r3, [r7, #12]
 8003088:	4a27      	ldr	r2, [pc, #156]	; (8003128 <ETH_Init+0x1e0>)
 800308a:	4293      	cmp	r3, r2
 800308c:	d101      	bne.n	8003092 <ETH_Init+0x14a>
    {
      return ETH_ERROR;
 800308e:	2300      	movs	r3, #0
 8003090:	e12a      	b.n	80032e8 <ETH_Init+0x3a0>
    }

    /* Reset Timeout counter */
    timeout = 0;
 8003092:	2300      	movs	r3, #0
 8003094:	60fb      	str	r3, [r7, #12]
    
    /* Read the result of the auto-negotiation */
    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
 8003096:	887b      	ldrh	r3, [r7, #2]
 8003098:	2110      	movs	r1, #16
 800309a:	4618      	mov	r0, r3
 800309c:	f000 fc5c 	bl	8003958 <ETH_ReadPHYRegister>
 80030a0:	4603      	mov	r3, r0
 80030a2:	62bb      	str	r3, [r7, #40]	; 0x28
  
    /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
    if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
 80030a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80030a6:	f003 0304 	and.w	r3, r3, #4
 80030aa:	2b00      	cmp	r3, #0
 80030ac:	d004      	beq.n	80030b8 <ETH_Init+0x170>
    {
      /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
 80030ae:	687b      	ldr	r3, [r7, #4]
 80030b0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80030b4:	621a      	str	r2, [r3, #32]
 80030b6:	e002      	b.n	80030be <ETH_Init+0x176>
    }
    else
    {
      /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
 80030b8:	687b      	ldr	r3, [r7, #4]
 80030ba:	2200      	movs	r2, #0
 80030bc:	621a      	str	r2, [r3, #32]
    }

    /* Configure the MAC with the speed fixed by the auto-negotiation process */
    if(RegValue & PHY_SPEED_STATUS)
 80030be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80030c0:	f003 0302 	and.w	r3, r3, #2
 80030c4:	2b00      	cmp	r3, #0
 80030c6:	d003      	beq.n	80030d0 <ETH_Init+0x188>
    {  
      /* Set Ethernet speed to 10M following the auto-negotiation */    
      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
 80030c8:	687b      	ldr	r3, [r7, #4]
 80030ca:	2200      	movs	r2, #0
 80030cc:	615a      	str	r2, [r3, #20]
 80030ce:	e031      	b.n	8003134 <ETH_Init+0x1ec>
    }
    else
    {   
      /* Set Ethernet speed to 100M following the auto-negotiation */ 
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
 80030d0:	687b      	ldr	r3, [r7, #4]
 80030d2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80030d6:	615a      	str	r2, [r3, #20]
 80030d8:	e02c      	b.n	8003134 <ETH_Init+0x1ec>
    }    
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
 80030da:	687b      	ldr	r3, [r7, #4]
 80030dc:	6a1b      	ldr	r3, [r3, #32]
 80030de:	08db      	lsrs	r3, r3, #3
 80030e0:	b29a      	uxth	r2, r3
                                                   (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
 80030e2:	687b      	ldr	r3, [r7, #4]
 80030e4:	695b      	ldr	r3, [r3, #20]
 80030e6:	085b      	lsrs	r3, r3, #1
 80030e8:	b29b      	uxth	r3, r3
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
 80030ea:	4313      	orrs	r3, r2
 80030ec:	b29a      	uxth	r2, r3
 80030ee:	887b      	ldrh	r3, [r7, #2]
 80030f0:	2100      	movs	r1, #0
 80030f2:	4618      	mov	r0, r3
 80030f4:	f000 fc80 	bl	80039f8 <ETH_WritePHYRegister>
 80030f8:	4603      	mov	r3, r0
 80030fa:	2b00      	cmp	r3, #0
 80030fc:	d116      	bne.n	800312c <ETH_Init+0x1e4>
    {
      /* Return ERROR in case of write timeout */
      return ETH_ERROR;
 80030fe:	2300      	movs	r3, #0
 8003100:	e0f2      	b.n	80032e8 <ETH_Init+0x3a0>
 8003102:	bf00      	nop
 8003104:	03938700 	.word	0x03938700
 8003108:	40028000 	.word	0x40028000
 800310c:	01312cff 	.word	0x01312cff
 8003110:	02160ebf 	.word	0x02160ebf
 8003114:	039386ff 	.word	0x039386ff
 8003118:	05f5e0ff 	.word	0x05f5e0ff
 800311c:	08f0d17f 	.word	0x08f0d17f
 8003120:	000fffff 	.word	0x000fffff
 8003124:	0004fffe 	.word	0x0004fffe
 8003128:	0004ffff 	.word	0x0004ffff
    }
    /* Delay to assure PHY configuration */
    _eth_delay_(PHY_CONFIG_DELAY);
 800312c:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8003130:	f7ff fe38 	bl	8002da4 <ETH_Delay>
    
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
 8003134:	4b6e      	ldr	r3, [pc, #440]	; (80032f0 <ETH_Init+0x3a8>)
 8003136:	681b      	ldr	r3, [r3, #0]
 8003138:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear WD, PCE, PS, TE and RE bits */
  tmpreg &= MACCR_CLEAR_MASK;
 800313a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800313c:	4b6d      	ldr	r3, [pc, #436]	; (80032f4 <ETH_Init+0x3ac>)
 800313e:	4013      	ands	r3, r2
 8003140:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Set the IPCO bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 8003142:	687b      	ldr	r3, [r7, #4]
 8003144:	685a      	ldr	r2, [r3, #4]
                  ETH_InitStruct->ETH_Jabber | 
 8003146:	687b      	ldr	r3, [r7, #4]
 8003148:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 800314a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_InterFrameGap |
 800314c:	687b      	ldr	r3, [r7, #4]
 800314e:	68db      	ldr	r3, [r3, #12]
                  ETH_InitStruct->ETH_Jabber | 
 8003150:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_CarrierSense |
 8003152:	687b      	ldr	r3, [r7, #4]
 8003154:	691b      	ldr	r3, [r3, #16]
                  ETH_InitStruct->ETH_InterFrameGap |
 8003156:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_Speed | 
 8003158:	687b      	ldr	r3, [r7, #4]
 800315a:	695b      	ldr	r3, [r3, #20]
                  ETH_InitStruct->ETH_CarrierSense |
 800315c:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ReceiveOwn |
 800315e:	687b      	ldr	r3, [r7, #4]
 8003160:	699b      	ldr	r3, [r3, #24]
                  ETH_InitStruct->ETH_Speed | 
 8003162:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_LoopbackMode |
 8003164:	687b      	ldr	r3, [r7, #4]
 8003166:	69db      	ldr	r3, [r3, #28]
                  ETH_InitStruct->ETH_ReceiveOwn |
 8003168:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_Mode | 
 800316a:	687b      	ldr	r3, [r7, #4]
 800316c:	6a1b      	ldr	r3, [r3, #32]
                  ETH_InitStruct->ETH_LoopbackMode |
 800316e:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ChecksumOffload |    
 8003170:	687b      	ldr	r3, [r7, #4]
 8003172:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                  ETH_InitStruct->ETH_Mode | 
 8003174:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_RetryTransmission | 
 8003176:	687b      	ldr	r3, [r7, #4]
 8003178:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                  ETH_InitStruct->ETH_ChecksumOffload |    
 800317a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
 800317c:	687b      	ldr	r3, [r7, #4]
 800317e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                  ETH_InitStruct->ETH_RetryTransmission | 
 8003180:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_BackOffLimit | 
 8003182:	687b      	ldr	r3, [r7, #4]
 8003184:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
 8003186:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_DeferralCheck);
 8003188:	687b      	ldr	r3, [r7, #4]
 800318a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
                  ETH_InitStruct->ETH_BackOffLimit | 
 800318c:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 800318e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003190:	4313      	orrs	r3, r2
 8003192:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Write to ETHERNET MACCR */
  ETH->MACCR = (uint32_t)tmpreg;
 8003194:	4a56      	ldr	r2, [pc, #344]	; (80032f0 <ETH_Init+0x3a8>)
 8003196:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003198:	6013      	str	r3, [r2, #0]
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 800319a:	4955      	ldr	r1, [pc, #340]	; (80032f0 <ETH_Init+0x3a8>)
 800319c:	687b      	ldr	r3, [r7, #4]
 800319e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
                          ETH_InitStruct->ETH_SourceAddrFilter |
 80031a0:	687b      	ldr	r3, [r7, #4]
 80031a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 80031a4:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_PassControlFrames |
 80031a6:	687b      	ldr	r3, [r7, #4]
 80031a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
                          ETH_InitStruct->ETH_SourceAddrFilter |
 80031aa:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
 80031ac:	687b      	ldr	r3, [r7, #4]
 80031ae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
                          ETH_InitStruct->ETH_PassControlFrames |
 80031b0:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_DestinationAddrFilter |
 80031b2:	687b      	ldr	r3, [r7, #4]
 80031b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
 80031b6:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_PromiscuousMode |
 80031b8:	687b      	ldr	r3, [r7, #4]
 80031ba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
                          ETH_InitStruct->ETH_DestinationAddrFilter |
 80031bc:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_MulticastFramesFilter |
 80031be:	687b      	ldr	r3, [r7, #4]
 80031c0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
                          ETH_InitStruct->ETH_PromiscuousMode |
 80031c2:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_UnicastFramesFilter); 
 80031c4:	687b      	ldr	r3, [r7, #4]
 80031c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
                          ETH_InitStruct->ETH_MulticastFramesFilter |
 80031c8:	4313      	orrs	r3, r2
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 80031ca:	604b      	str	r3, [r1, #4]
  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
  /* Write to ETHERNET MACHTHR */
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
 80031cc:	4a48      	ldr	r2, [pc, #288]	; (80032f0 <ETH_Init+0x3a8>)
 80031ce:	687b      	ldr	r3, [r7, #4]
 80031d0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80031d2:	6093      	str	r3, [r2, #8]
  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
 80031d4:	4a46      	ldr	r2, [pc, #280]	; (80032f0 <ETH_Init+0x3a8>)
 80031d6:	687b      	ldr	r3, [r7, #4]
 80031d8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80031da:	60d3      	str	r3, [r2, #12]
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
 80031dc:	4b44      	ldr	r3, [pc, #272]	; (80032f0 <ETH_Init+0x3a8>)
 80031de:	699b      	ldr	r3, [r3, #24]
 80031e0:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear xx bits */
  tmpreg &= MACFCR_CLEAR_MASK;
 80031e2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80031e4:	f64f 7341 	movw	r3, #65345	; 0xff41
 80031e8:	4013      	ands	r3, r2
 80031ea:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 80031ec:	687b      	ldr	r3, [r7, #4]
 80031ee:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80031f0:	041a      	lsls	r2, r3, #16
                   ETH_InitStruct->ETH_ZeroQuantaPause |
 80031f2:	687b      	ldr	r3, [r7, #4]
 80031f4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 80031f6:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_PauseLowThreshold |
 80031f8:	687b      	ldr	r3, [r7, #4]
 80031fa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
                   ETH_InitStruct->ETH_ZeroQuantaPause |
 80031fc:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
 80031fe:	687b      	ldr	r3, [r7, #4]
 8003200:	6edb      	ldr	r3, [r3, #108]	; 0x6c
                   ETH_InitStruct->ETH_PauseLowThreshold |
 8003202:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_ReceiveFlowControl |
 8003204:	687b      	ldr	r3, [r7, #4]
 8003206:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
 8003208:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_TransmitFlowControl); 
 800320a:	687b      	ldr	r3, [r7, #4]
 800320c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                   ETH_InitStruct->ETH_ReceiveFlowControl |
 800320e:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 8003210:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003212:	4313      	orrs	r3, r2
 8003214:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
 8003216:	4a36      	ldr	r2, [pc, #216]	; (80032f0 <ETH_Init+0x3a8>)
 8003218:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800321a:	6193      	str	r3, [r2, #24]
  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
 800321c:	4934      	ldr	r1, [pc, #208]	; (80032f0 <ETH_Init+0x3a8>)
 800321e:	687b      	ldr	r3, [r7, #4]
 8003220:	6f9a      	ldr	r2, [r3, #120]	; 0x78
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
 8003222:	687b      	ldr	r3, [r7, #4]
 8003224:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
 8003226:	4313      	orrs	r3, r2
 8003228:	61cb      	str	r3, [r1, #28]
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
 800322a:	4b31      	ldr	r3, [pc, #196]	; (80032f0 <ETH_Init+0x3a8>)
 800322c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8003230:	3318      	adds	r3, #24
 8003232:	681b      	ldr	r3, [r3, #0]
 8003234:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 8003236:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003238:	4b2f      	ldr	r3, [pc, #188]	; (80032f8 <ETH_Init+0x3b0>)
 800323a:	4013      	ands	r3, r2
 800323c:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 800323e:	687b      	ldr	r3, [r7, #4]
 8003240:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
                  ETH_InitStruct->ETH_ReceiveStoreForward |
 8003244:	687b      	ldr	r3, [r7, #4]
 8003246:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 800324a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_FlushReceivedFrame |
 800324c:	687b      	ldr	r3, [r7, #4]
 800324e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
                  ETH_InitStruct->ETH_ReceiveStoreForward |
 8003252:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_TransmitStoreForward | 
 8003254:	687b      	ldr	r3, [r7, #4]
 8003256:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
                  ETH_InitStruct->ETH_FlushReceivedFrame |
 800325a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_TransmitThresholdControl |
 800325c:	687b      	ldr	r3, [r7, #4]
 800325e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
                  ETH_InitStruct->ETH_TransmitStoreForward | 
 8003262:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ForwardErrorFrames |
 8003264:	687b      	ldr	r3, [r7, #4]
 8003266:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
                  ETH_InitStruct->ETH_TransmitThresholdControl |
 800326a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
 800326c:	687b      	ldr	r3, [r7, #4]
 800326e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
                  ETH_InitStruct->ETH_ForwardErrorFrames |
 8003272:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
 8003274:	687b      	ldr	r3, [r7, #4]
 8003276:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
 800327a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_SecondFrameOperate); 
 800327c:	687b      	ldr	r3, [r7, #4]
 800327e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
 8003282:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8003284:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003286:	4313      	orrs	r3, r2
 8003288:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Write to ETHERNET DMAOMR */
  ETH->DMAOMR = (uint32_t)tmpreg;
 800328a:	4b19      	ldr	r3, [pc, #100]	; (80032f0 <ETH_Init+0x3a8>)
 800328c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8003290:	3318      	adds	r3, #24
 8003292:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003294:	601a      	str	r2, [r3, #0]
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 8003296:	4916      	ldr	r1, [pc, #88]	; (80032f0 <ETH_Init+0x3a8>)
 8003298:	687b      	ldr	r3, [r7, #4]
 800329a:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
                          ETH_InitStruct->ETH_FixedBurst |
 800329e:	687b      	ldr	r3, [r7, #4]
 80032a0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 80032a4:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
 80032a6:	687b      	ldr	r3, [r7, #4]
 80032a8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
                          ETH_InitStruct->ETH_FixedBurst |
 80032ac:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_TxDMABurstLength | 
 80032ae:	687b      	ldr	r3, [r7, #4]
 80032b0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
 80032b4:	431a      	orrs	r2, r3
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
 80032b6:	687b      	ldr	r3, [r7, #4]
 80032b8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80032bc:	009b      	lsls	r3, r3, #2
                          ETH_InitStruct->ETH_TxDMABurstLength | 
 80032be:	431a      	orrs	r2, r3
                          ETH_InitStruct->ETH_DMAArbitration |
 80032c0:	687b      	ldr	r3, [r7, #4]
 80032c2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
 80032c6:	4313      	orrs	r3, r2
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 80032c8:	f443 0200 	orr.w	r2, r3, #8388608	; 0x800000
 80032cc:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 80032d0:	601a      	str	r2, [r3, #0]
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
                          
  #ifdef USE_ENHANCED_DMA_DESCRIPTORS
    /* Enable the Enhanced DMA descriptors */
    ETH->DMABMR |= ETH_DMABMR_EDE;
 80032d2:	4907      	ldr	r1, [pc, #28]	; (80032f0 <ETH_Init+0x3a8>)
 80032d4:	4b06      	ldr	r3, [pc, #24]	; (80032f0 <ETH_Init+0x3a8>)
 80032d6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80032da:	681b      	ldr	r3, [r3, #0]
 80032dc:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80032e0:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 80032e4:	601a      	str	r2, [r3, #0]
  #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                              
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
 80032e6:	2301      	movs	r3, #1
}
 80032e8:	4618      	mov	r0, r3
 80032ea:	3730      	adds	r7, #48	; 0x30
 80032ec:	46bd      	mov	sp, r7
 80032ee:	bd80      	pop	{r7, pc}
 80032f0:	40028000 	.word	0x40028000
 80032f4:	ff20810f 	.word	0xff20810f
 80032f8:	f8de3f23 	.word	0xf8de3f23

080032fc <ETH_Start>:
  * @brief  Enables ENET MAC and DMA reception/transmission 
  * @param  None
  * @retval None
  */
void ETH_Start(void)
{
 80032fc:	b580      	push	{r7, lr}
 80032fe:	af00      	add	r7, sp, #0
  /* Enable transmit state machine of the MAC for transmission on the MII */  
  ETH_MACTransmissionCmd(ENABLE);
 8003300:	2001      	movs	r0, #1
 8003302:	f000 f80d 	bl	8003320 <ETH_MACTransmissionCmd>
  /* Flush Transmit FIFO */
  ETH_FlushTransmitFIFO();
 8003306:	f000 fabd 	bl	8003884 <ETH_FlushTransmitFIFO>
  /* Enable receive state machine of the MAC for reception from the MII */  
  ETH_MACReceptionCmd(ENABLE);
 800330a:	2001      	movs	r0, #1
 800330c:	f000 f826 	bl	800335c <ETH_MACReceptionCmd>
 
  /* Start DMA transmission */
  ETH_DMATransmissionCmd(ENABLE); 
 8003310:	2001      	movs	r0, #1
 8003312:	f000 facd 	bl	80038b0 <ETH_DMATransmissionCmd>
  /* Start DMA reception */
  ETH_DMAReceptionCmd(ENABLE);   
 8003316:	2001      	movs	r0, #1
 8003318:	f000 faf4 	bl	8003904 <ETH_DMAReceptionCmd>
}
 800331c:	bf00      	nop
 800331e:	bd80      	pop	{r7, pc}

08003320 <ETH_MACTransmissionCmd>:
  * @param  NewState: new state of the MAC transmission.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACTransmissionCmd(FunctionalState NewState)
{ 
 8003320:	b480      	push	{r7}
 8003322:	b083      	sub	sp, #12
 8003324:	af00      	add	r7, sp, #0
 8003326:	4603      	mov	r3, r0
 8003328:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800332a:	79fb      	ldrb	r3, [r7, #7]
 800332c:	2b00      	cmp	r3, #0
 800332e:	d006      	beq.n	800333e <ETH_MACTransmissionCmd+0x1e>
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;  
 8003330:	4a09      	ldr	r2, [pc, #36]	; (8003358 <ETH_MACTransmissionCmd+0x38>)
 8003332:	4b09      	ldr	r3, [pc, #36]	; (8003358 <ETH_MACTransmissionCmd+0x38>)
 8003334:	681b      	ldr	r3, [r3, #0]
 8003336:	f043 0308 	orr.w	r3, r3, #8
 800333a:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the MAC transmission */
    ETH->MACCR &= ~ETH_MACCR_TE;
  }
}
 800333c:	e005      	b.n	800334a <ETH_MACTransmissionCmd+0x2a>
    ETH->MACCR &= ~ETH_MACCR_TE;
 800333e:	4a06      	ldr	r2, [pc, #24]	; (8003358 <ETH_MACTransmissionCmd+0x38>)
 8003340:	4b05      	ldr	r3, [pc, #20]	; (8003358 <ETH_MACTransmissionCmd+0x38>)
 8003342:	681b      	ldr	r3, [r3, #0]
 8003344:	f023 0308 	bic.w	r3, r3, #8
 8003348:	6013      	str	r3, [r2, #0]
}
 800334a:	bf00      	nop
 800334c:	370c      	adds	r7, #12
 800334e:	46bd      	mov	sp, r7
 8003350:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003354:	4770      	bx	lr
 8003356:	bf00      	nop
 8003358:	40028000 	.word	0x40028000

0800335c <ETH_MACReceptionCmd>:
  * @param  NewState: new state of the MAC reception.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACReceptionCmd(FunctionalState NewState)
{ 
 800335c:	b480      	push	{r7}
 800335e:	b083      	sub	sp, #12
 8003360:	af00      	add	r7, sp, #0
 8003362:	4603      	mov	r3, r0
 8003364:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003366:	79fb      	ldrb	r3, [r7, #7]
 8003368:	2b00      	cmp	r3, #0
 800336a:	d006      	beq.n	800337a <ETH_MACReceptionCmd+0x1e>
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;  
 800336c:	4a09      	ldr	r2, [pc, #36]	; (8003394 <ETH_MACReceptionCmd+0x38>)
 800336e:	4b09      	ldr	r3, [pc, #36]	; (8003394 <ETH_MACReceptionCmd+0x38>)
 8003370:	681b      	ldr	r3, [r3, #0]
 8003372:	f043 0304 	orr.w	r3, r3, #4
 8003376:	6013      	str	r3, [r2, #0]
  else
  {
    /* Disable the MAC reception */
    ETH->MACCR &= ~ETH_MACCR_RE;
  }
}
 8003378:	e005      	b.n	8003386 <ETH_MACReceptionCmd+0x2a>
    ETH->MACCR &= ~ETH_MACCR_RE;
 800337a:	4a06      	ldr	r2, [pc, #24]	; (8003394 <ETH_MACReceptionCmd+0x38>)
 800337c:	4b05      	ldr	r3, [pc, #20]	; (8003394 <ETH_MACReceptionCmd+0x38>)
 800337e:	681b      	ldr	r3, [r3, #0]
 8003380:	f023 0304 	bic.w	r3, r3, #4
 8003384:	6013      	str	r3, [r2, #0]
}
 8003386:	bf00      	nop
 8003388:	370c      	adds	r7, #12
 800338a:	46bd      	mov	sp, r7
 800338c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003390:	4770      	bx	lr
 8003392:	bf00      	nop
 8003394:	40028000 	.word	0x40028000

08003398 <ETH_MACAddressConfig>:
  *     @arg ETH_MAC_Address3 : MAC Address3
  * @param  Addr: Pointer on MAC address buffer data (6 bytes).
  * @retval None
  */
void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
{
 8003398:	b480      	push	{r7}
 800339a:	b085      	sub	sp, #20
 800339c:	af00      	add	r7, sp, #0
 800339e:	6078      	str	r0, [r7, #4]
 80033a0:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
 80033a2:	683b      	ldr	r3, [r7, #0]
 80033a4:	3305      	adds	r3, #5
 80033a6:	781b      	ldrb	r3, [r3, #0]
 80033a8:	021b      	lsls	r3, r3, #8
 80033aa:	683a      	ldr	r2, [r7, #0]
 80033ac:	3204      	adds	r2, #4
 80033ae:	7812      	ldrb	r2, [r2, #0]
 80033b0:	4313      	orrs	r3, r2
 80033b2:	60fb      	str	r3, [r7, #12]
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
 80033b4:	687a      	ldr	r2, [r7, #4]
 80033b6:	4b11      	ldr	r3, [pc, #68]	; (80033fc <ETH_MACAddressConfig+0x64>)
 80033b8:	4413      	add	r3, r2
 80033ba:	461a      	mov	r2, r3
 80033bc:	68fb      	ldr	r3, [r7, #12]
 80033be:	6013      	str	r3, [r2, #0]
  /* Calculate the selected MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
 80033c0:	683b      	ldr	r3, [r7, #0]
 80033c2:	3303      	adds	r3, #3
 80033c4:	781b      	ldrb	r3, [r3, #0]
 80033c6:	061a      	lsls	r2, r3, #24
 80033c8:	683b      	ldr	r3, [r7, #0]
 80033ca:	3302      	adds	r3, #2
 80033cc:	781b      	ldrb	r3, [r3, #0]
 80033ce:	041b      	lsls	r3, r3, #16
 80033d0:	431a      	orrs	r2, r3
 80033d2:	683b      	ldr	r3, [r7, #0]
 80033d4:	3301      	adds	r3, #1
 80033d6:	781b      	ldrb	r3, [r3, #0]
 80033d8:	021b      	lsls	r3, r3, #8
 80033da:	4313      	orrs	r3, r2
 80033dc:	683a      	ldr	r2, [r7, #0]
 80033de:	7812      	ldrb	r2, [r2, #0]
 80033e0:	4313      	orrs	r3, r2
 80033e2:	60fb      	str	r3, [r7, #12]
 
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
 80033e4:	687a      	ldr	r2, [r7, #4]
 80033e6:	4b06      	ldr	r3, [pc, #24]	; (8003400 <ETH_MACAddressConfig+0x68>)
 80033e8:	4413      	add	r3, r2
 80033ea:	461a      	mov	r2, r3
 80033ec:	68fb      	ldr	r3, [r7, #12]
 80033ee:	6013      	str	r3, [r2, #0]
}
 80033f0:	bf00      	nop
 80033f2:	3714      	adds	r7, #20
 80033f4:	46bd      	mov	sp, r7
 80033f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033fa:	4770      	bx	lr
 80033fc:	40028040 	.word	0x40028040
 8003400:	40028044 	.word	0x40028044

08003404 <ETH_Get_Received_Frame>:
  * with polling method only).
  * @param  none
  * @retval Structure of type FrameTypeDef
  */
FrameTypeDef ETH_Get_Received_Frame(void)
{ 
 8003404:	b490      	push	{r4, r7}
 8003406:	b086      	sub	sp, #24
 8003408:	af00      	add	r7, sp, #0
 800340a:	6078      	str	r0, [r7, #4]
  uint32_t framelength = 0;
 800340c:	2300      	movs	r3, #0
 800340e:	617b      	str	r3, [r7, #20]
  FrameTypeDef frame = {0,0,0}; 
 8003410:	2300      	movs	r3, #0
 8003412:	60bb      	str	r3, [r7, #8]
 8003414:	2300      	movs	r3, #0
 8003416:	60fb      	str	r3, [r7, #12]
 8003418:	2300      	movs	r3, #0
 800341a:	613b      	str	r3, [r7, #16]
  
  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 800341c:	4b17      	ldr	r3, [pc, #92]	; (800347c <ETH_Get_Received_Frame+0x78>)
 800341e:	681b      	ldr	r3, [r3, #0]
 8003420:	681b      	ldr	r3, [r3, #0]
 8003422:	0c1b      	lsrs	r3, r3, #16
 8003424:	f3c3 030d 	ubfx	r3, r3, #0, #14
 8003428:	3b04      	subs	r3, #4
 800342a:	617b      	str	r3, [r7, #20]
  frame.length = framelength;
 800342c:	697b      	ldr	r3, [r7, #20]
 800342e:	60bb      	str	r3, [r7, #8]
  
  /* Get the address of the buffer start address */ 
  /* Check if more than one segment in the frame */
  if (DMA_RX_FRAME_infos->Seg_Count >1)
 8003430:	4b13      	ldr	r3, [pc, #76]	; (8003480 <ETH_Get_Received_Frame+0x7c>)
 8003432:	681b      	ldr	r3, [r3, #0]
 8003434:	689b      	ldr	r3, [r3, #8]
 8003436:	2b01      	cmp	r3, #1
 8003438:	d905      	bls.n	8003446 <ETH_Get_Received_Frame+0x42>
  {
    frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
 800343a:	4b11      	ldr	r3, [pc, #68]	; (8003480 <ETH_Get_Received_Frame+0x7c>)
 800343c:	681b      	ldr	r3, [r3, #0]
 800343e:	681b      	ldr	r3, [r3, #0]
 8003440:	689b      	ldr	r3, [r3, #8]
 8003442:	60fb      	str	r3, [r7, #12]
 8003444:	e003      	b.n	800344e <ETH_Get_Received_Frame+0x4a>
  }
  else 
  {
    frame.buffer = DMARxDescToGet->Buffer1Addr;
 8003446:	4b0d      	ldr	r3, [pc, #52]	; (800347c <ETH_Get_Received_Frame+0x78>)
 8003448:	681b      	ldr	r3, [r3, #0]
 800344a:	689b      	ldr	r3, [r3, #8]
 800344c:	60fb      	str	r3, [r7, #12]
  }

  frame.descriptor = DMARxDescToGet;
 800344e:	4b0b      	ldr	r3, [pc, #44]	; (800347c <ETH_Get_Received_Frame+0x78>)
 8003450:	681b      	ldr	r3, [r3, #0]
 8003452:	613b      	str	r3, [r7, #16]
  
  /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
  /* Chained Mode */    
  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
 8003454:	4b09      	ldr	r3, [pc, #36]	; (800347c <ETH_Get_Received_Frame+0x78>)
 8003456:	681b      	ldr	r3, [r3, #0]
 8003458:	68db      	ldr	r3, [r3, #12]
 800345a:	461a      	mov	r2, r3
 800345c:	4b07      	ldr	r3, [pc, #28]	; (800347c <ETH_Get_Received_Frame+0x78>)
 800345e:	601a      	str	r2, [r3, #0]
  
  /* Return Frame */
  return (frame);  
 8003460:	687b      	ldr	r3, [r7, #4]
 8003462:	461c      	mov	r4, r3
 8003464:	f107 0308 	add.w	r3, r7, #8
 8003468:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800346c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8003470:	6878      	ldr	r0, [r7, #4]
 8003472:	3718      	adds	r7, #24
 8003474:	46bd      	mov	sp, r7
 8003476:	bc90      	pop	{r4, r7}
 8003478:	4770      	bx	lr
 800347a:	bf00      	nop
 800347c:	20007d90 	.word	0x20007d90
 8003480:	200095ac 	.word	0x200095ac

08003484 <ETH_Prepare_Transmit_Descriptors>:
  * @brief  Prepares DMA Tx descriptors to transmit an ethernet frame
  * @param  FrameLength : length of the frame to send
  * @retval error status
  */
uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
{   
 8003484:	b480      	push	{r7}
 8003486:	b087      	sub	sp, #28
 8003488:	af00      	add	r7, sp, #0
 800348a:	4603      	mov	r3, r0
 800348c:	80fb      	strh	r3, [r7, #6]
  uint32_t buf_count =0, size=0,i=0;
 800348e:	2300      	movs	r3, #0
 8003490:	617b      	str	r3, [r7, #20]
 8003492:	2300      	movs	r3, #0
 8003494:	60bb      	str	r3, [r7, #8]
 8003496:	2300      	movs	r3, #0
 8003498:	613b      	str	r3, [r7, #16]
  __IO ETH_DMADESCTypeDef *DMATxNextDesc;
  
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 800349a:	4b51      	ldr	r3, [pc, #324]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 800349c:	681b      	ldr	r3, [r3, #0]
 800349e:	681b      	ldr	r3, [r3, #0]
 80034a0:	2b00      	cmp	r3, #0
 80034a2:	da01      	bge.n	80034a8 <ETH_Prepare_Transmit_Descriptors+0x24>
  {  
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
 80034a4:	2300      	movs	r3, #0
 80034a6:	e095      	b.n	80035d4 <ETH_Prepare_Transmit_Descriptors+0x150>
  }
  
  DMATxNextDesc = DMATxDescToSet;
 80034a8:	4b4d      	ldr	r3, [pc, #308]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 80034aa:	681b      	ldr	r3, [r3, #0]
 80034ac:	60fb      	str	r3, [r7, #12]
  
  if (FrameLength > ETH_TX_BUF_SIZE)
 80034ae:	88fb      	ldrh	r3, [r7, #6]
 80034b0:	f240 52f4 	movw	r2, #1524	; 0x5f4
 80034b4:	4293      	cmp	r3, r2
 80034b6:	d917      	bls.n	80034e8 <ETH_Prepare_Transmit_Descriptors+0x64>
  {
    buf_count = FrameLength/ETH_TX_BUF_SIZE;
 80034b8:	88fb      	ldrh	r3, [r7, #6]
 80034ba:	4a4a      	ldr	r2, [pc, #296]	; (80035e4 <ETH_Prepare_Transmit_Descriptors+0x160>)
 80034bc:	fba2 2303 	umull	r2, r3, r2, r3
 80034c0:	0a9b      	lsrs	r3, r3, #10
 80034c2:	b29b      	uxth	r3, r3
 80034c4:	617b      	str	r3, [r7, #20]
    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
 80034c6:	88fb      	ldrh	r3, [r7, #6]
 80034c8:	4a46      	ldr	r2, [pc, #280]	; (80035e4 <ETH_Prepare_Transmit_Descriptors+0x160>)
 80034ca:	fba2 1203 	umull	r1, r2, r2, r3
 80034ce:	0a92      	lsrs	r2, r2, #10
 80034d0:	f240 51f4 	movw	r1, #1524	; 0x5f4
 80034d4:	fb01 f202 	mul.w	r2, r1, r2
 80034d8:	1a9b      	subs	r3, r3, r2
 80034da:	b29b      	uxth	r3, r3
 80034dc:	2b00      	cmp	r3, #0
 80034de:	d005      	beq.n	80034ec <ETH_Prepare_Transmit_Descriptors+0x68>
 80034e0:	697b      	ldr	r3, [r7, #20]
 80034e2:	3301      	adds	r3, #1
 80034e4:	617b      	str	r3, [r7, #20]
 80034e6:	e001      	b.n	80034ec <ETH_Prepare_Transmit_Descriptors+0x68>
  }
  else buf_count =1;
 80034e8:	2301      	movs	r3, #1
 80034ea:	617b      	str	r3, [r7, #20]
  
  if (buf_count ==1)
 80034ec:	697b      	ldr	r3, [r7, #20]
 80034ee:	2b01      	cmp	r3, #1
 80034f0:	d11c      	bne.n	800352c <ETH_Prepare_Transmit_Descriptors+0xa8>
  {
    /*set LAST and FIRST segment */
    DMATxDescToSet->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
 80034f2:	4b3b      	ldr	r3, [pc, #236]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 80034f4:	681b      	ldr	r3, [r3, #0]
 80034f6:	4a3a      	ldr	r2, [pc, #232]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 80034f8:	6812      	ldr	r2, [r2, #0]
 80034fa:	6812      	ldr	r2, [r2, #0]
 80034fc:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8003500:	601a      	str	r2, [r3, #0]
    /* Set frame size */
    DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
 8003502:	4b37      	ldr	r3, [pc, #220]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 8003504:	681b      	ldr	r3, [r3, #0]
 8003506:	88fa      	ldrh	r2, [r7, #6]
 8003508:	f3c2 020c 	ubfx	r2, r2, #0, #13
 800350c:	605a      	str	r2, [r3, #4]
    /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
    DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
 800350e:	4b34      	ldr	r3, [pc, #208]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 8003510:	681b      	ldr	r3, [r3, #0]
 8003512:	4a33      	ldr	r2, [pc, #204]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 8003514:	6812      	ldr	r2, [r2, #0]
 8003516:	6812      	ldr	r2, [r2, #0]
 8003518:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800351c:	601a      	str	r2, [r3, #0]
    DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
 800351e:	4b30      	ldr	r3, [pc, #192]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 8003520:	681b      	ldr	r3, [r3, #0]
 8003522:	68db      	ldr	r3, [r3, #12]
 8003524:	461a      	mov	r2, r3
 8003526:	4b2e      	ldr	r3, [pc, #184]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 8003528:	601a      	str	r2, [r3, #0]
 800352a:	e03d      	b.n	80035a8 <ETH_Prepare_Transmit_Descriptors+0x124>
  }
  else
  {
    for (i=0; i< buf_count; i++)
 800352c:	2300      	movs	r3, #0
 800352e:	613b      	str	r3, [r7, #16]
 8003530:	e033      	b.n	800359a <ETH_Prepare_Transmit_Descriptors+0x116>
    {
      if (i==0) 
 8003532:	693b      	ldr	r3, [r7, #16]
 8003534:	2b00      	cmp	r3, #0
 8003536:	d107      	bne.n	8003548 <ETH_Prepare_Transmit_Descriptors+0xc4>
      {
        /* Setting the first segment bit */
        DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
 8003538:	4b29      	ldr	r3, [pc, #164]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 800353a:	681b      	ldr	r3, [r3, #0]
 800353c:	4a28      	ldr	r2, [pc, #160]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 800353e:	6812      	ldr	r2, [r2, #0]
 8003540:	6812      	ldr	r2, [r2, #0]
 8003542:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003546:	601a      	str	r2, [r3, #0]
      }
      
      /* Program size */
      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
 8003548:	68fb      	ldr	r3, [r7, #12]
 800354a:	f240 52f4 	movw	r2, #1524	; 0x5f4
 800354e:	605a      	str	r2, [r3, #4]
       
      if (i== (buf_count-1))
 8003550:	697b      	ldr	r3, [r7, #20]
 8003552:	1e5a      	subs	r2, r3, #1
 8003554:	693b      	ldr	r3, [r7, #16]
 8003556:	429a      	cmp	r2, r3
 8003558:	d113      	bne.n	8003582 <ETH_Prepare_Transmit_Descriptors+0xfe>
      {
        /* Setting the last segment bit */
        DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
 800355a:	68fb      	ldr	r3, [r7, #12]
 800355c:	681b      	ldr	r3, [r3, #0]
 800355e:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 8003562:	68fb      	ldr	r3, [r7, #12]
 8003564:	601a      	str	r2, [r3, #0]
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
 8003566:	88fa      	ldrh	r2, [r7, #6]
 8003568:	697b      	ldr	r3, [r7, #20]
 800356a:	491f      	ldr	r1, [pc, #124]	; (80035e8 <ETH_Prepare_Transmit_Descriptors+0x164>)
 800356c:	fb01 f303 	mul.w	r3, r1, r3
 8003570:	4413      	add	r3, r2
 8003572:	f203 53f4 	addw	r3, r3, #1524	; 0x5f4
 8003576:	60bb      	str	r3, [r7, #8]
        DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
 8003578:	68bb      	ldr	r3, [r7, #8]
 800357a:	f3c3 020c 	ubfx	r2, r3, #0, #13
 800357e:	68fb      	ldr	r3, [r7, #12]
 8003580:	605a      	str	r2, [r3, #4]
      }
        
      /*give back descriptor to DMA */
      DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
 8003582:	68fb      	ldr	r3, [r7, #12]
 8003584:	681b      	ldr	r3, [r3, #0]
 8003586:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 800358a:	68fb      	ldr	r3, [r7, #12]
 800358c:	601a      	str	r2, [r3, #0]
      
      DMATxNextDesc = (ETH_DMADESCTypeDef *)(DMATxNextDesc->Buffer2NextDescAddr);
 800358e:	68fb      	ldr	r3, [r7, #12]
 8003590:	68db      	ldr	r3, [r3, #12]
 8003592:	60fb      	str	r3, [r7, #12]
    for (i=0; i< buf_count; i++)
 8003594:	693b      	ldr	r3, [r7, #16]
 8003596:	3301      	adds	r3, #1
 8003598:	613b      	str	r3, [r7, #16]
 800359a:	693a      	ldr	r2, [r7, #16]
 800359c:	697b      	ldr	r3, [r7, #20]
 800359e:	429a      	cmp	r2, r3
 80035a0:	d3c7      	bcc.n	8003532 <ETH_Prepare_Transmit_Descriptors+0xae>
      /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
     }
    DMATxDescToSet = DMATxNextDesc ;
 80035a2:	4a0f      	ldr	r2, [pc, #60]	; (80035e0 <ETH_Prepare_Transmit_Descriptors+0x15c>)
 80035a4:	68fb      	ldr	r3, [r7, #12]
 80035a6:	6013      	str	r3, [r2, #0]
  }
    
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
 80035a8:	4b10      	ldr	r3, [pc, #64]	; (80035ec <ETH_Prepare_Transmit_Descriptors+0x168>)
 80035aa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80035ae:	3314      	adds	r3, #20
 80035b0:	681b      	ldr	r3, [r3, #0]
 80035b2:	f003 0304 	and.w	r3, r3, #4
 80035b6:	2b00      	cmp	r3, #0
 80035b8:	d00b      	beq.n	80035d2 <ETH_Prepare_Transmit_Descriptors+0x14e>
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
 80035ba:	4b0c      	ldr	r3, [pc, #48]	; (80035ec <ETH_Prepare_Transmit_Descriptors+0x168>)
 80035bc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80035c0:	3314      	adds	r3, #20
 80035c2:	2204      	movs	r2, #4
 80035c4:	601a      	str	r2, [r3, #0]
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 80035c6:	4b09      	ldr	r3, [pc, #36]	; (80035ec <ETH_Prepare_Transmit_Descriptors+0x168>)
 80035c8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80035cc:	3304      	adds	r3, #4
 80035ce:	2200      	movs	r2, #0
 80035d0:	601a      	str	r2, [r3, #0]
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;   
 80035d2:	2301      	movs	r3, #1
}
 80035d4:	4618      	mov	r0, r3
 80035d6:	371c      	adds	r7, #28
 80035d8:	46bd      	mov	sp, r7
 80035da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035de:	4770      	bx	lr
 80035e0:	20007d94 	.word	0x20007d94
 80035e4:	ac02b00b 	.word	0xac02b00b
 80035e8:	fffffa0c 	.word	0xfffffa0c
 80035ec:	40028000 	.word	0x40028000

080035f0 <ETH_DMARxDescChainInit>:
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
 80035f0:	b480      	push	{r7}
 80035f2:	b087      	sub	sp, #28
 80035f4:	af00      	add	r7, sp, #0
 80035f6:	60f8      	str	r0, [r7, #12]
 80035f8:	60b9      	str	r1, [r7, #8]
 80035fa:	607a      	str	r2, [r7, #4]
  uint32_t i = 0;
 80035fc:	2300      	movs	r3, #0
 80035fe:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
 8003600:	4a21      	ldr	r2, [pc, #132]	; (8003688 <ETH_DMARxDescChainInit+0x98>)
 8003602:	68fb      	ldr	r3, [r7, #12]
 8003604:	6013      	str	r3, [r2, #0]
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 8003606:	2300      	movs	r3, #0
 8003608:	617b      	str	r3, [r7, #20]
 800360a:	e02a      	b.n	8003662 <ETH_DMARxDescChainInit+0x72>
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
 800360c:	697b      	ldr	r3, [r7, #20]
 800360e:	015b      	lsls	r3, r3, #5
 8003610:	68fa      	ldr	r2, [r7, #12]
 8003612:	4413      	add	r3, r2
 8003614:	613b      	str	r3, [r7, #16]
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
 8003616:	693b      	ldr	r3, [r7, #16]
 8003618:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800361c:	601a      	str	r2, [r3, #0]

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
 800361e:	693b      	ldr	r3, [r7, #16]
 8003620:	f244 52f4 	movw	r2, #17908	; 0x45f4
 8003624:	605a      	str	r2, [r3, #4]
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 8003626:	697b      	ldr	r3, [r7, #20]
 8003628:	f240 52f4 	movw	r2, #1524	; 0x5f4
 800362c:	fb02 f303 	mul.w	r3, r2, r3
 8003630:	68ba      	ldr	r2, [r7, #8]
 8003632:	4413      	add	r3, r2
 8003634:	461a      	mov	r2, r3
 8003636:	693b      	ldr	r3, [r7, #16]
 8003638:	609a      	str	r2, [r3, #8]
    
    /* Initialize the next descriptor with the Next Descriptor Polling Enable */
    if(i < (RxBuffCount-1))
 800363a:	687b      	ldr	r3, [r7, #4]
 800363c:	1e5a      	subs	r2, r3, #1
 800363e:	697b      	ldr	r3, [r7, #20]
 8003640:	429a      	cmp	r2, r3
 8003642:	d908      	bls.n	8003656 <ETH_DMARxDescChainInit+0x66>
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
 8003644:	697b      	ldr	r3, [r7, #20]
 8003646:	3301      	adds	r3, #1
 8003648:	015b      	lsls	r3, r3, #5
 800364a:	68fa      	ldr	r2, [r7, #12]
 800364c:	4413      	add	r3, r2
 800364e:	461a      	mov	r2, r3
 8003650:	693b      	ldr	r3, [r7, #16]
 8003652:	60da      	str	r2, [r3, #12]
 8003654:	e002      	b.n	800365c <ETH_DMARxDescChainInit+0x6c>
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
 8003656:	68fa      	ldr	r2, [r7, #12]
 8003658:	693b      	ldr	r3, [r7, #16]
 800365a:	60da      	str	r2, [r3, #12]
  for(i=0; i < RxBuffCount; i++)
 800365c:	697b      	ldr	r3, [r7, #20]
 800365e:	3301      	adds	r3, #1
 8003660:	617b      	str	r3, [r7, #20]
 8003662:	697a      	ldr	r2, [r7, #20]
 8003664:	687b      	ldr	r3, [r7, #4]
 8003666:	429a      	cmp	r2, r3
 8003668:	d3d0      	bcc.n	800360c <ETH_DMARxDescChainInit+0x1c>
    }
  }
   
  /* Set Receive Descriptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab; 
 800366a:	4b08      	ldr	r3, [pc, #32]	; (800368c <ETH_DMARxDescChainInit+0x9c>)
 800366c:	68fa      	ldr	r2, [r7, #12]
 800366e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8003672:	330c      	adds	r3, #12
 8003674:	601a      	str	r2, [r3, #0]
  

  DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
 8003676:	4b06      	ldr	r3, [pc, #24]	; (8003690 <ETH_DMARxDescChainInit+0xa0>)
 8003678:	4a06      	ldr	r2, [pc, #24]	; (8003694 <ETH_DMARxDescChainInit+0xa4>)
 800367a:	601a      	str	r2, [r3, #0]

}
 800367c:	bf00      	nop
 800367e:	371c      	adds	r7, #28
 8003680:	46bd      	mov	sp, r7
 8003682:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003686:	4770      	bx	lr
 8003688:	20007d90 	.word	0x20007d90
 800368c:	40028000 	.word	0x40028000
 8003690:	200095ac 	.word	0x200095ac
 8003694:	20007d84 	.word	0x20007d84

08003698 <ETH_CheckFrameReceived>:
  * @brief  This function polls for a frame reception
  * @param  None
  * @retval Returns 1 when a frame is received, 0 if none.
  */
uint32_t ETH_CheckFrameReceived(void)
{ 
 8003698:	b480      	push	{r7}
 800369a:	af00      	add	r7, sp, #0
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 800369c:	4b31      	ldr	r3, [pc, #196]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 800369e:	681b      	ldr	r3, [r3, #0]
 80036a0:	681b      	ldr	r3, [r3, #0]
 80036a2:	2b00      	cmp	r3, #0
 80036a4:	db12      	blt.n	80036cc <ETH_CheckFrameReceived+0x34>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
 80036a6:	4b2f      	ldr	r3, [pc, #188]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	681b      	ldr	r3, [r3, #0]
 80036ac:	f403 7380 	and.w	r3, r3, #256	; 0x100
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 80036b0:	2b00      	cmp	r3, #0
 80036b2:	d00b      	beq.n	80036cc <ETH_CheckFrameReceived+0x34>
    {   
      DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
 80036b4:	4b2c      	ldr	r3, [pc, #176]	; (8003768 <ETH_CheckFrameReceived+0xd0>)
 80036b6:	681b      	ldr	r3, [r3, #0]
 80036b8:	4a2a      	ldr	r2, [pc, #168]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 80036ba:	6812      	ldr	r2, [r2, #0]
 80036bc:	605a      	str	r2, [r3, #4]
      DMA_RX_FRAME_infos->Seg_Count++;
 80036be:	4b2a      	ldr	r3, [pc, #168]	; (8003768 <ETH_CheckFrameReceived+0xd0>)
 80036c0:	681b      	ldr	r3, [r3, #0]
 80036c2:	689a      	ldr	r2, [r3, #8]
 80036c4:	3201      	adds	r2, #1
 80036c6:	609a      	str	r2, [r3, #8]
      return 1;
 80036c8:	2301      	movs	r3, #1
 80036ca:	e045      	b.n	8003758 <ETH_CheckFrameReceived+0xc0>
    }
  
    /* check if first segment */
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 80036cc:	4b25      	ldr	r3, [pc, #148]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 80036ce:	681b      	ldr	r3, [r3, #0]
 80036d0:	681b      	ldr	r3, [r3, #0]
 80036d2:	2b00      	cmp	r3, #0
 80036d4:	db21      	blt.n	800371a <ETH_CheckFrameReceived+0x82>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 80036d6:	4b23      	ldr	r3, [pc, #140]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 80036d8:	681b      	ldr	r3, [r3, #0]
 80036da:	681b      	ldr	r3, [r3, #0]
 80036dc:	f403 7300 	and.w	r3, r3, #512	; 0x200
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 80036e0:	2b00      	cmp	r3, #0
 80036e2:	d01a      	beq.n	800371a <ETH_CheckFrameReceived+0x82>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
 80036e4:	4b1f      	ldr	r3, [pc, #124]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 80036e6:	681b      	ldr	r3, [r3, #0]
 80036e8:	681b      	ldr	r3, [r3, #0]
 80036ea:	f403 7380 	and.w	r3, r3, #256	; 0x100
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 80036ee:	2b00      	cmp	r3, #0
 80036f0:	d113      	bne.n	800371a <ETH_CheckFrameReceived+0x82>
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 80036f2:	4b1d      	ldr	r3, [pc, #116]	; (8003768 <ETH_CheckFrameReceived+0xd0>)
 80036f4:	681b      	ldr	r3, [r3, #0]
 80036f6:	4a1b      	ldr	r2, [pc, #108]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 80036f8:	6812      	ldr	r2, [r2, #0]
 80036fa:	601a      	str	r2, [r3, #0]
      DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
 80036fc:	4b1a      	ldr	r3, [pc, #104]	; (8003768 <ETH_CheckFrameReceived+0xd0>)
 80036fe:	681b      	ldr	r3, [r3, #0]
 8003700:	2200      	movs	r2, #0
 8003702:	605a      	str	r2, [r3, #4]
      DMA_RX_FRAME_infos->Seg_Count = 1;   
 8003704:	4b18      	ldr	r3, [pc, #96]	; (8003768 <ETH_CheckFrameReceived+0xd0>)
 8003706:	681b      	ldr	r3, [r3, #0]
 8003708:	2201      	movs	r2, #1
 800370a:	609a      	str	r2, [r3, #8]
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 800370c:	4b15      	ldr	r3, [pc, #84]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 800370e:	681b      	ldr	r3, [r3, #0]
 8003710:	68db      	ldr	r3, [r3, #12]
 8003712:	461a      	mov	r2, r3
 8003714:	4b13      	ldr	r3, [pc, #76]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 8003716:	601a      	str	r2, [r3, #0]
 8003718:	e01d      	b.n	8003756 <ETH_CheckFrameReceived+0xbe>
    }
    
    /* check if intermediate segment */ 
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 800371a:	4b12      	ldr	r3, [pc, #72]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 800371c:	681b      	ldr	r3, [r3, #0]
 800371e:	681b      	ldr	r3, [r3, #0]
 8003720:	2b00      	cmp	r3, #0
 8003722:	db18      	blt.n	8003756 <ETH_CheckFrameReceived+0xbe>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
 8003724:	4b0f      	ldr	r3, [pc, #60]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 8003726:	681b      	ldr	r3, [r3, #0]
 8003728:	681b      	ldr	r3, [r3, #0]
 800372a:	f403 7300 	and.w	r3, r3, #512	; 0x200
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 800372e:	2b00      	cmp	r3, #0
 8003730:	d111      	bne.n	8003756 <ETH_CheckFrameReceived+0xbe>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
 8003732:	4b0c      	ldr	r3, [pc, #48]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 8003734:	681b      	ldr	r3, [r3, #0]
 8003736:	681b      	ldr	r3, [r3, #0]
 8003738:	f403 7380 	and.w	r3, r3, #256	; 0x100
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
 800373c:	2b00      	cmp	r3, #0
 800373e:	d10a      	bne.n	8003756 <ETH_CheckFrameReceived+0xbe>
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
 8003740:	4b09      	ldr	r3, [pc, #36]	; (8003768 <ETH_CheckFrameReceived+0xd0>)
 8003742:	681b      	ldr	r3, [r3, #0]
 8003744:	689a      	ldr	r2, [r3, #8]
 8003746:	3201      	adds	r2, #1
 8003748:	609a      	str	r2, [r3, #8]
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 800374a:	4b06      	ldr	r3, [pc, #24]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 800374c:	681b      	ldr	r3, [r3, #0]
 800374e:	68db      	ldr	r3, [r3, #12]
 8003750:	461a      	mov	r2, r3
 8003752:	4b04      	ldr	r3, [pc, #16]	; (8003764 <ETH_CheckFrameReceived+0xcc>)
 8003754:	601a      	str	r2, [r3, #0]
    } 
    return 0;
 8003756:	2300      	movs	r3, #0
}
 8003758:	4618      	mov	r0, r3
 800375a:	46bd      	mov	sp, r7
 800375c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003760:	4770      	bx	lr
 8003762:	bf00      	nop
 8003764:	20007d90 	.word	0x20007d90
 8003768:	200095ac 	.word	0x200095ac

0800376c <ETH_DMATxDescChainInit>:
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
 800376c:	b480      	push	{r7}
 800376e:	b087      	sub	sp, #28
 8003770:	af00      	add	r7, sp, #0
 8003772:	60f8      	str	r0, [r7, #12]
 8003774:	60b9      	str	r1, [r7, #8]
 8003776:	607a      	str	r2, [r7, #4]
  uint32_t i = 0;
 8003778:	2300      	movs	r3, #0
 800377a:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
 800377c:	4a1e      	ldr	r2, [pc, #120]	; (80037f8 <ETH_DMATxDescChainInit+0x8c>)
 800377e:	68fb      	ldr	r3, [r7, #12]
 8003780:	6013      	str	r3, [r2, #0]
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 8003782:	2300      	movs	r3, #0
 8003784:	617b      	str	r3, [r7, #20]
 8003786:	e026      	b.n	80037d6 <ETH_DMATxDescChainInit+0x6a>
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
 8003788:	697b      	ldr	r3, [r7, #20]
 800378a:	015b      	lsls	r3, r3, #5
 800378c:	68fa      	ldr	r2, [r7, #12]
 800378e:	4413      	add	r3, r2
 8003790:	613b      	str	r3, [r7, #16]
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
 8003792:	693b      	ldr	r3, [r7, #16]
 8003794:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8003798:	601a      	str	r2, [r3, #0]
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 800379a:	697b      	ldr	r3, [r7, #20]
 800379c:	f240 52f4 	movw	r2, #1524	; 0x5f4
 80037a0:	fb02 f303 	mul.w	r3, r2, r3
 80037a4:	68ba      	ldr	r2, [r7, #8]
 80037a6:	4413      	add	r3, r2
 80037a8:	461a      	mov	r2, r3
 80037aa:	693b      	ldr	r3, [r7, #16]
 80037ac:	609a      	str	r2, [r3, #8]
    
    /* Initialize the next descriptor with the Next Descriptor Polling Enable */
    if(i < (TxBuffCount-1))
 80037ae:	687b      	ldr	r3, [r7, #4]
 80037b0:	1e5a      	subs	r2, r3, #1
 80037b2:	697b      	ldr	r3, [r7, #20]
 80037b4:	429a      	cmp	r2, r3
 80037b6:	d908      	bls.n	80037ca <ETH_DMATxDescChainInit+0x5e>
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
 80037b8:	697b      	ldr	r3, [r7, #20]
 80037ba:	3301      	adds	r3, #1
 80037bc:	015b      	lsls	r3, r3, #5
 80037be:	68fa      	ldr	r2, [r7, #12]
 80037c0:	4413      	add	r3, r2
 80037c2:	461a      	mov	r2, r3
 80037c4:	693b      	ldr	r3, [r7, #16]
 80037c6:	60da      	str	r2, [r3, #12]
 80037c8:	e002      	b.n	80037d0 <ETH_DMATxDescChainInit+0x64>
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
 80037ca:	68fa      	ldr	r2, [r7, #12]
 80037cc:	693b      	ldr	r3, [r7, #16]
 80037ce:	60da      	str	r2, [r3, #12]
  for(i=0; i < TxBuffCount; i++)
 80037d0:	697b      	ldr	r3, [r7, #20]
 80037d2:	3301      	adds	r3, #1
 80037d4:	617b      	str	r3, [r7, #20]
 80037d6:	697a      	ldr	r2, [r7, #20]
 80037d8:	687b      	ldr	r3, [r7, #4]
 80037da:	429a      	cmp	r2, r3
 80037dc:	d3d4      	bcc.n	8003788 <ETH_DMATxDescChainInit+0x1c>
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
 80037de:	4b07      	ldr	r3, [pc, #28]	; (80037fc <ETH_DMATxDescChainInit+0x90>)
 80037e0:	68fa      	ldr	r2, [r7, #12]
 80037e2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80037e6:	3310      	adds	r3, #16
 80037e8:	601a      	str	r2, [r3, #0]
}
 80037ea:	bf00      	nop
 80037ec:	371c      	adds	r7, #28
 80037ee:	46bd      	mov	sp, r7
 80037f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80037f4:	4770      	bx	lr
 80037f6:	bf00      	nop
 80037f8:	20007d94 	.word	0x20007d94
 80037fc:	40028000 	.word	0x40028000

08003800 <ETH_DMATxDescChecksumInsertionConfig>:
  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present
  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header                                                                
  * @retval None
  */
void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
{
 8003800:	b480      	push	{r7}
 8003802:	b083      	sub	sp, #12
 8003804:	af00      	add	r7, sp, #0
 8003806:	6078      	str	r0, [r7, #4]
 8003808:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
  
  /* Set the selected DMA Tx desc checksum insertion control */
  DMATxDesc->Status |= DMATxDesc_Checksum;
 800380a:	687b      	ldr	r3, [r7, #4]
 800380c:	681a      	ldr	r2, [r3, #0]
 800380e:	683b      	ldr	r3, [r7, #0]
 8003810:	431a      	orrs	r2, r3
 8003812:	687b      	ldr	r3, [r7, #4]
 8003814:	601a      	str	r2, [r3, #0]
}
 8003816:	bf00      	nop
 8003818:	370c      	adds	r7, #12
 800381a:	46bd      	mov	sp, r7
 800381c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003820:	4770      	bx	lr
	...

08003824 <ETH_SoftwareReset>:
  * @brief  Resets all MAC subsystem internal registers and logic.
  * @param  None
  * @retval None
  */
void ETH_SoftwareReset(void)
{
 8003824:	b480      	push	{r7}
 8003826:	af00      	add	r7, sp, #0
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  ETH->DMABMR |= ETH_DMABMR_SR;
 8003828:	4907      	ldr	r1, [pc, #28]	; (8003848 <ETH_SoftwareReset+0x24>)
 800382a:	4b07      	ldr	r3, [pc, #28]	; (8003848 <ETH_SoftwareReset+0x24>)
 800382c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8003830:	681b      	ldr	r3, [r3, #0]
 8003832:	f043 0201 	orr.w	r2, r3, #1
 8003836:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 800383a:	601a      	str	r2, [r3, #0]
}
 800383c:	bf00      	nop
 800383e:	46bd      	mov	sp, r7
 8003840:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003844:	4770      	bx	lr
 8003846:	bf00      	nop
 8003848:	40028000 	.word	0x40028000

0800384c <ETH_GetSoftwareResetStatus>:
  * @brief  Checks whether the ETHERNET software reset bit is set or not.
  * @param  None
  * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
  */
FlagStatus ETH_GetSoftwareResetStatus(void)
{
 800384c:	b480      	push	{r7}
 800384e:	b083      	sub	sp, #12
 8003850:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
 8003852:	2300      	movs	r3, #0
 8003854:	71fb      	strb	r3, [r7, #7]
  if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 8003856:	4b0a      	ldr	r3, [pc, #40]	; (8003880 <ETH_GetSoftwareResetStatus+0x34>)
 8003858:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800385c:	681b      	ldr	r3, [r3, #0]
 800385e:	f003 0301 	and.w	r3, r3, #1
 8003862:	2b00      	cmp	r3, #0
 8003864:	d002      	beq.n	800386c <ETH_GetSoftwareResetStatus+0x20>
  {
    bitstatus = SET;
 8003866:	2301      	movs	r3, #1
 8003868:	71fb      	strb	r3, [r7, #7]
 800386a:	e001      	b.n	8003870 <ETH_GetSoftwareResetStatus+0x24>
  }
  else
  {
    bitstatus = RESET;
 800386c:	2300      	movs	r3, #0
 800386e:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus;
 8003870:	79fb      	ldrb	r3, [r7, #7]
}
 8003872:	4618      	mov	r0, r3
 8003874:	370c      	adds	r7, #12
 8003876:	46bd      	mov	sp, r7
 8003878:	f85d 7b04 	ldr.w	r7, [sp], #4
 800387c:	4770      	bx	lr
 800387e:	bf00      	nop
 8003880:	40028000 	.word	0x40028000

08003884 <ETH_FlushTransmitFIFO>:
  * @brief  Clears the ETHERNET transmit FIFO.
  * @param  None                
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
 8003884:	b480      	push	{r7}
 8003886:	af00      	add	r7, sp, #0
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
 8003888:	4908      	ldr	r1, [pc, #32]	; (80038ac <ETH_FlushTransmitFIFO+0x28>)
 800388a:	4b08      	ldr	r3, [pc, #32]	; (80038ac <ETH_FlushTransmitFIFO+0x28>)
 800388c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8003890:	3318      	adds	r3, #24
 8003892:	681b      	ldr	r3, [r3, #0]
 8003894:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
 8003898:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 800389c:	3318      	adds	r3, #24
 800389e:	601a      	str	r2, [r3, #0]
}
 80038a0:	bf00      	nop
 80038a2:	46bd      	mov	sp, r7
 80038a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038a8:	4770      	bx	lr
 80038aa:	bf00      	nop
 80038ac:	40028000 	.word	0x40028000

080038b0 <ETH_DMATransmissionCmd>:
  * @param  NewState: new state of the DMA transmission.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATransmissionCmd(FunctionalState NewState)
{ 
 80038b0:	b480      	push	{r7}
 80038b2:	b083      	sub	sp, #12
 80038b4:	af00      	add	r7, sp, #0
 80038b6:	4603      	mov	r3, r0
 80038b8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80038ba:	79fb      	ldrb	r3, [r7, #7]
 80038bc:	2b00      	cmp	r3, #0
 80038be:	d00c      	beq.n	80038da <ETH_DMATransmissionCmd+0x2a>
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
 80038c0:	490f      	ldr	r1, [pc, #60]	; (8003900 <ETH_DMATransmissionCmd+0x50>)
 80038c2:	4b0f      	ldr	r3, [pc, #60]	; (8003900 <ETH_DMATransmissionCmd+0x50>)
 80038c4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80038c8:	3318      	adds	r3, #24
 80038ca:	681b      	ldr	r3, [r3, #0]
 80038cc:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 80038d0:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 80038d4:	3318      	adds	r3, #24
 80038d6:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the DMA transmission */
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
  }
}
 80038d8:	e00b      	b.n	80038f2 <ETH_DMATransmissionCmd+0x42>
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
 80038da:	4909      	ldr	r1, [pc, #36]	; (8003900 <ETH_DMATransmissionCmd+0x50>)
 80038dc:	4b08      	ldr	r3, [pc, #32]	; (8003900 <ETH_DMATransmissionCmd+0x50>)
 80038de:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80038e2:	3318      	adds	r3, #24
 80038e4:	681b      	ldr	r3, [r3, #0]
 80038e6:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 80038ea:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 80038ee:	3318      	adds	r3, #24
 80038f0:	601a      	str	r2, [r3, #0]
}
 80038f2:	bf00      	nop
 80038f4:	370c      	adds	r7, #12
 80038f6:	46bd      	mov	sp, r7
 80038f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038fc:	4770      	bx	lr
 80038fe:	bf00      	nop
 8003900:	40028000 	.word	0x40028000

08003904 <ETH_DMAReceptionCmd>:
  * @param  NewState: new state of the DMA reception.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMAReceptionCmd(FunctionalState NewState)
{ 
 8003904:	b480      	push	{r7}
 8003906:	b083      	sub	sp, #12
 8003908:	af00      	add	r7, sp, #0
 800390a:	4603      	mov	r3, r0
 800390c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800390e:	79fb      	ldrb	r3, [r7, #7]
 8003910:	2b00      	cmp	r3, #0
 8003912:	d00c      	beq.n	800392e <ETH_DMAReceptionCmd+0x2a>
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
 8003914:	490f      	ldr	r1, [pc, #60]	; (8003954 <ETH_DMAReceptionCmd+0x50>)
 8003916:	4b0f      	ldr	r3, [pc, #60]	; (8003954 <ETH_DMAReceptionCmd+0x50>)
 8003918:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800391c:	3318      	adds	r3, #24
 800391e:	681b      	ldr	r3, [r3, #0]
 8003920:	f043 0202 	orr.w	r2, r3, #2
 8003924:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 8003928:	3318      	adds	r3, #24
 800392a:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the DMA reception */
    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
  }
}
 800392c:	e00b      	b.n	8003946 <ETH_DMAReceptionCmd+0x42>
    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
 800392e:	4909      	ldr	r1, [pc, #36]	; (8003954 <ETH_DMAReceptionCmd+0x50>)
 8003930:	4b08      	ldr	r3, [pc, #32]	; (8003954 <ETH_DMAReceptionCmd+0x50>)
 8003932:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8003936:	3318      	adds	r3, #24
 8003938:	681b      	ldr	r3, [r3, #0]
 800393a:	f023 0202 	bic.w	r2, r3, #2
 800393e:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 8003942:	3318      	adds	r3, #24
 8003944:	601a      	str	r2, [r3, #0]
}
 8003946:	bf00      	nop
 8003948:	370c      	adds	r7, #12
 800394a:	46bd      	mov	sp, r7
 800394c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003950:	4770      	bx	lr
 8003952:	bf00      	nop
 8003954:	40028000 	.word	0x40028000

08003958 <ETH_ReadPHYRegister>:
  *     @arg More PHY register could be read depending on the used PHY
  * @retval ETH_ERROR: in case of timeout
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
 8003958:	b480      	push	{r7}
 800395a:	b085      	sub	sp, #20
 800395c:	af00      	add	r7, sp, #0
 800395e:	4603      	mov	r3, r0
 8003960:	460a      	mov	r2, r1
 8003962:	80fb      	strh	r3, [r7, #6]
 8003964:	4613      	mov	r3, r2
 8003966:	80bb      	strh	r3, [r7, #4]
  uint32_t tmpreg = 0;     
 8003968:	2300      	movs	r3, #0
 800396a:	60fb      	str	r3, [r7, #12]
__IO uint32_t timeout = 0;
 800396c:	2300      	movs	r3, #0
 800396e:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8003970:	4b1e      	ldr	r3, [pc, #120]	; (80039ec <ETH_ReadPHYRegister+0x94>)
 8003972:	691b      	ldr	r3, [r3, #16]
 8003974:	60fb      	str	r3, [r7, #12]
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
 8003976:	68fb      	ldr	r3, [r7, #12]
 8003978:	f003 031c 	and.w	r3, r3, #28
 800397c:	60fb      	str	r3, [r7, #12]
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 800397e:	88fb      	ldrh	r3, [r7, #6]
 8003980:	02db      	lsls	r3, r3, #11
 8003982:	b29b      	uxth	r3, r3
 8003984:	68fa      	ldr	r2, [r7, #12]
 8003986:	4313      	orrs	r3, r2
 8003988:	60fb      	str	r3, [r7, #12]
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
 800398a:	88bb      	ldrh	r3, [r7, #4]
 800398c:	019b      	lsls	r3, r3, #6
 800398e:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 8003992:	68fa      	ldr	r2, [r7, #12]
 8003994:	4313      	orrs	r3, r2
 8003996:	60fb      	str	r3, [r7, #12]
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
 8003998:	68fb      	ldr	r3, [r7, #12]
 800399a:	f023 0302 	bic.w	r3, r3, #2
 800399e:	60fb      	str	r3, [r7, #12]
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 80039a0:	68fb      	ldr	r3, [r7, #12]
 80039a2:	f043 0301 	orr.w	r3, r3, #1
 80039a6:	60fb      	str	r3, [r7, #12]
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 80039a8:	4a10      	ldr	r2, [pc, #64]	; (80039ec <ETH_ReadPHYRegister+0x94>)
 80039aa:	68fb      	ldr	r3, [r7, #12]
 80039ac:	6113      	str	r3, [r2, #16]
  /* Check for the Busy flag */
  do
  {
    timeout++;
 80039ae:	68bb      	ldr	r3, [r7, #8]
 80039b0:	3301      	adds	r3, #1
 80039b2:	60bb      	str	r3, [r7, #8]
    tmpreg = ETH->MACMIIAR;
 80039b4:	4b0d      	ldr	r3, [pc, #52]	; (80039ec <ETH_ReadPHYRegister+0x94>)
 80039b6:	691b      	ldr	r3, [r3, #16]
 80039b8:	60fb      	str	r3, [r7, #12]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 80039ba:	68fb      	ldr	r3, [r7, #12]
 80039bc:	f003 0301 	and.w	r3, r3, #1
 80039c0:	2b00      	cmp	r3, #0
 80039c2:	d003      	beq.n	80039cc <ETH_ReadPHYRegister+0x74>
 80039c4:	68bb      	ldr	r3, [r7, #8]
 80039c6:	4a0a      	ldr	r2, [pc, #40]	; (80039f0 <ETH_ReadPHYRegister+0x98>)
 80039c8:	4293      	cmp	r3, r2
 80039ca:	d9f0      	bls.n	80039ae <ETH_ReadPHYRegister+0x56>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 80039cc:	68bb      	ldr	r3, [r7, #8]
 80039ce:	4a09      	ldr	r2, [pc, #36]	; (80039f4 <ETH_ReadPHYRegister+0x9c>)
 80039d0:	4293      	cmp	r3, r2
 80039d2:	d101      	bne.n	80039d8 <ETH_ReadPHYRegister+0x80>
  {
    return (uint16_t)ETH_ERROR;
 80039d4:	2300      	movs	r3, #0
 80039d6:	e002      	b.n	80039de <ETH_ReadPHYRegister+0x86>
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 80039d8:	4b04      	ldr	r3, [pc, #16]	; (80039ec <ETH_ReadPHYRegister+0x94>)
 80039da:	695b      	ldr	r3, [r3, #20]
 80039dc:	b29b      	uxth	r3, r3
}
 80039de:	4618      	mov	r0, r3
 80039e0:	3714      	adds	r7, #20
 80039e2:	46bd      	mov	sp, r7
 80039e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039e8:	4770      	bx	lr
 80039ea:	bf00      	nop
 80039ec:	40028000 	.word	0x40028000
 80039f0:	0004fffe 	.word	0x0004fffe
 80039f4:	0004ffff 	.word	0x0004ffff

080039f8 <ETH_WritePHYRegister>:
  * @param  PHYValue: the value to write
  * @retval ETH_ERROR: in case of timeout
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
 80039f8:	b480      	push	{r7}
 80039fa:	b085      	sub	sp, #20
 80039fc:	af00      	add	r7, sp, #0
 80039fe:	4603      	mov	r3, r0
 8003a00:	80fb      	strh	r3, [r7, #6]
 8003a02:	460b      	mov	r3, r1
 8003a04:	80bb      	strh	r3, [r7, #4]
 8003a06:	4613      	mov	r3, r2
 8003a08:	807b      	strh	r3, [r7, #2]
  uint32_t tmpreg = 0;     
 8003a0a:	2300      	movs	r3, #0
 8003a0c:	60fb      	str	r3, [r7, #12]
  __IO uint32_t timeout = 0;
 8003a0e:	2300      	movs	r3, #0
 8003a10:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8003a12:	4b1f      	ldr	r3, [pc, #124]	; (8003a90 <ETH_WritePHYRegister+0x98>)
 8003a14:	691b      	ldr	r3, [r3, #16]
 8003a16:	60fb      	str	r3, [r7, #12]
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
 8003a18:	68fb      	ldr	r3, [r7, #12]
 8003a1a:	f003 031c 	and.w	r3, r3, #28
 8003a1e:	60fb      	str	r3, [r7, #12]
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 8003a20:	88fb      	ldrh	r3, [r7, #6]
 8003a22:	02db      	lsls	r3, r3, #11
 8003a24:	b29b      	uxth	r3, r3
 8003a26:	68fa      	ldr	r2, [r7, #12]
 8003a28:	4313      	orrs	r3, r2
 8003a2a:	60fb      	str	r3, [r7, #12]
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
 8003a2c:	88bb      	ldrh	r3, [r7, #4]
 8003a2e:	019b      	lsls	r3, r3, #6
 8003a30:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 8003a34:	68fa      	ldr	r2, [r7, #12]
 8003a36:	4313      	orrs	r3, r2
 8003a38:	60fb      	str	r3, [r7, #12]
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
 8003a3a:	68fb      	ldr	r3, [r7, #12]
 8003a3c:	f043 0302 	orr.w	r3, r3, #2
 8003a40:	60fb      	str	r3, [r7, #12]
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 8003a42:	68fb      	ldr	r3, [r7, #12]
 8003a44:	f043 0301 	orr.w	r3, r3, #1
 8003a48:	60fb      	str	r3, [r7, #12]
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 8003a4a:	4a11      	ldr	r2, [pc, #68]	; (8003a90 <ETH_WritePHYRegister+0x98>)
 8003a4c:	887b      	ldrh	r3, [r7, #2]
 8003a4e:	6153      	str	r3, [r2, #20]
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 8003a50:	4a0f      	ldr	r2, [pc, #60]	; (8003a90 <ETH_WritePHYRegister+0x98>)
 8003a52:	68fb      	ldr	r3, [r7, #12]
 8003a54:	6113      	str	r3, [r2, #16]
  /* Check for the Busy flag */
  do
  {
    timeout++;
 8003a56:	68bb      	ldr	r3, [r7, #8]
 8003a58:	3301      	adds	r3, #1
 8003a5a:	60bb      	str	r3, [r7, #8]
    tmpreg = ETH->MACMIIAR;
 8003a5c:	4b0c      	ldr	r3, [pc, #48]	; (8003a90 <ETH_WritePHYRegister+0x98>)
 8003a5e:	691b      	ldr	r3, [r3, #16]
 8003a60:	60fb      	str	r3, [r7, #12]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8003a62:	68fb      	ldr	r3, [r7, #12]
 8003a64:	f003 0301 	and.w	r3, r3, #1
 8003a68:	2b00      	cmp	r3, #0
 8003a6a:	d003      	beq.n	8003a74 <ETH_WritePHYRegister+0x7c>
 8003a6c:	68bb      	ldr	r3, [r7, #8]
 8003a6e:	4a09      	ldr	r2, [pc, #36]	; (8003a94 <ETH_WritePHYRegister+0x9c>)
 8003a70:	4293      	cmp	r3, r2
 8003a72:	d9f0      	bls.n	8003a56 <ETH_WritePHYRegister+0x5e>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
 8003a74:	68bb      	ldr	r3, [r7, #8]
 8003a76:	4a08      	ldr	r2, [pc, #32]	; (8003a98 <ETH_WritePHYRegister+0xa0>)
 8003a78:	4293      	cmp	r3, r2
 8003a7a:	d101      	bne.n	8003a80 <ETH_WritePHYRegister+0x88>
  {
    return ETH_ERROR;
 8003a7c:	2300      	movs	r3, #0
 8003a7e:	e000      	b.n	8003a82 <ETH_WritePHYRegister+0x8a>
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;  
 8003a80:	2301      	movs	r3, #1
}
 8003a82:	4618      	mov	r0, r3
 8003a84:	3714      	adds	r7, #20
 8003a86:	46bd      	mov	sp, r7
 8003a88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a8c:	4770      	bx	lr
 8003a8e:	bf00      	nop
 8003a90:	40028000 	.word	0x40028000
 8003a94:	0004fffe 	.word	0x0004fffe
 8003a98:	0004ffff 	.word	0x0004ffff

08003a9c <NVIC_SetPriority>:

    \param [in]      IRQn  Number of the interrupt for set priority
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003a9c:	b480      	push	{r7}
 8003a9e:	b083      	sub	sp, #12
 8003aa0:	af00      	add	r7, sp, #0
 8003aa2:	4603      	mov	r3, r0
 8003aa4:	6039      	str	r1, [r7, #0]
 8003aa6:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8003aa8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003aac:	2b00      	cmp	r3, #0
 8003aae:	da0b      	bge.n	8003ac8 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8003ab0:	490d      	ldr	r1, [pc, #52]	; (8003ae8 <NVIC_SetPriority+0x4c>)
 8003ab2:	79fb      	ldrb	r3, [r7, #7]
 8003ab4:	f003 030f 	and.w	r3, r3, #15
 8003ab8:	3b04      	subs	r3, #4
 8003aba:	683a      	ldr	r2, [r7, #0]
 8003abc:	b2d2      	uxtb	r2, r2
 8003abe:	0112      	lsls	r2, r2, #4
 8003ac0:	b2d2      	uxtb	r2, r2
 8003ac2:	440b      	add	r3, r1
 8003ac4:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
 8003ac6:	e009      	b.n	8003adc <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8003ac8:	4908      	ldr	r1, [pc, #32]	; (8003aec <NVIC_SetPriority+0x50>)
 8003aca:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003ace:	683a      	ldr	r2, [r7, #0]
 8003ad0:	b2d2      	uxtb	r2, r2
 8003ad2:	0112      	lsls	r2, r2, #4
 8003ad4:	b2d2      	uxtb	r2, r2
 8003ad6:	440b      	add	r3, r1
 8003ad8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8003adc:	bf00      	nop
 8003ade:	370c      	adds	r7, #12
 8003ae0:	46bd      	mov	sp, r7
 8003ae2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ae6:	4770      	bx	lr
 8003ae8:	e000ed00 	.word	0xe000ed00
 8003aec:	e000e100 	.word	0xe000e100

08003af0 <SysTick_Config>:
    \param [in]  ticks  Number of ticks between two interrupts
    \return          0  Function succeeded
    \return          1  Function failed
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8003af0:	b580      	push	{r7, lr}
 8003af2:	b082      	sub	sp, #8
 8003af4:	af00      	add	r7, sp, #0
 8003af6:	6078      	str	r0, [r7, #4]
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
 8003af8:	687b      	ldr	r3, [r7, #4]
 8003afa:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8003afe:	d301      	bcc.n	8003b04 <SysTick_Config+0x14>
 8003b00:	2301      	movs	r3, #1
 8003b02:	e011      	b.n	8003b28 <SysTick_Config+0x38>

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 8003b04:	4a0a      	ldr	r2, [pc, #40]	; (8003b30 <SysTick_Config+0x40>)
 8003b06:	687b      	ldr	r3, [r7, #4]
 8003b08:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003b0c:	3b01      	subs	r3, #1
 8003b0e:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
 8003b10:	210f      	movs	r1, #15
 8003b12:	f04f 30ff 	mov.w	r0, #4294967295
 8003b16:	f7ff ffc1 	bl	8003a9c <NVIC_SetPriority>
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8003b1a:	4b05      	ldr	r3, [pc, #20]	; (8003b30 <SysTick_Config+0x40>)
 8003b1c:	2200      	movs	r2, #0
 8003b1e:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8003b20:	4b03      	ldr	r3, [pc, #12]	; (8003b30 <SysTick_Config+0x40>)
 8003b22:	2207      	movs	r2, #7
 8003b24:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
  return (0);                                                  /* Function successful */
 8003b26:	2300      	movs	r3, #0
}
 8003b28:	4618      	mov	r0, r3
 8003b2a:	3708      	adds	r7, #8
 8003b2c:	46bd      	mov	sp, r7
 8003b2e:	bd80      	pop	{r7, pc}
 8003b30:	e000e010 	.word	0xe000e010

08003b34 <ETH_BSP_Config>:
  * @brief  ETH_BSP_Config
  * @param  None
  * @retval None
  */
void ETH_BSP_Config(void)
{
 8003b34:	b580      	push	{r7, lr}
 8003b36:	b084      	sub	sp, #16
 8003b38:	af00      	add	r7, sp, #0
  RCC_ClocksTypeDef RCC_Clocks;
  
  /* Configure the GPIO ports for ethernet pins */
  ETH_GPIO_Config();
 8003b3a:	f000 f87d 	bl	8003c38 <ETH_GPIO_Config>
  
  /* Configure the Ethernet MAC/DMA */
  ETH_MACDMA_Config();
 8003b3e:	f000 f81b 	bl	8003b78 <ETH_MACDMA_Config>
    while(1);
  }
#endif

  /* Configure the PHY to generate an interrupt on change of link status */
  Eth_Link_PHYITConfig(DP83848_PHY_ADDRESS);
 8003b42:	2001      	movs	r0, #1
 8003b44:	f000 f928 	bl	8003d98 <Eth_Link_PHYITConfig>

  /* Configure the EXTI for Ethernet link status. */
  Eth_Link_EXTIConfig();
 8003b48:	f000 f960 	bl	8003e0c <Eth_Link_EXTIConfig>
  
  /* Configure Systick clock source as HCLK */
  SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
 8003b4c:	2004      	movs	r0, #4
 8003b4e:	f000 fae3 	bl	8004118 <SysTick_CLKSourceConfig>

  /* SystTick configuration: an interrupt every 10ms */
  RCC_GetClocksFreq(&RCC_Clocks);
 8003b52:	463b      	mov	r3, r7
 8003b54:	4618      	mov	r0, r3
 8003b56:	f000 fe35 	bl	80047c4 <RCC_GetClocksFreq>
  SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);  
 8003b5a:	687b      	ldr	r3, [r7, #4]
 8003b5c:	4a05      	ldr	r2, [pc, #20]	; (8003b74 <ETH_BSP_Config+0x40>)
 8003b5e:	fba2 2303 	umull	r2, r3, r2, r3
 8003b62:	095b      	lsrs	r3, r3, #5
 8003b64:	4618      	mov	r0, r3
 8003b66:	f7ff ffc3 	bl	8003af0 <SysTick_Config>
}
 8003b6a:	bf00      	nop
 8003b6c:	3710      	adds	r7, #16
 8003b6e:	46bd      	mov	sp, r7
 8003b70:	bd80      	pop	{r7, pc}
 8003b72:	bf00      	nop
 8003b74:	51eb851f 	.word	0x51eb851f

08003b78 <ETH_MACDMA_Config>:
  * @brief  Configures the Ethernet Interface
  * @param  None
  * @retval None
  */
static void ETH_MACDMA_Config(void)
{
 8003b78:	b580      	push	{r7, lr}
 8003b7a:	b0b0      	sub	sp, #192	; 0xc0
 8003b7c:	af00      	add	r7, sp, #0
  ETH_InitTypeDef ETH_InitStructure;

  /* Enable ETHERNET clock  */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |
 8003b7e:	2101      	movs	r1, #1
 8003b80:	f04f 6060 	mov.w	r0, #234881024	; 0xe000000
 8003b84:	f000 fec6 	bl	8004914 <RCC_AHB1PeriphClockCmd>
                        RCC_AHB1Periph_ETH_MAC_Rx, ENABLE);
                        
  /* Reset ETHERNET on AHB Bus */
  ETH_DeInit();
 8003b88:	f7ff f921 	bl	8002dce <ETH_DeInit>

  /* Software reset */
  ETH_SoftwareReset();
 8003b8c:	f7ff fe4a 	bl	8003824 <ETH_SoftwareReset>

  /* Wait for software reset */
  while (ETH_GetSoftwareResetStatus() == SET);
 8003b90:	bf00      	nop
 8003b92:	f7ff fe5b 	bl	800384c <ETH_GetSoftwareResetStatus>
 8003b96:	4603      	mov	r3, r0
 8003b98:	2b01      	cmp	r3, #1
 8003b9a:	d0fa      	beq.n	8003b92 <ETH_MACDMA_Config+0x1a>

  /* ETHERNET Configuration --------------------------------------------------*/
  /* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */
  ETH_StructInit(&ETH_InitStructure);
 8003b9c:	1d3b      	adds	r3, r7, #4
 8003b9e:	4618      	mov	r0, r3
 8003ba0:	f7ff f923 	bl	8002dea <ETH_StructInit>

  /* Fill ETH_InitStructure parametrs */
  /*------------------------   MAC   -----------------------------------*/
  ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
 8003ba4:	2301      	movs	r3, #1
 8003ba6:	607b      	str	r3, [r7, #4]
  //ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
  //  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
  //  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;   

  ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
 8003ba8:	2300      	movs	r3, #0
 8003baa:	623b      	str	r3, [r7, #32]
  ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
 8003bac:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003bb0:	62fb      	str	r3, [r7, #44]	; 0x2c
  ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
 8003bb2:	2300      	movs	r3, #0
 8003bb4:	633b      	str	r3, [r7, #48]	; 0x30
  ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Disable;
 8003bb6:	2300      	movs	r3, #0
 8003bb8:	63fb      	str	r3, [r7, #60]	; 0x3c
  ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
 8003bba:	2300      	movs	r3, #0
 8003bbc:	64bb      	str	r3, [r7, #72]	; 0x48
  ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
 8003bbe:	2300      	movs	r3, #0
 8003bc0:	653b      	str	r3, [r7, #80]	; 0x50
  ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
 8003bc2:	2300      	movs	r3, #0
 8003bc4:	657b      	str	r3, [r7, #84]	; 0x54
  ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
 8003bc6:	2300      	movs	r3, #0
 8003bc8:	65bb      	str	r3, [r7, #88]	; 0x58
  /*------------------------   DMA   -----------------------------------*/  
  
  /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
  the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
  if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
  ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
 8003bca:	2300      	movs	r3, #0
 8003bcc:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
 8003bd0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8003bd4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
 8003bd8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003bdc:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 
  ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
 8003be0:	2300      	movs	r3, #0
 8003be2:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;   
 8003be6:	2300      	movs	r3, #0
 8003be8:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
 8003bec:	2304      	movs	r3, #4
 8003bee:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;      
 8003bf2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8003bf6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;                
 8003bfa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003bfe:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;          
 8003c02:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8003c06:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 8003c0a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8003c0e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
 8003c12:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8003c16:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

  /* Configure Ethernet */
  EthInitStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 8003c1a:	1d3b      	adds	r3, r7, #4
 8003c1c:	2101      	movs	r1, #1
 8003c1e:	4618      	mov	r0, r3
 8003c20:	f7ff f992 	bl	8002f48 <ETH_Init>
 8003c24:	4602      	mov	r2, r0
 8003c26:	4b03      	ldr	r3, [pc, #12]	; (8003c34 <ETH_MACDMA_Config+0xbc>)
 8003c28:	601a      	str	r2, [r3, #0]
}
 8003c2a:	bf00      	nop
 8003c2c:	37c0      	adds	r7, #192	; 0xc0
 8003c2e:	46bd      	mov	sp, r7
 8003c30:	bd80      	pop	{r7, pc}
 8003c32:	bf00      	nop
 8003c34:	200025cc 	.word	0x200025cc

08003c38 <ETH_GPIO_Config>:
  * @brief  Configures the different GPIO ports.
  * @param  None
  * @retval None
  */
void ETH_GPIO_Config(void)
{
 8003c38:	b580      	push	{r7, lr}
 8003c3a:	b082      	sub	sp, #8
 8003c3c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Enable GPIOs clocks */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB |
 8003c3e:	2101      	movs	r1, #1
 8003c40:	f240 10e7 	movw	r0, #487	; 0x1e7
 8003c44:	f000 fe66 	bl	8004914 <RCC_AHB1PeriphClockCmd>
                         RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOI |
                         RCC_AHB1Periph_GPIOG | RCC_AHB1Periph_GPIOH |
                         RCC_AHB1Periph_GPIOF, ENABLE);

  /* Enable SYSCFG clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);  
 8003c48:	2101      	movs	r1, #1
 8003c4a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003c4e:	f000 fe81 	bl	8004954 <RCC_APB2PeriphClockCmd>

  /* Configure MCO (PA8) */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 8003c52:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003c56:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8003c58:	2303      	movs	r3, #3
 8003c5a:	717b      	strb	r3, [r7, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003c5c:	2302      	movs	r3, #2
 8003c5e:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003c60:	2300      	movs	r3, #0
 8003c62:	71bb      	strb	r3, [r7, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;  
 8003c64:	2300      	movs	r3, #0
 8003c66:	71fb      	strb	r3, [r7, #7]
 #endif /* PHY_CLOCK_MCO */

  SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_MII);
#elif defined RMII_MODE  /* Mode RMII with STM324xG-EVAL */

  SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_RMII);
 8003c68:	2001      	movs	r0, #1
 8003c6a:	f000 fef5 	bl	8004a58 <SYSCFG_ETH_MediaInterfaceConfig>
        ETH_MII_TXD0/ETH_RMII_TXD0 -------> PG13
        ETH_MII_TXD1/ETH_RMII_TXD1 -------> PG14
                                                  */

  /* Configure PA1, PA2 and PA7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
 8003c6e:	2386      	movs	r3, #134	; 0x86
 8003c70:	603b      	str	r3, [r7, #0]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003c72:	463b      	mov	r3, r7
 8003c74:	4619      	mov	r1, r3
 8003c76:	4843      	ldr	r0, [pc, #268]	; (8003d84 <ETH_GPIO_Config+0x14c>)
 8003c78:	f000 fcb2 	bl	80045e0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
 8003c7c:	220b      	movs	r2, #11
 8003c7e:	2101      	movs	r1, #1
 8003c80:	4840      	ldr	r0, [pc, #256]	; (8003d84 <ETH_GPIO_Config+0x14c>)
 8003c82:	f000 fd55 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
 8003c86:	220b      	movs	r2, #11
 8003c88:	2102      	movs	r1, #2
 8003c8a:	483e      	ldr	r0, [pc, #248]	; (8003d84 <ETH_GPIO_Config+0x14c>)
 8003c8c:	f000 fd50 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);
 8003c90:	220b      	movs	r2, #11
 8003c92:	2107      	movs	r1, #7
 8003c94:	483b      	ldr	r0, [pc, #236]	; (8003d84 <ETH_GPIO_Config+0x14c>)
 8003c96:	f000 fd4b 	bl	8004730 <GPIO_PinAFConfig>

  /* Configure PB5 and PB8 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_8;
 8003c9a:	f44f 7390 	mov.w	r3, #288	; 0x120
 8003c9e:	603b      	str	r3, [r7, #0]
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8003ca0:	463b      	mov	r3, r7
 8003ca2:	4619      	mov	r1, r3
 8003ca4:	4838      	ldr	r0, [pc, #224]	; (8003d88 <ETH_GPIO_Config+0x150>)
 8003ca6:	f000 fc9b 	bl	80045e0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_ETH);	
 8003caa:	220b      	movs	r2, #11
 8003cac:	2105      	movs	r1, #5
 8003cae:	4836      	ldr	r0, [pc, #216]	; (8003d88 <ETH_GPIO_Config+0x150>)
 8003cb0:	f000 fd3e 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_ETH);
 8003cb4:	220b      	movs	r2, #11
 8003cb6:	2108      	movs	r1, #8
 8003cb8:	4833      	ldr	r0, [pc, #204]	; (8003d88 <ETH_GPIO_Config+0x150>)
 8003cba:	f000 fd39 	bl	8004730 <GPIO_PinAFConfig>

  /* Configure PC1, PC2, PC3, PC4 and PC5 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
 8003cbe:	233e      	movs	r3, #62	; 0x3e
 8003cc0:	603b      	str	r3, [r7, #0]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8003cc2:	463b      	mov	r3, r7
 8003cc4:	4619      	mov	r1, r3
 8003cc6:	4831      	ldr	r0, [pc, #196]	; (8003d8c <ETH_GPIO_Config+0x154>)
 8003cc8:	f000 fc8a 	bl	80045e0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH);
 8003ccc:	220b      	movs	r2, #11
 8003cce:	2101      	movs	r1, #1
 8003cd0:	482e      	ldr	r0, [pc, #184]	; (8003d8c <ETH_GPIO_Config+0x154>)
 8003cd2:	f000 fd2d 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource2, GPIO_AF_ETH);
 8003cd6:	220b      	movs	r2, #11
 8003cd8:	2102      	movs	r1, #2
 8003cda:	482c      	ldr	r0, [pc, #176]	; (8003d8c <ETH_GPIO_Config+0x154>)
 8003cdc:	f000 fd28 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource3, GPIO_AF_ETH);
 8003ce0:	220b      	movs	r2, #11
 8003ce2:	2103      	movs	r1, #3
 8003ce4:	4829      	ldr	r0, [pc, #164]	; (8003d8c <ETH_GPIO_Config+0x154>)
 8003ce6:	f000 fd23 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
 8003cea:	220b      	movs	r2, #11
 8003cec:	2104      	movs	r1, #4
 8003cee:	4827      	ldr	r0, [pc, #156]	; (8003d8c <ETH_GPIO_Config+0x154>)
 8003cf0:	f000 fd1e 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
 8003cf4:	220b      	movs	r2, #11
 8003cf6:	2105      	movs	r1, #5
 8003cf8:	4824      	ldr	r0, [pc, #144]	; (8003d8c <ETH_GPIO_Config+0x154>)
 8003cfa:	f000 fd19 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_Init(GPIOG, &GPIO_InitStructure);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource13, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_ETH);
*/
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
 8003cfe:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003d02:	603b      	str	r3, [r7, #0]
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 8003d04:	463b      	mov	r3, r7
 8003d06:	4619      	mov	r1, r3
 8003d08:	481f      	ldr	r0, [pc, #124]	; (8003d88 <ETH_GPIO_Config+0x150>)
 8003d0a:	f000 fc69 	bl	80045e0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_ETH);
 8003d0e:	220b      	movs	r2, #11
 8003d10:	210b      	movs	r1, #11
 8003d12:	481d      	ldr	r0, [pc, #116]	; (8003d88 <ETH_GPIO_Config+0x150>)
 8003d14:	f000 fd0c 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource12, GPIO_AF_ETH);
 8003d18:	220b      	movs	r2, #11
 8003d1a:	210c      	movs	r1, #12
 8003d1c:	481a      	ldr	r0, [pc, #104]	; (8003d88 <ETH_GPIO_Config+0x150>)
 8003d1e:	f000 fd07 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_ETH);
 8003d22:	220b      	movs	r2, #11
 8003d24:	210d      	movs	r1, #13
 8003d26:	4818      	ldr	r0, [pc, #96]	; (8003d88 <ETH_GPIO_Config+0x150>)
 8003d28:	f000 fd02 	bl	8004730 <GPIO_PinAFConfig>

  /* Configure PH2, PH3, PH6, PH7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;
 8003d2c:	23cc      	movs	r3, #204	; 0xcc
 8003d2e:	603b      	str	r3, [r7, #0]
  GPIO_Init(GPIOH, &GPIO_InitStructure);
 8003d30:	463b      	mov	r3, r7
 8003d32:	4619      	mov	r1, r3
 8003d34:	4816      	ldr	r0, [pc, #88]	; (8003d90 <ETH_GPIO_Config+0x158>)
 8003d36:	f000 fc53 	bl	80045e0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource2, GPIO_AF_ETH);
 8003d3a:	220b      	movs	r2, #11
 8003d3c:	2102      	movs	r1, #2
 8003d3e:	4814      	ldr	r0, [pc, #80]	; (8003d90 <ETH_GPIO_Config+0x158>)
 8003d40:	f000 fcf6 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource3, GPIO_AF_ETH);
 8003d44:	220b      	movs	r2, #11
 8003d46:	2103      	movs	r1, #3
 8003d48:	4811      	ldr	r0, [pc, #68]	; (8003d90 <ETH_GPIO_Config+0x158>)
 8003d4a:	f000 fcf1 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource6, GPIO_AF_ETH);
 8003d4e:	220b      	movs	r2, #11
 8003d50:	2106      	movs	r1, #6
 8003d52:	480f      	ldr	r0, [pc, #60]	; (8003d90 <ETH_GPIO_Config+0x158>)
 8003d54:	f000 fcec 	bl	8004730 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOH, GPIO_PinSource7, GPIO_AF_ETH);
 8003d58:	220b      	movs	r2, #11
 8003d5a:	2107      	movs	r1, #7
 8003d5c:	480c      	ldr	r0, [pc, #48]	; (8003d90 <ETH_GPIO_Config+0x158>)
 8003d5e:	f000 fce7 	bl	8004730 <GPIO_PinAFConfig>

  /* Configure PI10 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 8003d62:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003d66:	603b      	str	r3, [r7, #0]
  GPIO_Init(GPIOI, &GPIO_InitStructure);
 8003d68:	463b      	mov	r3, r7
 8003d6a:	4619      	mov	r1, r3
 8003d6c:	4809      	ldr	r0, [pc, #36]	; (8003d94 <ETH_GPIO_Config+0x15c>)
 8003d6e:	f000 fc37 	bl	80045e0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOI, GPIO_PinSource10, GPIO_AF_ETH);
 8003d72:	220b      	movs	r2, #11
 8003d74:	210a      	movs	r1, #10
 8003d76:	4807      	ldr	r0, [pc, #28]	; (8003d94 <ETH_GPIO_Config+0x15c>)
 8003d78:	f000 fcda 	bl	8004730 <GPIO_PinAFConfig>
}
 8003d7c:	bf00      	nop
 8003d7e:	3708      	adds	r7, #8
 8003d80:	46bd      	mov	sp, r7
 8003d82:	bd80      	pop	{r7, pc}
 8003d84:	40020000 	.word	0x40020000
 8003d88:	40020400 	.word	0x40020400
 8003d8c:	40020800 	.word	0x40020800
 8003d90:	40021c00 	.word	0x40021c00
 8003d94:	40022000 	.word	0x40022000

08003d98 <Eth_Link_PHYITConfig>:
  * @brief  Configure the PHY to generate an interrupt on change of link status.
  * @param PHYAddress: external PHY address  
  * @retval None
  */
uint32_t Eth_Link_PHYITConfig(uint16_t PHYAddress)
{
 8003d98:	b580      	push	{r7, lr}
 8003d9a:	b084      	sub	sp, #16
 8003d9c:	af00      	add	r7, sp, #0
 8003d9e:	4603      	mov	r3, r0
 8003da0:	80fb      	strh	r3, [r7, #6]
  uint32_t tmpreg = 0;
 8003da2:	2300      	movs	r3, #0
 8003da4:	60fb      	str	r3, [r7, #12]

  /* Read MICR register */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MICR);
 8003da6:	88fb      	ldrh	r3, [r7, #6]
 8003da8:	2111      	movs	r1, #17
 8003daa:	4618      	mov	r0, r3
 8003dac:	f7ff fdd4 	bl	8003958 <ETH_ReadPHYRegister>
 8003db0:	4603      	mov	r3, r0
 8003db2:	60fb      	str	r3, [r7, #12]

  /* Enable output interrupt events to signal via the INT pin */
  tmpreg |= (uint32_t)PHY_MICR_INT_EN | PHY_MICR_INT_OE;
 8003db4:	68fb      	ldr	r3, [r7, #12]
 8003db6:	f043 0303 	orr.w	r3, r3, #3
 8003dba:	60fb      	str	r3, [r7, #12]
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_MICR, tmpreg)))
 8003dbc:	68fb      	ldr	r3, [r7, #12]
 8003dbe:	b29a      	uxth	r2, r3
 8003dc0:	88fb      	ldrh	r3, [r7, #6]
 8003dc2:	2111      	movs	r1, #17
 8003dc4:	4618      	mov	r0, r3
 8003dc6:	f7ff fe17 	bl	80039f8 <ETH_WritePHYRegister>
 8003dca:	4603      	mov	r3, r0
 8003dcc:	2b00      	cmp	r3, #0
 8003dce:	d101      	bne.n	8003dd4 <Eth_Link_PHYITConfig+0x3c>
  {
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
 8003dd0:	2300      	movs	r3, #0
 8003dd2:	e017      	b.n	8003e04 <Eth_Link_PHYITConfig+0x6c>
  }

  /* Read MISR register */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MISR);
 8003dd4:	88fb      	ldrh	r3, [r7, #6]
 8003dd6:	2112      	movs	r1, #18
 8003dd8:	4618      	mov	r0, r3
 8003dda:	f7ff fdbd 	bl	8003958 <ETH_ReadPHYRegister>
 8003dde:	4603      	mov	r3, r0
 8003de0:	60fb      	str	r3, [r7, #12]

  /* Enable Interrupt on change of link status */
  tmpreg |= (uint32_t)PHY_MISR_LINK_INT_EN;
 8003de2:	68fb      	ldr	r3, [r7, #12]
 8003de4:	f043 0320 	orr.w	r3, r3, #32
 8003de8:	60fb      	str	r3, [r7, #12]
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_MISR, tmpreg)))
 8003dea:	68fb      	ldr	r3, [r7, #12]
 8003dec:	b29a      	uxth	r2, r3
 8003dee:	88fb      	ldrh	r3, [r7, #6]
 8003df0:	2112      	movs	r1, #18
 8003df2:	4618      	mov	r0, r3
 8003df4:	f7ff fe00 	bl	80039f8 <ETH_WritePHYRegister>
 8003df8:	4603      	mov	r3, r0
 8003dfa:	2b00      	cmp	r3, #0
 8003dfc:	d101      	bne.n	8003e02 <Eth_Link_PHYITConfig+0x6a>
  {
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
 8003dfe:	2300      	movs	r3, #0
 8003e00:	e000      	b.n	8003e04 <Eth_Link_PHYITConfig+0x6c>
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;   
 8003e02:	2301      	movs	r3, #1
}
 8003e04:	4618      	mov	r0, r3
 8003e06:	3710      	adds	r7, #16
 8003e08:	46bd      	mov	sp, r7
 8003e0a:	bd80      	pop	{r7, pc}

08003e0c <Eth_Link_EXTIConfig>:
  * @brief  EXTI configuration for Ethernet link status.
  * @param PHYAddress: external PHY address  
  * @retval None
  */
void Eth_Link_EXTIConfig(void)
{
 8003e0c:	b580      	push	{r7, lr}
 8003e0e:	b086      	sub	sp, #24
 8003e10:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the INT (PB14) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
 8003e12:	2101      	movs	r1, #1
 8003e14:	2002      	movs	r0, #2
 8003e16:	f000 fd7d 	bl	8004914 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8003e1a:	2101      	movs	r1, #1
 8003e1c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003e20:	f000 fd98 	bl	8004954 <RCC_APB2PeriphClockCmd>

  /* Configure INT pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8003e24:	2300      	movs	r3, #0
 8003e26:	753b      	strb	r3, [r7, #20]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003e28:	2300      	movs	r3, #0
 8003e2a:	75fb      	strb	r3, [r7, #23]
  GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
 8003e2c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8003e30:	613b      	str	r3, [r7, #16]
  GPIO_Init(ETH_LINK_GPIO_PORT, &GPIO_InitStructure);
 8003e32:	f107 0310 	add.w	r3, r7, #16
 8003e36:	4619      	mov	r1, r3
 8003e38:	4814      	ldr	r0, [pc, #80]	; (8003e8c <Eth_Link_EXTIConfig+0x80>)
 8003e3a:	f000 fbd1 	bl	80045e0 <GPIO_Init>

  /* Connect EXTI Line to INT Pin */
  SYSCFG_EXTILineConfig(ETH_LINK_EXTI_PORT_SOURCE, ETH_LINK_EXTI_PIN_SOURCE);
 8003e3e:	210e      	movs	r1, #14
 8003e40:	2001      	movs	r0, #1
 8003e42:	f000 fdc7 	bl	80049d4 <SYSCFG_EXTILineConfig>

  /* Configure EXTI line */
  EXTI_InitStructure.EXTI_Line = ETH_LINK_EXTI_LINE;
 8003e46:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8003e4a:	60bb      	str	r3, [r7, #8]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8003e4c:	2300      	movs	r3, #0
 8003e4e:	733b      	strb	r3, [r7, #12]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
 8003e50:	230c      	movs	r3, #12
 8003e52:	737b      	strb	r3, [r7, #13]
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8003e54:	2301      	movs	r3, #1
 8003e56:	73bb      	strb	r3, [r7, #14]
  EXTI_Init(&EXTI_InitStructure);
 8003e58:	f107 0308 	add.w	r3, r7, #8
 8003e5c:	4618      	mov	r0, r3
 8003e5e:	f000 fb19 	bl	8004494 <EXTI_Init>

  /* Enable and set the EXTI interrupt to the highest priority */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
 8003e62:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 8003e66:	f000 f8e1 	bl	800402c <NVIC_PriorityGroupConfig>
  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 8003e6a:	2328      	movs	r3, #40	; 0x28
 8003e6c:	713b      	strb	r3, [r7, #4]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8003e6e:	2300      	movs	r3, #0
 8003e70:	717b      	strb	r3, [r7, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8003e72:	2300      	movs	r3, #0
 8003e74:	71bb      	strb	r3, [r7, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003e76:	2301      	movs	r3, #1
 8003e78:	71fb      	strb	r3, [r7, #7]
  NVIC_Init(&NVIC_InitStructure);
 8003e7a:	1d3b      	adds	r3, r7, #4
 8003e7c:	4618      	mov	r0, r3
 8003e7e:	f000 f8e9 	bl	8004054 <NVIC_Init>
}
 8003e82:	bf00      	nop
 8003e84:	3718      	adds	r7, #24
 8003e86:	46bd      	mov	sp, r7
 8003e88:	bd80      	pop	{r7, pc}
 8003e8a:	bf00      	nop
 8003e8c:	40020400 	.word	0x40020400

08003e90 <Eth_Link_ITHandler>:
  * @brief  This function handles Ethernet link status.
  * @param  None
  * @retval None
  */
void Eth_Link_ITHandler(uint16_t PHYAddress)
{
 8003e90:	b580      	push	{r7, lr}
 8003e92:	b082      	sub	sp, #8
 8003e94:	af00      	add	r7, sp, #0
 8003e96:	4603      	mov	r3, r0
 8003e98:	80fb      	strh	r3, [r7, #6]
  /* Check whether the link interrupt has occurred or not */
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
 8003e9a:	88fb      	ldrh	r3, [r7, #6]
 8003e9c:	2112      	movs	r1, #18
 8003e9e:	4618      	mov	r0, r3
 8003ea0:	f7ff fd5a 	bl	8003958 <ETH_ReadPHYRegister>
 8003ea4:	4603      	mov	r3, r0
 8003ea6:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8003eaa:	2b00      	cmp	r3, #0
 8003eac:	d006      	beq.n	8003ebc <Eth_Link_ITHandler+0x2c>
  {
    EthLinkStatus = ~EthLinkStatus;
 8003eae:	4b05      	ldr	r3, [pc, #20]	; (8003ec4 <Eth_Link_ITHandler+0x34>)
 8003eb0:	781b      	ldrb	r3, [r3, #0]
 8003eb2:	b2db      	uxtb	r3, r3
 8003eb4:	43db      	mvns	r3, r3
 8003eb6:	b2da      	uxtb	r2, r3
 8003eb8:	4b02      	ldr	r3, [pc, #8]	; (8003ec4 <Eth_Link_ITHandler+0x34>)
 8003eba:	701a      	strb	r2, [r3, #0]
      LCD_DisplayStringLine(Line5, (uint8_t*)"  Network Cable is  ");
      LCD_DisplayStringLine(Line6, (uint8_t*)"   now connected    ");
    }
#endif
  }
}
 8003ebc:	bf00      	nop
 8003ebe:	3708      	adds	r7, #8
 8003ec0:	46bd      	mov	sp, r7
 8003ec2:	bd80      	pop	{r7, pc}
 8003ec4:	200025d0 	.word	0x200025d0

08003ec8 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8003ec8:	b580      	push	{r7, lr}
 8003eca:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003ecc:	4a16      	ldr	r2, [pc, #88]	; (8003f28 <SystemInit+0x60>)
 8003ece:	4b16      	ldr	r3, [pc, #88]	; (8003f28 <SystemInit+0x60>)
 8003ed0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003ed4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003ed8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003edc:	4a13      	ldr	r2, [pc, #76]	; (8003f2c <SystemInit+0x64>)
 8003ede:	4b13      	ldr	r3, [pc, #76]	; (8003f2c <SystemInit+0x64>)
 8003ee0:	681b      	ldr	r3, [r3, #0]
 8003ee2:	f043 0301 	orr.w	r3, r3, #1
 8003ee6:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003ee8:	4b10      	ldr	r3, [pc, #64]	; (8003f2c <SystemInit+0x64>)
 8003eea:	2200      	movs	r2, #0
 8003eec:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003eee:	4a0f      	ldr	r2, [pc, #60]	; (8003f2c <SystemInit+0x64>)
 8003ef0:	4b0e      	ldr	r3, [pc, #56]	; (8003f2c <SystemInit+0x64>)
 8003ef2:	681b      	ldr	r3, [r3, #0]
 8003ef4:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 8003ef8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003efc:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8003efe:	4b0b      	ldr	r3, [pc, #44]	; (8003f2c <SystemInit+0x64>)
 8003f00:	4a0b      	ldr	r2, [pc, #44]	; (8003f30 <SystemInit+0x68>)
 8003f02:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003f04:	4a09      	ldr	r2, [pc, #36]	; (8003f2c <SystemInit+0x64>)
 8003f06:	4b09      	ldr	r3, [pc, #36]	; (8003f2c <SystemInit+0x64>)
 8003f08:	681b      	ldr	r3, [r3, #0]
 8003f0a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003f0e:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8003f10:	4b06      	ldr	r3, [pc, #24]	; (8003f2c <SystemInit+0x64>)
 8003f12:	2200      	movs	r2, #0
 8003f14:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 8003f16:	f000 f80d 	bl	8003f34 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8003f1a:	4b03      	ldr	r3, [pc, #12]	; (8003f28 <SystemInit+0x60>)
 8003f1c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8003f20:	609a      	str	r2, [r3, #8]
#endif
}
 8003f22:	bf00      	nop
 8003f24:	bd80      	pop	{r7, pc}
 8003f26:	bf00      	nop
 8003f28:	e000ed00 	.word	0xe000ed00
 8003f2c:	40023800 	.word	0x40023800
 8003f30:	24003010 	.word	0x24003010

08003f34 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8003f34:	b480      	push	{r7}
 8003f36:	b083      	sub	sp, #12
 8003f38:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8003f3a:	2300      	movs	r3, #0
 8003f3c:	607b      	str	r3, [r7, #4]
 8003f3e:	2300      	movs	r3, #0
 8003f40:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8003f42:	4a36      	ldr	r2, [pc, #216]	; (800401c <SetSysClock+0xe8>)
 8003f44:	4b35      	ldr	r3, [pc, #212]	; (800401c <SetSysClock+0xe8>)
 8003f46:	681b      	ldr	r3, [r3, #0]
 8003f48:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003f4c:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8003f4e:	4b33      	ldr	r3, [pc, #204]	; (800401c <SetSysClock+0xe8>)
 8003f50:	681b      	ldr	r3, [r3, #0]
 8003f52:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003f56:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 8003f58:	687b      	ldr	r3, [r7, #4]
 8003f5a:	3301      	adds	r3, #1
 8003f5c:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8003f5e:	683b      	ldr	r3, [r7, #0]
 8003f60:	2b00      	cmp	r3, #0
 8003f62:	d103      	bne.n	8003f6c <SetSysClock+0x38>
 8003f64:	687b      	ldr	r3, [r7, #4]
 8003f66:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8003f6a:	d1f0      	bne.n	8003f4e <SetSysClock+0x1a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8003f6c:	4b2b      	ldr	r3, [pc, #172]	; (800401c <SetSysClock+0xe8>)
 8003f6e:	681b      	ldr	r3, [r3, #0]
 8003f70:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003f74:	2b00      	cmp	r3, #0
 8003f76:	d002      	beq.n	8003f7e <SetSysClock+0x4a>
  {
    HSEStatus = (uint32_t)0x01;
 8003f78:	2301      	movs	r3, #1
 8003f7a:	603b      	str	r3, [r7, #0]
 8003f7c:	e001      	b.n	8003f82 <SetSysClock+0x4e>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8003f7e:	2300      	movs	r3, #0
 8003f80:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 8003f82:	683b      	ldr	r3, [r7, #0]
 8003f84:	2b01      	cmp	r3, #1
 8003f86:	d142      	bne.n	800400e <SetSysClock+0xda>
  {
    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8003f88:	4a24      	ldr	r2, [pc, #144]	; (800401c <SetSysClock+0xe8>)
 8003f8a:	4b24      	ldr	r3, [pc, #144]	; (800401c <SetSysClock+0xe8>)
 8003f8c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003f8e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003f92:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_VOS;
 8003f94:	4a22      	ldr	r2, [pc, #136]	; (8004020 <SetSysClock+0xec>)
 8003f96:	4b22      	ldr	r3, [pc, #136]	; (8004020 <SetSysClock+0xec>)
 8003f98:	681b      	ldr	r3, [r3, #0]
 8003f9a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003f9e:	6013      	str	r3, [r2, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8003fa0:	4a1e      	ldr	r2, [pc, #120]	; (800401c <SetSysClock+0xe8>)
 8003fa2:	4b1e      	ldr	r3, [pc, #120]	; (800401c <SetSysClock+0xe8>)
 8003fa4:	689b      	ldr	r3, [r3, #8]
 8003fa6:	6093      	str	r3, [r2, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8003fa8:	4a1c      	ldr	r2, [pc, #112]	; (800401c <SetSysClock+0xe8>)
 8003faa:	4b1c      	ldr	r3, [pc, #112]	; (800401c <SetSysClock+0xe8>)
 8003fac:	689b      	ldr	r3, [r3, #8]
 8003fae:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003fb2:	6093      	str	r3, [r2, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8003fb4:	4a19      	ldr	r2, [pc, #100]	; (800401c <SetSysClock+0xe8>)
 8003fb6:	4b19      	ldr	r3, [pc, #100]	; (800401c <SetSysClock+0xe8>)
 8003fb8:	689b      	ldr	r3, [r3, #8]
 8003fba:	f443 53a0 	orr.w	r3, r3, #5120	; 0x1400
 8003fbe:	6093      	str	r3, [r2, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8003fc0:	4b16      	ldr	r3, [pc, #88]	; (800401c <SetSysClock+0xe8>)
 8003fc2:	4a18      	ldr	r2, [pc, #96]	; (8004024 <SetSysClock+0xf0>)
 8003fc4:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8003fc6:	4a15      	ldr	r2, [pc, #84]	; (800401c <SetSysClock+0xe8>)
 8003fc8:	4b14      	ldr	r3, [pc, #80]	; (800401c <SetSysClock+0xe8>)
 8003fca:	681b      	ldr	r3, [r3, #0]
 8003fcc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003fd0:	6013      	str	r3, [r2, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8003fd2:	bf00      	nop
 8003fd4:	4b11      	ldr	r3, [pc, #68]	; (800401c <SetSysClock+0xe8>)
 8003fd6:	681b      	ldr	r3, [r3, #0]
 8003fd8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003fdc:	2b00      	cmp	r3, #0
 8003fde:	d0f9      	beq.n	8003fd4 <SetSysClock+0xa0>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8003fe0:	4b11      	ldr	r3, [pc, #68]	; (8004028 <SetSysClock+0xf4>)
 8003fe2:	f240 6205 	movw	r2, #1541	; 0x605
 8003fe6:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8003fe8:	4a0c      	ldr	r2, [pc, #48]	; (800401c <SetSysClock+0xe8>)
 8003fea:	4b0c      	ldr	r3, [pc, #48]	; (800401c <SetSysClock+0xe8>)
 8003fec:	689b      	ldr	r3, [r3, #8]
 8003fee:	f023 0303 	bic.w	r3, r3, #3
 8003ff2:	6093      	str	r3, [r2, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 8003ff4:	4a09      	ldr	r2, [pc, #36]	; (800401c <SetSysClock+0xe8>)
 8003ff6:	4b09      	ldr	r3, [pc, #36]	; (800401c <SetSysClock+0xe8>)
 8003ff8:	689b      	ldr	r3, [r3, #8]
 8003ffa:	f043 0302 	orr.w	r3, r3, #2
 8003ffe:	6093      	str	r3, [r2, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL)
 8004000:	bf00      	nop
 8004002:	4b06      	ldr	r3, [pc, #24]	; (800401c <SetSysClock+0xe8>)
 8004004:	689b      	ldr	r3, [r3, #8]
 8004006:	f003 030c 	and.w	r3, r3, #12
 800400a:	2b08      	cmp	r3, #8
 800400c:	d1f9      	bne.n	8004002 <SetSysClock+0xce>
  else
  { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }

}
 800400e:	bf00      	nop
 8004010:	370c      	adds	r7, #12
 8004012:	46bd      	mov	sp, r7
 8004014:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004018:	4770      	bx	lr
 800401a:	bf00      	nop
 800401c:	40023800 	.word	0x40023800
 8004020:	40007000 	.word	0x40007000
 8004024:	07405408 	.word	0x07405408
 8004028:	40023c00 	.word	0x40023c00

0800402c <NVIC_PriorityGroupConfig>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 800402c:	b480      	push	{r7}
 800402e:	b083      	sub	sp, #12
 8004030:	af00      	add	r7, sp, #0
 8004032:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8004034:	4a06      	ldr	r2, [pc, #24]	; (8004050 <NVIC_PriorityGroupConfig+0x24>)
 8004036:	687b      	ldr	r3, [r7, #4]
 8004038:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800403c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004040:	60d3      	str	r3, [r2, #12]
}
 8004042:	bf00      	nop
 8004044:	370c      	adds	r7, #12
 8004046:	46bd      	mov	sp, r7
 8004048:	f85d 7b04 	ldr.w	r7, [sp], #4
 800404c:	4770      	bx	lr
 800404e:	bf00      	nop
 8004050:	e000ed00 	.word	0xe000ed00

08004054 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8004054:	b480      	push	{r7}
 8004056:	b085      	sub	sp, #20
 8004058:	af00      	add	r7, sp, #0
 800405a:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 800405c:	2300      	movs	r3, #0
 800405e:	73fb      	strb	r3, [r7, #15]
 8004060:	2300      	movs	r3, #0
 8004062:	73bb      	strb	r3, [r7, #14]
 8004064:	230f      	movs	r3, #15
 8004066:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8004068:	687b      	ldr	r3, [r7, #4]
 800406a:	78db      	ldrb	r3, [r3, #3]
 800406c:	2b00      	cmp	r3, #0
 800406e:	d039      	beq.n	80040e4 <NVIC_Init+0x90>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8004070:	4b27      	ldr	r3, [pc, #156]	; (8004110 <NVIC_Init+0xbc>)
 8004072:	68db      	ldr	r3, [r3, #12]
 8004074:	43db      	mvns	r3, r3
 8004076:	0a1b      	lsrs	r3, r3, #8
 8004078:	b2db      	uxtb	r3, r3
 800407a:	f003 0307 	and.w	r3, r3, #7
 800407e:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 8004080:	7bfb      	ldrb	r3, [r7, #15]
 8004082:	f1c3 0304 	rsb	r3, r3, #4
 8004086:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 8004088:	7b7a      	ldrb	r2, [r7, #13]
 800408a:	7bfb      	ldrb	r3, [r7, #15]
 800408c:	fa42 f303 	asr.w	r3, r2, r3
 8004090:	737b      	strb	r3, [r7, #13]

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8004092:	687b      	ldr	r3, [r7, #4]
 8004094:	785b      	ldrb	r3, [r3, #1]
 8004096:	461a      	mov	r2, r3
 8004098:	7bbb      	ldrb	r3, [r7, #14]
 800409a:	fa02 f303 	lsl.w	r3, r2, r3
 800409e:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80040a0:	687b      	ldr	r3, [r7, #4]
 80040a2:	789a      	ldrb	r2, [r3, #2]
 80040a4:	7b7b      	ldrb	r3, [r7, #13]
 80040a6:	4013      	ands	r3, r2
 80040a8:	b2da      	uxtb	r2, r3
 80040aa:	7bfb      	ldrb	r3, [r7, #15]
 80040ac:	4313      	orrs	r3, r2
 80040ae:	73fb      	strb	r3, [r7, #15]
        
    tmppriority = tmppriority << 0x04;
 80040b0:	7bfb      	ldrb	r3, [r7, #15]
 80040b2:	011b      	lsls	r3, r3, #4
 80040b4:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80040b6:	4a17      	ldr	r2, [pc, #92]	; (8004114 <NVIC_Init+0xc0>)
 80040b8:	687b      	ldr	r3, [r7, #4]
 80040ba:	781b      	ldrb	r3, [r3, #0]
 80040bc:	4413      	add	r3, r2
 80040be:	7bfa      	ldrb	r2, [r7, #15]
 80040c0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80040c4:	4a13      	ldr	r2, [pc, #76]	; (8004114 <NVIC_Init+0xc0>)
 80040c6:	687b      	ldr	r3, [r7, #4]
 80040c8:	781b      	ldrb	r3, [r3, #0]
 80040ca:	095b      	lsrs	r3, r3, #5
 80040cc:	b2db      	uxtb	r3, r3
 80040ce:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80040d0:	687b      	ldr	r3, [r7, #4]
 80040d2:	781b      	ldrb	r3, [r3, #0]
 80040d4:	f003 031f 	and.w	r3, r3, #31
 80040d8:	2101      	movs	r1, #1
 80040da:	fa01 f303 	lsl.w	r3, r1, r3
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80040de:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 80040e2:	e00f      	b.n	8004104 <NVIC_Init+0xb0>
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80040e4:	490b      	ldr	r1, [pc, #44]	; (8004114 <NVIC_Init+0xc0>)
 80040e6:	687b      	ldr	r3, [r7, #4]
 80040e8:	781b      	ldrb	r3, [r3, #0]
 80040ea:	095b      	lsrs	r3, r3, #5
 80040ec:	b2db      	uxtb	r3, r3
 80040ee:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80040f0:	687b      	ldr	r3, [r7, #4]
 80040f2:	781b      	ldrb	r3, [r3, #0]
 80040f4:	f003 031f 	and.w	r3, r3, #31
 80040f8:	2201      	movs	r2, #1
 80040fa:	409a      	lsls	r2, r3
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80040fc:	f100 0320 	add.w	r3, r0, #32
 8004100:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8004104:	bf00      	nop
 8004106:	3714      	adds	r7, #20
 8004108:	46bd      	mov	sp, r7
 800410a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800410e:	4770      	bx	lr
 8004110:	e000ed00 	.word	0xe000ed00
 8004114:	e000e100 	.word	0xe000e100

08004118 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8004118:	b480      	push	{r7}
 800411a:	b083      	sub	sp, #12
 800411c:	af00      	add	r7, sp, #0
 800411e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8004120:	687b      	ldr	r3, [r7, #4]
 8004122:	2b04      	cmp	r3, #4
 8004124:	d106      	bne.n	8004134 <SysTick_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8004126:	4a09      	ldr	r2, [pc, #36]	; (800414c <SysTick_CLKSourceConfig+0x34>)
 8004128:	4b08      	ldr	r3, [pc, #32]	; (800414c <SysTick_CLKSourceConfig+0x34>)
 800412a:	681b      	ldr	r3, [r3, #0]
 800412c:	f043 0304 	orr.w	r3, r3, #4
 8004130:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
  }
}
 8004132:	e005      	b.n	8004140 <SysTick_CLKSourceConfig+0x28>
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8004134:	4a05      	ldr	r2, [pc, #20]	; (800414c <SysTick_CLKSourceConfig+0x34>)
 8004136:	4b05      	ldr	r3, [pc, #20]	; (800414c <SysTick_CLKSourceConfig+0x34>)
 8004138:	681b      	ldr	r3, [r3, #0]
 800413a:	f023 0304 	bic.w	r3, r3, #4
 800413e:	6013      	str	r3, [r2, #0]
}
 8004140:	bf00      	nop
 8004142:	370c      	adds	r7, #12
 8004144:	46bd      	mov	sp, r7
 8004146:	f85d 7b04 	ldr.w	r7, [sp], #4
 800414a:	4770      	bx	lr
 800414c:	e000e010 	.word	0xe000e010

08004150 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8004150:	b480      	push	{r7}
 8004152:	b085      	sub	sp, #20
 8004154:	af00      	add	r7, sp, #0
 8004156:	6078      	str	r0, [r7, #4]
 8004158:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0;
 800415a:	2300      	movs	r3, #0
 800415c:	60fb      	str	r3, [r7, #12]
  uint8_t tmpreg2 = 0;
 800415e:	2300      	movs	r3, #0
 8004160:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8004162:	687b      	ldr	r3, [r7, #4]
 8004164:	685b      	ldr	r3, [r3, #4]
 8004166:	60fb      	str	r3, [r7, #12]
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 8004168:	68fb      	ldr	r3, [r7, #12]
 800416a:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 800416e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004172:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8004174:	683b      	ldr	r3, [r7, #0]
 8004176:	791b      	ldrb	r3, [r3, #4]
 8004178:	021a      	lsls	r2, r3, #8
                                   ADC_InitStruct->ADC_Resolution);
 800417a:	683b      	ldr	r3, [r7, #0]
 800417c:	681b      	ldr	r3, [r3, #0]
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 800417e:	4313      	orrs	r3, r2
 8004180:	68fa      	ldr	r2, [r7, #12]
 8004182:	4313      	orrs	r3, r2
 8004184:	60fb      	str	r3, [r7, #12]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8004186:	687b      	ldr	r3, [r7, #4]
 8004188:	68fa      	ldr	r2, [r7, #12]
 800418a:	605a      	str	r2, [r3, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 800418c:	687b      	ldr	r3, [r7, #4]
 800418e:	689b      	ldr	r3, [r3, #8]
 8004190:	60fb      	str	r3, [r7, #12]
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 8004192:	68fa      	ldr	r2, [r7, #12]
 8004194:	4b18      	ldr	r3, [pc, #96]	; (80041f8 <ADC_Init+0xa8>)
 8004196:	4013      	ands	r3, r2
 8004198:	60fb      	str	r3, [r7, #12]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 800419a:	683b      	ldr	r3, [r7, #0]
 800419c:	691a      	ldr	r2, [r3, #16]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 800419e:	683b      	ldr	r3, [r7, #0]
 80041a0:	68db      	ldr	r3, [r3, #12]
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80041a2:	431a      	orrs	r2, r3
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
 80041a4:	683b      	ldr	r3, [r7, #0]
 80041a6:	689b      	ldr	r3, [r3, #8]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 80041a8:	431a      	orrs	r2, r3
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 80041aa:	683b      	ldr	r3, [r7, #0]
 80041ac:	795b      	ldrb	r3, [r3, #5]
 80041ae:	005b      	lsls	r3, r3, #1
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80041b0:	4313      	orrs	r3, r2
 80041b2:	68fa      	ldr	r2, [r7, #12]
 80041b4:	4313      	orrs	r3, r2
 80041b6:	60fb      	str	r3, [r7, #12]
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 80041b8:	687b      	ldr	r3, [r7, #4]
 80041ba:	68fa      	ldr	r2, [r7, #12]
 80041bc:	609a      	str	r2, [r3, #8]
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 80041be:	687b      	ldr	r3, [r7, #4]
 80041c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80041c2:	60fb      	str	r3, [r7, #12]
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 80041c4:	68fb      	ldr	r3, [r7, #12]
 80041c6:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80041ca:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 80041cc:	683b      	ldr	r3, [r7, #0]
 80041ce:	7d1b      	ldrb	r3, [r3, #20]
 80041d0:	3b01      	subs	r3, #1
 80041d2:	b2da      	uxtb	r2, r3
 80041d4:	7afb      	ldrb	r3, [r7, #11]
 80041d6:	4313      	orrs	r3, r2
 80041d8:	72fb      	strb	r3, [r7, #11]
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 80041da:	7afb      	ldrb	r3, [r7, #11]
 80041dc:	051b      	lsls	r3, r3, #20
 80041de:	68fa      	ldr	r2, [r7, #12]
 80041e0:	4313      	orrs	r3, r2
 80041e2:	60fb      	str	r3, [r7, #12]
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 80041e4:	687b      	ldr	r3, [r7, #4]
 80041e6:	68fa      	ldr	r2, [r7, #12]
 80041e8:	62da      	str	r2, [r3, #44]	; 0x2c
}
 80041ea:	bf00      	nop
 80041ec:	3714      	adds	r7, #20
 80041ee:	46bd      	mov	sp, r7
 80041f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041f4:	4770      	bx	lr
 80041f6:	bf00      	nop
 80041f8:	c0fff7fd 	.word	0xc0fff7fd

080041fc <ADC_StructInit>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
 80041fc:	b480      	push	{r7}
 80041fe:	b083      	sub	sp, #12
 8004200:	af00      	add	r7, sp, #0
 8004202:	6078      	str	r0, [r7, #4]
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8004204:	687b      	ldr	r3, [r7, #4]
 8004206:	2200      	movs	r2, #0
 8004208:	601a      	str	r2, [r3, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 800420a:	687b      	ldr	r3, [r7, #4]
 800420c:	2200      	movs	r2, #0
 800420e:	711a      	strb	r2, [r3, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8004210:	687b      	ldr	r3, [r7, #4]
 8004212:	2200      	movs	r2, #0
 8004214:	715a      	strb	r2, [r3, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8004216:	687b      	ldr	r3, [r7, #4]
 8004218:	2200      	movs	r2, #0
 800421a:	609a      	str	r2, [r3, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 800421c:	687b      	ldr	r3, [r7, #4]
 800421e:	2200      	movs	r2, #0
 8004220:	60da      	str	r2, [r3, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8004222:	687b      	ldr	r3, [r7, #4]
 8004224:	2200      	movs	r2, #0
 8004226:	611a      	str	r2, [r3, #16]

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 8004228:	687b      	ldr	r3, [r7, #4]
 800422a:	2201      	movs	r2, #1
 800422c:	751a      	strb	r2, [r3, #20]
}
 800422e:	bf00      	nop
 8004230:	370c      	adds	r7, #12
 8004232:	46bd      	mov	sp, r7
 8004234:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004238:	4770      	bx	lr
	...

0800423c <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 800423c:	b480      	push	{r7}
 800423e:	b085      	sub	sp, #20
 8004240:	af00      	add	r7, sp, #0
 8004242:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg1 = 0;
 8004244:	2300      	movs	r3, #0
 8004246:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 8004248:	4b0e      	ldr	r3, [pc, #56]	; (8004284 <ADC_CommonInit+0x48>)
 800424a:	685b      	ldr	r3, [r3, #4]
 800424c:	60fb      	str	r3, [r7, #12]
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 800424e:	68fa      	ldr	r2, [r7, #12]
 8004250:	4b0d      	ldr	r3, [pc, #52]	; (8004288 <ADC_CommonInit+0x4c>)
 8004252:	4013      	ands	r3, r2
 8004254:	60fb      	str	r3, [r7, #12]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8004256:	687b      	ldr	r3, [r7, #4]
 8004258:	681a      	ldr	r2, [r3, #0]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 800425a:	687b      	ldr	r3, [r7, #4]
 800425c:	685b      	ldr	r3, [r3, #4]
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 800425e:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8004260:	687b      	ldr	r3, [r7, #4]
 8004262:	689b      	ldr	r3, [r3, #8]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 8004264:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
 8004266:	687b      	ldr	r3, [r7, #4]
 8004268:	68db      	ldr	r3, [r3, #12]
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 800426a:	4313      	orrs	r3, r2
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 800426c:	68fa      	ldr	r2, [r7, #12]
 800426e:	4313      	orrs	r3, r2
 8004270:	60fb      	str	r3, [r7, #12]
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 8004272:	4a04      	ldr	r2, [pc, #16]	; (8004284 <ADC_CommonInit+0x48>)
 8004274:	68fb      	ldr	r3, [r7, #12]
 8004276:	6053      	str	r3, [r2, #4]
}
 8004278:	bf00      	nop
 800427a:	3714      	adds	r7, #20
 800427c:	46bd      	mov	sp, r7
 800427e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004282:	4770      	bx	lr
 8004284:	40012300 	.word	0x40012300
 8004288:	fffc30e0 	.word	0xfffc30e0

0800428c <ADC_Cmd>:
  * @param  NewState: new state of the ADCx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 800428c:	b480      	push	{r7}
 800428e:	b083      	sub	sp, #12
 8004290:	af00      	add	r7, sp, #0
 8004292:	6078      	str	r0, [r7, #4]
 8004294:	460b      	mov	r3, r1
 8004296:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004298:	78fb      	ldrb	r3, [r7, #3]
 800429a:	2b00      	cmp	r3, #0
 800429c:	d006      	beq.n	80042ac <ADC_Cmd+0x20>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 800429e:	687b      	ldr	r3, [r7, #4]
 80042a0:	689b      	ldr	r3, [r3, #8]
 80042a2:	f043 0201 	orr.w	r2, r3, #1
 80042a6:	687b      	ldr	r3, [r7, #4]
 80042a8:	609a      	str	r2, [r3, #8]
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
  }
}
 80042aa:	e005      	b.n	80042b8 <ADC_Cmd+0x2c>
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 80042ac:	687b      	ldr	r3, [r7, #4]
 80042ae:	689b      	ldr	r3, [r3, #8]
 80042b0:	f023 0201 	bic.w	r2, r3, #1
 80042b4:	687b      	ldr	r3, [r7, #4]
 80042b6:	609a      	str	r2, [r3, #8]
}
 80042b8:	bf00      	nop
 80042ba:	370c      	adds	r7, #12
 80042bc:	46bd      	mov	sp, r7
 80042be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042c2:	4770      	bx	lr

080042c4 <ADC_RegularChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80042c4:	b480      	push	{r7}
 80042c6:	b085      	sub	sp, #20
 80042c8:	af00      	add	r7, sp, #0
 80042ca:	6078      	str	r0, [r7, #4]
 80042cc:	4608      	mov	r0, r1
 80042ce:	4611      	mov	r1, r2
 80042d0:	461a      	mov	r2, r3
 80042d2:	4603      	mov	r3, r0
 80042d4:	70fb      	strb	r3, [r7, #3]
 80042d6:	460b      	mov	r3, r1
 80042d8:	70bb      	strb	r3, [r7, #2]
 80042da:	4613      	mov	r3, r2
 80042dc:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 80042de:	2300      	movs	r3, #0
 80042e0:	60fb      	str	r3, [r7, #12]
 80042e2:	2300      	movs	r3, #0
 80042e4:	60bb      	str	r3, [r7, #8]
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80042e6:	78fb      	ldrb	r3, [r7, #3]
 80042e8:	2b09      	cmp	r3, #9
 80042ea:	d923      	bls.n	8004334 <ADC_RegularChannelConfig+0x70>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 80042ec:	687b      	ldr	r3, [r7, #4]
 80042ee:	68db      	ldr	r3, [r3, #12]
 80042f0:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 80042f2:	78fb      	ldrb	r3, [r7, #3]
 80042f4:	f1a3 020a 	sub.w	r2, r3, #10
 80042f8:	4613      	mov	r3, r2
 80042fa:	005b      	lsls	r3, r3, #1
 80042fc:	4413      	add	r3, r2
 80042fe:	2207      	movs	r2, #7
 8004300:	fa02 f303 	lsl.w	r3, r2, r3
 8004304:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8004306:	68bb      	ldr	r3, [r7, #8]
 8004308:	43db      	mvns	r3, r3
 800430a:	68fa      	ldr	r2, [r7, #12]
 800430c:	4013      	ands	r3, r2
 800430e:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8004310:	7879      	ldrb	r1, [r7, #1]
 8004312:	78fb      	ldrb	r3, [r7, #3]
 8004314:	f1a3 020a 	sub.w	r2, r3, #10
 8004318:	4613      	mov	r3, r2
 800431a:	005b      	lsls	r3, r3, #1
 800431c:	4413      	add	r3, r2
 800431e:	fa01 f303 	lsl.w	r3, r1, r3
 8004322:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8004324:	68fa      	ldr	r2, [r7, #12]
 8004326:	68bb      	ldr	r3, [r7, #8]
 8004328:	4313      	orrs	r3, r2
 800432a:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 800432c:	687b      	ldr	r3, [r7, #4]
 800432e:	68fa      	ldr	r2, [r7, #12]
 8004330:	60da      	str	r2, [r3, #12]
 8004332:	e01e      	b.n	8004372 <ADC_RegularChannelConfig+0xae>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8004334:	687b      	ldr	r3, [r7, #4]
 8004336:	691b      	ldr	r3, [r3, #16]
 8004338:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 800433a:	78fa      	ldrb	r2, [r7, #3]
 800433c:	4613      	mov	r3, r2
 800433e:	005b      	lsls	r3, r3, #1
 8004340:	4413      	add	r3, r2
 8004342:	2207      	movs	r2, #7
 8004344:	fa02 f303 	lsl.w	r3, r2, r3
 8004348:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800434a:	68bb      	ldr	r3, [r7, #8]
 800434c:	43db      	mvns	r3, r3
 800434e:	68fa      	ldr	r2, [r7, #12]
 8004350:	4013      	ands	r3, r2
 8004352:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8004354:	7879      	ldrb	r1, [r7, #1]
 8004356:	78fa      	ldrb	r2, [r7, #3]
 8004358:	4613      	mov	r3, r2
 800435a:	005b      	lsls	r3, r3, #1
 800435c:	4413      	add	r3, r2
 800435e:	fa01 f303 	lsl.w	r3, r1, r3
 8004362:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8004364:	68fa      	ldr	r2, [r7, #12]
 8004366:	68bb      	ldr	r3, [r7, #8]
 8004368:	4313      	orrs	r3, r2
 800436a:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 800436c:	687b      	ldr	r3, [r7, #4]
 800436e:	68fa      	ldr	r2, [r7, #12]
 8004370:	611a      	str	r2, [r3, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8004372:	78bb      	ldrb	r3, [r7, #2]
 8004374:	2b06      	cmp	r3, #6
 8004376:	d821      	bhi.n	80043bc <ADC_RegularChannelConfig+0xf8>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8004378:	687b      	ldr	r3, [r7, #4]
 800437a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800437c:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 800437e:	78bb      	ldrb	r3, [r7, #2]
 8004380:	1e5a      	subs	r2, r3, #1
 8004382:	4613      	mov	r3, r2
 8004384:	009b      	lsls	r3, r3, #2
 8004386:	4413      	add	r3, r2
 8004388:	221f      	movs	r2, #31
 800438a:	fa02 f303 	lsl.w	r3, r2, r3
 800438e:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8004390:	68bb      	ldr	r3, [r7, #8]
 8004392:	43db      	mvns	r3, r3
 8004394:	68fa      	ldr	r2, [r7, #12]
 8004396:	4013      	ands	r3, r2
 8004398:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 800439a:	78f9      	ldrb	r1, [r7, #3]
 800439c:	78bb      	ldrb	r3, [r7, #2]
 800439e:	1e5a      	subs	r2, r3, #1
 80043a0:	4613      	mov	r3, r2
 80043a2:	009b      	lsls	r3, r3, #2
 80043a4:	4413      	add	r3, r2
 80043a6:	fa01 f303 	lsl.w	r3, r1, r3
 80043aa:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80043ac:	68fa      	ldr	r2, [r7, #12]
 80043ae:	68bb      	ldr	r3, [r7, #8]
 80043b0:	4313      	orrs	r3, r2
 80043b2:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 80043b4:	687b      	ldr	r3, [r7, #4]
 80043b6:	68fa      	ldr	r2, [r7, #12]
 80043b8:	635a      	str	r2, [r3, #52]	; 0x34
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 80043ba:	e047      	b.n	800444c <ADC_RegularChannelConfig+0x188>
  else if (Rank < 13)
 80043bc:	78bb      	ldrb	r3, [r7, #2]
 80043be:	2b0c      	cmp	r3, #12
 80043c0:	d821      	bhi.n	8004406 <ADC_RegularChannelConfig+0x142>
    tmpreg1 = ADCx->SQR2;
 80043c2:	687b      	ldr	r3, [r7, #4]
 80043c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80043c6:	60fb      	str	r3, [r7, #12]
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 80043c8:	78bb      	ldrb	r3, [r7, #2]
 80043ca:	1fda      	subs	r2, r3, #7
 80043cc:	4613      	mov	r3, r2
 80043ce:	009b      	lsls	r3, r3, #2
 80043d0:	4413      	add	r3, r2
 80043d2:	221f      	movs	r2, #31
 80043d4:	fa02 f303 	lsl.w	r3, r2, r3
 80043d8:	60bb      	str	r3, [r7, #8]
    tmpreg1 &= ~tmpreg2;
 80043da:	68bb      	ldr	r3, [r7, #8]
 80043dc:	43db      	mvns	r3, r3
 80043de:	68fa      	ldr	r2, [r7, #12]
 80043e0:	4013      	ands	r3, r2
 80043e2:	60fb      	str	r3, [r7, #12]
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 80043e4:	78f9      	ldrb	r1, [r7, #3]
 80043e6:	78bb      	ldrb	r3, [r7, #2]
 80043e8:	1fda      	subs	r2, r3, #7
 80043ea:	4613      	mov	r3, r2
 80043ec:	009b      	lsls	r3, r3, #2
 80043ee:	4413      	add	r3, r2
 80043f0:	fa01 f303 	lsl.w	r3, r1, r3
 80043f4:	60bb      	str	r3, [r7, #8]
    tmpreg1 |= tmpreg2;
 80043f6:	68fa      	ldr	r2, [r7, #12]
 80043f8:	68bb      	ldr	r3, [r7, #8]
 80043fa:	4313      	orrs	r3, r2
 80043fc:	60fb      	str	r3, [r7, #12]
    ADCx->SQR2 = tmpreg1;
 80043fe:	687b      	ldr	r3, [r7, #4]
 8004400:	68fa      	ldr	r2, [r7, #12]
 8004402:	631a      	str	r2, [r3, #48]	; 0x30
}
 8004404:	e022      	b.n	800444c <ADC_RegularChannelConfig+0x188>
    tmpreg1 = ADCx->SQR1;
 8004406:	687b      	ldr	r3, [r7, #4]
 8004408:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800440a:	60fb      	str	r3, [r7, #12]
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 800440c:	78bb      	ldrb	r3, [r7, #2]
 800440e:	f1a3 020d 	sub.w	r2, r3, #13
 8004412:	4613      	mov	r3, r2
 8004414:	009b      	lsls	r3, r3, #2
 8004416:	4413      	add	r3, r2
 8004418:	221f      	movs	r2, #31
 800441a:	fa02 f303 	lsl.w	r3, r2, r3
 800441e:	60bb      	str	r3, [r7, #8]
    tmpreg1 &= ~tmpreg2;
 8004420:	68bb      	ldr	r3, [r7, #8]
 8004422:	43db      	mvns	r3, r3
 8004424:	68fa      	ldr	r2, [r7, #12]
 8004426:	4013      	ands	r3, r2
 8004428:	60fb      	str	r3, [r7, #12]
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 800442a:	78f9      	ldrb	r1, [r7, #3]
 800442c:	78bb      	ldrb	r3, [r7, #2]
 800442e:	f1a3 020d 	sub.w	r2, r3, #13
 8004432:	4613      	mov	r3, r2
 8004434:	009b      	lsls	r3, r3, #2
 8004436:	4413      	add	r3, r2
 8004438:	fa01 f303 	lsl.w	r3, r1, r3
 800443c:	60bb      	str	r3, [r7, #8]
    tmpreg1 |= tmpreg2;
 800443e:	68fa      	ldr	r2, [r7, #12]
 8004440:	68bb      	ldr	r3, [r7, #8]
 8004442:	4313      	orrs	r3, r2
 8004444:	60fb      	str	r3, [r7, #12]
    ADCx->SQR1 = tmpreg1;
 8004446:	687b      	ldr	r3, [r7, #4]
 8004448:	68fa      	ldr	r2, [r7, #12]
 800444a:	62da      	str	r2, [r3, #44]	; 0x2c
}
 800444c:	bf00      	nop
 800444e:	3714      	adds	r7, #20
 8004450:	46bd      	mov	sp, r7
 8004452:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004456:	4770      	bx	lr

08004458 <ADC_SoftwareStartConv>:
  * @brief  Enables the selected ADC software start conversion of the regular channels.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
 8004458:	b480      	push	{r7}
 800445a:	b083      	sub	sp, #12
 800445c:	af00      	add	r7, sp, #0
 800445e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8004460:	687b      	ldr	r3, [r7, #4]
 8004462:	689b      	ldr	r3, [r3, #8]
 8004464:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8004468:	687b      	ldr	r3, [r7, #4]
 800446a:	609a      	str	r2, [r3, #8]
}
 800446c:	bf00      	nop
 800446e:	370c      	adds	r7, #12
 8004470:	46bd      	mov	sp, r7
 8004472:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004476:	4770      	bx	lr

08004478 <ADC_GetConversionValue>:
  * @brief  Returns the last ADCx conversion result data for regular channel.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The Data conversion value.
  */
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
 8004478:	b480      	push	{r7}
 800447a:	b083      	sub	sp, #12
 800447c:	af00      	add	r7, sp, #0
 800447e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 8004480:	687b      	ldr	r3, [r7, #4]
 8004482:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004484:	b29b      	uxth	r3, r3
}
 8004486:	4618      	mov	r0, r3
 8004488:	370c      	adds	r7, #12
 800448a:	46bd      	mov	sp, r7
 800448c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004490:	4770      	bx	lr
	...

08004494 <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8004494:	b480      	push	{r7}
 8004496:	b085      	sub	sp, #20
 8004498:	af00      	add	r7, sp, #0
 800449a:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 800449c:	2300      	movs	r3, #0
 800449e:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 80044a0:	4b34      	ldr	r3, [pc, #208]	; (8004574 <EXTI_Init+0xe0>)
 80044a2:	60fb      	str	r3, [r7, #12]
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 80044a4:	687b      	ldr	r3, [r7, #4]
 80044a6:	799b      	ldrb	r3, [r3, #6]
 80044a8:	2b00      	cmp	r3, #0
 80044aa:	d04f      	beq.n	800454c <EXTI_Init+0xb8>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 80044ac:	4931      	ldr	r1, [pc, #196]	; (8004574 <EXTI_Init+0xe0>)
 80044ae:	4b31      	ldr	r3, [pc, #196]	; (8004574 <EXTI_Init+0xe0>)
 80044b0:	681a      	ldr	r2, [r3, #0]
 80044b2:	687b      	ldr	r3, [r7, #4]
 80044b4:	681b      	ldr	r3, [r3, #0]
 80044b6:	43db      	mvns	r3, r3
 80044b8:	4013      	ands	r3, r2
 80044ba:	600b      	str	r3, [r1, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80044bc:	492d      	ldr	r1, [pc, #180]	; (8004574 <EXTI_Init+0xe0>)
 80044be:	4b2d      	ldr	r3, [pc, #180]	; (8004574 <EXTI_Init+0xe0>)
 80044c0:	685a      	ldr	r2, [r3, #4]
 80044c2:	687b      	ldr	r3, [r7, #4]
 80044c4:	681b      	ldr	r3, [r3, #0]
 80044c6:	43db      	mvns	r3, r3
 80044c8:	4013      	ands	r3, r2
 80044ca:	604b      	str	r3, [r1, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 80044cc:	687b      	ldr	r3, [r7, #4]
 80044ce:	791b      	ldrb	r3, [r3, #4]
 80044d0:	461a      	mov	r2, r3
 80044d2:	68fb      	ldr	r3, [r7, #12]
 80044d4:	4413      	add	r3, r2
 80044d6:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80044d8:	68fb      	ldr	r3, [r7, #12]
 80044da:	68fa      	ldr	r2, [r7, #12]
 80044dc:	6811      	ldr	r1, [r2, #0]
 80044de:	687a      	ldr	r2, [r7, #4]
 80044e0:	6812      	ldr	r2, [r2, #0]
 80044e2:	430a      	orrs	r2, r1
 80044e4:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80044e6:	4923      	ldr	r1, [pc, #140]	; (8004574 <EXTI_Init+0xe0>)
 80044e8:	4b22      	ldr	r3, [pc, #136]	; (8004574 <EXTI_Init+0xe0>)
 80044ea:	689a      	ldr	r2, [r3, #8]
 80044ec:	687b      	ldr	r3, [r7, #4]
 80044ee:	681b      	ldr	r3, [r3, #0]
 80044f0:	43db      	mvns	r3, r3
 80044f2:	4013      	ands	r3, r2
 80044f4:	608b      	str	r3, [r1, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80044f6:	491f      	ldr	r1, [pc, #124]	; (8004574 <EXTI_Init+0xe0>)
 80044f8:	4b1e      	ldr	r3, [pc, #120]	; (8004574 <EXTI_Init+0xe0>)
 80044fa:	68da      	ldr	r2, [r3, #12]
 80044fc:	687b      	ldr	r3, [r7, #4]
 80044fe:	681b      	ldr	r3, [r3, #0]
 8004500:	43db      	mvns	r3, r3
 8004502:	4013      	ands	r3, r2
 8004504:	60cb      	str	r3, [r1, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8004506:	687b      	ldr	r3, [r7, #4]
 8004508:	795b      	ldrb	r3, [r3, #5]
 800450a:	2b10      	cmp	r3, #16
 800450c:	d10e      	bne.n	800452c <EXTI_Init+0x98>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 800450e:	4919      	ldr	r1, [pc, #100]	; (8004574 <EXTI_Init+0xe0>)
 8004510:	4b18      	ldr	r3, [pc, #96]	; (8004574 <EXTI_Init+0xe0>)
 8004512:	689a      	ldr	r2, [r3, #8]
 8004514:	687b      	ldr	r3, [r7, #4]
 8004516:	681b      	ldr	r3, [r3, #0]
 8004518:	4313      	orrs	r3, r2
 800451a:	608b      	str	r3, [r1, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 800451c:	4915      	ldr	r1, [pc, #84]	; (8004574 <EXTI_Init+0xe0>)
 800451e:	4b15      	ldr	r3, [pc, #84]	; (8004574 <EXTI_Init+0xe0>)
 8004520:	68da      	ldr	r2, [r3, #12]
 8004522:	687b      	ldr	r3, [r7, #4]
 8004524:	681b      	ldr	r3, [r3, #0]
 8004526:	4313      	orrs	r3, r2
 8004528:	60cb      	str	r3, [r1, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 800452a:	e01d      	b.n	8004568 <EXTI_Init+0xd4>
      tmp = (uint32_t)EXTI_BASE;
 800452c:	4b11      	ldr	r3, [pc, #68]	; (8004574 <EXTI_Init+0xe0>)
 800452e:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8004530:	687b      	ldr	r3, [r7, #4]
 8004532:	795b      	ldrb	r3, [r3, #5]
 8004534:	461a      	mov	r2, r3
 8004536:	68fb      	ldr	r3, [r7, #12]
 8004538:	4413      	add	r3, r2
 800453a:	60fb      	str	r3, [r7, #12]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800453c:	68fb      	ldr	r3, [r7, #12]
 800453e:	68fa      	ldr	r2, [r7, #12]
 8004540:	6811      	ldr	r1, [r2, #0]
 8004542:	687a      	ldr	r2, [r7, #4]
 8004544:	6812      	ldr	r2, [r2, #0]
 8004546:	430a      	orrs	r2, r1
 8004548:	601a      	str	r2, [r3, #0]
}
 800454a:	e00d      	b.n	8004568 <EXTI_Init+0xd4>
    tmp += EXTI_InitStruct->EXTI_Mode;
 800454c:	687b      	ldr	r3, [r7, #4]
 800454e:	791b      	ldrb	r3, [r3, #4]
 8004550:	461a      	mov	r2, r3
 8004552:	68fb      	ldr	r3, [r7, #12]
 8004554:	4413      	add	r3, r2
 8004556:	60fb      	str	r3, [r7, #12]
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8004558:	68fb      	ldr	r3, [r7, #12]
 800455a:	68fa      	ldr	r2, [r7, #12]
 800455c:	6811      	ldr	r1, [r2, #0]
 800455e:	687a      	ldr	r2, [r7, #4]
 8004560:	6812      	ldr	r2, [r2, #0]
 8004562:	43d2      	mvns	r2, r2
 8004564:	400a      	ands	r2, r1
 8004566:	601a      	str	r2, [r3, #0]
}
 8004568:	bf00      	nop
 800456a:	3714      	adds	r7, #20
 800456c:	46bd      	mov	sp, r7
 800456e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004572:	4770      	bx	lr
 8004574:	40013c00 	.word	0x40013c00

08004578 <EXTI_GetITStatus>:
  * @param  EXTI_Line: specifies the EXTI line to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 8004578:	b480      	push	{r7}
 800457a:	b085      	sub	sp, #20
 800457c:	af00      	add	r7, sp, #0
 800457e:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 8004580:	2300      	movs	r3, #0
 8004582:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 8004584:	2300      	movs	r3, #0
 8004586:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8004588:	4b0c      	ldr	r3, [pc, #48]	; (80045bc <EXTI_GetITStatus+0x44>)
 800458a:	681a      	ldr	r2, [r3, #0]
 800458c:	687b      	ldr	r3, [r7, #4]
 800458e:	4013      	ands	r3, r2
 8004590:	60bb      	str	r3, [r7, #8]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8004592:	4b0a      	ldr	r3, [pc, #40]	; (80045bc <EXTI_GetITStatus+0x44>)
 8004594:	695a      	ldr	r2, [r3, #20]
 8004596:	687b      	ldr	r3, [r7, #4]
 8004598:	4013      	ands	r3, r2
 800459a:	2b00      	cmp	r3, #0
 800459c:	d005      	beq.n	80045aa <EXTI_GetITStatus+0x32>
 800459e:	68bb      	ldr	r3, [r7, #8]
 80045a0:	2b00      	cmp	r3, #0
 80045a2:	d002      	beq.n	80045aa <EXTI_GetITStatus+0x32>
  {
    bitstatus = SET;
 80045a4:	2301      	movs	r3, #1
 80045a6:	73fb      	strb	r3, [r7, #15]
 80045a8:	e001      	b.n	80045ae <EXTI_GetITStatus+0x36>
  }
  else
  {
    bitstatus = RESET;
 80045aa:	2300      	movs	r3, #0
 80045ac:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80045ae:	7bfb      	ldrb	r3, [r7, #15]
}
 80045b0:	4618      	mov	r0, r3
 80045b2:	3714      	adds	r7, #20
 80045b4:	46bd      	mov	sp, r7
 80045b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045ba:	4770      	bx	lr
 80045bc:	40013c00 	.word	0x40013c00

080045c0 <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 80045c0:	b480      	push	{r7}
 80045c2:	b083      	sub	sp, #12
 80045c4:	af00      	add	r7, sp, #0
 80045c6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80045c8:	4a04      	ldr	r2, [pc, #16]	; (80045dc <EXTI_ClearITPendingBit+0x1c>)
 80045ca:	687b      	ldr	r3, [r7, #4]
 80045cc:	6153      	str	r3, [r2, #20]
}
 80045ce:	bf00      	nop
 80045d0:	370c      	adds	r7, #12
 80045d2:	46bd      	mov	sp, r7
 80045d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045d8:	4770      	bx	lr
 80045da:	bf00      	nop
 80045dc:	40013c00 	.word	0x40013c00

080045e0 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80045e0:	b480      	push	{r7}
 80045e2:	b087      	sub	sp, #28
 80045e4:	af00      	add	r7, sp, #0
 80045e6:	6078      	str	r0, [r7, #4]
 80045e8:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 80045ea:	2300      	movs	r3, #0
 80045ec:	617b      	str	r3, [r7, #20]
 80045ee:	2300      	movs	r3, #0
 80045f0:	613b      	str	r3, [r7, #16]
 80045f2:	2300      	movs	r3, #0
 80045f4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80045f6:	2300      	movs	r3, #0
 80045f8:	617b      	str	r3, [r7, #20]
 80045fa:	e076      	b.n	80046ea <GPIO_Init+0x10a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80045fc:	2201      	movs	r2, #1
 80045fe:	697b      	ldr	r3, [r7, #20]
 8004600:	fa02 f303 	lsl.w	r3, r2, r3
 8004604:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8004606:	683b      	ldr	r3, [r7, #0]
 8004608:	681a      	ldr	r2, [r3, #0]
 800460a:	693b      	ldr	r3, [r7, #16]
 800460c:	4013      	ands	r3, r2
 800460e:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8004610:	68fa      	ldr	r2, [r7, #12]
 8004612:	693b      	ldr	r3, [r7, #16]
 8004614:	429a      	cmp	r2, r3
 8004616:	d165      	bne.n	80046e4 <GPIO_Init+0x104>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8004618:	687b      	ldr	r3, [r7, #4]
 800461a:	681a      	ldr	r2, [r3, #0]
 800461c:	697b      	ldr	r3, [r7, #20]
 800461e:	005b      	lsls	r3, r3, #1
 8004620:	2103      	movs	r1, #3
 8004622:	fa01 f303 	lsl.w	r3, r1, r3
 8004626:	43db      	mvns	r3, r3
 8004628:	401a      	ands	r2, r3
 800462a:	687b      	ldr	r3, [r7, #4]
 800462c:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800462e:	687b      	ldr	r3, [r7, #4]
 8004630:	681a      	ldr	r2, [r3, #0]
 8004632:	683b      	ldr	r3, [r7, #0]
 8004634:	791b      	ldrb	r3, [r3, #4]
 8004636:	4619      	mov	r1, r3
 8004638:	697b      	ldr	r3, [r7, #20]
 800463a:	005b      	lsls	r3, r3, #1
 800463c:	fa01 f303 	lsl.w	r3, r1, r3
 8004640:	431a      	orrs	r2, r3
 8004642:	687b      	ldr	r3, [r7, #4]
 8004644:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8004646:	683b      	ldr	r3, [r7, #0]
 8004648:	791b      	ldrb	r3, [r3, #4]
 800464a:	2b01      	cmp	r3, #1
 800464c:	d003      	beq.n	8004656 <GPIO_Init+0x76>
 800464e:	683b      	ldr	r3, [r7, #0]
 8004650:	791b      	ldrb	r3, [r3, #4]
 8004652:	2b02      	cmp	r3, #2
 8004654:	d12e      	bne.n	80046b4 <GPIO_Init+0xd4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8004656:	687b      	ldr	r3, [r7, #4]
 8004658:	689a      	ldr	r2, [r3, #8]
 800465a:	697b      	ldr	r3, [r7, #20]
 800465c:	005b      	lsls	r3, r3, #1
 800465e:	2103      	movs	r1, #3
 8004660:	fa01 f303 	lsl.w	r3, r1, r3
 8004664:	43db      	mvns	r3, r3
 8004666:	401a      	ands	r2, r3
 8004668:	687b      	ldr	r3, [r7, #4]
 800466a:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800466c:	687b      	ldr	r3, [r7, #4]
 800466e:	689a      	ldr	r2, [r3, #8]
 8004670:	683b      	ldr	r3, [r7, #0]
 8004672:	795b      	ldrb	r3, [r3, #5]
 8004674:	4619      	mov	r1, r3
 8004676:	697b      	ldr	r3, [r7, #20]
 8004678:	005b      	lsls	r3, r3, #1
 800467a:	fa01 f303 	lsl.w	r3, r1, r3
 800467e:	431a      	orrs	r2, r3
 8004680:	687b      	ldr	r3, [r7, #4]
 8004682:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8004684:	687b      	ldr	r3, [r7, #4]
 8004686:	685a      	ldr	r2, [r3, #4]
 8004688:	697b      	ldr	r3, [r7, #20]
 800468a:	b29b      	uxth	r3, r3
 800468c:	4619      	mov	r1, r3
 800468e:	2301      	movs	r3, #1
 8004690:	408b      	lsls	r3, r1
 8004692:	43db      	mvns	r3, r3
 8004694:	401a      	ands	r2, r3
 8004696:	687b      	ldr	r3, [r7, #4]
 8004698:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800469a:	687b      	ldr	r3, [r7, #4]
 800469c:	685b      	ldr	r3, [r3, #4]
 800469e:	683a      	ldr	r2, [r7, #0]
 80046a0:	7992      	ldrb	r2, [r2, #6]
 80046a2:	4611      	mov	r1, r2
 80046a4:	697a      	ldr	r2, [r7, #20]
 80046a6:	b292      	uxth	r2, r2
 80046a8:	fa01 f202 	lsl.w	r2, r1, r2
 80046ac:	b292      	uxth	r2, r2
 80046ae:	431a      	orrs	r2, r3
 80046b0:	687b      	ldr	r3, [r7, #4]
 80046b2:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80046b4:	687b      	ldr	r3, [r7, #4]
 80046b6:	68da      	ldr	r2, [r3, #12]
 80046b8:	697b      	ldr	r3, [r7, #20]
 80046ba:	b29b      	uxth	r3, r3
 80046bc:	005b      	lsls	r3, r3, #1
 80046be:	2103      	movs	r1, #3
 80046c0:	fa01 f303 	lsl.w	r3, r1, r3
 80046c4:	43db      	mvns	r3, r3
 80046c6:	401a      	ands	r2, r3
 80046c8:	687b      	ldr	r3, [r7, #4]
 80046ca:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80046cc:	687b      	ldr	r3, [r7, #4]
 80046ce:	68da      	ldr	r2, [r3, #12]
 80046d0:	683b      	ldr	r3, [r7, #0]
 80046d2:	79db      	ldrb	r3, [r3, #7]
 80046d4:	4619      	mov	r1, r3
 80046d6:	697b      	ldr	r3, [r7, #20]
 80046d8:	005b      	lsls	r3, r3, #1
 80046da:	fa01 f303 	lsl.w	r3, r1, r3
 80046de:	431a      	orrs	r2, r3
 80046e0:	687b      	ldr	r3, [r7, #4]
 80046e2:	60da      	str	r2, [r3, #12]
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80046e4:	697b      	ldr	r3, [r7, #20]
 80046e6:	3301      	adds	r3, #1
 80046e8:	617b      	str	r3, [r7, #20]
 80046ea:	697b      	ldr	r3, [r7, #20]
 80046ec:	2b0f      	cmp	r3, #15
 80046ee:	d985      	bls.n	80045fc <GPIO_Init+0x1c>
    }
  }
}
 80046f0:	bf00      	nop
 80046f2:	371c      	adds	r7, #28
 80046f4:	46bd      	mov	sp, r7
 80046f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80046fa:	4770      	bx	lr

080046fc <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80046fc:	b480      	push	{r7}
 80046fe:	b085      	sub	sp, #20
 8004700:	af00      	add	r7, sp, #0
 8004702:	6078      	str	r0, [r7, #4]
 8004704:	460b      	mov	r3, r1
 8004706:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 8004708:	2300      	movs	r3, #0
 800470a:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 800470c:	687b      	ldr	r3, [r7, #4]
 800470e:	691a      	ldr	r2, [r3, #16]
 8004710:	887b      	ldrh	r3, [r7, #2]
 8004712:	4013      	ands	r3, r2
 8004714:	2b00      	cmp	r3, #0
 8004716:	d002      	beq.n	800471e <GPIO_ReadInputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
 8004718:	2301      	movs	r3, #1
 800471a:	73fb      	strb	r3, [r7, #15]
 800471c:	e001      	b.n	8004722 <GPIO_ReadInputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 800471e:	2300      	movs	r3, #0
 8004720:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8004722:	7bfb      	ldrb	r3, [r7, #15]
}
 8004724:	4618      	mov	r0, r3
 8004726:	3714      	adds	r7, #20
 8004728:	46bd      	mov	sp, r7
 800472a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800472e:	4770      	bx	lr

08004730 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8004730:	b480      	push	{r7}
 8004732:	b085      	sub	sp, #20
 8004734:	af00      	add	r7, sp, #0
 8004736:	6078      	str	r0, [r7, #4]
 8004738:	460b      	mov	r3, r1
 800473a:	807b      	strh	r3, [r7, #2]
 800473c:	4613      	mov	r3, r2
 800473e:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 8004740:	2300      	movs	r3, #0
 8004742:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8004744:	2300      	movs	r3, #0
 8004746:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8004748:	787a      	ldrb	r2, [r7, #1]
 800474a:	887b      	ldrh	r3, [r7, #2]
 800474c:	f003 0307 	and.w	r3, r3, #7
 8004750:	009b      	lsls	r3, r3, #2
 8004752:	fa02 f303 	lsl.w	r3, r2, r3
 8004756:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8004758:	887b      	ldrh	r3, [r7, #2]
 800475a:	08db      	lsrs	r3, r3, #3
 800475c:	b29b      	uxth	r3, r3
 800475e:	4618      	mov	r0, r3
 8004760:	887b      	ldrh	r3, [r7, #2]
 8004762:	08db      	lsrs	r3, r3, #3
 8004764:	b29b      	uxth	r3, r3
 8004766:	461a      	mov	r2, r3
 8004768:	687b      	ldr	r3, [r7, #4]
 800476a:	3208      	adds	r2, #8
 800476c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8004770:	887b      	ldrh	r3, [r7, #2]
 8004772:	f003 0307 	and.w	r3, r3, #7
 8004776:	009b      	lsls	r3, r3, #2
 8004778:	210f      	movs	r1, #15
 800477a:	fa01 f303 	lsl.w	r3, r1, r3
 800477e:	43db      	mvns	r3, r3
 8004780:	ea02 0103 	and.w	r1, r2, r3
 8004784:	687b      	ldr	r3, [r7, #4]
 8004786:	f100 0208 	add.w	r2, r0, #8
 800478a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 800478e:	887b      	ldrh	r3, [r7, #2]
 8004790:	08db      	lsrs	r3, r3, #3
 8004792:	b29b      	uxth	r3, r3
 8004794:	461a      	mov	r2, r3
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	3208      	adds	r2, #8
 800479a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800479e:	68fb      	ldr	r3, [r7, #12]
 80047a0:	4313      	orrs	r3, r2
 80047a2:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 80047a4:	887b      	ldrh	r3, [r7, #2]
 80047a6:	08db      	lsrs	r3, r3, #3
 80047a8:	b29b      	uxth	r3, r3
 80047aa:	461a      	mov	r2, r3
 80047ac:	687b      	ldr	r3, [r7, #4]
 80047ae:	3208      	adds	r2, #8
 80047b0:	68b9      	ldr	r1, [r7, #8]
 80047b2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80047b6:	bf00      	nop
 80047b8:	3714      	adds	r7, #20
 80047ba:	46bd      	mov	sp, r7
 80047bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80047c0:	4770      	bx	lr
	...

080047c4 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80047c4:	b480      	push	{r7}
 80047c6:	b089      	sub	sp, #36	; 0x24
 80047c8:	af00      	add	r7, sp, #0
 80047ca:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 80047cc:	2300      	movs	r3, #0
 80047ce:	61bb      	str	r3, [r7, #24]
 80047d0:	2300      	movs	r3, #0
 80047d2:	617b      	str	r3, [r7, #20]
 80047d4:	2300      	movs	r3, #0
 80047d6:	61fb      	str	r3, [r7, #28]
 80047d8:	2302      	movs	r3, #2
 80047da:	613b      	str	r3, [r7, #16]
 80047dc:	2300      	movs	r3, #0
 80047de:	60fb      	str	r3, [r7, #12]
 80047e0:	2302      	movs	r3, #2
 80047e2:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80047e4:	4b47      	ldr	r3, [pc, #284]	; (8004904 <RCC_GetClocksFreq+0x140>)
 80047e6:	689b      	ldr	r3, [r3, #8]
 80047e8:	f003 030c 	and.w	r3, r3, #12
 80047ec:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 80047ee:	69bb      	ldr	r3, [r7, #24]
 80047f0:	2b04      	cmp	r3, #4
 80047f2:	d007      	beq.n	8004804 <RCC_GetClocksFreq+0x40>
 80047f4:	2b08      	cmp	r3, #8
 80047f6:	d009      	beq.n	800480c <RCC_GetClocksFreq+0x48>
 80047f8:	2b00      	cmp	r3, #0
 80047fa:	d13d      	bne.n	8004878 <RCC_GetClocksFreq+0xb4>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80047fc:	687b      	ldr	r3, [r7, #4]
 80047fe:	4a42      	ldr	r2, [pc, #264]	; (8004908 <RCC_GetClocksFreq+0x144>)
 8004800:	601a      	str	r2, [r3, #0]
      break;
 8004802:	e03d      	b.n	8004880 <RCC_GetClocksFreq+0xbc>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8004804:	687b      	ldr	r3, [r7, #4]
 8004806:	4a41      	ldr	r2, [pc, #260]	; (800490c <RCC_GetClocksFreq+0x148>)
 8004808:	601a      	str	r2, [r3, #0]
      break;
 800480a:	e039      	b.n	8004880 <RCC_GetClocksFreq+0xbc>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800480c:	4b3d      	ldr	r3, [pc, #244]	; (8004904 <RCC_GetClocksFreq+0x140>)
 800480e:	685b      	ldr	r3, [r3, #4]
 8004810:	0d9b      	lsrs	r3, r3, #22
 8004812:	f003 0301 	and.w	r3, r3, #1
 8004816:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004818:	4b3a      	ldr	r3, [pc, #232]	; (8004904 <RCC_GetClocksFreq+0x140>)
 800481a:	685b      	ldr	r3, [r3, #4]
 800481c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8004820:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 8004822:	68fb      	ldr	r3, [r7, #12]
 8004824:	2b00      	cmp	r3, #0
 8004826:	d00c      	beq.n	8004842 <RCC_GetClocksFreq+0x7e>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8004828:	4a38      	ldr	r2, [pc, #224]	; (800490c <RCC_GetClocksFreq+0x148>)
 800482a:	68bb      	ldr	r3, [r7, #8]
 800482c:	fbb2 f3f3 	udiv	r3, r2, r3
 8004830:	4a34      	ldr	r2, [pc, #208]	; (8004904 <RCC_GetClocksFreq+0x140>)
 8004832:	6852      	ldr	r2, [r2, #4]
 8004834:	0992      	lsrs	r2, r2, #6
 8004836:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800483a:	fb02 f303 	mul.w	r3, r2, r3
 800483e:	61fb      	str	r3, [r7, #28]
 8004840:	e00b      	b.n	800485a <RCC_GetClocksFreq+0x96>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8004842:	4a31      	ldr	r2, [pc, #196]	; (8004908 <RCC_GetClocksFreq+0x144>)
 8004844:	68bb      	ldr	r3, [r7, #8]
 8004846:	fbb2 f3f3 	udiv	r3, r2, r3
 800484a:	4a2e      	ldr	r2, [pc, #184]	; (8004904 <RCC_GetClocksFreq+0x140>)
 800484c:	6852      	ldr	r2, [r2, #4]
 800484e:	0992      	lsrs	r2, r2, #6
 8004850:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8004854:	fb02 f303 	mul.w	r3, r2, r3
 8004858:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800485a:	4b2a      	ldr	r3, [pc, #168]	; (8004904 <RCC_GetClocksFreq+0x140>)
 800485c:	685b      	ldr	r3, [r3, #4]
 800485e:	0c1b      	lsrs	r3, r3, #16
 8004860:	f003 0303 	and.w	r3, r3, #3
 8004864:	3301      	adds	r3, #1
 8004866:	005b      	lsls	r3, r3, #1
 8004868:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 800486a:	69fa      	ldr	r2, [r7, #28]
 800486c:	693b      	ldr	r3, [r7, #16]
 800486e:	fbb2 f2f3 	udiv	r2, r2, r3
 8004872:	687b      	ldr	r3, [r7, #4]
 8004874:	601a      	str	r2, [r3, #0]
      break;
 8004876:	e003      	b.n	8004880 <RCC_GetClocksFreq+0xbc>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8004878:	687b      	ldr	r3, [r7, #4]
 800487a:	4a23      	ldr	r2, [pc, #140]	; (8004908 <RCC_GetClocksFreq+0x144>)
 800487c:	601a      	str	r2, [r3, #0]
      break;
 800487e:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8004880:	4b20      	ldr	r3, [pc, #128]	; (8004904 <RCC_GetClocksFreq+0x140>)
 8004882:	689b      	ldr	r3, [r3, #8]
 8004884:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004888:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 800488a:	69bb      	ldr	r3, [r7, #24]
 800488c:	091b      	lsrs	r3, r3, #4
 800488e:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8004890:	4a1f      	ldr	r2, [pc, #124]	; (8004910 <RCC_GetClocksFreq+0x14c>)
 8004892:	69bb      	ldr	r3, [r7, #24]
 8004894:	4413      	add	r3, r2
 8004896:	781b      	ldrb	r3, [r3, #0]
 8004898:	b2db      	uxtb	r3, r3
 800489a:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800489c:	687b      	ldr	r3, [r7, #4]
 800489e:	681a      	ldr	r2, [r3, #0]
 80048a0:	697b      	ldr	r3, [r7, #20]
 80048a2:	40da      	lsrs	r2, r3
 80048a4:	687b      	ldr	r3, [r7, #4]
 80048a6:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 80048a8:	4b16      	ldr	r3, [pc, #88]	; (8004904 <RCC_GetClocksFreq+0x140>)
 80048aa:	689b      	ldr	r3, [r3, #8]
 80048ac:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 80048b0:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 80048b2:	69bb      	ldr	r3, [r7, #24]
 80048b4:	0a9b      	lsrs	r3, r3, #10
 80048b6:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 80048b8:	4a15      	ldr	r2, [pc, #84]	; (8004910 <RCC_GetClocksFreq+0x14c>)
 80048ba:	69bb      	ldr	r3, [r7, #24]
 80048bc:	4413      	add	r3, r2
 80048be:	781b      	ldrb	r3, [r3, #0]
 80048c0:	b2db      	uxtb	r3, r3
 80048c2:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80048c4:	687b      	ldr	r3, [r7, #4]
 80048c6:	685a      	ldr	r2, [r3, #4]
 80048c8:	697b      	ldr	r3, [r7, #20]
 80048ca:	40da      	lsrs	r2, r3
 80048cc:	687b      	ldr	r3, [r7, #4]
 80048ce:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80048d0:	4b0c      	ldr	r3, [pc, #48]	; (8004904 <RCC_GetClocksFreq+0x140>)
 80048d2:	689b      	ldr	r3, [r3, #8]
 80048d4:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 80048d8:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 80048da:	69bb      	ldr	r3, [r7, #24]
 80048dc:	0b5b      	lsrs	r3, r3, #13
 80048de:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 80048e0:	4a0b      	ldr	r2, [pc, #44]	; (8004910 <RCC_GetClocksFreq+0x14c>)
 80048e2:	69bb      	ldr	r3, [r7, #24]
 80048e4:	4413      	add	r3, r2
 80048e6:	781b      	ldrb	r3, [r3, #0]
 80048e8:	b2db      	uxtb	r3, r3
 80048ea:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80048ec:	687b      	ldr	r3, [r7, #4]
 80048ee:	685a      	ldr	r2, [r3, #4]
 80048f0:	697b      	ldr	r3, [r7, #20]
 80048f2:	40da      	lsrs	r2, r3
 80048f4:	687b      	ldr	r3, [r7, #4]
 80048f6:	60da      	str	r2, [r3, #12]
}
 80048f8:	bf00      	nop
 80048fa:	3724      	adds	r7, #36	; 0x24
 80048fc:	46bd      	mov	sp, r7
 80048fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004902:	4770      	bx	lr
 8004904:	40023800 	.word	0x40023800
 8004908:	00f42400 	.word	0x00f42400
 800490c:	007a1200 	.word	0x007a1200
 8004910:	20000008 	.word	0x20000008

08004914 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8004914:	b480      	push	{r7}
 8004916:	b083      	sub	sp, #12
 8004918:	af00      	add	r7, sp, #0
 800491a:	6078      	str	r0, [r7, #4]
 800491c:	460b      	mov	r3, r1
 800491e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004920:	78fb      	ldrb	r3, [r7, #3]
 8004922:	2b00      	cmp	r3, #0
 8004924:	d006      	beq.n	8004934 <RCC_AHB1PeriphClockCmd+0x20>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8004926:	490a      	ldr	r1, [pc, #40]	; (8004950 <RCC_AHB1PeriphClockCmd+0x3c>)
 8004928:	4b09      	ldr	r3, [pc, #36]	; (8004950 <RCC_AHB1PeriphClockCmd+0x3c>)
 800492a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800492c:	687b      	ldr	r3, [r7, #4]
 800492e:	4313      	orrs	r3, r2
 8004930:	630b      	str	r3, [r1, #48]	; 0x30
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
  }
}
 8004932:	e006      	b.n	8004942 <RCC_AHB1PeriphClockCmd+0x2e>
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8004934:	4906      	ldr	r1, [pc, #24]	; (8004950 <RCC_AHB1PeriphClockCmd+0x3c>)
 8004936:	4b06      	ldr	r3, [pc, #24]	; (8004950 <RCC_AHB1PeriphClockCmd+0x3c>)
 8004938:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800493a:	687b      	ldr	r3, [r7, #4]
 800493c:	43db      	mvns	r3, r3
 800493e:	4013      	ands	r3, r2
 8004940:	630b      	str	r3, [r1, #48]	; 0x30
}
 8004942:	bf00      	nop
 8004944:	370c      	adds	r7, #12
 8004946:	46bd      	mov	sp, r7
 8004948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800494c:	4770      	bx	lr
 800494e:	bf00      	nop
 8004950:	40023800 	.word	0x40023800

08004954 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8004954:	b480      	push	{r7}
 8004956:	b083      	sub	sp, #12
 8004958:	af00      	add	r7, sp, #0
 800495a:	6078      	str	r0, [r7, #4]
 800495c:	460b      	mov	r3, r1
 800495e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004960:	78fb      	ldrb	r3, [r7, #3]
 8004962:	2b00      	cmp	r3, #0
 8004964:	d006      	beq.n	8004974 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8004966:	490a      	ldr	r1, [pc, #40]	; (8004990 <RCC_APB2PeriphClockCmd+0x3c>)
 8004968:	4b09      	ldr	r3, [pc, #36]	; (8004990 <RCC_APB2PeriphClockCmd+0x3c>)
 800496a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800496c:	687b      	ldr	r3, [r7, #4]
 800496e:	4313      	orrs	r3, r2
 8004970:	644b      	str	r3, [r1, #68]	; 0x44
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 8004972:	e006      	b.n	8004982 <RCC_APB2PeriphClockCmd+0x2e>
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8004974:	4906      	ldr	r1, [pc, #24]	; (8004990 <RCC_APB2PeriphClockCmd+0x3c>)
 8004976:	4b06      	ldr	r3, [pc, #24]	; (8004990 <RCC_APB2PeriphClockCmd+0x3c>)
 8004978:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800497a:	687b      	ldr	r3, [r7, #4]
 800497c:	43db      	mvns	r3, r3
 800497e:	4013      	ands	r3, r2
 8004980:	644b      	str	r3, [r1, #68]	; 0x44
}
 8004982:	bf00      	nop
 8004984:	370c      	adds	r7, #12
 8004986:	46bd      	mov	sp, r7
 8004988:	f85d 7b04 	ldr.w	r7, [sp], #4
 800498c:	4770      	bx	lr
 800498e:	bf00      	nop
 8004990:	40023800 	.word	0x40023800

08004994 <RCC_AHB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8004994:	b480      	push	{r7}
 8004996:	b083      	sub	sp, #12
 8004998:	af00      	add	r7, sp, #0
 800499a:	6078      	str	r0, [r7, #4]
 800499c:	460b      	mov	r3, r1
 800499e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80049a0:	78fb      	ldrb	r3, [r7, #3]
 80049a2:	2b00      	cmp	r3, #0
 80049a4:	d006      	beq.n	80049b4 <RCC_AHB1PeriphResetCmd+0x20>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 80049a6:	490a      	ldr	r1, [pc, #40]	; (80049d0 <RCC_AHB1PeriphResetCmd+0x3c>)
 80049a8:	4b09      	ldr	r3, [pc, #36]	; (80049d0 <RCC_AHB1PeriphResetCmd+0x3c>)
 80049aa:	691a      	ldr	r2, [r3, #16]
 80049ac:	687b      	ldr	r3, [r7, #4]
 80049ae:	4313      	orrs	r3, r2
 80049b0:	610b      	str	r3, [r1, #16]
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
  }
}
 80049b2:	e006      	b.n	80049c2 <RCC_AHB1PeriphResetCmd+0x2e>
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 80049b4:	4906      	ldr	r1, [pc, #24]	; (80049d0 <RCC_AHB1PeriphResetCmd+0x3c>)
 80049b6:	4b06      	ldr	r3, [pc, #24]	; (80049d0 <RCC_AHB1PeriphResetCmd+0x3c>)
 80049b8:	691a      	ldr	r2, [r3, #16]
 80049ba:	687b      	ldr	r3, [r7, #4]
 80049bc:	43db      	mvns	r3, r3
 80049be:	4013      	ands	r3, r2
 80049c0:	610b      	str	r3, [r1, #16]
}
 80049c2:	bf00      	nop
 80049c4:	370c      	adds	r7, #12
 80049c6:	46bd      	mov	sp, r7
 80049c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049cc:	4770      	bx	lr
 80049ce:	bf00      	nop
 80049d0:	40023800 	.word	0x40023800

080049d4 <SYSCFG_EXTILineConfig>:
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11).
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 80049d4:	b490      	push	{r4, r7}
 80049d6:	b084      	sub	sp, #16
 80049d8:	af00      	add	r7, sp, #0
 80049da:	4603      	mov	r3, r0
 80049dc:	460a      	mov	r2, r1
 80049de:	71fb      	strb	r3, [r7, #7]
 80049e0:	4613      	mov	r3, r2
 80049e2:	71bb      	strb	r3, [r7, #6]
  uint32_t tmp = 0x00;
 80049e4:	2300      	movs	r3, #0
 80049e6:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80049e8:	79bb      	ldrb	r3, [r7, #6]
 80049ea:	f003 0303 	and.w	r3, r3, #3
 80049ee:	009b      	lsls	r3, r3, #2
 80049f0:	220f      	movs	r2, #15
 80049f2:	fa02 f303 	lsl.w	r3, r2, r3
 80049f6:	60fb      	str	r3, [r7, #12]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 80049f8:	4916      	ldr	r1, [pc, #88]	; (8004a54 <SYSCFG_EXTILineConfig+0x80>)
 80049fa:	79bb      	ldrb	r3, [r7, #6]
 80049fc:	089b      	lsrs	r3, r3, #2
 80049fe:	b2db      	uxtb	r3, r3
 8004a00:	4618      	mov	r0, r3
 8004a02:	4a14      	ldr	r2, [pc, #80]	; (8004a54 <SYSCFG_EXTILineConfig+0x80>)
 8004a04:	79bb      	ldrb	r3, [r7, #6]
 8004a06:	089b      	lsrs	r3, r3, #2
 8004a08:	b2db      	uxtb	r3, r3
 8004a0a:	3302      	adds	r3, #2
 8004a0c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8004a10:	68fb      	ldr	r3, [r7, #12]
 8004a12:	43db      	mvns	r3, r3
 8004a14:	401a      	ands	r2, r3
 8004a16:	1c83      	adds	r3, r0, #2
 8004a18:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8004a1c:	480d      	ldr	r0, [pc, #52]	; (8004a54 <SYSCFG_EXTILineConfig+0x80>)
 8004a1e:	79bb      	ldrb	r3, [r7, #6]
 8004a20:	089b      	lsrs	r3, r3, #2
 8004a22:	b2db      	uxtb	r3, r3
 8004a24:	461c      	mov	r4, r3
 8004a26:	4a0b      	ldr	r2, [pc, #44]	; (8004a54 <SYSCFG_EXTILineConfig+0x80>)
 8004a28:	79bb      	ldrb	r3, [r7, #6]
 8004a2a:	089b      	lsrs	r3, r3, #2
 8004a2c:	b2db      	uxtb	r3, r3
 8004a2e:	3302      	adds	r3, #2
 8004a30:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8004a34:	79f9      	ldrb	r1, [r7, #7]
 8004a36:	79bb      	ldrb	r3, [r7, #6]
 8004a38:	f003 0303 	and.w	r3, r3, #3
 8004a3c:	009b      	lsls	r3, r3, #2
 8004a3e:	fa01 f303 	lsl.w	r3, r1, r3
 8004a42:	431a      	orrs	r2, r3
 8004a44:	1ca3      	adds	r3, r4, #2
 8004a46:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
 8004a4a:	bf00      	nop
 8004a4c:	3710      	adds	r7, #16
 8004a4e:	46bd      	mov	sp, r7
 8004a50:	bc90      	pop	{r4, r7}
 8004a52:	4770      	bx	lr
 8004a54:	40013800 	.word	0x40013800

08004a58 <SYSCFG_ETH_MediaInterfaceConfig>:
  *            @arg SYSCFG_ETH_MediaInterface_MII: MII mode selected
  *            @arg SYSCFG_ETH_MediaInterface_RMII: RMII mode selected 
  * @retval None 
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
 8004a58:	b480      	push	{r7}
 8004a5a:	b083      	sub	sp, #12
 8004a5c:	af00      	add	r7, sp, #0
 8004a5e:	6078      	str	r0, [r7, #4]
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 8004a60:	4a04      	ldr	r2, [pc, #16]	; (8004a74 <SYSCFG_ETH_MediaInterfaceConfig+0x1c>)
 8004a62:	687b      	ldr	r3, [r7, #4]
 8004a64:	6013      	str	r3, [r2, #0]
}
 8004a66:	bf00      	nop
 8004a68:	370c      	adds	r7, #12
 8004a6a:	46bd      	mov	sp, r7
 8004a6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004a70:	4770      	bx	lr
 8004a72:	bf00      	nop
 8004a74:	422700dc 	.word	0x422700dc

08004a78 <fs_malloc>:
#endif /* LWIP_HTTPD_CUSTOM_FILES */

/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
 8004a78:	b480      	push	{r7}
 8004a7a:	b083      	sub	sp, #12
 8004a7c:	af00      	add	r7, sp, #0
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8004a7e:	2300      	movs	r3, #0
 8004a80:	607b      	str	r3, [r7, #4]
 8004a82:	e01f      	b.n	8004ac4 <fs_malloc+0x4c>
    if(fs_memory[i].inuse == 0) {
 8004a84:	4914      	ldr	r1, [pc, #80]	; (8004ad8 <fs_malloc+0x60>)
 8004a86:	687a      	ldr	r2, [r7, #4]
 8004a88:	4613      	mov	r3, r2
 8004a8a:	005b      	lsls	r3, r3, #1
 8004a8c:	4413      	add	r3, r2
 8004a8e:	00db      	lsls	r3, r3, #3
 8004a90:	440b      	add	r3, r1
 8004a92:	3314      	adds	r3, #20
 8004a94:	781b      	ldrb	r3, [r3, #0]
 8004a96:	2b00      	cmp	r3, #0
 8004a98:	d111      	bne.n	8004abe <fs_malloc+0x46>
      fs_memory[i].inuse = 1;
 8004a9a:	490f      	ldr	r1, [pc, #60]	; (8004ad8 <fs_malloc+0x60>)
 8004a9c:	687a      	ldr	r2, [r7, #4]
 8004a9e:	4613      	mov	r3, r2
 8004aa0:	005b      	lsls	r3, r3, #1
 8004aa2:	4413      	add	r3, r2
 8004aa4:	00db      	lsls	r3, r3, #3
 8004aa6:	440b      	add	r3, r1
 8004aa8:	3314      	adds	r3, #20
 8004aaa:	2201      	movs	r2, #1
 8004aac:	701a      	strb	r2, [r3, #0]
      return(&fs_memory[i].file);
 8004aae:	687a      	ldr	r2, [r7, #4]
 8004ab0:	4613      	mov	r3, r2
 8004ab2:	005b      	lsls	r3, r3, #1
 8004ab4:	4413      	add	r3, r2
 8004ab6:	00db      	lsls	r3, r3, #3
 8004ab8:	4a07      	ldr	r2, [pc, #28]	; (8004ad8 <fs_malloc+0x60>)
 8004aba:	4413      	add	r3, r2
 8004abc:	e006      	b.n	8004acc <fs_malloc+0x54>
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8004abe:	687b      	ldr	r3, [r7, #4]
 8004ac0:	3301      	adds	r3, #1
 8004ac2:	607b      	str	r3, [r7, #4]
 8004ac4:	687b      	ldr	r3, [r7, #4]
 8004ac6:	2b09      	cmp	r3, #9
 8004ac8:	dddc      	ble.n	8004a84 <fs_malloc+0xc>
    }
  }
  return(NULL);
 8004aca:	2300      	movs	r3, #0
}
 8004acc:	4618      	mov	r0, r3
 8004ace:	370c      	adds	r7, #12
 8004ad0:	46bd      	mov	sp, r7
 8004ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ad6:	4770      	bx	lr
 8004ad8:	2000a218 	.word	0x2000a218

08004adc <fs_free>:

/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
 8004adc:	b480      	push	{r7}
 8004ade:	b085      	sub	sp, #20
 8004ae0:	af00      	add	r7, sp, #0
 8004ae2:	6078      	str	r0, [r7, #4]
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8004ae4:	2300      	movs	r3, #0
 8004ae6:	60fb      	str	r3, [r7, #12]
 8004ae8:	e017      	b.n	8004b1a <fs_free+0x3e>
    if(&fs_memory[i].file == file) {
 8004aea:	68fa      	ldr	r2, [r7, #12]
 8004aec:	4613      	mov	r3, r2
 8004aee:	005b      	lsls	r3, r3, #1
 8004af0:	4413      	add	r3, r2
 8004af2:	00db      	lsls	r3, r3, #3
 8004af4:	4a0d      	ldr	r2, [pc, #52]	; (8004b2c <fs_free+0x50>)
 8004af6:	441a      	add	r2, r3
 8004af8:	687b      	ldr	r3, [r7, #4]
 8004afa:	429a      	cmp	r2, r3
 8004afc:	d10a      	bne.n	8004b14 <fs_free+0x38>
      fs_memory[i].inuse = 0;
 8004afe:	490b      	ldr	r1, [pc, #44]	; (8004b2c <fs_free+0x50>)
 8004b00:	68fa      	ldr	r2, [r7, #12]
 8004b02:	4613      	mov	r3, r2
 8004b04:	005b      	lsls	r3, r3, #1
 8004b06:	4413      	add	r3, r2
 8004b08:	00db      	lsls	r3, r3, #3
 8004b0a:	440b      	add	r3, r1
 8004b0c:	3314      	adds	r3, #20
 8004b0e:	2200      	movs	r2, #0
 8004b10:	701a      	strb	r2, [r3, #0]
      break;
 8004b12:	e005      	b.n	8004b20 <fs_free+0x44>
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8004b14:	68fb      	ldr	r3, [r7, #12]
 8004b16:	3301      	adds	r3, #1
 8004b18:	60fb      	str	r3, [r7, #12]
 8004b1a:	68fb      	ldr	r3, [r7, #12]
 8004b1c:	2b09      	cmp	r3, #9
 8004b1e:	dde4      	ble.n	8004aea <fs_free+0xe>
    }
  }
  return;
 8004b20:	bf00      	nop
}
 8004b22:	3714      	adds	r7, #20
 8004b24:	46bd      	mov	sp, r7
 8004b26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004b2a:	4770      	bx	lr
 8004b2c:	2000a218 	.word	0x2000a218

08004b30 <fs_open>:

/*-----------------------------------------------------------------------------------*/
struct fs_file *
fs_open(const char *name)
{
 8004b30:	b580      	push	{r7, lr}
 8004b32:	b084      	sub	sp, #16
 8004b34:	af00      	add	r7, sp, #0
 8004b36:	6078      	str	r0, [r7, #4]
  struct fs_file *file;
  const struct fsdata_file *f;

  file = fs_malloc();
 8004b38:	f7ff ff9e 	bl	8004a78 <fs_malloc>
 8004b3c:	60b8      	str	r0, [r7, #8]
  if(file == NULL) {
 8004b3e:	68bb      	ldr	r3, [r7, #8]
 8004b40:	2b00      	cmp	r3, #0
 8004b42:	d101      	bne.n	8004b48 <fs_open+0x18>
    return NULL;
 8004b44:	2300      	movs	r3, #0
 8004b46:	e02a      	b.n	8004b9e <fs_open+0x6e>
    return file;
  }
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */

  for(f = FS_ROOT; f != NULL; f = f->next) {
 8004b48:	4b17      	ldr	r3, [pc, #92]	; (8004ba8 <fs_open+0x78>)
 8004b4a:	60fb      	str	r3, [r7, #12]
 8004b4c:	e020      	b.n	8004b90 <fs_open+0x60>
    if (!strcmp(name, (char *)f->name)) {
 8004b4e:	68fb      	ldr	r3, [r7, #12]
 8004b50:	685b      	ldr	r3, [r3, #4]
 8004b52:	4619      	mov	r1, r3
 8004b54:	6878      	ldr	r0, [r7, #4]
 8004b56:	f7fb fb3b 	bl	80001d0 <strcmp>
 8004b5a:	4603      	mov	r3, r0
 8004b5c:	2b00      	cmp	r3, #0
 8004b5e:	d114      	bne.n	8004b8a <fs_open+0x5a>
      file->data = (const char *)f->data;
 8004b60:	68fb      	ldr	r3, [r7, #12]
 8004b62:	689a      	ldr	r2, [r3, #8]
 8004b64:	68bb      	ldr	r3, [r7, #8]
 8004b66:	601a      	str	r2, [r3, #0]
      file->len = f->len;
 8004b68:	68fb      	ldr	r3, [r7, #12]
 8004b6a:	68da      	ldr	r2, [r3, #12]
 8004b6c:	68bb      	ldr	r3, [r7, #8]
 8004b6e:	605a      	str	r2, [r3, #4]
      file->index = f->len;
 8004b70:	68fb      	ldr	r3, [r7, #12]
 8004b72:	68da      	ldr	r2, [r3, #12]
 8004b74:	68bb      	ldr	r3, [r7, #8]
 8004b76:	609a      	str	r2, [r3, #8]
      file->pextension = NULL;
 8004b78:	68bb      	ldr	r3, [r7, #8]
 8004b7a:	2200      	movs	r2, #0
 8004b7c:	60da      	str	r2, [r3, #12]
      file->http_header_included = f->http_header_included;
 8004b7e:	68fb      	ldr	r3, [r7, #12]
 8004b80:	7c1a      	ldrb	r2, [r3, #16]
 8004b82:	68bb      	ldr	r3, [r7, #8]
 8004b84:	741a      	strb	r2, [r3, #16]
      file->chksum = f->chksum;
#endif /* HTTPD_PRECALCULATED_CHECKSUM */
#if LWIP_HTTPD_FILE_STATE
      file->state = fs_state_init(file, name);
#endif /* #if LWIP_HTTPD_FILE_STATE */
      return file;
 8004b86:	68bb      	ldr	r3, [r7, #8]
 8004b88:	e009      	b.n	8004b9e <fs_open+0x6e>
  for(f = FS_ROOT; f != NULL; f = f->next) {
 8004b8a:	68fb      	ldr	r3, [r7, #12]
 8004b8c:	681b      	ldr	r3, [r3, #0]
 8004b8e:	60fb      	str	r3, [r7, #12]
 8004b90:	68fb      	ldr	r3, [r7, #12]
 8004b92:	2b00      	cmp	r3, #0
 8004b94:	d1db      	bne.n	8004b4e <fs_open+0x1e>
    }
  }
  fs_free(file);
 8004b96:	68b8      	ldr	r0, [r7, #8]
 8004b98:	f7ff ffa0 	bl	8004adc <fs_free>
  return NULL;
 8004b9c:	2300      	movs	r3, #0
}
 8004b9e:	4618      	mov	r0, r3
 8004ba0:	3710      	adds	r7, #16
 8004ba2:	46bd      	mov	sp, r7
 8004ba4:	bd80      	pop	{r7, pc}
 8004ba6:	bf00      	nop
 8004ba8:	0801b524 	.word	0x0801b524

08004bac <fs_close>:

/*-----------------------------------------------------------------------------------*/
void
fs_close(struct fs_file *file)
{
 8004bac:	b580      	push	{r7, lr}
 8004bae:	b082      	sub	sp, #8
 8004bb0:	af00      	add	r7, sp, #0
 8004bb2:	6078      	str	r0, [r7, #4]
  }
#endif /* LWIP_HTTPD_CUSTOM_FILES */
#if LWIP_HTTPD_FILE_STATE
  fs_state_free(file, file->state);
#endif /* #if LWIP_HTTPD_FILE_STATE */
  fs_free(file);
 8004bb4:	6878      	ldr	r0, [r7, #4]
 8004bb6:	f7ff ff91 	bl	8004adc <fs_free>
}
 8004bba:	bf00      	nop
 8004bbc:	3708      	adds	r7, #8
 8004bbe:	46bd      	mov	sp, r7
 8004bc0:	bd80      	pop	{r7, pc}

08004bc2 <fs_read>:
/*-----------------------------------------------------------------------------------*/
int
fs_read(struct fs_file *file, char *buffer, int count)
{
 8004bc2:	b580      	push	{r7, lr}
 8004bc4:	b086      	sub	sp, #24
 8004bc6:	af00      	add	r7, sp, #0
 8004bc8:	60f8      	str	r0, [r7, #12]
 8004bca:	60b9      	str	r1, [r7, #8]
 8004bcc:	607a      	str	r2, [r7, #4]
  int read;

  if(file->index == file->len) {
 8004bce:	68fb      	ldr	r3, [r7, #12]
 8004bd0:	689a      	ldr	r2, [r3, #8]
 8004bd2:	68fb      	ldr	r3, [r7, #12]
 8004bd4:	685b      	ldr	r3, [r3, #4]
 8004bd6:	429a      	cmp	r2, r3
 8004bd8:	d102      	bne.n	8004be0 <fs_read+0x1e>
    return -1;
 8004bda:	f04f 33ff 	mov.w	r3, #4294967295
 8004bde:	e01c      	b.n	8004c1a <fs_read+0x58>
  }

  read = file->len - file->index;
 8004be0:	68fb      	ldr	r3, [r7, #12]
 8004be2:	685a      	ldr	r2, [r3, #4]
 8004be4:	68fb      	ldr	r3, [r7, #12]
 8004be6:	689b      	ldr	r3, [r3, #8]
 8004be8:	1ad3      	subs	r3, r2, r3
 8004bea:	617b      	str	r3, [r7, #20]
  if(read > count) {
 8004bec:	697a      	ldr	r2, [r7, #20]
 8004bee:	687b      	ldr	r3, [r7, #4]
 8004bf0:	429a      	cmp	r2, r3
 8004bf2:	dd01      	ble.n	8004bf8 <fs_read+0x36>
    read = count;
 8004bf4:	687b      	ldr	r3, [r7, #4]
 8004bf6:	617b      	str	r3, [r7, #20]
  }

  MEMCPY(buffer, (file->data + file->index), read);
 8004bf8:	68fb      	ldr	r3, [r7, #12]
 8004bfa:	681b      	ldr	r3, [r3, #0]
 8004bfc:	68fa      	ldr	r2, [r7, #12]
 8004bfe:	6892      	ldr	r2, [r2, #8]
 8004c00:	4413      	add	r3, r2
 8004c02:	697a      	ldr	r2, [r7, #20]
 8004c04:	4619      	mov	r1, r3
 8004c06:	68b8      	ldr	r0, [r7, #8]
 8004c08:	f009 fd2d 	bl	800e666 <memcpy>
  file->index += read;
 8004c0c:	68fb      	ldr	r3, [r7, #12]
 8004c0e:	689a      	ldr	r2, [r3, #8]
 8004c10:	697b      	ldr	r3, [r7, #20]
 8004c12:	441a      	add	r2, r3
 8004c14:	68fb      	ldr	r3, [r7, #12]
 8004c16:	609a      	str	r2, [r3, #8]

  return(read);
 8004c18:	697b      	ldr	r3, [r7, #20]
}
 8004c1a:	4618      	mov	r0, r3
 8004c1c:	3718      	adds	r7, #24
 8004c1e:	46bd      	mov	sp, r7
 8004c20:	bd80      	pop	{r7, pc}

08004c22 <fs_bytes_left>:
/*-----------------------------------------------------------------------------------*/
int fs_bytes_left(struct fs_file *file)
{
 8004c22:	b480      	push	{r7}
 8004c24:	b083      	sub	sp, #12
 8004c26:	af00      	add	r7, sp, #0
 8004c28:	6078      	str	r0, [r7, #4]
  return file->len - file->index;
 8004c2a:	687b      	ldr	r3, [r7, #4]
 8004c2c:	685a      	ldr	r2, [r3, #4]
 8004c2e:	687b      	ldr	r3, [r7, #4]
 8004c30:	689b      	ldr	r3, [r3, #8]
 8004c32:	1ad3      	subs	r3, r2, r3
}
 8004c34:	4618      	mov	r0, r3
 8004c36:	370c      	adds	r7, #12
 8004c38:	46bd      	mov	sp, r7
 8004c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c3e:	4770      	bx	lr

08004c40 <strnstr>:
#endif /* LWIP_HTTPD_CGI */

#if LWIP_HTTPD_STRNSTR_PRIVATE
/** Like strstr but does not need 'buffer' to be NULL-terminated */
static char* strnstr(const char* buffer, const char* token, size_t n)
{
 8004c40:	b580      	push	{r7, lr}
 8004c42:	b086      	sub	sp, #24
 8004c44:	af00      	add	r7, sp, #0
 8004c46:	60f8      	str	r0, [r7, #12]
 8004c48:	60b9      	str	r1, [r7, #8]
 8004c4a:	607a      	str	r2, [r7, #4]
  const char* p;
  int tokenlen = (int)strlen(token);
 8004c4c:	68b8      	ldr	r0, [r7, #8]
 8004c4e:	f7fb fac9 	bl	80001e4 <strlen>
 8004c52:	4603      	mov	r3, r0
 8004c54:	613b      	str	r3, [r7, #16]
  if (tokenlen == 0) {
 8004c56:	693b      	ldr	r3, [r7, #16]
 8004c58:	2b00      	cmp	r3, #0
 8004c5a:	d101      	bne.n	8004c60 <strnstr+0x20>
    return (char *)buffer;
 8004c5c:	68fb      	ldr	r3, [r7, #12]
 8004c5e:	e023      	b.n	8004ca8 <strnstr+0x68>
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 8004c60:	68fb      	ldr	r3, [r7, #12]
 8004c62:	617b      	str	r3, [r7, #20]
 8004c64:	e013      	b.n	8004c8e <strnstr+0x4e>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
 8004c66:	697b      	ldr	r3, [r7, #20]
 8004c68:	781a      	ldrb	r2, [r3, #0]
 8004c6a:	68bb      	ldr	r3, [r7, #8]
 8004c6c:	781b      	ldrb	r3, [r3, #0]
 8004c6e:	429a      	cmp	r2, r3
 8004c70:	d10a      	bne.n	8004c88 <strnstr+0x48>
 8004c72:	693b      	ldr	r3, [r7, #16]
 8004c74:	461a      	mov	r2, r3
 8004c76:	68b9      	ldr	r1, [r7, #8]
 8004c78:	6978      	ldr	r0, [r7, #20]
 8004c7a:	f009 fd1d 	bl	800e6b8 <strncmp>
 8004c7e:	4603      	mov	r3, r0
 8004c80:	2b00      	cmp	r3, #0
 8004c82:	d101      	bne.n	8004c88 <strnstr+0x48>
      return (char *)p;
 8004c84:	697b      	ldr	r3, [r7, #20]
 8004c86:	e00f      	b.n	8004ca8 <strnstr+0x68>
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 8004c88:	697b      	ldr	r3, [r7, #20]
 8004c8a:	3301      	adds	r3, #1
 8004c8c:	617b      	str	r3, [r7, #20]
 8004c8e:	697b      	ldr	r3, [r7, #20]
 8004c90:	781b      	ldrb	r3, [r3, #0]
 8004c92:	2b00      	cmp	r3, #0
 8004c94:	d007      	beq.n	8004ca6 <strnstr+0x66>
 8004c96:	693b      	ldr	r3, [r7, #16]
 8004c98:	697a      	ldr	r2, [r7, #20]
 8004c9a:	441a      	add	r2, r3
 8004c9c:	68f9      	ldr	r1, [r7, #12]
 8004c9e:	687b      	ldr	r3, [r7, #4]
 8004ca0:	440b      	add	r3, r1
 8004ca2:	429a      	cmp	r2, r3
 8004ca4:	d9df      	bls.n	8004c66 <strnstr+0x26>
    }
  }
  return NULL;
 8004ca6:	2300      	movs	r3, #0
} 
 8004ca8:	4618      	mov	r0, r3
 8004caa:	3718      	adds	r7, #24
 8004cac:	46bd      	mov	sp, r7
 8004cae:	bd80      	pop	{r7, pc}

08004cb0 <http_state_alloc>:
#endif /* LWIP_HTTPD_STRNSTR_PRIVATE */

/** Allocate a struct http_state. */
static struct http_state* http_state_alloc(void)
{
 8004cb0:	b580      	push	{r7, lr}
 8004cb2:	b082      	sub	sp, #8
 8004cb4:	af00      	add	r7, sp, #0
  struct http_state *ret;
#if HTTPD_USE_MEM_POOL
  ret = (struct http_state *)memp_malloc(MEMP_HTTPD_STATE);
#else /* HTTPD_USE_MEM_POOL */
  ret = (struct http_state *)mem_malloc(sizeof(struct http_state));
 8004cb6:	f44f 70ba 	mov.w	r0, #372	; 0x174
 8004cba:	f003 f931 	bl	8007f20 <mem_malloc>
 8004cbe:	6078      	str	r0, [r7, #4]
#endif /* HTTPD_USE_MEM_POOL */
  if (ret != NULL) {
 8004cc0:	687b      	ldr	r3, [r7, #4]
 8004cc2:	2b00      	cmp	r3, #0
 8004cc4:	d005      	beq.n	8004cd2 <http_state_alloc+0x22>
    /* Initialize the structure. */
    memset(ret, 0, sizeof(struct http_state));
 8004cc6:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8004cca:	2100      	movs	r1, #0
 8004ccc:	6878      	ldr	r0, [r7, #4]
 8004cce:	f009 fcd5 	bl	800e67c <memset>
#if LWIP_HTTPD_DYNAMIC_HEADERS
    /* Indicate that the headers are not yet valid */
    ret->hdr_index = NUM_FILE_HDR_STRINGS;
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
  }
  return ret;
 8004cd2:	687b      	ldr	r3, [r7, #4]
}
 8004cd4:	4618      	mov	r0, r3
 8004cd6:	3708      	adds	r7, #8
 8004cd8:	46bd      	mov	sp, r7
 8004cda:	bd80      	pop	{r7, pc}

08004cdc <http_state_free>:

/** Free a struct http_state.
 * Also frees the file data if dynamic.
 */
static void http_state_free(struct http_state *hs)
{
 8004cdc:	b580      	push	{r7, lr}
 8004cde:	b082      	sub	sp, #8
 8004ce0:	af00      	add	r7, sp, #0
 8004ce2:	6078      	str	r0, [r7, #4]
  if (hs != NULL) {
 8004ce4:	687b      	ldr	r3, [r7, #4]
 8004ce6:	2b00      	cmp	r3, #0
 8004ce8:	d01a      	beq.n	8004d20 <http_state_free+0x44>
    if(hs->handle) {
 8004cea:	687b      	ldr	r3, [r7, #4]
 8004cec:	681b      	ldr	r3, [r3, #0]
 8004cee:	2b00      	cmp	r3, #0
 8004cf0:	d007      	beq.n	8004d02 <http_state_free+0x26>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 8004cf2:	687b      	ldr	r3, [r7, #4]
 8004cf4:	681b      	ldr	r3, [r3, #0]
 8004cf6:	4618      	mov	r0, r3
 8004cf8:	f7ff ff58 	bl	8004bac <fs_close>
      hs->handle = NULL;
 8004cfc:	687b      	ldr	r3, [r7, #4]
 8004cfe:	2200      	movs	r2, #0
 8004d00:	601a      	str	r2, [r3, #0]
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    if (hs->buf != NULL) {
 8004d02:	687b      	ldr	r3, [r7, #4]
 8004d04:	68db      	ldr	r3, [r3, #12]
 8004d06:	2b00      	cmp	r3, #0
 8004d08:	d007      	beq.n	8004d1a <http_state_free+0x3e>
      mem_free(hs->buf);
 8004d0a:	687b      	ldr	r3, [r7, #4]
 8004d0c:	68db      	ldr	r3, [r3, #12]
 8004d0e:	4618      	mov	r0, r3
 8004d10:	f003 f814 	bl	8007d3c <mem_free>
      hs->buf = NULL;
 8004d14:	687b      	ldr	r3, [r7, #4]
 8004d16:	2200      	movs	r2, #0
 8004d18:	60da      	str	r2, [r3, #12]
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 8004d1a:	6878      	ldr	r0, [r7, #4]
 8004d1c:	f003 f80e 	bl	8007d3c <mem_free>
#endif /* HTTPD_USE_MEM_POOL */
  }
}
 8004d20:	bf00      	nop
 8004d22:	3708      	adds	r7, #8
 8004d24:	46bd      	mov	sp, r7
 8004d26:	bd80      	pop	{r7, pc}

08004d28 <http_write>:
 *        amount of data sent)
 * @param apiflags directly passed to tcp_write
 * @return the return value of tcp_write
 */
static err_t http_write(struct tcp_pcb *pcb, const void* ptr, u16_t *length, u8_t apiflags)
{
 8004d28:	b580      	push	{r7, lr}
 8004d2a:	b086      	sub	sp, #24
 8004d2c:	af00      	add	r7, sp, #0
 8004d2e:	60f8      	str	r0, [r7, #12]
 8004d30:	60b9      	str	r1, [r7, #8]
 8004d32:	607a      	str	r2, [r7, #4]
 8004d34:	70fb      	strb	r3, [r7, #3]
   u16_t len;
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
 8004d36:	687b      	ldr	r3, [r7, #4]
 8004d38:	881b      	ldrh	r3, [r3, #0]
 8004d3a:	82fb      	strh	r3, [r7, #22]
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sending %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 8004d3c:	78fb      	ldrb	r3, [r7, #3]
 8004d3e:	8afa      	ldrh	r2, [r7, #22]
 8004d40:	68b9      	ldr	r1, [r7, #8]
 8004d42:	68f8      	ldr	r0, [r7, #12]
 8004d44:	f006 fca9 	bl	800b69a <tcp_write>
 8004d48:	4603      	mov	r3, r0
 8004d4a:	757b      	strb	r3, [r7, #21]
     if (err == ERR_MEM) {
 8004d4c:	f997 3015 	ldrsb.w	r3, [r7, #21]
 8004d50:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004d54:	d10f      	bne.n	8004d76 <http_write+0x4e>
       if ((tcp_sndbuf(pcb) == 0) ||
 8004d56:	68fb      	ldr	r3, [r7, #12]
 8004d58:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8004d5c:	2b00      	cmp	r3, #0
 8004d5e:	d004      	beq.n	8004d6a <http_write+0x42>
           (pcb->snd_queuelen >= TCP_SND_QUEUELEN)) {
 8004d60:	68fb      	ldr	r3, [r7, #12]
 8004d62:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
       if ((tcp_sndbuf(pcb) == 0) ||
 8004d66:	2b07      	cmp	r3, #7
 8004d68:	d902      	bls.n	8004d70 <http_write+0x48>
         /* no need to try smaller sizes */
         len = 1;
 8004d6a:	2301      	movs	r3, #1
 8004d6c:	82fb      	strh	r3, [r7, #22]
 8004d6e:	e002      	b.n	8004d76 <http_write+0x4e>
       } else {
         len /= 2;
 8004d70:	8afb      	ldrh	r3, [r7, #22]
 8004d72:	085b      	lsrs	r3, r3, #1
 8004d74:	82fb      	strh	r3, [r7, #22]
       }
     }
   } while ((err == ERR_MEM) && (len > 1));
 8004d76:	f997 3015 	ldrsb.w	r3, [r7, #21]
 8004d7a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004d7e:	d102      	bne.n	8004d86 <http_write+0x5e>
 8004d80:	8afb      	ldrh	r3, [r7, #22]
 8004d82:	2b01      	cmp	r3, #1
 8004d84:	d8da      	bhi.n	8004d3c <http_write+0x14>

   *length = len;
 8004d86:	687b      	ldr	r3, [r7, #4]
 8004d88:	8afa      	ldrh	r2, [r7, #22]
 8004d8a:	801a      	strh	r2, [r3, #0]
   return err;
 8004d8c:	f997 3015 	ldrsb.w	r3, [r7, #21]
}
 8004d90:	4618      	mov	r0, r3
 8004d92:	3718      	adds	r7, #24
 8004d94:	46bd      	mov	sp, r7
 8004d96:	bd80      	pop	{r7, pc}

08004d98 <http_close_conn>:
 *
 * @param pcb the tcp pcb to reset callbacks
 * @param hs connection state to free
 */
static void http_close_conn(struct tcp_pcb *pcb, struct http_state *hs)
{
 8004d98:	b580      	push	{r7, lr}
 8004d9a:	b084      	sub	sp, #16
 8004d9c:	af00      	add	r7, sp, #0
 8004d9e:	6078      	str	r0, [r7, #4]
 8004da0:	6039      	str	r1, [r7, #0]
    httpd_post_finished(hs, http_post_response_filename, LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN);
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 8004da2:	2100      	movs	r1, #0
 8004da4:	6878      	ldr	r0, [r7, #4]
 8004da6:	f004 fdf9 	bl	800999c <tcp_arg>
  tcp_recv(pcb, NULL);
 8004daa:	2100      	movs	r1, #0
 8004dac:	6878      	ldr	r0, [r7, #4]
 8004dae:	f004 fe03 	bl	80099b8 <tcp_recv>
  tcp_err(pcb, NULL);
 8004db2:	2100      	movs	r1, #0
 8004db4:	6878      	ldr	r0, [r7, #4]
 8004db6:	f004 fe1d 	bl	80099f4 <tcp_err>
  tcp_poll(pcb, NULL, 0);
 8004dba:	2200      	movs	r2, #0
 8004dbc:	2100      	movs	r1, #0
 8004dbe:	6878      	ldr	r0, [r7, #4]
 8004dc0:	f004 fe35 	bl	8009a2e <tcp_poll>
  tcp_sent(pcb, NULL);
 8004dc4:	2100      	movs	r1, #0
 8004dc6:	6878      	ldr	r0, [r7, #4]
 8004dc8:	f004 fe05 	bl	80099d6 <tcp_sent>
  http_state_free(hs);
 8004dcc:	6838      	ldr	r0, [r7, #0]
 8004dce:	f7ff ff85 	bl	8004cdc <http_state_free>

  err = tcp_close(pcb);
 8004dd2:	6878      	ldr	r0, [r7, #4]
 8004dd4:	f003 fef0 	bl	8008bb8 <tcp_close>
 8004dd8:	4603      	mov	r3, r0
 8004dda:	73fb      	strb	r3, [r7, #15]
  if (err != ERR_OK) {
 8004ddc:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8004de0:	2b00      	cmp	r3, #0
 8004de2:	d004      	beq.n	8004dee <http_close_conn+0x56>
    LWIP_DEBUGF(HTTPD_DEBUG, ("Error %d closing %p\n", err, (void*)pcb));
    /* error closing, try again later in poll */
    tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 8004de4:	2204      	movs	r2, #4
 8004de6:	4904      	ldr	r1, [pc, #16]	; (8004df8 <http_close_conn+0x60>)
 8004de8:	6878      	ldr	r0, [r7, #4]
 8004dea:	f004 fe20 	bl	8009a2e <tcp_poll>
  }
}
 8004dee:	bf00      	nop
 8004df0:	3710      	adds	r7, #16
 8004df2:	46bd      	mov	sp, r7
 8004df4:	bd80      	pop	{r7, pc}
 8004df6:	bf00      	nop
 8004df8:	08005ba9 	.word	0x08005ba9

08004dfc <extract_uri_parameters>:
 * @param hs http connection state
 * @param params pointer to the NULL-terminated parameter string from the URI
 * @return number of parameters extracted
 */
static int extract_uri_parameters(struct http_state *hs, char *params)
{
 8004dfc:	b580      	push	{r7, lr}
 8004dfe:	b086      	sub	sp, #24
 8004e00:	af00      	add	r7, sp, #0
 8004e02:	6078      	str	r0, [r7, #4]
 8004e04:	6039      	str	r1, [r7, #0]
  char *pair;
  char *equals;
  int loop;

  /* If we have no parameters at all, return immediately. */
  if(!params || (params[0] == '\0')) {
 8004e06:	683b      	ldr	r3, [r7, #0]
 8004e08:	2b00      	cmp	r3, #0
 8004e0a:	d003      	beq.n	8004e14 <extract_uri_parameters+0x18>
 8004e0c:	683b      	ldr	r3, [r7, #0]
 8004e0e:	781b      	ldrb	r3, [r3, #0]
 8004e10:	2b00      	cmp	r3, #0
 8004e12:	d101      	bne.n	8004e18 <extract_uri_parameters+0x1c>
      return(0);
 8004e14:	2300      	movs	r3, #0
 8004e16:	e04e      	b.n	8004eb6 <extract_uri_parameters+0xba>
  }

  /* Get a pointer to our first parameter */
  pair = params;
 8004e18:	683b      	ldr	r3, [r7, #0]
 8004e1a:	617b      	str	r3, [r7, #20]

  /* Parse up to LWIP_HTTPD_MAX_CGI_PARAMETERS from the passed string and ignore the
   * remainder (if any) */
  for(loop = 0; (loop < LWIP_HTTPD_MAX_CGI_PARAMETERS) && pair; loop++) {
 8004e1c:	2300      	movs	r3, #0
 8004e1e:	613b      	str	r3, [r7, #16]
 8004e20:	e042      	b.n	8004ea8 <extract_uri_parameters+0xac>

    /* Save the name of the parameter */
    hs->params[loop] = pair;
 8004e22:	687a      	ldr	r2, [r7, #4]
 8004e24:	693b      	ldr	r3, [r7, #16]
 8004e26:	333c      	adds	r3, #60	; 0x3c
 8004e28:	009b      	lsls	r3, r3, #2
 8004e2a:	4413      	add	r3, r2
 8004e2c:	697a      	ldr	r2, [r7, #20]
 8004e2e:	605a      	str	r2, [r3, #4]

    /* Remember the start of this name=value pair */
    equals = pair;
 8004e30:	697b      	ldr	r3, [r7, #20]
 8004e32:	60fb      	str	r3, [r7, #12]

    /* Find the start of the next name=value pair and replace the delimiter
     * with a 0 to terminate the previous pair string. */
    pair = strchr(pair, '&');
 8004e34:	2126      	movs	r1, #38	; 0x26
 8004e36:	6978      	ldr	r0, [r7, #20]
 8004e38:	f009 fc28 	bl	800e68c <strchr>
 8004e3c:	6178      	str	r0, [r7, #20]
    if(pair) {
 8004e3e:	697b      	ldr	r3, [r7, #20]
 8004e40:	2b00      	cmp	r3, #0
 8004e42:	d006      	beq.n	8004e52 <extract_uri_parameters+0x56>
      *pair = '\0';
 8004e44:	697b      	ldr	r3, [r7, #20]
 8004e46:	2200      	movs	r2, #0
 8004e48:	701a      	strb	r2, [r3, #0]
      pair++;
 8004e4a:	697b      	ldr	r3, [r7, #20]
 8004e4c:	3301      	adds	r3, #1
 8004e4e:	617b      	str	r3, [r7, #20]
 8004e50:	e00c      	b.n	8004e6c <extract_uri_parameters+0x70>
    } else {
       /* We didn't find a new parameter so find the end of the URI and
        * replace the space with a '\0' */
        pair = strchr(equals, ' ');
 8004e52:	2120      	movs	r1, #32
 8004e54:	68f8      	ldr	r0, [r7, #12]
 8004e56:	f009 fc19 	bl	800e68c <strchr>
 8004e5a:	6178      	str	r0, [r7, #20]
        if(pair) {
 8004e5c:	697b      	ldr	r3, [r7, #20]
 8004e5e:	2b00      	cmp	r3, #0
 8004e60:	d002      	beq.n	8004e68 <extract_uri_parameters+0x6c>
            *pair = '\0';
 8004e62:	697b      	ldr	r3, [r7, #20]
 8004e64:	2200      	movs	r2, #0
 8004e66:	701a      	strb	r2, [r3, #0]
        }

        /* Revert to NULL so that we exit the loop as expected. */
        pair = NULL;
 8004e68:	2300      	movs	r3, #0
 8004e6a:	617b      	str	r3, [r7, #20]
    }

    /* Now find the '=' in the previous pair, replace it with '\0' and save
     * the parameter value string. */
    equals = strchr(equals, '=');
 8004e6c:	213d      	movs	r1, #61	; 0x3d
 8004e6e:	68f8      	ldr	r0, [r7, #12]
 8004e70:	f009 fc0c 	bl	800e68c <strchr>
 8004e74:	60f8      	str	r0, [r7, #12]
    if(equals) {
 8004e76:	68fb      	ldr	r3, [r7, #12]
 8004e78:	2b00      	cmp	r3, #0
 8004e7a:	d00b      	beq.n	8004e94 <extract_uri_parameters+0x98>
      *equals = '\0';
 8004e7c:	68fb      	ldr	r3, [r7, #12]
 8004e7e:	2200      	movs	r2, #0
 8004e80:	701a      	strb	r2, [r3, #0]
      hs->param_vals[loop] = equals + 1;
 8004e82:	68fb      	ldr	r3, [r7, #12]
 8004e84:	1c5a      	adds	r2, r3, #1
 8004e86:	6879      	ldr	r1, [r7, #4]
 8004e88:	693b      	ldr	r3, [r7, #16]
 8004e8a:	334c      	adds	r3, #76	; 0x4c
 8004e8c:	009b      	lsls	r3, r3, #2
 8004e8e:	440b      	add	r3, r1
 8004e90:	605a      	str	r2, [r3, #4]
 8004e92:	e006      	b.n	8004ea2 <extract_uri_parameters+0xa6>
    } else {
      hs->param_vals[loop] = NULL;
 8004e94:	687a      	ldr	r2, [r7, #4]
 8004e96:	693b      	ldr	r3, [r7, #16]
 8004e98:	334c      	adds	r3, #76	; 0x4c
 8004e9a:	009b      	lsls	r3, r3, #2
 8004e9c:	4413      	add	r3, r2
 8004e9e:	2200      	movs	r2, #0
 8004ea0:	605a      	str	r2, [r3, #4]
  for(loop = 0; (loop < LWIP_HTTPD_MAX_CGI_PARAMETERS) && pair; loop++) {
 8004ea2:	693b      	ldr	r3, [r7, #16]
 8004ea4:	3301      	adds	r3, #1
 8004ea6:	613b      	str	r3, [r7, #16]
 8004ea8:	693b      	ldr	r3, [r7, #16]
 8004eaa:	2b0f      	cmp	r3, #15
 8004eac:	dc02      	bgt.n	8004eb4 <extract_uri_parameters+0xb8>
 8004eae:	697b      	ldr	r3, [r7, #20]
 8004eb0:	2b00      	cmp	r3, #0
 8004eb2:	d1b6      	bne.n	8004e22 <extract_uri_parameters+0x26>
    }
  }

  return loop;
 8004eb4:	693b      	ldr	r3, [r7, #16]
}
 8004eb6:	4618      	mov	r0, r3
 8004eb8:	3718      	adds	r7, #24
 8004eba:	46bd      	mov	sp, r7
 8004ebc:	bd80      	pop	{r7, pc}
	...

08004ec0 <get_tag_insert>:
 * @todo: return tag_insert_len - maybe it can be removed from struct http_state?
 *
 * @param hs http connection state
 */
static void get_tag_insert(struct http_state *hs)
{
 8004ec0:	b580      	push	{r7, lr}
 8004ec2:	b084      	sub	sp, #16
 8004ec4:	af00      	add	r7, sp, #0
 8004ec6:	6078      	str	r0, [r7, #4]
#if LWIP_HTTPD_SSI_MULTIPART
  u16_t current_tag_part = hs->tag_part;
  hs->tag_part = HTTPD_LAST_TAG_PART;
#endif /* LWIP_HTTPD_SSI_MULTIPART */

  if(g_pfnSSIHandler && g_ppcTags && g_iNumTags) {
 8004ec8:	4b38      	ldr	r3, [pc, #224]	; (8004fac <get_tag_insert+0xec>)
 8004eca:	681b      	ldr	r3, [r3, #0]
 8004ecc:	2b00      	cmp	r3, #0
 8004ece:	d02e      	beq.n	8004f2e <get_tag_insert+0x6e>
 8004ed0:	4b37      	ldr	r3, [pc, #220]	; (8004fb0 <get_tag_insert+0xf0>)
 8004ed2:	681b      	ldr	r3, [r3, #0]
 8004ed4:	2b00      	cmp	r3, #0
 8004ed6:	d02a      	beq.n	8004f2e <get_tag_insert+0x6e>
 8004ed8:	4b36      	ldr	r3, [pc, #216]	; (8004fb4 <get_tag_insert+0xf4>)
 8004eda:	681b      	ldr	r3, [r3, #0]
 8004edc:	2b00      	cmp	r3, #0
 8004ede:	d026      	beq.n	8004f2e <get_tag_insert+0x6e>

    /* Find this tag in the list we have been provided. */
    for(loop = 0; loop < g_iNumTags; loop++) {
 8004ee0:	2300      	movs	r3, #0
 8004ee2:	60fb      	str	r3, [r7, #12]
 8004ee4:	e01e      	b.n	8004f24 <get_tag_insert+0x64>
      if(strcmp((hs->tag_name), g_ppcTags[loop]) == 0) {
 8004ee6:	687b      	ldr	r3, [r7, #4]
 8004ee8:	f103 002e 	add.w	r0, r3, #46	; 0x2e
 8004eec:	4b30      	ldr	r3, [pc, #192]	; (8004fb0 <get_tag_insert+0xf0>)
 8004eee:	681a      	ldr	r2, [r3, #0]
 8004ef0:	68fb      	ldr	r3, [r7, #12]
 8004ef2:	009b      	lsls	r3, r3, #2
 8004ef4:	4413      	add	r3, r2
 8004ef6:	681b      	ldr	r3, [r3, #0]
 8004ef8:	4619      	mov	r1, r3
 8004efa:	f7fb f969 	bl	80001d0 <strcmp>
 8004efe:	4603      	mov	r3, r0
 8004f00:	2b00      	cmp	r3, #0
 8004f02:	d10c      	bne.n	8004f1e <get_tag_insert+0x5e>
        hs->tag_insert_len = g_pfnSSIHandler(loop, hs->tag_insert,
 8004f04:	4b29      	ldr	r3, [pc, #164]	; (8004fac <get_tag_insert+0xec>)
 8004f06:	681b      	ldr	r3, [r3, #0]
 8004f08:	687a      	ldr	r2, [r7, #4]
 8004f0a:	f102 0130 	add.w	r1, r2, #48	; 0x30
 8004f0e:	22c0      	movs	r2, #192	; 0xc0
 8004f10:	68f8      	ldr	r0, [r7, #12]
 8004f12:	4798      	blx	r3
 8004f14:	4603      	mov	r3, r0
 8004f16:	461a      	mov	r2, r3
 8004f18:	687b      	ldr	r3, [r7, #4]
 8004f1a:	855a      	strh	r2, [r3, #42]	; 0x2a
#endif /* LWIP_HTTPD_SSI_MULTIPART */
#if LWIP_HTTPD_FILE_STATE
           , hs->handle->state
#endif /* LWIP_HTTPD_FILE_STATE */
           );
        return;
 8004f1c:	e043      	b.n	8004fa6 <get_tag_insert+0xe6>
    for(loop = 0; loop < g_iNumTags; loop++) {
 8004f1e:	68fb      	ldr	r3, [r7, #12]
 8004f20:	3301      	adds	r3, #1
 8004f22:	60fb      	str	r3, [r7, #12]
 8004f24:	4b23      	ldr	r3, [pc, #140]	; (8004fb4 <get_tag_insert+0xf4>)
 8004f26:	681b      	ldr	r3, [r3, #0]
 8004f28:	68fa      	ldr	r2, [r7, #12]
 8004f2a:	429a      	cmp	r2, r3
 8004f2c:	dbdb      	blt.n	8004ee6 <get_tag_insert+0x26>
   * marker. */
#define UNKNOWN_TAG1_TEXT "<b>***UNKNOWN TAG "
#define UNKNOWN_TAG1_LEN  18
#define UNKNOWN_TAG2_TEXT "***</b>"
#define UNKNOWN_TAG2_LEN  7
  len = LWIP_MIN(strlen(hs->tag_name),
 8004f2e:	687b      	ldr	r3, [r7, #4]
 8004f30:	332e      	adds	r3, #46	; 0x2e
 8004f32:	4618      	mov	r0, r3
 8004f34:	f7fb f956 	bl	80001e4 <strlen>
 8004f38:	4603      	mov	r3, r0
 8004f3a:	2ba6      	cmp	r3, #166	; 0xa6
 8004f3c:	d806      	bhi.n	8004f4c <get_tag_insert+0x8c>
 8004f3e:	687b      	ldr	r3, [r7, #4]
 8004f40:	332e      	adds	r3, #46	; 0x2e
 8004f42:	4618      	mov	r0, r3
 8004f44:	f7fb f94e 	bl	80001e4 <strlen>
 8004f48:	4603      	mov	r3, r0
 8004f4a:	e000      	b.n	8004f4e <get_tag_insert+0x8e>
 8004f4c:	23a7      	movs	r3, #167	; 0xa7
 8004f4e:	60bb      	str	r3, [r7, #8]
    LWIP_HTTPD_MAX_TAG_INSERT_LEN - (UNKNOWN_TAG1_LEN + UNKNOWN_TAG2_LEN));
  MEMCPY(hs->tag_insert, UNKNOWN_TAG1_TEXT, UNKNOWN_TAG1_LEN);
 8004f50:	687b      	ldr	r3, [r7, #4]
 8004f52:	3330      	adds	r3, #48	; 0x30
 8004f54:	2212      	movs	r2, #18
 8004f56:	4918      	ldr	r1, [pc, #96]	; (8004fb8 <get_tag_insert+0xf8>)
 8004f58:	4618      	mov	r0, r3
 8004f5a:	f009 fb84 	bl	800e666 <memcpy>
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN], hs->tag_name, len);
 8004f5e:	687b      	ldr	r3, [r7, #4]
 8004f60:	f103 0042 	add.w	r0, r3, #66	; 0x42
 8004f64:	687b      	ldr	r3, [r7, #4]
 8004f66:	332e      	adds	r3, #46	; 0x2e
 8004f68:	68ba      	ldr	r2, [r7, #8]
 8004f6a:	4619      	mov	r1, r3
 8004f6c:	f009 fb7b 	bl	800e666 <memcpy>
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN + len], UNKNOWN_TAG2_TEXT, UNKNOWN_TAG2_LEN);
 8004f70:	68bb      	ldr	r3, [r7, #8]
 8004f72:	3312      	adds	r3, #18
 8004f74:	3330      	adds	r3, #48	; 0x30
 8004f76:	687a      	ldr	r2, [r7, #4]
 8004f78:	4413      	add	r3, r2
 8004f7a:	2207      	movs	r2, #7
 8004f7c:	490f      	ldr	r1, [pc, #60]	; (8004fbc <get_tag_insert+0xfc>)
 8004f7e:	4618      	mov	r0, r3
 8004f80:	f009 fb71 	bl	800e666 <memcpy>
  hs->tag_insert[UNKNOWN_TAG1_LEN + len + UNKNOWN_TAG2_LEN] = 0;
 8004f84:	68bb      	ldr	r3, [r7, #8]
 8004f86:	3319      	adds	r3, #25
 8004f88:	687a      	ldr	r2, [r7, #4]
 8004f8a:	4413      	add	r3, r2
 8004f8c:	2200      	movs	r2, #0
 8004f8e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

  len = strlen(hs->tag_insert);
 8004f92:	687b      	ldr	r3, [r7, #4]
 8004f94:	3330      	adds	r3, #48	; 0x30
 8004f96:	4618      	mov	r0, r3
 8004f98:	f7fb f924 	bl	80001e4 <strlen>
 8004f9c:	60b8      	str	r0, [r7, #8]
  LWIP_ASSERT("len <= 0xffff", len <= 0xffff);
  hs->tag_insert_len = (u16_t)len;
 8004f9e:	68bb      	ldr	r3, [r7, #8]
 8004fa0:	b29a      	uxth	r2, r3
 8004fa2:	687b      	ldr	r3, [r7, #4]
 8004fa4:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 8004fa6:	3710      	adds	r7, #16
 8004fa8:	46bd      	mov	sp, r7
 8004faa:	bd80      	pop	{r7, pc}
 8004fac:	200029d4 	.word	0x200029d4
 8004fb0:	200029dc 	.word	0x200029dc
 8004fb4:	200029d8 	.word	0x200029d8
 8004fb8:	0800e7b0 	.word	0x0800e7b0
 8004fbc:	0800e7c4 	.word	0x0800e7c4

08004fc0 <http_send_data>:
 *
 * @param pcb the pcb to send data
 * @param hs connection state
 */
static u8_t http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
 8004fc0:	b580      	push	{r7, lr}
 8004fc2:	b086      	sub	sp, #24
 8004fc4:	af00      	add	r7, sp, #0
 8004fc6:	6078      	str	r0, [r7, #4]
 8004fc8:	6039      	str	r1, [r7, #0]
  err_t err;
  u16_t len;
  u16_t mss;
  u8_t data_to_send = false;
 8004fca:	2300      	movs	r3, #0
 8004fcc:	75bb      	strb	r3, [r7, #22]
      return 1;
    }
  }
#else /* LWIP_HTTPD_DYNAMIC_HEADERS */
  /* Assume no error until we find otherwise */
  err = ERR_OK;
 8004fce:	2300      	movs	r3, #0
 8004fd0:	75fb      	strb	r3, [r7, #23]
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */

  /* Have we run out of file data to send? If so, we need to read the next
   * block from the file. */
  if (hs->left == 0) {
 8004fd2:	683b      	ldr	r3, [r7, #0]
 8004fd4:	695b      	ldr	r3, [r3, #20]
 8004fd6:	2b00      	cmp	r3, #0
 8004fd8:	d161      	bne.n	800509e <http_send_data+0xde>
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    int count;
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */

    /* Do we have a valid file handle? */
    if (hs->handle == NULL) {
 8004fda:	683b      	ldr	r3, [r7, #0]
 8004fdc:	681b      	ldr	r3, [r3, #0]
 8004fde:	2b00      	cmp	r3, #0
 8004fe0:	d105      	bne.n	8004fee <http_send_data+0x2e>
      /* No - close the connection. */
      http_close_conn(pcb, hs);
 8004fe2:	6839      	ldr	r1, [r7, #0]
 8004fe4:	6878      	ldr	r0, [r7, #4]
 8004fe6:	f7ff fed7 	bl	8004d98 <http_close_conn>
      return 0;
 8004fea:	2300      	movs	r3, #0
 8004fec:	e372      	b.n	80056d4 <http_send_data+0x714>
    }
    if (fs_bytes_left(hs->handle) <= 0) {
 8004fee:	683b      	ldr	r3, [r7, #0]
 8004ff0:	681b      	ldr	r3, [r3, #0]
 8004ff2:	4618      	mov	r0, r3
 8004ff4:	f7ff fe15 	bl	8004c22 <fs_bytes_left>
 8004ff8:	4603      	mov	r3, r0
 8004ffa:	2b00      	cmp	r3, #0
 8004ffc:	dc05      	bgt.n	800500a <http_send_data+0x4a>
      /* We reached the end of the file so this request is done.
       * @todo: don't close here for HTTP/1.1? */
      LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
      http_close_conn(pcb, hs);
 8004ffe:	6839      	ldr	r1, [r7, #0]
 8005000:	6878      	ldr	r0, [r7, #4]
 8005002:	f7ff fec9 	bl	8004d98 <http_close_conn>
      return 0;
 8005006:	2300      	movs	r3, #0
 8005008:	e364      	b.n	80056d4 <http_send_data+0x714>
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    /* Do we already have a send buffer allocated? */
    if(hs->buf) {
 800500a:	683b      	ldr	r3, [r7, #0]
 800500c:	68db      	ldr	r3, [r3, #12]
 800500e:	2b00      	cmp	r3, #0
 8005010:	d003      	beq.n	800501a <http_send_data+0x5a>
      /* Yes - get the length of the buffer */
      count = hs->buf_len;
 8005012:	683b      	ldr	r3, [r7, #0]
 8005014:	691b      	ldr	r3, [r3, #16]
 8005016:	613b      	str	r3, [r7, #16]
 8005018:	e021      	b.n	800505e <http_send_data+0x9e>
    } else {
      /* We don't have a send buffer so allocate one up to 2mss bytes long. */
      count = 2 * tcp_mss(pcb);
 800501a:	687b      	ldr	r3, [r7, #4]
 800501c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800501e:	005b      	lsls	r3, r3, #1
 8005020:	613b      	str	r3, [r7, #16]
      do {
        hs->buf = (char*)mem_malloc((mem_size_t)count);
 8005022:	693b      	ldr	r3, [r7, #16]
 8005024:	b29b      	uxth	r3, r3
 8005026:	4618      	mov	r0, r3
 8005028:	f002 ff7a 	bl	8007f20 <mem_malloc>
 800502c:	4602      	mov	r2, r0
 800502e:	683b      	ldr	r3, [r7, #0]
 8005030:	60da      	str	r2, [r3, #12]
        if (hs->buf != NULL) {
 8005032:	683b      	ldr	r3, [r7, #0]
 8005034:	68db      	ldr	r3, [r3, #12]
 8005036:	2b00      	cmp	r3, #0
 8005038:	d003      	beq.n	8005042 <http_send_data+0x82>
          hs->buf_len = count;
 800503a:	683b      	ldr	r3, [r7, #0]
 800503c:	693a      	ldr	r2, [r7, #16]
 800503e:	611a      	str	r2, [r3, #16]
          break;
 8005040:	e007      	b.n	8005052 <http_send_data+0x92>
        }
        count = count / 2;
 8005042:	693b      	ldr	r3, [r7, #16]
 8005044:	0fda      	lsrs	r2, r3, #31
 8005046:	4413      	add	r3, r2
 8005048:	105b      	asrs	r3, r3, #1
 800504a:	613b      	str	r3, [r7, #16]
      } while (count > 100);
 800504c:	693b      	ldr	r3, [r7, #16]
 800504e:	2b64      	cmp	r3, #100	; 0x64
 8005050:	dce7      	bgt.n	8005022 <http_send_data+0x62>

      /* Did we get a send buffer? If not, return immediately. */
      if (hs->buf == NULL) {
 8005052:	683b      	ldr	r3, [r7, #0]
 8005054:	68db      	ldr	r3, [r3, #12]
 8005056:	2b00      	cmp	r3, #0
 8005058:	d101      	bne.n	800505e <http_send_data+0x9e>
        LWIP_DEBUGF(HTTPD_DEBUG, ("No buff\n"));
        return 0;
 800505a:	2300      	movs	r3, #0
 800505c:	e33a      	b.n	80056d4 <http_send_data+0x714>
    }

    /* Read a block of data from the file. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Trying to read %d bytes.\n", count));

    count = fs_read(hs->handle, hs->buf, count);
 800505e:	683b      	ldr	r3, [r7, #0]
 8005060:	6818      	ldr	r0, [r3, #0]
 8005062:	683b      	ldr	r3, [r7, #0]
 8005064:	68db      	ldr	r3, [r3, #12]
 8005066:	693a      	ldr	r2, [r7, #16]
 8005068:	4619      	mov	r1, r3
 800506a:	f7ff fdaa 	bl	8004bc2 <fs_read>
 800506e:	6138      	str	r0, [r7, #16]
    if(count < 0) {
 8005070:	693b      	ldr	r3, [r7, #16]
 8005072:	2b00      	cmp	r3, #0
 8005074:	da05      	bge.n	8005082 <http_send_data+0xc2>
      /* We reached the end of the file so this request is done.
       * @todo: don't close here for HTTP/1.1? */
      LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
      http_close_conn(pcb, hs);
 8005076:	6839      	ldr	r1, [r7, #0]
 8005078:	6878      	ldr	r0, [r7, #4]
 800507a:	f7ff fe8d 	bl	8004d98 <http_close_conn>
      return 1;
 800507e:	2301      	movs	r3, #1
 8005080:	e328      	b.n	80056d4 <http_send_data+0x714>
    }

    /* Set up to send the block of data we just read */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Read %d bytes.\n", count));
    hs->left = count;
 8005082:	693a      	ldr	r2, [r7, #16]
 8005084:	683b      	ldr	r3, [r7, #0]
 8005086:	615a      	str	r2, [r3, #20]
    hs->file = hs->buf;
 8005088:	683b      	ldr	r3, [r7, #0]
 800508a:	68da      	ldr	r2, [r3, #12]
 800508c:	683b      	ldr	r3, [r7, #0]
 800508e:	605a      	str	r2, [r3, #4]
#if LWIP_HTTPD_SSI
    hs->parse_left = count;
 8005090:	693a      	ldr	r2, [r7, #16]
 8005092:	683b      	ldr	r3, [r7, #0]
 8005094:	625a      	str	r2, [r3, #36]	; 0x24
    hs->parsed = hs->buf;
 8005096:	683b      	ldr	r3, [r7, #0]
 8005098:	68da      	ldr	r2, [r3, #12]
 800509a:	683b      	ldr	r3, [r7, #0]
 800509c:	61da      	str	r2, [r3, #28]
    LWIP_ASSERT("SSI and DYNAMIC_HEADERS turned off but eof not reached", 0);
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
  }

#if LWIP_HTTPD_SSI
  if(!hs->tag_check) {
 800509e:	683b      	ldr	r3, [r7, #0]
 80050a0:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80050a4:	2b00      	cmp	r3, #0
 80050a6:	d142      	bne.n	800512e <http_send_data+0x16e>
    /* We are not processing an SHTML file so no tag checking is necessary.
     * Just send the data as we received it from the file. */

    /* We cannot send more data than space available in the send
       buffer. */
    if (tcp_sndbuf(pcb) < hs->left) {
 80050a8:	687b      	ldr	r3, [r7, #4]
 80050aa:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 80050ae:	461a      	mov	r2, r3
 80050b0:	683b      	ldr	r3, [r7, #0]
 80050b2:	695b      	ldr	r3, [r3, #20]
 80050b4:	429a      	cmp	r2, r3
 80050b6:	d204      	bcs.n	80050c2 <http_send_data+0x102>
      len = tcp_sndbuf(pcb);
 80050b8:	687b      	ldr	r3, [r7, #4]
 80050ba:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 80050be:	81bb      	strh	r3, [r7, #12]
 80050c0:	e003      	b.n	80050ca <http_send_data+0x10a>
    } else {
      len = (u16_t)hs->left;
 80050c2:	683b      	ldr	r3, [r7, #0]
 80050c4:	695b      	ldr	r3, [r3, #20]
 80050c6:	b29b      	uxth	r3, r3
 80050c8:	81bb      	strh	r3, [r7, #12]
      LWIP_ASSERT("hs->left did not fit into u16_t!", (len == hs->left));
    }
    mss = tcp_mss(pcb);
 80050ca:	687b      	ldr	r3, [r7, #4]
 80050cc:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80050ce:	81fb      	strh	r3, [r7, #14]
    if(len > (2 * mss)) {
 80050d0:	89bb      	ldrh	r3, [r7, #12]
 80050d2:	461a      	mov	r2, r3
 80050d4:	89fb      	ldrh	r3, [r7, #14]
 80050d6:	005b      	lsls	r3, r3, #1
 80050d8:	429a      	cmp	r2, r3
 80050da:	dd03      	ble.n	80050e4 <http_send_data+0x124>
      len = 2 * mss;
 80050dc:	89fb      	ldrh	r3, [r7, #14]
 80050de:	005b      	lsls	r3, r3, #1
 80050e0:	b29b      	uxth	r3, r3
 80050e2:	81bb      	strh	r3, [r7, #12]
    }

    err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 80050e4:	683b      	ldr	r3, [r7, #0]
 80050e6:	6859      	ldr	r1, [r3, #4]
 80050e8:	683b      	ldr	r3, [r7, #0]
 80050ea:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80050ee:	2b00      	cmp	r3, #0
 80050f0:	bf14      	ite	ne
 80050f2:	2301      	movne	r3, #1
 80050f4:	2300      	moveq	r3, #0
 80050f6:	b2db      	uxtb	r3, r3
 80050f8:	f107 020c 	add.w	r2, r7, #12
 80050fc:	6878      	ldr	r0, [r7, #4]
 80050fe:	f7ff fe13 	bl	8004d28 <http_write>
 8005102:	4603      	mov	r3, r0
 8005104:	75fb      	strb	r3, [r7, #23]
    if (err == ERR_OK) {
 8005106:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800510a:	2b00      	cmp	r3, #0
 800510c:	f040 82cf 	bne.w	80056ae <http_send_data+0x6ee>
      data_to_send = true;
 8005110:	2301      	movs	r3, #1
 8005112:	75bb      	strb	r3, [r7, #22]
      hs->file += len;
 8005114:	683b      	ldr	r3, [r7, #0]
 8005116:	685b      	ldr	r3, [r3, #4]
 8005118:	89ba      	ldrh	r2, [r7, #12]
 800511a:	441a      	add	r2, r3
 800511c:	683b      	ldr	r3, [r7, #0]
 800511e:	605a      	str	r2, [r3, #4]
      hs->left -= len;
 8005120:	683b      	ldr	r3, [r7, #0]
 8005122:	695b      	ldr	r3, [r3, #20]
 8005124:	89ba      	ldrh	r2, [r7, #12]
 8005126:	1a9a      	subs	r2, r3, r2
 8005128:	683b      	ldr	r3, [r7, #0]
 800512a:	615a      	str	r2, [r3, #20]
 800512c:	e2bf      	b.n	80056ae <http_send_data+0x6ee>
     * them with insert strings. We need to be careful here since a tag may
     * straddle the boundary of two blocks read from the file and we may also
     * have to split the insert string between two tcp_write operations. */

    /* How much data could we send? */
    len = tcp_sndbuf(pcb);
 800512e:	687b      	ldr	r3, [r7, #4]
 8005130:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8005134:	81bb      	strh	r3, [r7, #12]

    /* Do we have remaining data to send before parsing more? */
    if(hs->parsed > hs->file) {
 8005136:	683b      	ldr	r3, [r7, #0]
 8005138:	69da      	ldr	r2, [r3, #28]
 800513a:	683b      	ldr	r3, [r7, #0]
 800513c:	685b      	ldr	r3, [r3, #4]
 800513e:	429a      	cmp	r2, r3
 8005140:	f240 8256 	bls.w	80055f0 <http_send_data+0x630>
      /* We cannot send more data than space available in the send
         buffer. */
      if (tcp_sndbuf(pcb) < (hs->parsed - hs->file)) {
 8005144:	687b      	ldr	r3, [r7, #4]
 8005146:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 800514a:	461a      	mov	r2, r3
 800514c:	683b      	ldr	r3, [r7, #0]
 800514e:	69db      	ldr	r3, [r3, #28]
 8005150:	4619      	mov	r1, r3
 8005152:	683b      	ldr	r3, [r7, #0]
 8005154:	685b      	ldr	r3, [r3, #4]
 8005156:	1acb      	subs	r3, r1, r3
 8005158:	429a      	cmp	r2, r3
 800515a:	da04      	bge.n	8005166 <http_send_data+0x1a6>
        len = tcp_sndbuf(pcb);
 800515c:	687b      	ldr	r3, [r7, #4]
 800515e:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8005162:	81bb      	strh	r3, [r7, #12]
 8005164:	e007      	b.n	8005176 <http_send_data+0x1b6>
      } else {
        LWIP_ASSERT("Data size does not fit into u16_t!",
                    (hs->parsed - hs->file) <= 0xffff);
        len = (u16_t)(hs->parsed - hs->file);
 8005166:	683b      	ldr	r3, [r7, #0]
 8005168:	69db      	ldr	r3, [r3, #28]
 800516a:	461a      	mov	r2, r3
 800516c:	683b      	ldr	r3, [r7, #0]
 800516e:	685b      	ldr	r3, [r3, #4]
 8005170:	1ad3      	subs	r3, r2, r3
 8005172:	b29b      	uxth	r3, r3
 8005174:	81bb      	strh	r3, [r7, #12]
      }
      mss = tcp_mss(pcb);
 8005176:	687b      	ldr	r3, [r7, #4]
 8005178:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800517a:	81fb      	strh	r3, [r7, #14]
      if(len > (2 * mss)) {
 800517c:	89bb      	ldrh	r3, [r7, #12]
 800517e:	461a      	mov	r2, r3
 8005180:	89fb      	ldrh	r3, [r7, #14]
 8005182:	005b      	lsls	r3, r3, #1
 8005184:	429a      	cmp	r2, r3
 8005186:	dd03      	ble.n	8005190 <http_send_data+0x1d0>
        len = 2 * mss;
 8005188:	89fb      	ldrh	r3, [r7, #14]
 800518a:	005b      	lsls	r3, r3, #1
 800518c:	b29b      	uxth	r3, r3
 800518e:	81bb      	strh	r3, [r7, #12]
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 8005190:	683b      	ldr	r3, [r7, #0]
 8005192:	6859      	ldr	r1, [r3, #4]
 8005194:	683b      	ldr	r3, [r7, #0]
 8005196:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800519a:	2b00      	cmp	r3, #0
 800519c:	bf14      	ite	ne
 800519e:	2301      	movne	r3, #1
 80051a0:	2300      	moveq	r3, #0
 80051a2:	b2db      	uxtb	r3, r3
 80051a4:	f107 020c 	add.w	r2, r7, #12
 80051a8:	6878      	ldr	r0, [r7, #4]
 80051aa:	f7ff fdbd 	bl	8004d28 <http_write>
 80051ae:	4603      	mov	r3, r0
 80051b0:	75fb      	strb	r3, [r7, #23]
      if (err == ERR_OK) {
 80051b2:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80051b6:	2b00      	cmp	r3, #0
 80051b8:	d10d      	bne.n	80051d6 <http_send_data+0x216>
        data_to_send = true;
 80051ba:	2301      	movs	r3, #1
 80051bc:	75bb      	strb	r3, [r7, #22]
        hs->file += len;
 80051be:	683b      	ldr	r3, [r7, #0]
 80051c0:	685b      	ldr	r3, [r3, #4]
 80051c2:	89ba      	ldrh	r2, [r7, #12]
 80051c4:	441a      	add	r2, r3
 80051c6:	683b      	ldr	r3, [r7, #0]
 80051c8:	605a      	str	r2, [r3, #4]
        hs->left -= len;
 80051ca:	683b      	ldr	r3, [r7, #0]
 80051cc:	695b      	ldr	r3, [r3, #20]
 80051ce:	89ba      	ldrh	r2, [r7, #12]
 80051d0:	1a9a      	subs	r2, r3, r2
 80051d2:	683b      	ldr	r3, [r7, #0]
 80051d4:	615a      	str	r2, [r3, #20]
      }

      /* If the send buffer is full, return now. */
      if(tcp_sndbuf(pcb) == 0) {
 80051d6:	687b      	ldr	r3, [r7, #4]
 80051d8:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 80051dc:	2b00      	cmp	r3, #0
 80051de:	f040 8207 	bne.w	80055f0 <http_send_data+0x630>
        return data_to_send;
 80051e2:	7dbb      	ldrb	r3, [r7, #22]
 80051e4:	e276      	b.n	80056d4 <http_send_data+0x714>

    /* We have sent all the data that was already parsed so continue parsing
     * the buffer contents looking for SSI tags. */
    while((hs->parse_left) && (err == ERR_OK)) {
      /* @todo: somewhere in this loop, 'len' should grow again... */
      if (len == 0) {
 80051e6:	89bb      	ldrh	r3, [r7, #12]
 80051e8:	2b00      	cmp	r3, #0
 80051ea:	d101      	bne.n	80051f0 <http_send_data+0x230>
        return data_to_send;
 80051ec:	7dbb      	ldrb	r3, [r7, #22]
 80051ee:	e271      	b.n	80056d4 <http_send_data+0x714>
      }
      switch(hs->tag_state) {
 80051f0:	683b      	ldr	r3, [r7, #0]
 80051f2:	f893 30f1 	ldrb.w	r3, [r3, #241]	; 0xf1
 80051f6:	2b04      	cmp	r3, #4
 80051f8:	f200 81fa 	bhi.w	80055f0 <http_send_data+0x630>
 80051fc:	a201      	add	r2, pc, #4	; (adr r2, 8005204 <http_send_data+0x244>)
 80051fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005202:	bf00      	nop
 8005204:	08005219 	.word	0x08005219
 8005208:	0800524b 	.word	0x0800524b
 800520c:	080052a3 	.word	0x080052a3
 8005210:	080053b7 	.word	0x080053b7
 8005214:	080054f9 	.word	0x080054f9
        case TAG_NONE:
          /* We are not currently processing an SSI tag so scan for the
           * start of the lead-in marker. */
          if(*hs->parsed == g_pcTagLeadIn[0]) {
 8005218:	683b      	ldr	r3, [r7, #0]
 800521a:	69db      	ldr	r3, [r3, #28]
 800521c:	781a      	ldrb	r2, [r3, #0]
 800521e:	4b77      	ldr	r3, [pc, #476]	; (80053fc <http_send_data+0x43c>)
 8005220:	781b      	ldrb	r3, [r3, #0]
 8005222:	429a      	cmp	r2, r3
 8005224:	d106      	bne.n	8005234 <http_send_data+0x274>
            /* We found what could be the lead-in for a new tag so change
             * state appropriately. */
            hs->tag_state = TAG_LEADIN;
 8005226:	683b      	ldr	r3, [r7, #0]
 8005228:	2201      	movs	r2, #1
 800522a:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
            hs->tag_index = 1;
 800522e:	683b      	ldr	r3, [r7, #0]
 8005230:	2201      	movs	r2, #1
 8005232:	851a      	strh	r2, [r3, #40]	; 0x28
            hs->tag_started = hs->parsed;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG */
          }

          /* Move on to the next character in the buffer */
          hs->parse_left--;
 8005234:	683b      	ldr	r3, [r7, #0]
 8005236:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005238:	1e5a      	subs	r2, r3, #1
 800523a:	683b      	ldr	r3, [r7, #0]
 800523c:	625a      	str	r2, [r3, #36]	; 0x24
          hs->parsed++;
 800523e:	683b      	ldr	r3, [r7, #0]
 8005240:	69db      	ldr	r3, [r3, #28]
 8005242:	1c5a      	adds	r2, r3, #1
 8005244:	683b      	ldr	r3, [r7, #0]
 8005246:	61da      	str	r2, [r3, #28]
          break;
 8005248:	e1d2      	b.n	80055f0 <http_send_data+0x630>
        case TAG_LEADIN:
          /* We are processing the lead-in marker, looking for the start of
           * the tag name. */

          /* Have we reached the end of the leadin? */
          if(hs->tag_index == LEN_TAG_LEAD_IN) {
 800524a:	683b      	ldr	r3, [r7, #0]
 800524c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800524e:	2b05      	cmp	r3, #5
 8005250:	d107      	bne.n	8005262 <http_send_data+0x2a2>
            hs->tag_index = 0;
 8005252:	683b      	ldr	r3, [r7, #0]
 8005254:	2200      	movs	r2, #0
 8005256:	851a      	strh	r2, [r3, #40]	; 0x28
            hs->tag_state = TAG_FOUND;
 8005258:	683b      	ldr	r3, [r7, #0]
 800525a:	2202      	movs	r2, #2
 800525c:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
 8005260:	e1c6      	b.n	80055f0 <http_send_data+0x630>
          } else {
            /* Have we found the next character we expect for the tag leadin? */
            if(*hs->parsed == g_pcTagLeadIn[hs->tag_index]) {
 8005262:	683b      	ldr	r3, [r7, #0]
 8005264:	69db      	ldr	r3, [r3, #28]
 8005266:	781a      	ldrb	r2, [r3, #0]
 8005268:	4964      	ldr	r1, [pc, #400]	; (80053fc <http_send_data+0x43c>)
 800526a:	683b      	ldr	r3, [r7, #0]
 800526c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800526e:	440b      	add	r3, r1
 8005270:	781b      	ldrb	r3, [r3, #0]
 8005272:	429a      	cmp	r2, r3
 8005274:	d106      	bne.n	8005284 <http_send_data+0x2c4>
              /* Yes - move to the next one unless we have found the complete
               * leadin, in which case we start looking for the tag itself */
              hs->tag_index++;
 8005276:	683b      	ldr	r3, [r7, #0]
 8005278:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800527a:	3301      	adds	r3, #1
 800527c:	b29a      	uxth	r2, r3
 800527e:	683b      	ldr	r3, [r7, #0]
 8005280:	851a      	strh	r2, [r3, #40]	; 0x28
 8005282:	e003      	b.n	800528c <http_send_data+0x2cc>
            } else {
              /* We found an unexpected character so this is not a tag. Move
               * back to idle state. */
              hs->tag_state = TAG_NONE;
 8005284:	683b      	ldr	r3, [r7, #0]
 8005286:	2200      	movs	r2, #0
 8005288:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
            }

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 800528c:	683b      	ldr	r3, [r7, #0]
 800528e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005290:	1e5a      	subs	r2, r3, #1
 8005292:	683b      	ldr	r3, [r7, #0]
 8005294:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 8005296:	683b      	ldr	r3, [r7, #0]
 8005298:	69db      	ldr	r3, [r3, #28]
 800529a:	1c5a      	adds	r2, r3, #1
 800529c:	683b      	ldr	r3, [r7, #0]
 800529e:	61da      	str	r2, [r3, #28]
          }
          break;
 80052a0:	e1a6      	b.n	80055f0 <http_send_data+0x630>
          /* We are reading the tag name, looking for the start of the
           * lead-out marker and removing any whitespace found. */

          /* Remove leading whitespace between the tag leading and the first
           * tag name character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 80052a2:	683b      	ldr	r3, [r7, #0]
 80052a4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80052a6:	2b00      	cmp	r3, #0
 80052a8:	d11e      	bne.n	80052e8 <http_send_data+0x328>
 80052aa:	683b      	ldr	r3, [r7, #0]
 80052ac:	69db      	ldr	r3, [r3, #28]
 80052ae:	781b      	ldrb	r3, [r3, #0]
 80052b0:	2b20      	cmp	r3, #32
 80052b2:	d00e      	beq.n	80052d2 <http_send_data+0x312>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 80052b4:	683b      	ldr	r3, [r7, #0]
 80052b6:	69db      	ldr	r3, [r3, #28]
 80052b8:	781b      	ldrb	r3, [r3, #0]
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 80052ba:	2b09      	cmp	r3, #9
 80052bc:	d009      	beq.n	80052d2 <http_send_data+0x312>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 80052be:	683b      	ldr	r3, [r7, #0]
 80052c0:	69db      	ldr	r3, [r3, #28]
 80052c2:	781b      	ldrb	r3, [r3, #0]
 80052c4:	2b0a      	cmp	r3, #10
 80052c6:	d004      	beq.n	80052d2 <http_send_data+0x312>
             (*hs->parsed == '\r'))) {
 80052c8:	683b      	ldr	r3, [r7, #0]
 80052ca:	69db      	ldr	r3, [r3, #28]
 80052cc:	781b      	ldrb	r3, [r3, #0]
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 80052ce:	2b0d      	cmp	r3, #13
 80052d0:	d10a      	bne.n	80052e8 <http_send_data+0x328>
            /* Move on to the next character in the buffer */
            hs->parse_left--;
 80052d2:	683b      	ldr	r3, [r7, #0]
 80052d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80052d6:	1e5a      	subs	r2, r3, #1
 80052d8:	683b      	ldr	r3, [r7, #0]
 80052da:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 80052dc:	683b      	ldr	r3, [r7, #0]
 80052de:	69db      	ldr	r3, [r3, #28]
 80052e0:	1c5a      	adds	r2, r3, #1
 80052e2:	683b      	ldr	r3, [r7, #0]
 80052e4:	61da      	str	r2, [r3, #28]
            break;
 80052e6:	e183      	b.n	80055f0 <http_send_data+0x630>
          }

          /* Have we found the end of the tag name? This is signalled by
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
 80052e8:	683b      	ldr	r3, [r7, #0]
 80052ea:	69db      	ldr	r3, [r3, #28]
 80052ec:	781a      	ldrb	r2, [r3, #0]
 80052ee:	4b44      	ldr	r3, [pc, #272]	; (8005400 <http_send_data+0x440>)
 80052f0:	781b      	ldrb	r3, [r3, #0]
 80052f2:	429a      	cmp	r2, r3
 80052f4:	d013      	beq.n	800531e <http_send_data+0x35e>
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
 80052f6:	683b      	ldr	r3, [r7, #0]
 80052f8:	69db      	ldr	r3, [r3, #28]
 80052fa:	781b      	ldrb	r3, [r3, #0]
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
 80052fc:	2b20      	cmp	r3, #32
 80052fe:	d00e      	beq.n	800531e <http_send_data+0x35e>
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
 8005300:	683b      	ldr	r3, [r7, #0]
 8005302:	69db      	ldr	r3, [r3, #28]
 8005304:	781b      	ldrb	r3, [r3, #0]
 8005306:	2b09      	cmp	r3, #9
 8005308:	d009      	beq.n	800531e <http_send_data+0x35e>
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {
 800530a:	683b      	ldr	r3, [r7, #0]
 800530c:	69db      	ldr	r3, [r3, #28]
 800530e:	781b      	ldrb	r3, [r3, #0]
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
 8005310:	2b0a      	cmp	r3, #10
 8005312:	d004      	beq.n	800531e <http_send_data+0x35e>
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {
 8005314:	683b      	ldr	r3, [r7, #0]
 8005316:	69db      	ldr	r3, [r3, #28]
 8005318:	781b      	ldrb	r3, [r3, #0]
 800531a:	2b0d      	cmp	r3, #13
 800531c:	d129      	bne.n	8005372 <http_send_data+0x3b2>

            if(hs->tag_index == 0) {
 800531e:	683b      	ldr	r3, [r7, #0]
 8005320:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8005322:	2b00      	cmp	r3, #0
 8005324:	d104      	bne.n	8005330 <http_send_data+0x370>
              /* We read a zero length tag so ignore it. */
              hs->tag_state = TAG_NONE;
 8005326:	683b      	ldr	r3, [r7, #0]
 8005328:	2200      	movs	r2, #0
 800532a:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
            if(hs->tag_index == 0) {
 800532e:	e037      	b.n	80053a0 <http_send_data+0x3e0>
            } else {
              /* We read a non-empty tag so go ahead and look for the
               * leadout string. */
              hs->tag_state = TAG_LEADOUT;
 8005330:	683b      	ldr	r3, [r7, #0]
 8005332:	2203      	movs	r2, #3
 8005334:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
              LWIP_ASSERT("hs->tag_index <= 0xff", hs->tag_index <= 0xff);
              hs->tag_name_len = (u8_t)hs->tag_index;
 8005338:	683b      	ldr	r3, [r7, #0]
 800533a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800533c:	b2da      	uxtb	r2, r3
 800533e:	683b      	ldr	r3, [r7, #0]
 8005340:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
              hs->tag_name[hs->tag_index] = '\0';
 8005344:	683b      	ldr	r3, [r7, #0]
 8005346:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8005348:	461a      	mov	r2, r3
 800534a:	683b      	ldr	r3, [r7, #0]
 800534c:	4413      	add	r3, r2
 800534e:	2200      	movs	r2, #0
 8005350:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
              if(*hs->parsed == g_pcTagLeadOut[0]) {
 8005354:	683b      	ldr	r3, [r7, #0]
 8005356:	69db      	ldr	r3, [r3, #28]
 8005358:	781a      	ldrb	r2, [r3, #0]
 800535a:	4b29      	ldr	r3, [pc, #164]	; (8005400 <http_send_data+0x440>)
 800535c:	781b      	ldrb	r3, [r3, #0]
 800535e:	429a      	cmp	r2, r3
 8005360:	d103      	bne.n	800536a <http_send_data+0x3aa>
                hs->tag_index = 1;
 8005362:	683b      	ldr	r3, [r7, #0]
 8005364:	2201      	movs	r2, #1
 8005366:	851a      	strh	r2, [r3, #40]	; 0x28
            if(hs->tag_index == 0) {
 8005368:	e01a      	b.n	80053a0 <http_send_data+0x3e0>
              } else {
                hs->tag_index = 0;
 800536a:	683b      	ldr	r3, [r7, #0]
 800536c:	2200      	movs	r2, #0
 800536e:	851a      	strh	r2, [r3, #40]	; 0x28
            if(hs->tag_index == 0) {
 8005370:	e016      	b.n	80053a0 <http_send_data+0x3e0>
              }
            }
          } else {
            /* This character is part of the tag name so save it */
            if(hs->tag_index < LWIP_HTTPD_MAX_TAG_NAME_LEN) {
 8005372:	683b      	ldr	r3, [r7, #0]
 8005374:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8005376:	2b00      	cmp	r3, #0
 8005378:	d10e      	bne.n	8005398 <http_send_data+0x3d8>
              hs->tag_name[hs->tag_index++] = *hs->parsed;
 800537a:	683b      	ldr	r3, [r7, #0]
 800537c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800537e:	1c5a      	adds	r2, r3, #1
 8005380:	b291      	uxth	r1, r2
 8005382:	683a      	ldr	r2, [r7, #0]
 8005384:	8511      	strh	r1, [r2, #40]	; 0x28
 8005386:	4619      	mov	r1, r3
 8005388:	683b      	ldr	r3, [r7, #0]
 800538a:	69db      	ldr	r3, [r3, #28]
 800538c:	781a      	ldrb	r2, [r3, #0]
 800538e:	683b      	ldr	r3, [r7, #0]
 8005390:	440b      	add	r3, r1
 8005392:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
 8005396:	e003      	b.n	80053a0 <http_send_data+0x3e0>
            } else {
              /* The tag was too long so ignore it. */
              hs->tag_state = TAG_NONE;
 8005398:	683b      	ldr	r3, [r7, #0]
 800539a:	2200      	movs	r2, #0
 800539c:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
            }
          }

          /* Move on to the next character in the buffer */
          hs->parse_left--;
 80053a0:	683b      	ldr	r3, [r7, #0]
 80053a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80053a4:	1e5a      	subs	r2, r3, #1
 80053a6:	683b      	ldr	r3, [r7, #0]
 80053a8:	625a      	str	r2, [r3, #36]	; 0x24
          hs->parsed++;
 80053aa:	683b      	ldr	r3, [r7, #0]
 80053ac:	69db      	ldr	r3, [r3, #28]
 80053ae:	1c5a      	adds	r2, r3, #1
 80053b0:	683b      	ldr	r3, [r7, #0]
 80053b2:	61da      	str	r2, [r3, #28]

          break;
 80053b4:	e11c      	b.n	80055f0 <http_send_data+0x630>

        /* We are looking for the end of the lead-out marker. */
        case TAG_LEADOUT:
          /* Remove leading whitespace between the tag leading and the first
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 80053b6:	683b      	ldr	r3, [r7, #0]
 80053b8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80053ba:	2b00      	cmp	r3, #0
 80053bc:	d122      	bne.n	8005404 <http_send_data+0x444>
 80053be:	683b      	ldr	r3, [r7, #0]
 80053c0:	69db      	ldr	r3, [r3, #28]
 80053c2:	781b      	ldrb	r3, [r3, #0]
 80053c4:	2b20      	cmp	r3, #32
 80053c6:	d00e      	beq.n	80053e6 <http_send_data+0x426>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 80053c8:	683b      	ldr	r3, [r7, #0]
 80053ca:	69db      	ldr	r3, [r3, #28]
 80053cc:	781b      	ldrb	r3, [r3, #0]
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 80053ce:	2b09      	cmp	r3, #9
 80053d0:	d009      	beq.n	80053e6 <http_send_data+0x426>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 80053d2:	683b      	ldr	r3, [r7, #0]
 80053d4:	69db      	ldr	r3, [r3, #28]
 80053d6:	781b      	ldrb	r3, [r3, #0]
 80053d8:	2b0a      	cmp	r3, #10
 80053da:	d004      	beq.n	80053e6 <http_send_data+0x426>
             (*hs->parsed == '\r'))) {
 80053dc:	683b      	ldr	r3, [r7, #0]
 80053de:	69db      	ldr	r3, [r3, #28]
 80053e0:	781b      	ldrb	r3, [r3, #0]
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 80053e2:	2b0d      	cmp	r3, #13
 80053e4:	d10e      	bne.n	8005404 <http_send_data+0x444>
            /* Move on to the next character in the buffer */
            hs->parse_left--;
 80053e6:	683b      	ldr	r3, [r7, #0]
 80053e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80053ea:	1e5a      	subs	r2, r3, #1
 80053ec:	683b      	ldr	r3, [r7, #0]
 80053ee:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 80053f0:	683b      	ldr	r3, [r7, #0]
 80053f2:	69db      	ldr	r3, [r3, #28]
 80053f4:	1c5a      	adds	r2, r3, #1
 80053f6:	683b      	ldr	r3, [r7, #0]
 80053f8:	61da      	str	r2, [r3, #28]
            break;
 80053fa:	e0f9      	b.n	80055f0 <http_send_data+0x630>
 80053fc:	0800e7a4 	.word	0x0800e7a4
 8005400:	0800e7ac 	.word	0x0800e7ac
          }

          /* Have we found the next character we expect for the tag leadout? */
          if(*hs->parsed == g_pcTagLeadOut[hs->tag_index]) {
 8005404:	683b      	ldr	r3, [r7, #0]
 8005406:	69db      	ldr	r3, [r3, #28]
 8005408:	781a      	ldrb	r2, [r3, #0]
 800540a:	498c      	ldr	r1, [pc, #560]	; (800563c <http_send_data+0x67c>)
 800540c:	683b      	ldr	r3, [r7, #0]
 800540e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8005410:	440b      	add	r3, r1
 8005412:	781b      	ldrb	r3, [r3, #0]
 8005414:	429a      	cmp	r2, r3
 8005416:	d160      	bne.n	80054da <http_send_data+0x51a>
            /* Yes - move to the next one unless we have found the complete
             * leadout, in which case we need to call the client to process
             * the tag. */

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 8005418:	683b      	ldr	r3, [r7, #0]
 800541a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800541c:	1e5a      	subs	r2, r3, #1
 800541e:	683b      	ldr	r3, [r7, #0]
 8005420:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 8005422:	683b      	ldr	r3, [r7, #0]
 8005424:	69db      	ldr	r3, [r3, #28]
 8005426:	1c5a      	adds	r2, r3, #1
 8005428:	683b      	ldr	r3, [r7, #0]
 800542a:	61da      	str	r2, [r3, #28]

            if(hs->tag_index == (LEN_TAG_LEAD_OUT - 1)) {
 800542c:	683b      	ldr	r3, [r7, #0]
 800542e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8005430:	2b02      	cmp	r3, #2
 8005432:	d14b      	bne.n	80054cc <http_send_data+0x50c>
              /* Call the client to ask for the insert string for the
               * tag we just found. */
#if LWIP_HTTPD_SSI_MULTIPART
              hs->tag_part = 0; /* start with tag part 0 */
#endif /* LWIP_HTTPD_SSI_MULTIPART */
              get_tag_insert(hs);
 8005434:	6838      	ldr	r0, [r7, #0]
 8005436:	f7ff fd43 	bl	8004ec0 <get_tag_insert>

              /* Next time through, we are going to be sending data
               * immediately, either the end of the block we start
               * sending here or the insert string. */
              hs->tag_index = 0;
 800543a:	683b      	ldr	r3, [r7, #0]
 800543c:	2200      	movs	r2, #0
 800543e:	851a      	strh	r2, [r3, #40]	; 0x28
              hs->tag_state = TAG_SENDING;
 8005440:	683b      	ldr	r3, [r7, #0]
 8005442:	2204      	movs	r2, #4
 8005444:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
              hs->tag_end = hs->parsed;
 8005448:	683b      	ldr	r3, [r7, #0]
 800544a:	69da      	ldr	r2, [r3, #28]
 800544c:	683b      	ldr	r3, [r7, #0]
 800544e:	621a      	str	r2, [r3, #32]
              hs->parsed = hs->tag_started;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/

              /* If there is any unsent data in the buffer prior to the
               * tag, we need to send it now. */
              if (hs->tag_end > hs->file) {
 8005450:	683b      	ldr	r3, [r7, #0]
 8005452:	6a1a      	ldr	r2, [r3, #32]
 8005454:	683b      	ldr	r3, [r7, #0]
 8005456:	685b      	ldr	r3, [r3, #4]
 8005458:	429a      	cmp	r2, r3
 800545a:	f240 80c9 	bls.w	80055f0 <http_send_data+0x630>
                /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
                if(len > hs->tag_end - hs->file) {
 800545e:	89bb      	ldrh	r3, [r7, #12]
 8005460:	461a      	mov	r2, r3
 8005462:	683b      	ldr	r3, [r7, #0]
 8005464:	6a1b      	ldr	r3, [r3, #32]
 8005466:	4619      	mov	r1, r3
 8005468:	683b      	ldr	r3, [r7, #0]
 800546a:	685b      	ldr	r3, [r3, #4]
 800546c:	1acb      	subs	r3, r1, r3
 800546e:	429a      	cmp	r2, r3
 8005470:	dd07      	ble.n	8005482 <http_send_data+0x4c2>
                  len = (u16_t)(hs->tag_end - hs->file);
 8005472:	683b      	ldr	r3, [r7, #0]
 8005474:	6a1b      	ldr	r3, [r3, #32]
 8005476:	461a      	mov	r2, r3
 8005478:	683b      	ldr	r3, [r7, #0]
 800547a:	685b      	ldr	r3, [r3, #4]
 800547c:	1ad3      	subs	r3, r2, r3
 800547e:	b29b      	uxth	r3, r3
 8005480:	81bb      	strh	r3, [r7, #12]
                  /* we would include the tag in sending */
                  len = (u16_t)(hs->tag_started - hs->file);
                }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/

                err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 8005482:	683b      	ldr	r3, [r7, #0]
 8005484:	6859      	ldr	r1, [r3, #4]
 8005486:	683b      	ldr	r3, [r7, #0]
 8005488:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800548c:	2b00      	cmp	r3, #0
 800548e:	bf14      	ite	ne
 8005490:	2301      	movne	r3, #1
 8005492:	2300      	moveq	r3, #0
 8005494:	b2db      	uxtb	r3, r3
 8005496:	f107 020c 	add.w	r2, r7, #12
 800549a:	6878      	ldr	r0, [r7, #4]
 800549c:	f7ff fc44 	bl	8004d28 <http_write>
 80054a0:	4603      	mov	r3, r0
 80054a2:	75fb      	strb	r3, [r7, #23]
                if (err == ERR_OK) {
 80054a4:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80054a8:	2b00      	cmp	r3, #0
 80054aa:	f040 80a1 	bne.w	80055f0 <http_send_data+0x630>
                  data_to_send = true;
 80054ae:	2301      	movs	r3, #1
 80054b0:	75bb      	strb	r3, [r7, #22]
                  if(hs->tag_started <= hs->file) {
                    /* pretend to have sent the tag, too */
                    len += hs->tag_end - hs->tag_started;
                  }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
                  hs->file += len;
 80054b2:	683b      	ldr	r3, [r7, #0]
 80054b4:	685b      	ldr	r3, [r3, #4]
 80054b6:	89ba      	ldrh	r2, [r7, #12]
 80054b8:	441a      	add	r2, r3
 80054ba:	683b      	ldr	r3, [r7, #0]
 80054bc:	605a      	str	r2, [r3, #4]
                  hs->left -= len;
 80054be:	683b      	ldr	r3, [r7, #0]
 80054c0:	695b      	ldr	r3, [r3, #20]
 80054c2:	89ba      	ldrh	r2, [r7, #12]
 80054c4:	1a9a      	subs	r2, r3, r2
 80054c6:	683b      	ldr	r3, [r7, #0]
 80054c8:	615a      	str	r2, [r3, #20]
 80054ca:	e091      	b.n	80055f0 <http_send_data+0x630>
                }
              }
            } else {
              hs->tag_index++;
 80054cc:	683b      	ldr	r3, [r7, #0]
 80054ce:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80054d0:	3301      	adds	r3, #1
 80054d2:	b29a      	uxth	r2, r3
 80054d4:	683b      	ldr	r3, [r7, #0]
 80054d6:	851a      	strh	r2, [r3, #40]	; 0x28
 80054d8:	e08a      	b.n	80055f0 <http_send_data+0x630>
            }
          } else {
            /* We found an unexpected character so this is not a tag. Move
             * back to idle state. */
            hs->parse_left--;
 80054da:	683b      	ldr	r3, [r7, #0]
 80054dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80054de:	1e5a      	subs	r2, r3, #1
 80054e0:	683b      	ldr	r3, [r7, #0]
 80054e2:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 80054e4:	683b      	ldr	r3, [r7, #0]
 80054e6:	69db      	ldr	r3, [r3, #28]
 80054e8:	1c5a      	adds	r2, r3, #1
 80054ea:	683b      	ldr	r3, [r7, #0]
 80054ec:	61da      	str	r2, [r3, #28]
            hs->tag_state = TAG_NONE;
 80054ee:	683b      	ldr	r3, [r7, #0]
 80054f0:	2200      	movs	r2, #0
 80054f2:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
          }
          break;
 80054f6:	e07b      	b.n	80055f0 <http_send_data+0x630>
         * from the file prior to the insert point or the insert string itself.
         */
        case TAG_SENDING:
          /* Do we have any remaining file data to send from the buffer prior
           * to the tag? */
          if(hs->tag_end > hs->file) {
 80054f8:	683b      	ldr	r3, [r7, #0]
 80054fa:	6a1a      	ldr	r2, [r3, #32]
 80054fc:	683b      	ldr	r3, [r7, #0]
 80054fe:	685b      	ldr	r3, [r3, #4]
 8005500:	429a      	cmp	r2, r3
 8005502:	d93b      	bls.n	800557c <http_send_data+0x5bc>
            /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
            if(len > hs->tag_end - hs->file) {
 8005504:	89bb      	ldrh	r3, [r7, #12]
 8005506:	461a      	mov	r2, r3
 8005508:	683b      	ldr	r3, [r7, #0]
 800550a:	6a1b      	ldr	r3, [r3, #32]
 800550c:	4619      	mov	r1, r3
 800550e:	683b      	ldr	r3, [r7, #0]
 8005510:	685b      	ldr	r3, [r3, #4]
 8005512:	1acb      	subs	r3, r1, r3
 8005514:	429a      	cmp	r2, r3
 8005516:	dd07      	ble.n	8005528 <http_send_data+0x568>
              len = (u16_t)(hs->tag_end - hs->file);
 8005518:	683b      	ldr	r3, [r7, #0]
 800551a:	6a1b      	ldr	r3, [r3, #32]
 800551c:	461a      	mov	r2, r3
 800551e:	683b      	ldr	r3, [r7, #0]
 8005520:	685b      	ldr	r3, [r3, #4]
 8005522:	1ad3      	subs	r3, r2, r3
 8005524:	b29b      	uxth	r3, r3
 8005526:	81bb      	strh	r3, [r7, #12]
            if (len > hs->tag_started - hs->file) {
              /* we would include the tag in sending */
              len = (u16_t)(hs->tag_started - hs->file);
            }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/
            if (len != 0) {
 8005528:	89bb      	ldrh	r3, [r7, #12]
 800552a:	2b00      	cmp	r3, #0
 800552c:	d011      	beq.n	8005552 <http_send_data+0x592>
              err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 800552e:	683b      	ldr	r3, [r7, #0]
 8005530:	6859      	ldr	r1, [r3, #4]
 8005532:	683b      	ldr	r3, [r7, #0]
 8005534:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005538:	2b00      	cmp	r3, #0
 800553a:	bf14      	ite	ne
 800553c:	2301      	movne	r3, #1
 800553e:	2300      	moveq	r3, #0
 8005540:	b2db      	uxtb	r3, r3
 8005542:	f107 020c 	add.w	r2, r7, #12
 8005546:	6878      	ldr	r0, [r7, #4]
 8005548:	f7ff fbee 	bl	8004d28 <http_write>
 800554c:	4603      	mov	r3, r0
 800554e:	75fb      	strb	r3, [r7, #23]
 8005550:	e001      	b.n	8005556 <http_send_data+0x596>
            } else {
              err = ERR_OK;
 8005552:	2300      	movs	r3, #0
 8005554:	75fb      	strb	r3, [r7, #23]
            }
            if (err == ERR_OK) {
 8005556:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800555a:	2b00      	cmp	r3, #0
 800555c:	d148      	bne.n	80055f0 <http_send_data+0x630>
              data_to_send = true;
 800555e:	2301      	movs	r3, #1
 8005560:	75bb      	strb	r3, [r7, #22]
              if(hs->tag_started <= hs->file) {
                /* pretend to have sent the tag, too */
                len += hs->tag_end - hs->tag_started;
              }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
              hs->file += len;
 8005562:	683b      	ldr	r3, [r7, #0]
 8005564:	685b      	ldr	r3, [r3, #4]
 8005566:	89ba      	ldrh	r2, [r7, #12]
 8005568:	441a      	add	r2, r3
 800556a:	683b      	ldr	r3, [r7, #0]
 800556c:	605a      	str	r2, [r3, #4]
              hs->left -= len;
 800556e:	683b      	ldr	r3, [r7, #0]
 8005570:	695b      	ldr	r3, [r3, #20]
 8005572:	89ba      	ldrh	r2, [r7, #12]
 8005574:	1a9a      	subs	r2, r3, r2
 8005576:	683b      	ldr	r3, [r7, #0]
 8005578:	615a      	str	r2, [r3, #20]
 800557a:	e039      	b.n	80055f0 <http_send_data+0x630>
              }
            }
#endif /* LWIP_HTTPD_SSI_MULTIPART */

            /* Do we still have insert data left to send? */
            if(hs->tag_index < hs->tag_insert_len) {
 800557c:	683b      	ldr	r3, [r7, #0]
 800557e:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8005580:	683b      	ldr	r3, [r7, #0]
 8005582:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8005584:	429a      	cmp	r2, r3
 8005586:	d22b      	bcs.n	80055e0 <http_send_data+0x620>
              /* We are sending the insert string itself. How much of the
               * insert can we send? */
              if(len > (hs->tag_insert_len - hs->tag_index)) {
 8005588:	89bb      	ldrh	r3, [r7, #12]
 800558a:	461a      	mov	r2, r3
 800558c:	683b      	ldr	r3, [r7, #0]
 800558e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8005590:	4619      	mov	r1, r3
 8005592:	683b      	ldr	r3, [r7, #0]
 8005594:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8005596:	1acb      	subs	r3, r1, r3
 8005598:	429a      	cmp	r2, r3
 800559a:	dd06      	ble.n	80055aa <http_send_data+0x5ea>
                len = (hs->tag_insert_len - hs->tag_index);
 800559c:	683b      	ldr	r3, [r7, #0]
 800559e:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
 80055a0:	683b      	ldr	r3, [r7, #0]
 80055a2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80055a4:	1ad3      	subs	r3, r2, r3
 80055a6:	b29b      	uxth	r3, r3
 80055a8:	81bb      	strh	r3, [r7, #12]

              /* Note that we set the copy flag here since we only have a
               * single tag insert buffer per connection. If we don't do
               * this, insert corruption can occur if more than one insert
               * is processed before we call tcp_output. */
              err = http_write(pcb, &(hs->tag_insert[hs->tag_index]), &len,
 80055aa:	683b      	ldr	r3, [r7, #0]
 80055ac:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80055ae:	3330      	adds	r3, #48	; 0x30
 80055b0:	683a      	ldr	r2, [r7, #0]
 80055b2:	18d1      	adds	r1, r2, r3
 80055b4:	f107 020c 	add.w	r2, r7, #12
 80055b8:	2301      	movs	r3, #1
 80055ba:	6878      	ldr	r0, [r7, #4]
 80055bc:	f7ff fbb4 	bl	8004d28 <http_write>
 80055c0:	4603      	mov	r3, r0
 80055c2:	75fb      	strb	r3, [r7, #23]
                               HTTP_IS_TAG_VOLATILE(hs));
              if (err == ERR_OK) {
 80055c4:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80055c8:	2b00      	cmp	r3, #0
 80055ca:	d110      	bne.n	80055ee <http_send_data+0x62e>
                data_to_send = true;
 80055cc:	2301      	movs	r3, #1
 80055ce:	75bb      	strb	r3, [r7, #22]
                hs->tag_index += len;
 80055d0:	683b      	ldr	r3, [r7, #0]
 80055d2:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 80055d4:	89bb      	ldrh	r3, [r7, #12]
 80055d6:	4413      	add	r3, r2
 80055d8:	b29a      	uxth	r2, r3
 80055da:	683b      	ldr	r3, [r7, #0]
 80055dc:	851a      	strh	r2, [r3, #40]	; 0x28
 80055de:	e006      	b.n	80055ee <http_send_data+0x62e>
              }
            } else {
              /* We have sent all the insert data so go back to looking for
               * a new tag. */
              LWIP_DEBUGF(HTTPD_DEBUG, ("Everything sent.\n"));
              hs->tag_index = 0;
 80055e0:	683b      	ldr	r3, [r7, #0]
 80055e2:	2200      	movs	r2, #0
 80055e4:	851a      	strh	r2, [r3, #40]	; 0x28
              hs->tag_state = TAG_NONE;
 80055e6:	683b      	ldr	r3, [r7, #0]
 80055e8:	2200      	movs	r2, #0
 80055ea:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
#if !LWIP_HTTPD_SSI_INCLUDE_TAG
              hs->parsed = hs->tag_end;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
            }
            break;
 80055ee:	bf00      	nop
    while((hs->parse_left) && (err == ERR_OK)) {
 80055f0:	683b      	ldr	r3, [r7, #0]
 80055f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80055f4:	2b00      	cmp	r3, #0
 80055f6:	d004      	beq.n	8005602 <http_send_data+0x642>
 80055f8:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80055fc:	2b00      	cmp	r3, #0
 80055fe:	f43f adf2 	beq.w	80051e6 <http_send_data+0x226>
    }

    /* If we drop out of the end of the for loop, this implies we must have
     * file data to send so send it now. In TAG_SENDING state, we've already
     * handled this so skip the send if that's the case. */
    if((hs->tag_state != TAG_SENDING) && (hs->parsed > hs->file)) {
 8005602:	683b      	ldr	r3, [r7, #0]
 8005604:	f893 30f1 	ldrb.w	r3, [r3, #241]	; 0xf1
 8005608:	2b04      	cmp	r3, #4
 800560a:	d050      	beq.n	80056ae <http_send_data+0x6ee>
 800560c:	683b      	ldr	r3, [r7, #0]
 800560e:	69da      	ldr	r2, [r3, #28]
 8005610:	683b      	ldr	r3, [r7, #0]
 8005612:	685b      	ldr	r3, [r3, #4]
 8005614:	429a      	cmp	r2, r3
 8005616:	d94a      	bls.n	80056ae <http_send_data+0x6ee>
      /* We cannot send more data than space available in the send
         buffer. */
      if (tcp_sndbuf(pcb) < (hs->parsed - hs->file)) {
 8005618:	687b      	ldr	r3, [r7, #4]
 800561a:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 800561e:	461a      	mov	r2, r3
 8005620:	683b      	ldr	r3, [r7, #0]
 8005622:	69db      	ldr	r3, [r3, #28]
 8005624:	4619      	mov	r1, r3
 8005626:	683b      	ldr	r3, [r7, #0]
 8005628:	685b      	ldr	r3, [r3, #4]
 800562a:	1acb      	subs	r3, r1, r3
 800562c:	429a      	cmp	r2, r3
 800562e:	da07      	bge.n	8005640 <http_send_data+0x680>
        len = tcp_sndbuf(pcb);
 8005630:	687b      	ldr	r3, [r7, #4]
 8005632:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8005636:	81bb      	strh	r3, [r7, #12]
 8005638:	e00a      	b.n	8005650 <http_send_data+0x690>
 800563a:	bf00      	nop
 800563c:	0800e7ac 	.word	0x0800e7ac
      } else {
        LWIP_ASSERT("Data size does not fit into u16_t!",
                    (hs->parsed - hs->file) <= 0xffff);
        len = (u16_t)(hs->parsed - hs->file);
 8005640:	683b      	ldr	r3, [r7, #0]
 8005642:	69db      	ldr	r3, [r3, #28]
 8005644:	461a      	mov	r2, r3
 8005646:	683b      	ldr	r3, [r7, #0]
 8005648:	685b      	ldr	r3, [r3, #4]
 800564a:	1ad3      	subs	r3, r2, r3
 800564c:	b29b      	uxth	r3, r3
 800564e:	81bb      	strh	r3, [r7, #12]
      }
      if(len > (2 * tcp_mss(pcb))) {
 8005650:	89bb      	ldrh	r3, [r7, #12]
 8005652:	461a      	mov	r2, r3
 8005654:	687b      	ldr	r3, [r7, #4]
 8005656:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8005658:	005b      	lsls	r3, r3, #1
 800565a:	429a      	cmp	r2, r3
 800565c:	dd04      	ble.n	8005668 <http_send_data+0x6a8>
        len = 2 * tcp_mss(pcb);
 800565e:	687b      	ldr	r3, [r7, #4]
 8005660:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8005662:	005b      	lsls	r3, r3, #1
 8005664:	b29b      	uxth	r3, r3
 8005666:	81bb      	strh	r3, [r7, #12]
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 8005668:	683b      	ldr	r3, [r7, #0]
 800566a:	6859      	ldr	r1, [r3, #4]
 800566c:	683b      	ldr	r3, [r7, #0]
 800566e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005672:	2b00      	cmp	r3, #0
 8005674:	bf14      	ite	ne
 8005676:	2301      	movne	r3, #1
 8005678:	2300      	moveq	r3, #0
 800567a:	b2db      	uxtb	r3, r3
 800567c:	f107 020c 	add.w	r2, r7, #12
 8005680:	6878      	ldr	r0, [r7, #4]
 8005682:	f7ff fb51 	bl	8004d28 <http_write>
 8005686:	4603      	mov	r3, r0
 8005688:	75fb      	strb	r3, [r7, #23]
      if (err == ERR_OK) {
 800568a:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800568e:	2b00      	cmp	r3, #0
 8005690:	d10d      	bne.n	80056ae <http_send_data+0x6ee>
        data_to_send = true;
 8005692:	2301      	movs	r3, #1
 8005694:	75bb      	strb	r3, [r7, #22]
        hs->file += len;
 8005696:	683b      	ldr	r3, [r7, #0]
 8005698:	685b      	ldr	r3, [r3, #4]
 800569a:	89ba      	ldrh	r2, [r7, #12]
 800569c:	441a      	add	r2, r3
 800569e:	683b      	ldr	r3, [r7, #0]
 80056a0:	605a      	str	r2, [r3, #4]
        hs->left -= len;
 80056a2:	683b      	ldr	r3, [r7, #0]
 80056a4:	695b      	ldr	r3, [r3, #20]
 80056a6:	89ba      	ldrh	r2, [r7, #12]
 80056a8:	1a9a      	subs	r2, r3, r2
 80056aa:	683b      	ldr	r3, [r7, #0]
 80056ac:	615a      	str	r2, [r3, #20]
      }
    }
  }
#endif /* LWIP_HTTPD_SSI */

  if((hs->left == 0) && (fs_bytes_left(hs->handle) <= 0)) {
 80056ae:	683b      	ldr	r3, [r7, #0]
 80056b0:	695b      	ldr	r3, [r3, #20]
 80056b2:	2b00      	cmp	r3, #0
 80056b4:	d10d      	bne.n	80056d2 <http_send_data+0x712>
 80056b6:	683b      	ldr	r3, [r7, #0]
 80056b8:	681b      	ldr	r3, [r3, #0]
 80056ba:	4618      	mov	r0, r3
 80056bc:	f7ff fab1 	bl	8004c22 <fs_bytes_left>
 80056c0:	4603      	mov	r3, r0
 80056c2:	2b00      	cmp	r3, #0
 80056c4:	dc05      	bgt.n	80056d2 <http_send_data+0x712>
    /* We reached the end of the file so this request is done.
     * This adds the FIN flag right into the last data segment.
     * @todo: don't close here for HTTP/1.1? */
    LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
    http_close_conn(pcb, hs);
 80056c6:	6839      	ldr	r1, [r7, #0]
 80056c8:	6878      	ldr	r0, [r7, #4]
 80056ca:	f7ff fb65 	bl	8004d98 <http_close_conn>
    return 0;
 80056ce:	2300      	movs	r3, #0
 80056d0:	e000      	b.n	80056d4 <http_send_data+0x714>
  }
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("send_data end.\n"));
  return data_to_send;
 80056d2:	7dbb      	ldrb	r3, [r7, #22]
}
 80056d4:	4618      	mov	r0, r3
 80056d6:	3718      	adds	r7, #24
 80056d8:	46bd      	mov	sp, r7
 80056da:	bd80      	pop	{r7, pc}

080056dc <http_get_404_file>:
 *
 * @param uri pointer that receives the actual file name URI
 * @return file struct for the error page or NULL no matching file was found
 */
static struct fs_file * http_get_404_file(const char **uri)
{
 80056dc:	b580      	push	{r7, lr}
 80056de:	b084      	sub	sp, #16
 80056e0:	af00      	add	r7, sp, #0
 80056e2:	6078      	str	r0, [r7, #4]
  struct fs_file *file;

  *uri = "/404.html";
 80056e4:	687b      	ldr	r3, [r7, #4]
 80056e6:	4a15      	ldr	r2, [pc, #84]	; (800573c <http_get_404_file+0x60>)
 80056e8:	601a      	str	r2, [r3, #0]
  file = fs_open(*uri);
 80056ea:	687b      	ldr	r3, [r7, #4]
 80056ec:	681b      	ldr	r3, [r3, #0]
 80056ee:	4618      	mov	r0, r3
 80056f0:	f7ff fa1e 	bl	8004b30 <fs_open>
 80056f4:	60f8      	str	r0, [r7, #12]
  if(file == NULL) {
 80056f6:	68fb      	ldr	r3, [r7, #12]
 80056f8:	2b00      	cmp	r3, #0
 80056fa:	d11a      	bne.n	8005732 <http_get_404_file+0x56>
    /* 404.html doesn't exist. Try 404.htm instead. */
    *uri = "/404.htm";
 80056fc:	687b      	ldr	r3, [r7, #4]
 80056fe:	4a10      	ldr	r2, [pc, #64]	; (8005740 <http_get_404_file+0x64>)
 8005700:	601a      	str	r2, [r3, #0]
    file = fs_open(*uri);
 8005702:	687b      	ldr	r3, [r7, #4]
 8005704:	681b      	ldr	r3, [r3, #0]
 8005706:	4618      	mov	r0, r3
 8005708:	f7ff fa12 	bl	8004b30 <fs_open>
 800570c:	60f8      	str	r0, [r7, #12]
    if(file == NULL) {
 800570e:	68fb      	ldr	r3, [r7, #12]
 8005710:	2b00      	cmp	r3, #0
 8005712:	d10e      	bne.n	8005732 <http_get_404_file+0x56>
      /* 404.htm doesn't exist either. Try 404.shtml instead. */
      *uri = "/404.shtml";
 8005714:	687b      	ldr	r3, [r7, #4]
 8005716:	4a0b      	ldr	r2, [pc, #44]	; (8005744 <http_get_404_file+0x68>)
 8005718:	601a      	str	r2, [r3, #0]
      file = fs_open(*uri);
 800571a:	687b      	ldr	r3, [r7, #4]
 800571c:	681b      	ldr	r3, [r3, #0]
 800571e:	4618      	mov	r0, r3
 8005720:	f7ff fa06 	bl	8004b30 <fs_open>
 8005724:	60f8      	str	r0, [r7, #12]
      if(file == NULL) {
 8005726:	68fb      	ldr	r3, [r7, #12]
 8005728:	2b00      	cmp	r3, #0
 800572a:	d102      	bne.n	8005732 <http_get_404_file+0x56>
        /* 404.htm doesn't exist either. Indicate to the caller that it should
         * send back a default 404 page.
         */
        *uri = NULL;
 800572c:	687b      	ldr	r3, [r7, #4]
 800572e:	2200      	movs	r2, #0
 8005730:	601a      	str	r2, [r3, #0]
      }
    }
  }

  return file;
 8005732:	68fb      	ldr	r3, [r7, #12]
}
 8005734:	4618      	mov	r0, r3
 8005736:	3710      	adds	r7, #16
 8005738:	46bd      	mov	sp, r7
 800573a:	bd80      	pop	{r7, pc}
 800573c:	0800e7cc 	.word	0x0800e7cc
 8005740:	0800e7d8 	.word	0x0800e7d8
 8005744:	0800e7e4 	.word	0x0800e7e4

08005748 <http_parse_request>:
 * @return ERR_OK if request was OK and hs has been initialized correctly
 *         ERR_INPROGRESS if request was OK so far but not fully received
 *         another err_t otherwise
 */
static err_t http_parse_request(struct pbuf **inp, struct http_state *hs, struct tcp_pcb *pcb)
{
 8005748:	b580      	push	{r7, lr}
 800574a:	b08e      	sub	sp, #56	; 0x38
 800574c:	af00      	add	r7, sp, #0
 800574e:	60f8      	str	r0, [r7, #12]
 8005750:	60b9      	str	r1, [r7, #8]
 8005752:	607a      	str	r2, [r7, #4]
  char *data;
  char *crlf;
  u16_t data_len;
  struct pbuf *p = *inp;
 8005754:	68fb      	ldr	r3, [r7, #12]
 8005756:	681b      	ldr	r3, [r3, #0]
 8005758:	627b      	str	r3, [r7, #36]	; 0x24

  LWIP_UNUSED_ARG(pcb); /* only used for post */
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("hs != NULL", hs != NULL);

  if ((hs->handle != NULL) || (hs->file != NULL)) {
 800575a:	68bb      	ldr	r3, [r7, #8]
 800575c:	681b      	ldr	r3, [r3, #0]
 800575e:	2b00      	cmp	r3, #0
 8005760:	d103      	bne.n	800576a <http_parse_request+0x22>
 8005762:	68bb      	ldr	r3, [r7, #8]
 8005764:	685b      	ldr	r3, [r3, #4]
 8005766:	2b00      	cmp	r3, #0
 8005768:	d002      	beq.n	8005770 <http_parse_request+0x28>
    LWIP_DEBUGF(HTTPD_DEBUG, ("Received data while sending a file\n"));
    /* already sending a file */
    /* @todo: abort? */
    return ERR_USE;
 800576a:	f06f 030a 	mvn.w	r3, #10
 800576e:	e09e      	b.n	80058ae <http_parse_request+0x166>
  LWIP_DEBUGF(HTTPD_DEBUG, ("Received %d bytes\n", p->tot_len));

  /* first check allowed characters in this pbuf? */

  /* enqueue the pbuf */
  if (hs->req == NULL) {
 8005770:	68bb      	ldr	r3, [r7, #8]
 8005772:	689b      	ldr	r3, [r3, #8]
 8005774:	2b00      	cmp	r3, #0
 8005776:	d103      	bne.n	8005780 <http_parse_request+0x38>
    LWIP_DEBUGF(HTTPD_DEBUG, ("First pbuf\n"));
    hs->req = p;
 8005778:	68bb      	ldr	r3, [r7, #8]
 800577a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800577c:	609a      	str	r2, [r3, #8]
 800577e:	e005      	b.n	800578c <http_parse_request+0x44>
  } else {
    LWIP_DEBUGF(HTTPD_DEBUG, ("pbuf enqueued\n"));
    pbuf_cat(hs->req, p);
 8005780:	68bb      	ldr	r3, [r7, #8]
 8005782:	689b      	ldr	r3, [r3, #8]
 8005784:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8005786:	4618      	mov	r0, r3
 8005788:	f003 f888 	bl	800889c <pbuf_cat>
  }

  if (hs->req->next != NULL) {
 800578c:	68bb      	ldr	r3, [r7, #8]
 800578e:	689b      	ldr	r3, [r3, #8]
 8005790:	681b      	ldr	r3, [r3, #0]
 8005792:	2b00      	cmp	r3, #0
 8005794:	d012      	beq.n	80057bc <http_parse_request+0x74>
    data_len = LWIP_MIN(hs->req->tot_len, LWIP_HTTPD_MAX_REQ_LENGTH);
 8005796:	68bb      	ldr	r3, [r7, #8]
 8005798:	689b      	ldr	r3, [r3, #8]
 800579a:	891b      	ldrh	r3, [r3, #8]
 800579c:	f240 32ff 	movw	r2, #1023	; 0x3ff
 80057a0:	4293      	cmp	r3, r2
 80057a2:	bf28      	it	cs
 80057a4:	4613      	movcs	r3, r2
 80057a6:	867b      	strh	r3, [r7, #50]	; 0x32
    pbuf_copy_partial(hs->req, httpd_req_buf, data_len, 0);
 80057a8:	68bb      	ldr	r3, [r7, #8]
 80057aa:	6898      	ldr	r0, [r3, #8]
 80057ac:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 80057ae:	2300      	movs	r3, #0
 80057b0:	4941      	ldr	r1, [pc, #260]	; (80058b8 <http_parse_request+0x170>)
 80057b2:	f003 f931 	bl	8008a18 <pbuf_copy_partial>
    data = httpd_req_buf;
 80057b6:	4b40      	ldr	r3, [pc, #256]	; (80058b8 <http_parse_request+0x170>)
 80057b8:	637b      	str	r3, [r7, #52]	; 0x34
 80057ba:	e005      	b.n	80057c8 <http_parse_request+0x80>
  } else
#endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
  {
    data = (char *)p->payload;
 80057bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80057be:	685b      	ldr	r3, [r3, #4]
 80057c0:	637b      	str	r3, [r7, #52]	; 0x34
    data_len = p->len;
 80057c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80057c4:	895b      	ldrh	r3, [r3, #10]
 80057c6:	867b      	strh	r3, [r7, #50]	; 0x32
      LWIP_DEBUGF(HTTPD_DEBUG, ("Warning: incomplete header due to chained pbufs\n"));
    }
  }

  /* received enough data for minimal request? */
  if (data_len >= MIN_REQ_LEN) {
 80057c8:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 80057ca:	2b06      	cmp	r3, #6
 80057cc:	d95a      	bls.n	8005884 <http_parse_request+0x13c>
    /* wait for CRLF before parsing anything */
    crlf = strnstr(data, CRLF, data_len);
 80057ce:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 80057d0:	461a      	mov	r2, r3
 80057d2:	493a      	ldr	r1, [pc, #232]	; (80058bc <http_parse_request+0x174>)
 80057d4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80057d6:	f7ff fa33 	bl	8004c40 <strnstr>
 80057da:	6238      	str	r0, [r7, #32]
    if (crlf != NULL) {
 80057dc:	6a3b      	ldr	r3, [r7, #32]
 80057de:	2b00      	cmp	r3, #0
 80057e0:	d050      	beq.n	8005884 <http_parse_request+0x13c>
#if LWIP_HTTPD_SUPPORT_POST
      int is_post = 0;
#endif /* LWIP_HTTPD_SUPPORT_POST */
      int is_09 = 0;
 80057e2:	2300      	movs	r3, #0
 80057e4:	62fb      	str	r3, [r7, #44]	; 0x2c
      char *sp1, *sp2;
      u16_t left_len, uri_len;
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("CRLF received, parsing request\n"));
      /* parse method */
      if (!strncmp(data, "GET ", 4)) {
 80057e6:	2204      	movs	r2, #4
 80057e8:	4935      	ldr	r1, [pc, #212]	; (80058c0 <http_parse_request+0x178>)
 80057ea:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80057ec:	f008 ff64 	bl	800e6b8 <strncmp>
 80057f0:	4603      	mov	r3, r0
 80057f2:	2b00      	cmp	r3, #0
 80057f4:	d117      	bne.n	8005826 <http_parse_request+0xde>
        sp1 = data + 3;
 80057f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80057f8:	3303      	adds	r3, #3
 80057fa:	61fb      	str	r3, [r7, #28]
        LWIP_DEBUGF(HTTPD_DEBUG, ("Unsupported request method (not implemented): \"%s\"\n",
          data));
        return http_find_error_file(hs, 501);
      }
      /* if we come here, method is OK, parse URI */
      left_len = data_len - ((sp1 +1) - data);
 80057fc:	69fb      	ldr	r3, [r7, #28]
 80057fe:	3301      	adds	r3, #1
 8005800:	461a      	mov	r2, r3
 8005802:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005804:	1ad3      	subs	r3, r2, r3
 8005806:	b29b      	uxth	r3, r3
 8005808:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 800580a:	1ad3      	subs	r3, r2, r3
 800580c:	837b      	strh	r3, [r7, #26]
      sp2 = strnstr(sp1 + 1, " ", left_len);
 800580e:	69fb      	ldr	r3, [r7, #28]
 8005810:	3301      	adds	r3, #1
 8005812:	8b7a      	ldrh	r2, [r7, #26]
 8005814:	492b      	ldr	r1, [pc, #172]	; (80058c4 <http_parse_request+0x17c>)
 8005816:	4618      	mov	r0, r3
 8005818:	f7ff fa12 	bl	8004c40 <strnstr>
 800581c:	62b8      	str	r0, [r7, #40]	; 0x28
#if LWIP_HTTPD_SUPPORT_V09
      if (sp2 == NULL) {
 800581e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005820:	2b00      	cmp	r3, #0
 8005822:	d111      	bne.n	8005848 <http_parse_request+0x100>
 8005824:	e006      	b.n	8005834 <http_parse_request+0xec>
        data[4] = 0;
 8005826:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005828:	3304      	adds	r3, #4
 800582a:	2200      	movs	r2, #0
 800582c:	701a      	strb	r2, [r3, #0]
        return http_find_error_file(hs, 501);
 800582e:	f06f 0309 	mvn.w	r3, #9
 8005832:	e03c      	b.n	80058ae <http_parse_request+0x166>
        /* HTTP 0.9: respond with correct protocol version */
        sp2 = strnstr(sp1 + 1, CRLF, left_len);
 8005834:	69fb      	ldr	r3, [r7, #28]
 8005836:	3301      	adds	r3, #1
 8005838:	8b7a      	ldrh	r2, [r7, #26]
 800583a:	4920      	ldr	r1, [pc, #128]	; (80058bc <http_parse_request+0x174>)
 800583c:	4618      	mov	r0, r3
 800583e:	f7ff f9ff 	bl	8004c40 <strnstr>
 8005842:	62b8      	str	r0, [r7, #40]	; 0x28
        is_09 = 1;
 8005844:	2301      	movs	r3, #1
 8005846:	62fb      	str	r3, [r7, #44]	; 0x2c
          goto badrequest;
        }
#endif /* LWIP_HTTPD_SUPPORT_POST */
      }
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
 8005848:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800584a:	69fa      	ldr	r2, [r7, #28]
 800584c:	3201      	adds	r2, #1
 800584e:	1a9b      	subs	r3, r3, r2
 8005850:	833b      	strh	r3, [r7, #24]
      if ((sp2 != 0) && (sp2 > sp1)) {
 8005852:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005854:	2b00      	cmp	r3, #0
 8005856:	d015      	beq.n	8005884 <http_parse_request+0x13c>
 8005858:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800585a:	69fb      	ldr	r3, [r7, #28]
 800585c:	429a      	cmp	r2, r3
 800585e:	d911      	bls.n	8005884 <http_parse_request+0x13c>
        char *uri = sp1 + 1;
 8005860:	69fb      	ldr	r3, [r7, #28]
 8005862:	3301      	adds	r3, #1
 8005864:	617b      	str	r3, [r7, #20]
        /* null-terminate the METHOD (pbuf is freed anyway wen returning) */
        *sp1 = 0;
 8005866:	69fb      	ldr	r3, [r7, #28]
 8005868:	2200      	movs	r2, #0
 800586a:	701a      	strb	r2, [r3, #0]
        uri[uri_len] = 0;
 800586c:	8b3b      	ldrh	r3, [r7, #24]
 800586e:	697a      	ldr	r2, [r7, #20]
 8005870:	4413      	add	r3, r2
 8005872:	2200      	movs	r2, #0
 8005874:	701a      	strb	r2, [r3, #0]
          }
          return err;
        } else
#endif /* LWIP_HTTPD_SUPPORT_POST */
        {
          return http_find_file(hs, uri, is_09);
 8005876:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005878:	6979      	ldr	r1, [r7, #20]
 800587a:	68b8      	ldr	r0, [r7, #8]
 800587c:	f000 f824 	bl	80058c8 <http_find_file>
 8005880:	4603      	mov	r3, r0
 8005882:	e014      	b.n	80058ae <http_parse_request+0x166>
      }
    }
  }

#if LWIP_HTTPD_SUPPORT_REQUESTLIST
  clen = pbuf_clen(hs->req);
 8005884:	68bb      	ldr	r3, [r7, #8]
 8005886:	689b      	ldr	r3, [r3, #8]
 8005888:	4618      	mov	r0, r3
 800588a:	f002 ffdd 	bl	8008848 <pbuf_clen>
 800588e:	4603      	mov	r3, r0
 8005890:	827b      	strh	r3, [r7, #18]
  if ((hs->req->tot_len <= LWIP_HTTPD_REQ_BUFSIZE) &&
 8005892:	68bb      	ldr	r3, [r7, #8]
 8005894:	689b      	ldr	r3, [r3, #8]
 8005896:	891b      	ldrh	r3, [r3, #8]
 8005898:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800589c:	d205      	bcs.n	80058aa <http_parse_request+0x162>
 800589e:	8a7b      	ldrh	r3, [r7, #18]
 80058a0:	2b0a      	cmp	r3, #10
 80058a2:	d802      	bhi.n	80058aa <http_parse_request+0x162>
    (clen <= LWIP_HTTPD_REQ_QUEUELEN)) {
    /* request not fully received (too short or CRLF is missing) */
    return ERR_INPROGRESS;
 80058a4:	f06f 030d 	mvn.w	r3, #13
 80058a8:	e001      	b.n	80058ae <http_parse_request+0x166>
#if LWIP_HTTPD_SUPPORT_POST
badrequest:
#endif /* LWIP_HTTPD_SUPPORT_POST */
    LWIP_DEBUGF(HTTPD_DEBUG, ("bad request\n"));
    /* could not parse request */
    return http_find_error_file(hs, 400);
 80058aa:	f06f 0309 	mvn.w	r3, #9
  }
}
 80058ae:	4618      	mov	r0, r3
 80058b0:	3738      	adds	r7, #56	; 0x38
 80058b2:	46bd      	mov	sp, r7
 80058b4:	bd80      	pop	{r7, pc}
 80058b6:	bf00      	nop
 80058b8:	200025d4 	.word	0x200025d4
 80058bc:	0800e7f0 	.word	0x0800e7f0
 80058c0:	0800e7f4 	.word	0x0800e7f4
 80058c4:	0800e7fc 	.word	0x0800e7fc

080058c8 <http_find_file>:
 * @param is_09 1 if the request is HTTP/0.9 (no HTTP headers in response)
 * @return ERR_OK if file was found and hs has been initialized correctly
 *         another err_t otherwise
 */
static err_t http_find_file(struct http_state *hs, const char *uri, int is_09)
{
 80058c8:	b590      	push	{r4, r7, lr}
 80058ca:	b08b      	sub	sp, #44	; 0x2c
 80058cc:	af00      	add	r7, sp, #0
 80058ce:	60f8      	str	r0, [r7, #12]
 80058d0:	60b9      	str	r1, [r7, #8]
 80058d2:	607a      	str	r2, [r7, #4]
  size_t loop;
  struct fs_file *file = NULL;
 80058d4:	2300      	movs	r3, #0
 80058d6:	623b      	str	r3, [r7, #32]
#if LWIP_HTTPD_SSI
  /*
   * By default, assume we will not be processing server-side-includes
   * tags
   */
  hs->tag_check = false;
 80058d8:	68fb      	ldr	r3, [r7, #12]
 80058da:	2200      	movs	r2, #0
 80058dc:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
#endif /* LWIP_HTTPD_SSI */

  /* Have we been asked for the default root file? */
  if((uri[0] == '/') &&  (uri[1] == 0)) {
 80058e0:	68bb      	ldr	r3, [r7, #8]
 80058e2:	781b      	ldrb	r3, [r3, #0]
 80058e4:	2b2f      	cmp	r3, #47	; 0x2f
 80058e6:	d135      	bne.n	8005954 <http_find_file+0x8c>
 80058e8:	68bb      	ldr	r3, [r7, #8]
 80058ea:	3301      	adds	r3, #1
 80058ec:	781b      	ldrb	r3, [r3, #0]
 80058ee:	2b00      	cmp	r3, #0
 80058f0:	d130      	bne.n	8005954 <http_find_file+0x8c>
    /* Try each of the configured default filenames until we find one
       that exists. */
    for (loop = 0; loop < NUM_DEFAULT_FILENAMES; loop++) {
 80058f2:	2300      	movs	r3, #0
 80058f4:	627b      	str	r3, [r7, #36]	; 0x24
 80058f6:	e01b      	b.n	8005930 <http_find_file+0x68>
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Looking for %s...\n", g_psDefaultFilenames[loop].name));
      file = fs_open((char *)g_psDefaultFilenames[loop].name);
 80058f8:	4a5d      	ldr	r2, [pc, #372]	; (8005a70 <http_find_file+0x1a8>)
 80058fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058fc:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8005900:	4618      	mov	r0, r3
 8005902:	f7ff f915 	bl	8004b30 <fs_open>
 8005906:	6238      	str	r0, [r7, #32]
      uri = (char *)g_psDefaultFilenames[loop].name;
 8005908:	4a59      	ldr	r2, [pc, #356]	; (8005a70 <http_find_file+0x1a8>)
 800590a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800590c:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8005910:	60bb      	str	r3, [r7, #8]
      if(file != NULL) {
 8005912:	6a3b      	ldr	r3, [r7, #32]
 8005914:	2b00      	cmp	r3, #0
 8005916:	d008      	beq.n	800592a <http_find_file+0x62>
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Opened.\n"));
#if LWIP_HTTPD_SSI
        hs->tag_check = g_psDefaultFilenames[loop].shtml;
 8005918:	4a55      	ldr	r2, [pc, #340]	; (8005a70 <http_find_file+0x1a8>)
 800591a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800591c:	00db      	lsls	r3, r3, #3
 800591e:	4413      	add	r3, r2
 8005920:	791a      	ldrb	r2, [r3, #4]
 8005922:	68fb      	ldr	r3, [r7, #12]
 8005924:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
#endif /* LWIP_HTTPD_SSI */
        break;
 8005928:	e005      	b.n	8005936 <http_find_file+0x6e>
    for (loop = 0; loop < NUM_DEFAULT_FILENAMES; loop++) {
 800592a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800592c:	3301      	adds	r3, #1
 800592e:	627b      	str	r3, [r7, #36]	; 0x24
 8005930:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005932:	2b04      	cmp	r3, #4
 8005934:	d9e0      	bls.n	80058f8 <http_find_file+0x30>
      }
    }
    if (file == NULL) {
 8005936:	6a3b      	ldr	r3, [r7, #32]
 8005938:	2b00      	cmp	r3, #0
 800593a:	f040 808d 	bne.w	8005a58 <http_find_file+0x190>
      /* None of the default filenames exist so send back a 404 page */
      file = http_get_404_file(&uri);
 800593e:	f107 0308 	add.w	r3, r7, #8
 8005942:	4618      	mov	r0, r3
 8005944:	f7ff feca 	bl	80056dc <http_get_404_file>
 8005948:	6238      	str	r0, [r7, #32]
#if LWIP_HTTPD_SSI
      hs->tag_check = false;
 800594a:	68fb      	ldr	r3, [r7, #12]
 800594c:	2200      	movs	r2, #0
 800594e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    if (file == NULL) {
 8005952:	e081      	b.n	8005a58 <http_find_file+0x190>
    }
  } else {
    /* No - we've been asked for a specific file. */
#if LWIP_HTTPD_CGI
    /* First, isolate the base URI (without any parameters) */
    params = (char *)strchr(uri, '?');
 8005954:	68bb      	ldr	r3, [r7, #8]
 8005956:	213f      	movs	r1, #63	; 0x3f
 8005958:	4618      	mov	r0, r3
 800595a:	f008 fe97 	bl	800e68c <strchr>
 800595e:	61b8      	str	r0, [r7, #24]
    if (params != NULL) {
 8005960:	69bb      	ldr	r3, [r7, #24]
 8005962:	2b00      	cmp	r3, #0
 8005964:	d005      	beq.n	8005972 <http_find_file+0xaa>
      /* URI contains parameters. NULL-terminate the base URI */
      *params = '\0';
 8005966:	69bb      	ldr	r3, [r7, #24]
 8005968:	2200      	movs	r2, #0
 800596a:	701a      	strb	r2, [r3, #0]
      params++;
 800596c:	69bb      	ldr	r3, [r7, #24]
 800596e:	3301      	adds	r3, #1
 8005970:	61bb      	str	r3, [r7, #24]
    }

    /* Does the base URI we have isolated correspond to a CGI handler? */
    if (g_iNumCGIs && g_pCGIs) {
 8005972:	4b40      	ldr	r3, [pc, #256]	; (8005a74 <http_find_file+0x1ac>)
 8005974:	681b      	ldr	r3, [r3, #0]
 8005976:	2b00      	cmp	r3, #0
 8005978:	d040      	beq.n	80059fc <http_find_file+0x134>
 800597a:	4b3f      	ldr	r3, [pc, #252]	; (8005a78 <http_find_file+0x1b0>)
 800597c:	681b      	ldr	r3, [r3, #0]
 800597e:	2b00      	cmp	r3, #0
 8005980:	d03c      	beq.n	80059fc <http_find_file+0x134>
      for (i = 0; i < g_iNumCGIs; i++) {
 8005982:	2300      	movs	r3, #0
 8005984:	61fb      	str	r3, [r7, #28]
 8005986:	e026      	b.n	80059d6 <http_find_file+0x10e>
        if (strcmp(uri, g_pCGIs[i].pcCGIName) == 0) {
 8005988:	68b8      	ldr	r0, [r7, #8]
 800598a:	4b3b      	ldr	r3, [pc, #236]	; (8005a78 <http_find_file+0x1b0>)
 800598c:	681a      	ldr	r2, [r3, #0]
 800598e:	69fb      	ldr	r3, [r7, #28]
 8005990:	00db      	lsls	r3, r3, #3
 8005992:	4413      	add	r3, r2
 8005994:	681b      	ldr	r3, [r3, #0]
 8005996:	4619      	mov	r1, r3
 8005998:	f7fa fc1a 	bl	80001d0 <strcmp>
 800599c:	4603      	mov	r3, r0
 800599e:	2b00      	cmp	r3, #0
 80059a0:	d116      	bne.n	80059d0 <http_find_file+0x108>
          /*
           * We found a CGI that handles this URI so extract the
           * parameters and call the handler.
           */
           count = extract_uri_parameters(hs, params);
 80059a2:	69b9      	ldr	r1, [r7, #24]
 80059a4:	68f8      	ldr	r0, [r7, #12]
 80059a6:	f7ff fa29 	bl	8004dfc <extract_uri_parameters>
 80059aa:	6178      	str	r0, [r7, #20]
           uri = g_pCGIs[i].pfnCGIHandler(i, count, hs->params,
 80059ac:	4b32      	ldr	r3, [pc, #200]	; (8005a78 <http_find_file+0x1b0>)
 80059ae:	681a      	ldr	r2, [r3, #0]
 80059b0:	69fb      	ldr	r3, [r7, #28]
 80059b2:	00db      	lsls	r3, r3, #3
 80059b4:	4413      	add	r3, r2
 80059b6:	685c      	ldr	r4, [r3, #4]
 80059b8:	68fb      	ldr	r3, [r7, #12]
 80059ba:	f103 02f4 	add.w	r2, r3, #244	; 0xf4
                                          hs->param_vals);
 80059be:	68fb      	ldr	r3, [r7, #12]
 80059c0:	f503 739a 	add.w	r3, r3, #308	; 0x134
           uri = g_pCGIs[i].pfnCGIHandler(i, count, hs->params,
 80059c4:	6979      	ldr	r1, [r7, #20]
 80059c6:	69f8      	ldr	r0, [r7, #28]
 80059c8:	47a0      	blx	r4
 80059ca:	4603      	mov	r3, r0
 80059cc:	60bb      	str	r3, [r7, #8]
           break;
 80059ce:	e007      	b.n	80059e0 <http_find_file+0x118>
      for (i = 0; i < g_iNumCGIs; i++) {
 80059d0:	69fb      	ldr	r3, [r7, #28]
 80059d2:	3301      	adds	r3, #1
 80059d4:	61fb      	str	r3, [r7, #28]
 80059d6:	4b27      	ldr	r3, [pc, #156]	; (8005a74 <http_find_file+0x1ac>)
 80059d8:	681b      	ldr	r3, [r3, #0]
 80059da:	69fa      	ldr	r2, [r7, #28]
 80059dc:	429a      	cmp	r2, r3
 80059de:	dbd3      	blt.n	8005988 <http_find_file+0xc0>
        }
      }

      /* Did we handle this URL as a CGI? If not, reinstate the
       * original URL and pass it to the file system directly. */
      if (i == g_iNumCGIs) {
 80059e0:	4b24      	ldr	r3, [pc, #144]	; (8005a74 <http_find_file+0x1ac>)
 80059e2:	681b      	ldr	r3, [r3, #0]
 80059e4:	69fa      	ldr	r2, [r7, #28]
 80059e6:	429a      	cmp	r2, r3
 80059e8:	d108      	bne.n	80059fc <http_find_file+0x134>
        /* Replace the ? marker at the beginning of the parameters */
        if (params != NULL) {
 80059ea:	69bb      	ldr	r3, [r7, #24]
 80059ec:	2b00      	cmp	r3, #0
 80059ee:	d005      	beq.n	80059fc <http_find_file+0x134>
           params--;
 80059f0:	69bb      	ldr	r3, [r7, #24]
 80059f2:	3b01      	subs	r3, #1
 80059f4:	61bb      	str	r3, [r7, #24]
          *params = '?';
 80059f6:	69bb      	ldr	r3, [r7, #24]
 80059f8:	223f      	movs	r2, #63	; 0x3f
 80059fa:	701a      	strb	r2, [r3, #0]
    }
#endif /* LWIP_HTTPD_CGI */

    LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Opening %s\n", uri));

    file = fs_open(uri);
 80059fc:	68bb      	ldr	r3, [r7, #8]
 80059fe:	4618      	mov	r0, r3
 8005a00:	f7ff f896 	bl	8004b30 <fs_open>
 8005a04:	6238      	str	r0, [r7, #32]
    if (file == NULL) {
 8005a06:	6a3b      	ldr	r3, [r7, #32]
 8005a08:	2b00      	cmp	r3, #0
 8005a0a:	d105      	bne.n	8005a18 <http_find_file+0x150>
      file = http_get_404_file(&uri);
 8005a0c:	f107 0308 	add.w	r3, r7, #8
 8005a10:	4618      	mov	r0, r3
 8005a12:	f7ff fe63 	bl	80056dc <http_get_404_file>
 8005a16:	6238      	str	r0, [r7, #32]
    }
#if LWIP_HTTPD_SSI
    if (file != NULL) {
 8005a18:	6a3b      	ldr	r3, [r7, #32]
 8005a1a:	2b00      	cmp	r3, #0
 8005a1c:	d01c      	beq.n	8005a58 <http_find_file+0x190>
      /*
       * See if we have been asked for an shtml file and, if so,
       * enable tag checking.
       */
      hs->tag_check = false;
 8005a1e:	68fb      	ldr	r3, [r7, #12]
 8005a20:	2200      	movs	r2, #0
 8005a22:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
 8005a26:	2300      	movs	r3, #0
 8005a28:	627b      	str	r3, [r7, #36]	; 0x24
 8005a2a:	e012      	b.n	8005a52 <http_find_file+0x18a>
        if (strstr(uri, g_pcSSIExtensions[loop])) {
 8005a2c:	68b8      	ldr	r0, [r7, #8]
 8005a2e:	4a13      	ldr	r2, [pc, #76]	; (8005a7c <http_find_file+0x1b4>)
 8005a30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005a32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8005a36:	4619      	mov	r1, r3
 8005a38:	f008 fe50 	bl	800e6dc <strstr>
 8005a3c:	4603      	mov	r3, r0
 8005a3e:	2b00      	cmp	r3, #0
 8005a40:	d004      	beq.n	8005a4c <http_find_file+0x184>
          hs->tag_check = true;
 8005a42:	68fb      	ldr	r3, [r7, #12]
 8005a44:	2201      	movs	r2, #1
 8005a46:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
          break;
 8005a4a:	e005      	b.n	8005a58 <http_find_file+0x190>
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
 8005a4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005a4e:	3301      	adds	r3, #1
 8005a50:	627b      	str	r3, [r7, #36]	; 0x24
 8005a52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005a54:	2b03      	cmp	r3, #3
 8005a56:	d9e9      	bls.n	8005a2c <http_find_file+0x164>
        }
      }
    }
#endif /* LWIP_HTTPD_SSI */
  }
  return http_init_file(hs, file, is_09, uri);
 8005a58:	68bb      	ldr	r3, [r7, #8]
 8005a5a:	687a      	ldr	r2, [r7, #4]
 8005a5c:	6a39      	ldr	r1, [r7, #32]
 8005a5e:	68f8      	ldr	r0, [r7, #12]
 8005a60:	f000 f80e 	bl	8005a80 <http_init_file>
 8005a64:	4603      	mov	r3, r0
}
 8005a66:	4618      	mov	r0, r3
 8005a68:	372c      	adds	r7, #44	; 0x2c
 8005a6a:	46bd      	mov	sp, r7
 8005a6c:	bd90      	pop	{r4, r7, pc}
 8005a6e:	bf00      	nop
 8005a70:	0801b538 	.word	0x0801b538
 8005a74:	200029e4 	.word	0x200029e4
 8005a78:	200029e0 	.word	0x200029e0
 8005a7c:	20000018 	.word	0x20000018

08005a80 <http_init_file>:
 * @param uri the HTTP header URI
 * @return ERR_OK if file was found and hs has been initialized correctly
 *         another err_t otherwise
 */
static err_t http_init_file(struct http_state *hs, struct fs_file *file, int is_09, const char *uri)
{
 8005a80:	b580      	push	{r7, lr}
 8005a82:	b086      	sub	sp, #24
 8005a84:	af00      	add	r7, sp, #0
 8005a86:	60f8      	str	r0, [r7, #12]
 8005a88:	60b9      	str	r1, [r7, #8]
 8005a8a:	607a      	str	r2, [r7, #4]
 8005a8c:	603b      	str	r3, [r7, #0]
  if (file != NULL) {
 8005a8e:	68bb      	ldr	r3, [r7, #8]
 8005a90:	2b00      	cmp	r3, #0
 8005a92:	d04a      	beq.n	8005b2a <http_init_file+0xaa>
    /* file opened, initialise struct http_state */
#if LWIP_HTTPD_SSI
    hs->tag_index = 0;
 8005a94:	68fb      	ldr	r3, [r7, #12]
 8005a96:	2200      	movs	r2, #0
 8005a98:	851a      	strh	r2, [r3, #40]	; 0x28
    hs->tag_state = TAG_NONE;
 8005a9a:	68fb      	ldr	r3, [r7, #12]
 8005a9c:	2200      	movs	r2, #0
 8005a9e:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
    hs->parsed = file->data;
 8005aa2:	68bb      	ldr	r3, [r7, #8]
 8005aa4:	681a      	ldr	r2, [r3, #0]
 8005aa6:	68fb      	ldr	r3, [r7, #12]
 8005aa8:	61da      	str	r2, [r3, #28]
    hs->parse_left = file->len;
 8005aaa:	68bb      	ldr	r3, [r7, #8]
 8005aac:	685b      	ldr	r3, [r3, #4]
 8005aae:	461a      	mov	r2, r3
 8005ab0:	68fb      	ldr	r3, [r7, #12]
 8005ab2:	625a      	str	r2, [r3, #36]	; 0x24
    hs->tag_end = file->data;
 8005ab4:	68bb      	ldr	r3, [r7, #8]
 8005ab6:	681a      	ldr	r2, [r3, #0]
 8005ab8:	68fb      	ldr	r3, [r7, #12]
 8005aba:	621a      	str	r2, [r3, #32]
#endif /* LWIP_HTTPD_SSI */
    hs->handle = file;
 8005abc:	68fb      	ldr	r3, [r7, #12]
 8005abe:	68ba      	ldr	r2, [r7, #8]
 8005ac0:	601a      	str	r2, [r3, #0]
    hs->file = (char*)file->data;
 8005ac2:	68bb      	ldr	r3, [r7, #8]
 8005ac4:	681a      	ldr	r2, [r3, #0]
 8005ac6:	68fb      	ldr	r3, [r7, #12]
 8005ac8:	605a      	str	r2, [r3, #4]
    LWIP_ASSERT("File length must be positive!", (file->len >= 0));
    hs->left = file->len;
 8005aca:	68bb      	ldr	r3, [r7, #8]
 8005acc:	685b      	ldr	r3, [r3, #4]
 8005ace:	461a      	mov	r2, r3
 8005ad0:	68fb      	ldr	r3, [r7, #12]
 8005ad2:	615a      	str	r2, [r3, #20]
    hs->retries = 0;
 8005ad4:	68fb      	ldr	r3, [r7, #12]
 8005ad6:	2200      	movs	r2, #0
 8005ad8:	761a      	strb	r2, [r3, #24]
#endif /* LWIP_HTTPD_TIMING */
#if !LWIP_HTTPD_DYNAMIC_HEADERS
    LWIP_ASSERT("HTTP headers not included in file system", hs->handle->http_header_included);
#endif /* !LWIP_HTTPD_DYNAMIC_HEADERS */
#if LWIP_HTTPD_SUPPORT_V09
    if (hs->handle->http_header_included && is_09) {
 8005ada:	68fb      	ldr	r3, [r7, #12]
 8005adc:	681b      	ldr	r3, [r3, #0]
 8005ade:	7c1b      	ldrb	r3, [r3, #16]
 8005ae0:	2b00      	cmp	r3, #0
 8005ae2:	d02e      	beq.n	8005b42 <http_init_file+0xc2>
 8005ae4:	687b      	ldr	r3, [r7, #4]
 8005ae6:	2b00      	cmp	r3, #0
 8005ae8:	d02b      	beq.n	8005b42 <http_init_file+0xc2>
      /* HTTP/0.9 responses are sent without HTTP header,
         search for the end of the header. */
      char *file_start = strnstr(hs->file, CRLF CRLF, hs->left);
 8005aea:	68fb      	ldr	r3, [r7, #12]
 8005aec:	6858      	ldr	r0, [r3, #4]
 8005aee:	68fb      	ldr	r3, [r7, #12]
 8005af0:	695b      	ldr	r3, [r3, #20]
 8005af2:	461a      	mov	r2, r3
 8005af4:	4915      	ldr	r1, [pc, #84]	; (8005b4c <http_init_file+0xcc>)
 8005af6:	f7ff f8a3 	bl	8004c40 <strnstr>
 8005afa:	6178      	str	r0, [r7, #20]
      if (file_start != NULL) {
 8005afc:	697b      	ldr	r3, [r7, #20]
 8005afe:	2b00      	cmp	r3, #0
 8005b00:	d01f      	beq.n	8005b42 <http_init_file+0xc2>
        size_t diff = file_start + 4 - hs->file;
 8005b02:	697b      	ldr	r3, [r7, #20]
 8005b04:	3304      	adds	r3, #4
 8005b06:	461a      	mov	r2, r3
 8005b08:	68fb      	ldr	r3, [r7, #12]
 8005b0a:	685b      	ldr	r3, [r3, #4]
 8005b0c:	1ad3      	subs	r3, r2, r3
 8005b0e:	613b      	str	r3, [r7, #16]
        hs->file += diff;
 8005b10:	68fb      	ldr	r3, [r7, #12]
 8005b12:	685a      	ldr	r2, [r3, #4]
 8005b14:	693b      	ldr	r3, [r7, #16]
 8005b16:	441a      	add	r2, r3
 8005b18:	68fb      	ldr	r3, [r7, #12]
 8005b1a:	605a      	str	r2, [r3, #4]
        hs->left -= (u32_t)diff;
 8005b1c:	68fb      	ldr	r3, [r7, #12]
 8005b1e:	695a      	ldr	r2, [r3, #20]
 8005b20:	693b      	ldr	r3, [r7, #16]
 8005b22:	1ad2      	subs	r2, r2, r3
 8005b24:	68fb      	ldr	r3, [r7, #12]
 8005b26:	615a      	str	r2, [r3, #20]
 8005b28:	e00b      	b.n	8005b42 <http_init_file+0xc2>
      }
    }
#endif /* LWIP_HTTPD_SUPPORT_V09*/
  } else {
    hs->handle = NULL;
 8005b2a:	68fb      	ldr	r3, [r7, #12]
 8005b2c:	2200      	movs	r2, #0
 8005b2e:	601a      	str	r2, [r3, #0]
    hs->file = NULL;
 8005b30:	68fb      	ldr	r3, [r7, #12]
 8005b32:	2200      	movs	r2, #0
 8005b34:	605a      	str	r2, [r3, #4]
    hs->left = 0;
 8005b36:	68fb      	ldr	r3, [r7, #12]
 8005b38:	2200      	movs	r2, #0
 8005b3a:	615a      	str	r2, [r3, #20]
    hs->retries = 0;
 8005b3c:	68fb      	ldr	r3, [r7, #12]
 8005b3e:	2200      	movs	r2, #0
 8005b40:	761a      	strb	r2, [r3, #24]
    get_http_headers(hs, (char*)uri);
  }
#else /* LWIP_HTTPD_DYNAMIC_HEADERS */
  LWIP_UNUSED_ARG(uri);
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
  return ERR_OK;
 8005b42:	2300      	movs	r3, #0
}
 8005b44:	4618      	mov	r0, r3
 8005b46:	3718      	adds	r7, #24
 8005b48:	46bd      	mov	sp, r7
 8005b4a:	bd80      	pop	{r7, pc}
 8005b4c:	0800e800 	.word	0x0800e800

08005b50 <http_err>:
/**
 * The pcb had an error and is already deallocated.
 * The argument might still be valid (if != NULL).
 */
static void http_err(void *arg, err_t err)
{
 8005b50:	b580      	push	{r7, lr}
 8005b52:	b084      	sub	sp, #16
 8005b54:	af00      	add	r7, sp, #0
 8005b56:	6078      	str	r0, [r7, #4]
 8005b58:	460b      	mov	r3, r1
 8005b5a:	70fb      	strb	r3, [r7, #3]
  struct http_state *hs = (struct http_state *)arg;
 8005b5c:	687b      	ldr	r3, [r7, #4]
 8005b5e:	60fb      	str	r3, [r7, #12]
  LWIP_UNUSED_ARG(err);

  LWIP_DEBUGF(HTTPD_DEBUG, ("http_err: %s", lwip_strerr(err)));

  if (hs != NULL) {
 8005b60:	68fb      	ldr	r3, [r7, #12]
 8005b62:	2b00      	cmp	r3, #0
 8005b64:	d002      	beq.n	8005b6c <http_err+0x1c>
    http_state_free(hs);
 8005b66:	68f8      	ldr	r0, [r7, #12]
 8005b68:	f7ff f8b8 	bl	8004cdc <http_state_free>
  }
}
 8005b6c:	bf00      	nop
 8005b6e:	3710      	adds	r7, #16
 8005b70:	46bd      	mov	sp, r7
 8005b72:	bd80      	pop	{r7, pc}

08005b74 <http_sent>:
/**
 * Data has been sent and acknowledged by the remote host.
 * This means that more data can be sent.
 */
static err_t http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 8005b74:	b580      	push	{r7, lr}
 8005b76:	b086      	sub	sp, #24
 8005b78:	af00      	add	r7, sp, #0
 8005b7a:	60f8      	str	r0, [r7, #12]
 8005b7c:	60b9      	str	r1, [r7, #8]
 8005b7e:	4613      	mov	r3, r2
 8005b80:	80fb      	strh	r3, [r7, #6]
  struct http_state *hs = (struct http_state *)arg;
 8005b82:	68fb      	ldr	r3, [r7, #12]
 8005b84:	617b      	str	r3, [r7, #20]

  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_sent %p\n", (void*)pcb));

  LWIP_UNUSED_ARG(len);

  if (hs == NULL) {
 8005b86:	697b      	ldr	r3, [r7, #20]
 8005b88:	2b00      	cmp	r3, #0
 8005b8a:	d101      	bne.n	8005b90 <http_sent+0x1c>
    return ERR_OK;
 8005b8c:	2300      	movs	r3, #0
 8005b8e:	e007      	b.n	8005ba0 <http_sent+0x2c>
  }

  hs->retries = 0;
 8005b90:	697b      	ldr	r3, [r7, #20]
 8005b92:	2200      	movs	r2, #0
 8005b94:	761a      	strb	r2, [r3, #24]

  http_send_data(pcb, hs);
 8005b96:	6979      	ldr	r1, [r7, #20]
 8005b98:	68b8      	ldr	r0, [r7, #8]
 8005b9a:	f7ff fa11 	bl	8004fc0 <http_send_data>

  return ERR_OK;
 8005b9e:	2300      	movs	r3, #0
}
 8005ba0:	4618      	mov	r0, r3
 8005ba2:	3718      	adds	r7, #24
 8005ba4:	46bd      	mov	sp, r7
 8005ba6:	bd80      	pop	{r7, pc}

08005ba8 <http_poll>:
 * If the last portion of a file has not been sent in 2 seconds, close.
 *
 * This could be increased, but we don't want to waste resources for bad connections.
 */
static err_t http_poll(void *arg, struct tcp_pcb *pcb)
{
 8005ba8:	b580      	push	{r7, lr}
 8005baa:	b084      	sub	sp, #16
 8005bac:	af00      	add	r7, sp, #0
 8005bae:	6078      	str	r0, [r7, #4]
 8005bb0:	6039      	str	r1, [r7, #0]
  struct http_state *hs = (struct http_state *)arg;
 8005bb2:	687b      	ldr	r3, [r7, #4]
 8005bb4:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_poll: pcb=%p hs=%p pcb_state=%s\n",
    (void*)pcb, (void*)hs, tcp_debug_state_str(pcb->state)));

  if (hs == NULL) {
 8005bb6:	68fb      	ldr	r3, [r7, #12]
 8005bb8:	2b00      	cmp	r3, #0
 8005bba:	d105      	bne.n	8005bc8 <http_poll+0x20>
    /* arg is null, close. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("http_poll: arg is NULL, close\n"));
    http_close_conn(pcb, hs);
 8005bbc:	68f9      	ldr	r1, [r7, #12]
 8005bbe:	6838      	ldr	r0, [r7, #0]
 8005bc0:	f7ff f8ea 	bl	8004d98 <http_close_conn>
    return ERR_OK;
 8005bc4:	2300      	movs	r3, #0
 8005bc6:	e021      	b.n	8005c0c <http_poll+0x64>
  } else {
    hs->retries++;
 8005bc8:	68fb      	ldr	r3, [r7, #12]
 8005bca:	7e1b      	ldrb	r3, [r3, #24]
 8005bcc:	3301      	adds	r3, #1
 8005bce:	b2da      	uxtb	r2, r3
 8005bd0:	68fb      	ldr	r3, [r7, #12]
 8005bd2:	761a      	strb	r2, [r3, #24]
    if (hs->retries == HTTPD_MAX_RETRIES) {
 8005bd4:	68fb      	ldr	r3, [r7, #12]
 8005bd6:	7e1b      	ldrb	r3, [r3, #24]
 8005bd8:	2b04      	cmp	r3, #4
 8005bda:	d105      	bne.n	8005be8 <http_poll+0x40>
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_poll: too many retries, close\n"));
      http_close_conn(pcb, hs);
 8005bdc:	68f9      	ldr	r1, [r7, #12]
 8005bde:	6838      	ldr	r0, [r7, #0]
 8005be0:	f7ff f8da 	bl	8004d98 <http_close_conn>
      return ERR_OK;
 8005be4:	2300      	movs	r3, #0
 8005be6:	e011      	b.n	8005c0c <http_poll+0x64>
    }

    /* If this connection has a file open, try to send some more data. If
     * it has not yet received a GET request, don't do this since it will
     * cause the connection to close immediately. */
    if(hs && (hs->handle)) {
 8005be8:	68fb      	ldr	r3, [r7, #12]
 8005bea:	2b00      	cmp	r3, #0
 8005bec:	d00d      	beq.n	8005c0a <http_poll+0x62>
 8005bee:	68fb      	ldr	r3, [r7, #12]
 8005bf0:	681b      	ldr	r3, [r3, #0]
 8005bf2:	2b00      	cmp	r3, #0
 8005bf4:	d009      	beq.n	8005c0a <http_poll+0x62>
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_poll: try to send more data\n"));
      if(http_send_data(pcb, hs)) {
 8005bf6:	68f9      	ldr	r1, [r7, #12]
 8005bf8:	6838      	ldr	r0, [r7, #0]
 8005bfa:	f7ff f9e1 	bl	8004fc0 <http_send_data>
 8005bfe:	4603      	mov	r3, r0
 8005c00:	2b00      	cmp	r3, #0
 8005c02:	d002      	beq.n	8005c0a <http_poll+0x62>
        /* If we wrote anything to be sent, go ahead and send it now. */
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("tcp_output\n"));
        tcp_output(pcb);
 8005c04:	6838      	ldr	r0, [r7, #0]
 8005c06:	f006 f8a1 	bl	800bd4c <tcp_output>
      }
    }
  }

  return ERR_OK;
 8005c0a:	2300      	movs	r3, #0
}
 8005c0c:	4618      	mov	r0, r3
 8005c0e:	3710      	adds	r7, #16
 8005c10:	46bd      	mov	sp, r7
 8005c12:	bd80      	pop	{r7, pc}

08005c14 <http_recv>:
/**
 * Data has been received on this pcb.
 * For HTTP 1.0, this should normally only happen once (if the request fits in one packet).
 */
static err_t http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 8005c14:	b580      	push	{r7, lr}
 8005c16:	b086      	sub	sp, #24
 8005c18:	af00      	add	r7, sp, #0
 8005c1a:	60f8      	str	r0, [r7, #12]
 8005c1c:	60b9      	str	r1, [r7, #8]
 8005c1e:	607a      	str	r2, [r7, #4]
 8005c20:	70fb      	strb	r3, [r7, #3]
  err_t parsed = ERR_ABRT;
 8005c22:	23fb      	movs	r3, #251	; 0xfb
 8005c24:	75fb      	strb	r3, [r7, #23]
  struct http_state *hs = (struct http_state *)arg;
 8005c26:	68fb      	ldr	r3, [r7, #12]
 8005c28:	613b      	str	r3, [r7, #16]
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: pcb=%p pbuf=%p err=%s\n", (void*)pcb,
    (void*)p, lwip_strerr(err)));

  if ((err != ERR_OK) || (p == NULL) || (hs == NULL)) {
 8005c2a:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8005c2e:	2b00      	cmp	r3, #0
 8005c30:	d105      	bne.n	8005c3e <http_recv+0x2a>
 8005c32:	687b      	ldr	r3, [r7, #4]
 8005c34:	2b00      	cmp	r3, #0
 8005c36:	d002      	beq.n	8005c3e <http_recv+0x2a>
 8005c38:	693b      	ldr	r3, [r7, #16]
 8005c3a:	2b00      	cmp	r3, #0
 8005c3c:	d112      	bne.n	8005c64 <http_recv+0x50>
    /* error or closed by other side? */
    if (p != NULL) {
 8005c3e:	687b      	ldr	r3, [r7, #4]
 8005c40:	2b00      	cmp	r3, #0
 8005c42:	d009      	beq.n	8005c58 <http_recv+0x44>
      /* Inform TCP that we have taken the data. */
      tcp_recved(pcb, p->tot_len);
 8005c44:	687b      	ldr	r3, [r7, #4]
 8005c46:	891b      	ldrh	r3, [r3, #8]
 8005c48:	4619      	mov	r1, r3
 8005c4a:	68b8      	ldr	r0, [r7, #8]
 8005c4c:	f003 fa77 	bl	800913e <tcp_recved>
      pbuf_free(p);
 8005c50:	687b      	ldr	r3, [r7, #4]
 8005c52:	4618      	mov	r0, r3
 8005c54:	f002 fda9 	bl	80087aa <pbuf_free>
    }
    if (hs == NULL) {
      /* this should not happen, only to be robust */
      LWIP_DEBUGF(HTTPD_DEBUG, ("Error, http_recv: hs is NULL, close\n"));
    }
    http_close_conn(pcb, hs);
 8005c58:	6939      	ldr	r1, [r7, #16]
 8005c5a:	68b8      	ldr	r0, [r7, #8]
 8005c5c:	f7ff f89c 	bl	8004d98 <http_close_conn>
    return ERR_OK;
 8005c60:	2300      	movs	r3, #0
 8005c62:	e035      	b.n	8005cd0 <http_recv+0xbc>
     hs->unrecved_bytes += p->tot_len;
  } else
#endif /* LWIP_HTTPD_SUPPORT_POST && LWIP_HTTPD_POST_MANUAL_WND */
  {
    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
 8005c64:	687b      	ldr	r3, [r7, #4]
 8005c66:	891b      	ldrh	r3, [r3, #8]
 8005c68:	4619      	mov	r1, r3
 8005c6a:	68b8      	ldr	r0, [r7, #8]
 8005c6c:	f003 fa67 	bl	800913e <tcp_recved>
    }
    return ERR_OK;
  } else
#endif /* LWIP_HTTPD_SUPPORT_POST */
  {
    if (hs->handle == NULL) {
 8005c70:	693b      	ldr	r3, [r7, #16]
 8005c72:	681b      	ldr	r3, [r3, #0]
 8005c74:	2b00      	cmp	r3, #0
 8005c76:	d107      	bne.n	8005c88 <http_recv+0x74>
      parsed = http_parse_request(&p, hs, pcb);
 8005c78:	1d3b      	adds	r3, r7, #4
 8005c7a:	68ba      	ldr	r2, [r7, #8]
 8005c7c:	6939      	ldr	r1, [r7, #16]
 8005c7e:	4618      	mov	r0, r3
 8005c80:	f7ff fd62 	bl	8005748 <http_parse_request>
 8005c84:	4603      	mov	r3, r0
 8005c86:	75fb      	strb	r3, [r7, #23]
        || parsed == ERR_INPROGRESS ||parsed == ERR_ARG || parsed == ERR_USE);
    } else {
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_recv: already sending data\n"));
    }
#if LWIP_HTTPD_SUPPORT_REQUESTLIST
    if (parsed != ERR_INPROGRESS) {
 8005c88:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8005c8c:	f113 0f0e 	cmn.w	r3, #14
 8005c90:	d00b      	beq.n	8005caa <http_recv+0x96>
      /* request fully parsed or error */
      if (hs->req != NULL) {
 8005c92:	693b      	ldr	r3, [r7, #16]
 8005c94:	689b      	ldr	r3, [r3, #8]
 8005c96:	2b00      	cmp	r3, #0
 8005c98:	d007      	beq.n	8005caa <http_recv+0x96>
        pbuf_free(hs->req);
 8005c9a:	693b      	ldr	r3, [r7, #16]
 8005c9c:	689b      	ldr	r3, [r3, #8]
 8005c9e:	4618      	mov	r0, r3
 8005ca0:	f002 fd83 	bl	80087aa <pbuf_free>
        hs->req = NULL;
 8005ca4:	693b      	ldr	r3, [r7, #16]
 8005ca6:	2200      	movs	r2, #0
 8005ca8:	609a      	str	r2, [r3, #8]
    if (p != NULL) {
      /* pbuf not passed to application, free it now */
      pbuf_free(p);
    }
#endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
    if (parsed == ERR_OK) {
 8005caa:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8005cae:	2b00      	cmp	r3, #0
 8005cb0:	d104      	bne.n	8005cbc <http_recv+0xa8>
#if LWIP_HTTPD_SUPPORT_POST
      if (hs->post_content_len_left == 0)
#endif /* LWIP_HTTPD_SUPPORT_POST */
      {
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: data %p len %"S32_F"\n", hs->file, hs->left));
        http_send_data(pcb, hs);
 8005cb2:	6939      	ldr	r1, [r7, #16]
 8005cb4:	68b8      	ldr	r0, [r7, #8]
 8005cb6:	f7ff f983 	bl	8004fc0 <http_send_data>
 8005cba:	e008      	b.n	8005cce <http_recv+0xba>
      }
    } else if (parsed == ERR_ARG) {
 8005cbc:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8005cc0:	f113 0f0a 	cmn.w	r3, #10
 8005cc4:	d103      	bne.n	8005cce <http_recv+0xba>
      /* @todo: close on ERR_USE? */
      http_close_conn(pcb, hs);
 8005cc6:	6939      	ldr	r1, [r7, #16]
 8005cc8:	68b8      	ldr	r0, [r7, #8]
 8005cca:	f7ff f865 	bl	8004d98 <http_close_conn>
    }
  }
  return ERR_OK;
 8005cce:	2300      	movs	r3, #0
}
 8005cd0:	4618      	mov	r0, r3
 8005cd2:	3718      	adds	r7, #24
 8005cd4:	46bd      	mov	sp, r7
 8005cd6:	bd80      	pop	{r7, pc}

08005cd8 <http_accept>:

/**
 * A new incoming connection has been accepted.
 */
static err_t http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
 8005cd8:	b580      	push	{r7, lr}
 8005cda:	b086      	sub	sp, #24
 8005cdc:	af00      	add	r7, sp, #0
 8005cde:	60f8      	str	r0, [r7, #12]
 8005ce0:	60b9      	str	r1, [r7, #8]
 8005ce2:	4613      	mov	r3, r2
 8005ce4:	71fb      	strb	r3, [r7, #7]
  struct http_state *hs;
  struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)arg;
 8005ce6:	68fb      	ldr	r3, [r7, #12]
 8005ce8:	617b      	str	r3, [r7, #20]
  LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept %p / %p\n", (void*)pcb, arg));

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);
  /* Set priority */
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 8005cea:	2101      	movs	r1, #1
 8005cec:	68b8      	ldr	r0, [r7, #8]
 8005cee:	f003 fd23 	bl	8009738 <tcp_setprio>

  /* Allocate memory for the structure that holds the state of the
     connection - initialized by that function. */
  hs = http_state_alloc();
 8005cf2:	f7fe ffdd 	bl	8004cb0 <http_state_alloc>
 8005cf6:	6138      	str	r0, [r7, #16]
  if (hs == NULL) {
 8005cf8:	693b      	ldr	r3, [r7, #16]
 8005cfa:	2b00      	cmp	r3, #0
 8005cfc:	d102      	bne.n	8005d04 <http_accept+0x2c>
    LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept: Out of memory, RST\n"));
    return ERR_MEM;
 8005cfe:	f04f 33ff 	mov.w	r3, #4294967295
 8005d02:	e015      	b.n	8005d30 <http_accept+0x58>
  }

  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
 8005d04:	6939      	ldr	r1, [r7, #16]
 8005d06:	68b8      	ldr	r0, [r7, #8]
 8005d08:	f003 fe48 	bl	800999c <tcp_arg>

  /* Set up the various callback functions */
  tcp_recv(pcb, http_recv);
 8005d0c:	490a      	ldr	r1, [pc, #40]	; (8005d38 <http_accept+0x60>)
 8005d0e:	68b8      	ldr	r0, [r7, #8]
 8005d10:	f003 fe52 	bl	80099b8 <tcp_recv>
  tcp_err(pcb, http_err);
 8005d14:	4909      	ldr	r1, [pc, #36]	; (8005d3c <http_accept+0x64>)
 8005d16:	68b8      	ldr	r0, [r7, #8]
 8005d18:	f003 fe6c 	bl	80099f4 <tcp_err>
  tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 8005d1c:	2204      	movs	r2, #4
 8005d1e:	4908      	ldr	r1, [pc, #32]	; (8005d40 <http_accept+0x68>)
 8005d20:	68b8      	ldr	r0, [r7, #8]
 8005d22:	f003 fe84 	bl	8009a2e <tcp_poll>
  tcp_sent(pcb, http_sent);
 8005d26:	4907      	ldr	r1, [pc, #28]	; (8005d44 <http_accept+0x6c>)
 8005d28:	68b8      	ldr	r0, [r7, #8]
 8005d2a:	f003 fe54 	bl	80099d6 <tcp_sent>

  return ERR_OK;
 8005d2e:	2300      	movs	r3, #0
}
 8005d30:	4618      	mov	r0, r3
 8005d32:	3718      	adds	r7, #24
 8005d34:	46bd      	mov	sp, r7
 8005d36:	bd80      	pop	{r7, pc}
 8005d38:	08005c15 	.word	0x08005c15
 8005d3c:	08005b51 	.word	0x08005b51
 8005d40:	08005ba9 	.word	0x08005ba9
 8005d44:	08005b75 	.word	0x08005b75

08005d48 <httpd_init_addr>:

/**
 * Initialize the httpd with the specified local address.
 */
static void httpd_init_addr(struct ip_addr *local_addr)
{
 8005d48:	b580      	push	{r7, lr}
 8005d4a:	b084      	sub	sp, #16
 8005d4c:	af00      	add	r7, sp, #0
 8005d4e:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *pcb;
  err_t err;

  pcb = tcp_new();
 8005d50:	f003 fe1c 	bl	800998c <tcp_new>
 8005d54:	60f8      	str	r0, [r7, #12]
  LWIP_ASSERT("httpd_init: tcp_new failed", pcb != NULL);
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 8005d56:	2101      	movs	r1, #1
 8005d58:	68f8      	ldr	r0, [r7, #12]
 8005d5a:	f003 fced 	bl	8009738 <tcp_setprio>
  /* set SOF_REUSEADDR here to explicitly bind httpd to multiple interfaces */
  err = tcp_bind(pcb, local_addr, HTTPD_SERVER_PORT);
 8005d5e:	2250      	movs	r2, #80	; 0x50
 8005d60:	6879      	ldr	r1, [r7, #4]
 8005d62:	68f8      	ldr	r0, [r7, #12]
 8005d64:	f003 f852 	bl	8008e0c <tcp_bind>
 8005d68:	4603      	mov	r3, r0
 8005d6a:	72fb      	strb	r3, [r7, #11]
  LWIP_ASSERT("httpd_init: tcp_bind failed", err == ERR_OK);
  pcb = tcp_listen(pcb);
 8005d6c:	21ff      	movs	r1, #255	; 0xff
 8005d6e:	68f8      	ldr	r0, [r7, #12]
 8005d70:	f003 f91e 	bl	8008fb0 <tcp_listen_with_backlog>
 8005d74:	60f8      	str	r0, [r7, #12]
  LWIP_ASSERT("httpd_init: tcp_listen failed", pcb != NULL);
  /* initialize callback arg and accept callback */
  tcp_arg(pcb, pcb);
 8005d76:	68f9      	ldr	r1, [r7, #12]
 8005d78:	68f8      	ldr	r0, [r7, #12]
 8005d7a:	f003 fe0f 	bl	800999c <tcp_arg>
  tcp_accept(pcb, http_accept);
 8005d7e:	4904      	ldr	r1, [pc, #16]	; (8005d90 <httpd_init_addr+0x48>)
 8005d80:	68f8      	ldr	r0, [r7, #12]
 8005d82:	f003 fe46 	bl	8009a12 <tcp_accept>
}
 8005d86:	bf00      	nop
 8005d88:	3710      	adds	r7, #16
 8005d8a:	46bd      	mov	sp, r7
 8005d8c:	bd80      	pop	{r7, pc}
 8005d8e:	bf00      	nop
 8005d90:	08005cd9 	.word	0x08005cd9

08005d94 <httpd_init>:

/**
 * Initialize the httpd: set up a listening PCB and bind it to the defined port
 */
void httpd_init(void)
{
 8005d94:	b580      	push	{r7, lr}
 8005d96:	af00      	add	r7, sp, #0
  LWIP_DEBUGF(HTTPD_DEBUG, ("httpd_init\n"));

#if LWIP_HTTPD_SSI
  httpd_ssi_init();
 8005d98:	f000 f9be 	bl	8006118 <httpd_ssi_init>
#endif
  
#if LWIP_HTTPD_CGI
  httpd_cgi_init();
 8005d9c:	f000 f9ca 	bl	8006134 <httpd_cgi_init>
#endif
  
  httpd_init_addr(IP_ADDR_ANY);
 8005da0:	4802      	ldr	r0, [pc, #8]	; (8005dac <httpd_init+0x18>)
 8005da2:	f7ff ffd1 	bl	8005d48 <httpd_init_addr>
}
 8005da6:	bf00      	nop
 8005da8:	bd80      	pop	{r7, pc}
 8005daa:	bf00      	nop
 8005dac:	0801b568 	.word	0x0801b568

08005db0 <http_set_ssi_handler>:
 * @param ssi_handler the SSI handler function
 * @param tags an array of SSI tag strings to search for in SSI-enabled files
 * @param num_tags number of tags in the 'tags' array
 */
void http_set_ssi_handler(tSSIHandler ssi_handler, const char **tags, int num_tags)
{
 8005db0:	b480      	push	{r7}
 8005db2:	b085      	sub	sp, #20
 8005db4:	af00      	add	r7, sp, #0
 8005db6:	60f8      	str	r0, [r7, #12]
 8005db8:	60b9      	str	r1, [r7, #8]
 8005dba:	607a      	str	r2, [r7, #4]

  LWIP_ASSERT("no ssi_handler given", ssi_handler != NULL);
  LWIP_ASSERT("no tags given", tags != NULL);
  LWIP_ASSERT("invalid number of tags", num_tags > 0);

  g_pfnSSIHandler = ssi_handler;
 8005dbc:	4a07      	ldr	r2, [pc, #28]	; (8005ddc <http_set_ssi_handler+0x2c>)
 8005dbe:	68fb      	ldr	r3, [r7, #12]
 8005dc0:	6013      	str	r3, [r2, #0]
  g_ppcTags = tags;
 8005dc2:	4a07      	ldr	r2, [pc, #28]	; (8005de0 <http_set_ssi_handler+0x30>)
 8005dc4:	68bb      	ldr	r3, [r7, #8]
 8005dc6:	6013      	str	r3, [r2, #0]
  g_iNumTags = num_tags;
 8005dc8:	4a06      	ldr	r2, [pc, #24]	; (8005de4 <http_set_ssi_handler+0x34>)
 8005dca:	687b      	ldr	r3, [r7, #4]
 8005dcc:	6013      	str	r3, [r2, #0]
}
 8005dce:	bf00      	nop
 8005dd0:	3714      	adds	r7, #20
 8005dd2:	46bd      	mov	sp, r7
 8005dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dd8:	4770      	bx	lr
 8005dda:	bf00      	nop
 8005ddc:	200029d4 	.word	0x200029d4
 8005de0:	200029dc 	.word	0x200029dc
 8005de4:	200029d8 	.word	0x200029d8

08005de8 <http_set_cgi_handlers>:
 *
 * @param cgis an array of CGI filenames/handler functions
 * @param num_handlers number of elements in the 'cgis' array
 */
void http_set_cgi_handlers(const tCGI *cgis, int num_handlers)
{
 8005de8:	b480      	push	{r7}
 8005dea:	b083      	sub	sp, #12
 8005dec:	af00      	add	r7, sp, #0
 8005dee:	6078      	str	r0, [r7, #4]
 8005df0:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("no cgis given", cgis != NULL);
  LWIP_ASSERT("invalid number of handlers", num_handlers > 0);
  
  g_pCGIs = cgis;
 8005df2:	4a06      	ldr	r2, [pc, #24]	; (8005e0c <http_set_cgi_handlers+0x24>)
 8005df4:	687b      	ldr	r3, [r7, #4]
 8005df6:	6013      	str	r3, [r2, #0]
  g_iNumCGIs = num_handlers;
 8005df8:	4a05      	ldr	r2, [pc, #20]	; (8005e10 <http_set_cgi_handlers+0x28>)
 8005dfa:	683b      	ldr	r3, [r7, #0]
 8005dfc:	6013      	str	r3, [r2, #0]
}
 8005dfe:	bf00      	nop
 8005e00:	370c      	adds	r7, #12
 8005e02:	46bd      	mov	sp, r7
 8005e04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e08:	4770      	bx	lr
 8005e0a:	bf00      	nop
 8005e0c:	200029e0 	.word	0x200029e0
 8005e10:	200029e4 	.word	0x200029e4

08005e14 <ADC_Configuration>:
  * @brief  Configures the ADC.
  * @param  None
  * @retval None
  */
static void ADC_Configuration(void)
{
 8005e14:	b580      	push	{r7, lr}
 8005e16:	b08c      	sub	sp, #48	; 0x30
 8005e18:	af00      	add	r7, sp, #0
  ADC_InitTypeDef ADC_InitStructure;
  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable ADC3 clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
 8005e1a:	2101      	movs	r1, #1
 8005e1c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8005e20:	f7fe fd98 	bl	8004954 <RCC_APB2PeriphClockCmd>

  /* Configure ADC Channel 12 as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8005e24:	2304      	movs	r3, #4
 8005e26:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 8005e28:	2303      	movs	r3, #3
 8005e2a:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8005e2c:	2300      	movs	r3, #0
 8005e2e:	71fb      	strb	r3, [r7, #7]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005e30:	463b      	mov	r3, r7
 8005e32:	4619      	mov	r1, r3
 8005e34:	481c      	ldr	r0, [pc, #112]	; (8005ea8 <ADC_Configuration+0x94>)
 8005e36:	f7fe fbd3 	bl	80045e0 <GPIO_Init>

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 8005e3a:	2300      	movs	r3, #0
 8005e3c:	60bb      	str	r3, [r7, #8]
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div6;
 8005e3e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8005e42:	60fb      	str	r3, [r7, #12]
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8005e44:	2300      	movs	r3, #0
 8005e46:	613b      	str	r3, [r7, #16]
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles; 
 8005e48:	2300      	movs	r3, #0
 8005e4a:	617b      	str	r3, [r7, #20]
  ADC_CommonInit(&ADC_CommonInitStructure); 
 8005e4c:	f107 0308 	add.w	r3, r7, #8
 8005e50:	4618      	mov	r0, r3
 8005e52:	f7fe f9f3 	bl	800423c <ADC_CommonInit>

  /* ADC3 Configuration ------------------------------------------------------*/
  ADC_StructInit(&ADC_InitStructure);
 8005e56:	f107 0318 	add.w	r3, r7, #24
 8005e5a:	4618      	mov	r0, r3
 8005e5c:	f7fe f9ce 	bl	80041fc <ADC_StructInit>
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 8005e60:	2300      	movs	r3, #0
 8005e62:	61bb      	str	r3, [r7, #24]
  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
 8005e64:	2300      	movs	r3, #0
 8005e66:	773b      	strb	r3, [r7, #28]
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
 8005e68:	2301      	movs	r3, #1
 8005e6a:	777b      	strb	r3, [r7, #29]
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None; 
 8005e6c:	2300      	movs	r3, #0
 8005e6e:	623b      	str	r3, [r7, #32]
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8005e70:	2300      	movs	r3, #0
 8005e72:	62bb      	str	r3, [r7, #40]	; 0x28
  ADC_InitStructure.ADC_NbrOfConversion = 1;
 8005e74:	2301      	movs	r3, #1
 8005e76:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
  ADC_Init(ADC3, &ADC_InitStructure);
 8005e7a:	f107 0318 	add.w	r3, r7, #24
 8005e7e:	4619      	mov	r1, r3
 8005e80:	480a      	ldr	r0, [pc, #40]	; (8005eac <ADC_Configuration+0x98>)
 8005e82:	f7fe f965 	bl	8004150 <ADC_Init>

  /* ADC3 Regular Channel Config */
  ADC_RegularChannelConfig(ADC3, ADC_Channel_12, 1, ADC_SampleTime_56Cycles);
 8005e86:	2303      	movs	r3, #3
 8005e88:	2201      	movs	r2, #1
 8005e8a:	210c      	movs	r1, #12
 8005e8c:	4807      	ldr	r0, [pc, #28]	; (8005eac <ADC_Configuration+0x98>)
 8005e8e:	f7fe fa19 	bl	80042c4 <ADC_RegularChannelConfig>

  /* Enable ADC3 */
  ADC_Cmd(ADC3, ENABLE);
 8005e92:	2101      	movs	r1, #1
 8005e94:	4805      	ldr	r0, [pc, #20]	; (8005eac <ADC_Configuration+0x98>)
 8005e96:	f7fe f9f9 	bl	800428c <ADC_Cmd>

  /* ADC3 regular Software Start Conv */ 
  ADC_SoftwareStartConv(ADC3);
 8005e9a:	4804      	ldr	r0, [pc, #16]	; (8005eac <ADC_Configuration+0x98>)
 8005e9c:	f7fe fadc 	bl	8004458 <ADC_SoftwareStartConv>
}
 8005ea0:	bf00      	nop
 8005ea2:	3730      	adds	r7, #48	; 0x30
 8005ea4:	46bd      	mov	sp, r7
 8005ea6:	bd80      	pop	{r7, pc}
 8005ea8:	40020800 	.word	0x40020800
 8005eac:	40012200 	.word	0x40012200

08005eb0 <ADC_Handler>:

/**
  * @brief  ADC_Handler : SSI handler for ADC page 
  */
u16_t ADC_Handler(int iIndex, char *pcInsert, int iInsertLen)
{
 8005eb0:	b590      	push	{r4, r7, lr}
 8005eb2:	b087      	sub	sp, #28
 8005eb4:	af00      	add	r7, sp, #0
 8005eb6:	60f8      	str	r0, [r7, #12]
 8005eb8:	60b9      	str	r1, [r7, #8]
 8005eba:	607a      	str	r2, [r7, #4]
  /* We have only one SSI handler iIndex = 0 */
  if (iIndex ==0)
 8005ebc:	68fb      	ldr	r3, [r7, #12]
 8005ebe:	2b00      	cmp	r3, #0
 8005ec0:	f040 8085 	bne.w	8005fce <ADC_Handler+0x11e>
  {  
    char Digit1=0, Digit2=0, Digit3=0, Digit4=0; 
 8005ec4:	2300      	movs	r3, #0
 8005ec6:	75fb      	strb	r3, [r7, #23]
 8005ec8:	2300      	movs	r3, #0
 8005eca:	75bb      	strb	r3, [r7, #22]
 8005ecc:	2300      	movs	r3, #0
 8005ece:	757b      	strb	r3, [r7, #21]
 8005ed0:	2300      	movs	r3, #0
 8005ed2:	753b      	strb	r3, [r7, #20]
    uint32_t ADCVal = 0;        
 8005ed4:	2300      	movs	r3, #0
 8005ed6:	613b      	str	r3, [r7, #16]

     /* configure ADC if not yet configured */
     if (ADC_not_configured ==1)       
 8005ed8:	4b4b      	ldr	r3, [pc, #300]	; (8006008 <ADC_Handler+0x158>)
 8005eda:	681b      	ldr	r3, [r3, #0]
 8005edc:	2b01      	cmp	r3, #1
 8005ede:	d104      	bne.n	8005eea <ADC_Handler+0x3a>
     {
        ADC_Configuration();
 8005ee0:	f7ff ff98 	bl	8005e14 <ADC_Configuration>
        ADC_not_configured=0;
 8005ee4:	4b48      	ldr	r3, [pc, #288]	; (8006008 <ADC_Handler+0x158>)
 8005ee6:	2200      	movs	r2, #0
 8005ee8:	601a      	str	r2, [r3, #0]
     }
     
     /* get ADC conversion value */
     ADCVal = ADC_GetConversionValue(ADC3);
 8005eea:	4848      	ldr	r0, [pc, #288]	; (800600c <ADC_Handler+0x15c>)
 8005eec:	f7fe fac4 	bl	8004478 <ADC_GetConversionValue>
 8005ef0:	4603      	mov	r3, r0
 8005ef2:	613b      	str	r3, [r7, #16]
     
     /* convert to Voltage,  step = 0.8 mV */
     ADCVal = (uint32_t)(ADCVal * 0.8);  
 8005ef4:	6938      	ldr	r0, [r7, #16]
 8005ef6:	f7fa fabf 	bl	8000478 <__aeabi_ui2d>
 8005efa:	a341      	add	r3, pc, #260	; (adr r3, 8006000 <ADC_Handler+0x150>)
 8005efc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005f00:	f7fa fb30 	bl	8000564 <__aeabi_dmul>
 8005f04:	4603      	mov	r3, r0
 8005f06:	460c      	mov	r4, r1
 8005f08:	4618      	mov	r0, r3
 8005f0a:	4621      	mov	r1, r4
 8005f0c:	f7fa fd3c 	bl	8000988 <__aeabi_d2uiz>
 8005f10:	4603      	mov	r3, r0
 8005f12:	613b      	str	r3, [r7, #16]
     
     /* get digits to display */
     
     Digit1= ADCVal/1000;
 8005f14:	693b      	ldr	r3, [r7, #16]
 8005f16:	4a3e      	ldr	r2, [pc, #248]	; (8006010 <ADC_Handler+0x160>)
 8005f18:	fba2 2303 	umull	r2, r3, r2, r3
 8005f1c:	099b      	lsrs	r3, r3, #6
 8005f1e:	75fb      	strb	r3, [r7, #23]
     Digit2= (ADCVal-(Digit1*1000))/100 ;
 8005f20:	7dfb      	ldrb	r3, [r7, #23]
 8005f22:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8005f26:	fb02 f303 	mul.w	r3, r2, r3
 8005f2a:	461a      	mov	r2, r3
 8005f2c:	693b      	ldr	r3, [r7, #16]
 8005f2e:	1a9b      	subs	r3, r3, r2
 8005f30:	4a38      	ldr	r2, [pc, #224]	; (8006014 <ADC_Handler+0x164>)
 8005f32:	fba2 2303 	umull	r2, r3, r2, r3
 8005f36:	095b      	lsrs	r3, r3, #5
 8005f38:	75bb      	strb	r3, [r7, #22]
     Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
 8005f3a:	7dfb      	ldrb	r3, [r7, #23]
 8005f3c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8005f40:	fb02 f203 	mul.w	r2, r2, r3
 8005f44:	7dbb      	ldrb	r3, [r7, #22]
 8005f46:	2164      	movs	r1, #100	; 0x64
 8005f48:	fb01 f303 	mul.w	r3, r1, r3
 8005f4c:	4413      	add	r3, r2
 8005f4e:	461a      	mov	r2, r3
 8005f50:	693b      	ldr	r3, [r7, #16]
 8005f52:	1a9b      	subs	r3, r3, r2
 8005f54:	4a30      	ldr	r2, [pc, #192]	; (8006018 <ADC_Handler+0x168>)
 8005f56:	fba2 2303 	umull	r2, r3, r2, r3
 8005f5a:	08db      	lsrs	r3, r3, #3
 8005f5c:	757b      	strb	r3, [r7, #21]
     Digit4= ADCVal -((Digit1*1000)+(Digit2*100)+ (Digit3*10));
 8005f5e:	693b      	ldr	r3, [r7, #16]
 8005f60:	b2da      	uxtb	r2, r3
 8005f62:	7dfb      	ldrb	r3, [r7, #23]
 8005f64:	4619      	mov	r1, r3
 8005f66:	009b      	lsls	r3, r3, #2
 8005f68:	1acb      	subs	r3, r1, r3
 8005f6a:	00db      	lsls	r3, r3, #3
 8005f6c:	b2d9      	uxtb	r1, r3
 8005f6e:	7dbb      	ldrb	r3, [r7, #22]
 8005f70:	4618      	mov	r0, r3
 8005f72:	0080      	lsls	r0, r0, #2
 8005f74:	4403      	add	r3, r0
 8005f76:	4618      	mov	r0, r3
 8005f78:	0084      	lsls	r4, r0, #2
 8005f7a:	4618      	mov	r0, r3
 8005f7c:	4623      	mov	r3, r4
 8005f7e:	4403      	add	r3, r0
 8005f80:	009b      	lsls	r3, r3, #2
 8005f82:	b2db      	uxtb	r3, r3
 8005f84:	440b      	add	r3, r1
 8005f86:	b2d9      	uxtb	r1, r3
 8005f88:	7d7b      	ldrb	r3, [r7, #21]
 8005f8a:	4618      	mov	r0, r3
 8005f8c:	0080      	lsls	r0, r0, #2
 8005f8e:	4403      	add	r3, r0
 8005f90:	005b      	lsls	r3, r3, #1
 8005f92:	b2db      	uxtb	r3, r3
 8005f94:	440b      	add	r3, r1
 8005f96:	b2db      	uxtb	r3, r3
 8005f98:	1ad3      	subs	r3, r2, r3
 8005f9a:	753b      	strb	r3, [r7, #20]
        
     /* prepare data to be inserted in html */
     *pcInsert       = (char)(Digit1+0x30);
 8005f9c:	7dfb      	ldrb	r3, [r7, #23]
 8005f9e:	3330      	adds	r3, #48	; 0x30
 8005fa0:	b2da      	uxtb	r2, r3
 8005fa2:	68bb      	ldr	r3, [r7, #8]
 8005fa4:	701a      	strb	r2, [r3, #0]
     *(pcInsert + 1) = (char)(Digit2+0x30);
 8005fa6:	68bb      	ldr	r3, [r7, #8]
 8005fa8:	3301      	adds	r3, #1
 8005faa:	7dba      	ldrb	r2, [r7, #22]
 8005fac:	3230      	adds	r2, #48	; 0x30
 8005fae:	b2d2      	uxtb	r2, r2
 8005fb0:	701a      	strb	r2, [r3, #0]
     *(pcInsert + 2) = (char)(Digit3+0x30);
 8005fb2:	68bb      	ldr	r3, [r7, #8]
 8005fb4:	3302      	adds	r3, #2
 8005fb6:	7d7a      	ldrb	r2, [r7, #21]
 8005fb8:	3230      	adds	r2, #48	; 0x30
 8005fba:	b2d2      	uxtb	r2, r2
 8005fbc:	701a      	strb	r2, [r3, #0]
     *(pcInsert + 3) = (char)(Digit4+0x30);
 8005fbe:	68bb      	ldr	r3, [r7, #8]
 8005fc0:	3303      	adds	r3, #3
 8005fc2:	7d3a      	ldrb	r2, [r7, #20]
 8005fc4:	3230      	adds	r2, #48	; 0x30
 8005fc6:	b2d2      	uxtb	r2, r2
 8005fc8:	701a      	strb	r2, [r3, #0]
    
    /* 4 characters need to be inserted in html*/
    return 4;
 8005fca:	2304      	movs	r3, #4
 8005fcc:	e014      	b.n	8005ff8 <ADC_Handler+0x148>
  } else if (iIndex == 1) { // Test tag "u" value
 8005fce:	68fb      	ldr	r3, [r7, #12]
 8005fd0:	2b01      	cmp	r3, #1
 8005fd2:	d110      	bne.n	8005ff6 <ADC_Handler+0x146>
	    /* prepare data to be inserted in html */
	     *pcInsert       = (char)('1');
 8005fd4:	68bb      	ldr	r3, [r7, #8]
 8005fd6:	2231      	movs	r2, #49	; 0x31
 8005fd8:	701a      	strb	r2, [r3, #0]
	     *(pcInsert + 1) = (char)('2');
 8005fda:	68bb      	ldr	r3, [r7, #8]
 8005fdc:	3301      	adds	r3, #1
 8005fde:	2232      	movs	r2, #50	; 0x32
 8005fe0:	701a      	strb	r2, [r3, #0]
	     *(pcInsert + 2) = (char)('3');
 8005fe2:	68bb      	ldr	r3, [r7, #8]
 8005fe4:	3302      	adds	r3, #2
 8005fe6:	2233      	movs	r2, #51	; 0x33
 8005fe8:	701a      	strb	r2, [r3, #0]
	     *(pcInsert + 3) = (char)('4');
 8005fea:	68bb      	ldr	r3, [r7, #8]
 8005fec:	3303      	adds	r3, #3
 8005fee:	2234      	movs	r2, #52	; 0x34
 8005ff0:	701a      	strb	r2, [r3, #0]

	    /* 4 characters need to be inserted in html*/
	    return 4;
 8005ff2:	2304      	movs	r3, #4
 8005ff4:	e000      	b.n	8005ff8 <ADC_Handler+0x148>
  }
  return 0;
 8005ff6:	2300      	movs	r3, #0
}
 8005ff8:	4618      	mov	r0, r3
 8005ffa:	371c      	adds	r7, #28
 8005ffc:	46bd      	mov	sp, r7
 8005ffe:	bd90      	pop	{r4, r7, pc}
 8006000:	9999999a 	.word	0x9999999a
 8006004:	3fe99999 	.word	0x3fe99999
 8006008:	20000028 	.word	0x20000028
 800600c:	40012200 	.word	0x40012200
 8006010:	10624dd3 	.word	0x10624dd3
 8006014:	51eb851f 	.word	0x51eb851f
 8006018:	cccccccd 	.word	0xcccccccd

0800601c <LEDS_CGI_Handler>:

/**
  * @brief  CGI handler for LEDs control 
  */
const char * LEDS_CGI_Handler(int iIndex, int iNumParams, char *pcParam[], char *pcValue[])
{
 800601c:	b580      	push	{r7, lr}
 800601e:	b086      	sub	sp, #24
 8006020:	af00      	add	r7, sp, #0
 8006022:	60f8      	str	r0, [r7, #12]
 8006024:	60b9      	str	r1, [r7, #8]
 8006026:	607a      	str	r2, [r7, #4]
 8006028:	603b      	str	r3, [r7, #0]
  uint32_t i=0;
 800602a:	2300      	movs	r3, #0
 800602c:	617b      	str	r3, [r7, #20]
  
  /* We have only one SSI handler iIndex = 0 */
  if (iIndex==0)
 800602e:	68fb      	ldr	r3, [r7, #12]
 8006030:	2b00      	cmp	r3, #0
 8006032:	d160      	bne.n	80060f6 <LEDS_CGI_Handler+0xda>
  {
    /* All leds off */
    STM_EVAL_LEDOff(LED5);
 8006034:	2002      	movs	r0, #2
 8006036:	f007 ff51 	bl	800dedc <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED6);
 800603a:	2003      	movs	r0, #3
 800603c:	f007 ff4e 	bl	800dedc <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED3);
 8006040:	2001      	movs	r0, #1
 8006042:	f007 ff4b 	bl	800dedc <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED4);
 8006046:	2000      	movs	r0, #0
 8006048:	f007 ff48 	bl	800dedc <STM_EVAL_LEDOff>
    
    /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
    for (i=0; i<iNumParams; i++)
 800604c:	2300      	movs	r3, #0
 800604e:	617b      	str	r3, [r7, #20]
 8006050:	e04d      	b.n	80060ee <LEDS_CGI_Handler+0xd2>
    {
      /* check parameter "led" */
      if (strcmp(pcParam[i] , "led")==0)   
 8006052:	697b      	ldr	r3, [r7, #20]
 8006054:	009b      	lsls	r3, r3, #2
 8006056:	687a      	ldr	r2, [r7, #4]
 8006058:	4413      	add	r3, r2
 800605a:	681b      	ldr	r3, [r3, #0]
 800605c:	4928      	ldr	r1, [pc, #160]	; (8006100 <LEDS_CGI_Handler+0xe4>)
 800605e:	4618      	mov	r0, r3
 8006060:	f7fa f8b6 	bl	80001d0 <strcmp>
 8006064:	4603      	mov	r3, r0
 8006066:	2b00      	cmp	r3, #0
 8006068:	d13e      	bne.n	80060e8 <LEDS_CGI_Handler+0xcc>
      {
        /* switch led1 ON if 1 */
        if(strcmp(pcValue[i], "1") ==0) 
 800606a:	697b      	ldr	r3, [r7, #20]
 800606c:	009b      	lsls	r3, r3, #2
 800606e:	683a      	ldr	r2, [r7, #0]
 8006070:	4413      	add	r3, r2
 8006072:	681b      	ldr	r3, [r3, #0]
 8006074:	4923      	ldr	r1, [pc, #140]	; (8006104 <LEDS_CGI_Handler+0xe8>)
 8006076:	4618      	mov	r0, r3
 8006078:	f7fa f8aa 	bl	80001d0 <strcmp>
 800607c:	4603      	mov	r3, r0
 800607e:	2b00      	cmp	r3, #0
 8006080:	d103      	bne.n	800608a <LEDS_CGI_Handler+0x6e>
          STM_EVAL_LEDOn(LED3);
 8006082:	2001      	movs	r0, #1
 8006084:	f007 ff12 	bl	800deac <STM_EVAL_LEDOn>
 8006088:	e02e      	b.n	80060e8 <LEDS_CGI_Handler+0xcc>
          
        /* switch led2 ON if 2 */
        else if(strcmp(pcValue[i], "2") ==0) 
 800608a:	697b      	ldr	r3, [r7, #20]
 800608c:	009b      	lsls	r3, r3, #2
 800608e:	683a      	ldr	r2, [r7, #0]
 8006090:	4413      	add	r3, r2
 8006092:	681b      	ldr	r3, [r3, #0]
 8006094:	491c      	ldr	r1, [pc, #112]	; (8006108 <LEDS_CGI_Handler+0xec>)
 8006096:	4618      	mov	r0, r3
 8006098:	f7fa f89a 	bl	80001d0 <strcmp>
 800609c:	4603      	mov	r3, r0
 800609e:	2b00      	cmp	r3, #0
 80060a0:	d103      	bne.n	80060aa <LEDS_CGI_Handler+0x8e>
          STM_EVAL_LEDOn(LED5);
 80060a2:	2002      	movs	r0, #2
 80060a4:	f007 ff02 	bl	800deac <STM_EVAL_LEDOn>
 80060a8:	e01e      	b.n	80060e8 <LEDS_CGI_Handler+0xcc>
        
        /* switch led3 ON if 3 */
        else if(strcmp(pcValue[i], "3") ==0) 
 80060aa:	697b      	ldr	r3, [r7, #20]
 80060ac:	009b      	lsls	r3, r3, #2
 80060ae:	683a      	ldr	r2, [r7, #0]
 80060b0:	4413      	add	r3, r2
 80060b2:	681b      	ldr	r3, [r3, #0]
 80060b4:	4915      	ldr	r1, [pc, #84]	; (800610c <LEDS_CGI_Handler+0xf0>)
 80060b6:	4618      	mov	r0, r3
 80060b8:	f7fa f88a 	bl	80001d0 <strcmp>
 80060bc:	4603      	mov	r3, r0
 80060be:	2b00      	cmp	r3, #0
 80060c0:	d103      	bne.n	80060ca <LEDS_CGI_Handler+0xae>
          STM_EVAL_LEDOn(LED6);
 80060c2:	2003      	movs	r0, #3
 80060c4:	f007 fef2 	bl	800deac <STM_EVAL_LEDOn>
 80060c8:	e00e      	b.n	80060e8 <LEDS_CGI_Handler+0xcc>
        
        /* switch led4 ON if 4 */
        else if(strcmp(pcValue[i], "4") ==0) 
 80060ca:	697b      	ldr	r3, [r7, #20]
 80060cc:	009b      	lsls	r3, r3, #2
 80060ce:	683a      	ldr	r2, [r7, #0]
 80060d0:	4413      	add	r3, r2
 80060d2:	681b      	ldr	r3, [r3, #0]
 80060d4:	490e      	ldr	r1, [pc, #56]	; (8006110 <LEDS_CGI_Handler+0xf4>)
 80060d6:	4618      	mov	r0, r3
 80060d8:	f7fa f87a 	bl	80001d0 <strcmp>
 80060dc:	4603      	mov	r3, r0
 80060de:	2b00      	cmp	r3, #0
 80060e0:	d102      	bne.n	80060e8 <LEDS_CGI_Handler+0xcc>
          STM_EVAL_LEDOn(LED4);
 80060e2:	2000      	movs	r0, #0
 80060e4:	f007 fee2 	bl	800deac <STM_EVAL_LEDOn>
    for (i=0; i<iNumParams; i++)
 80060e8:	697b      	ldr	r3, [r7, #20]
 80060ea:	3301      	adds	r3, #1
 80060ec:	617b      	str	r3, [r7, #20]
 80060ee:	68bb      	ldr	r3, [r7, #8]
 80060f0:	697a      	ldr	r2, [r7, #20]
 80060f2:	429a      	cmp	r2, r3
 80060f4:	d3ad      	bcc.n	8006052 <LEDS_CGI_Handler+0x36>
      }
    }
  }
  /* uri to send after cgi call*/
  return "/STM32F4x7LED.html";  
 80060f6:	4b07      	ldr	r3, [pc, #28]	; (8006114 <LEDS_CGI_Handler+0xf8>)
}
 80060f8:	4618      	mov	r0, r3
 80060fa:	3718      	adds	r7, #24
 80060fc:	46bd      	mov	sp, r7
 80060fe:	bd80      	pop	{r7, pc}
 8006100:	0800e81c 	.word	0x0800e81c
 8006104:	0800e820 	.word	0x0800e820
 8006108:	0800e824 	.word	0x0800e824
 800610c:	0800e828 	.word	0x0800e828
 8006110:	0800e82c 	.word	0x0800e82c
 8006114:	0800e830 	.word	0x0800e830

08006118 <httpd_ssi_init>:

/**
 * Initialize SSI handlers
 */
void httpd_ssi_init(void)
{  
 8006118:	b580      	push	{r7, lr}
 800611a:	af00      	add	r7, sp, #0
  /* configure SSI handlers (ADC page SSI) */
  http_set_ssi_handler(ADC_Handler, (char const **)TAGS, 2);
 800611c:	2202      	movs	r2, #2
 800611e:	4903      	ldr	r1, [pc, #12]	; (800612c <httpd_ssi_init+0x14>)
 8006120:	4803      	ldr	r0, [pc, #12]	; (8006130 <httpd_ssi_init+0x18>)
 8006122:	f7ff fe45 	bl	8005db0 <http_set_ssi_handler>
}
 8006126:	bf00      	nop
 8006128:	bd80      	pop	{r7, pc}
 800612a:	bf00      	nop
 800612c:	20000034 	.word	0x20000034
 8006130:	08005eb1 	.word	0x08005eb1

08006134 <httpd_cgi_init>:

/**
 * Initialize CGI handlers
 */
void httpd_cgi_init(void)
{ 
 8006134:	b580      	push	{r7, lr}
 8006136:	af00      	add	r7, sp, #0
  /* configure CGI handlers (LEDs control CGI) */
  CGI_TAB[0] = LEDS_CGI;
 8006138:	4b05      	ldr	r3, [pc, #20]	; (8006150 <httpd_cgi_init+0x1c>)
 800613a:	4a06      	ldr	r2, [pc, #24]	; (8006154 <httpd_cgi_init+0x20>)
 800613c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8006140:	e883 0003 	stmia.w	r3, {r0, r1}
  http_set_cgi_handlers(CGI_TAB, 1);
 8006144:	2101      	movs	r1, #1
 8006146:	4802      	ldr	r0, [pc, #8]	; (8006150 <httpd_cgi_init+0x1c>)
 8006148:	f7ff fe4e 	bl	8005de8 <http_set_cgi_handlers>
}
 800614c:	bf00      	nop
 800614e:	bd80      	pop	{r7, pc}
 8006150:	2000a30c 	.word	0x2000a30c
 8006154:	0801b560 	.word	0x0801b560

08006158 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
 8006158:	b580      	push	{r7, lr}
 800615a:	b082      	sub	sp, #8
 800615c:	af00      	add	r7, sp, #0
 800615e:	6078      	str	r0, [r7, #4]
 8006160:	6039      	str	r1, [r7, #0]
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8006162:	687b      	ldr	r3, [r7, #4]
 8006164:	2b00      	cmp	r3, #0
 8006166:	d013      	beq.n	8006190 <dhcp_arp_reply+0x38>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
 8006168:	687b      	ldr	r3, [r7, #4]
 800616a:	6a1b      	ldr	r3, [r3, #32]
 800616c:	2b00      	cmp	r3, #0
 800616e:	d010      	beq.n	8006192 <dhcp_arp_reply+0x3a>
 8006170:	687b      	ldr	r3, [r7, #4]
 8006172:	6a1b      	ldr	r3, [r3, #32]
 8006174:	7c9b      	ldrb	r3, [r3, #18]
 8006176:	2b08      	cmp	r3, #8
 8006178:	d10b      	bne.n	8006192 <dhcp_arp_reply+0x3a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
 800617a:	683b      	ldr	r3, [r7, #0]
 800617c:	681a      	ldr	r2, [r3, #0]
 800617e:	687b      	ldr	r3, [r7, #4]
 8006180:	6a1b      	ldr	r3, [r3, #32]
 8006182:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006184:	429a      	cmp	r2, r3
 8006186:	d104      	bne.n	8006192 <dhcp_arp_reply+0x3a>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
 8006188:	6878      	ldr	r0, [r7, #4]
 800618a:	f000 f805 	bl	8006198 <dhcp_decline>
 800618e:	e000      	b.n	8006192 <dhcp_arp_reply+0x3a>
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8006190:	bf00      	nop
    }
  }
}
 8006192:	3708      	adds	r7, #8
 8006194:	46bd      	mov	sp, r7
 8006196:	bd80      	pop	{r7, pc}

08006198 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
 8006198:	b580      	push	{r7, lr}
 800619a:	b086      	sub	sp, #24
 800619c:	af02      	add	r7, sp, #8
 800619e:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
 80061a0:	687b      	ldr	r3, [r7, #4]
 80061a2:	6a1b      	ldr	r3, [r3, #32]
 80061a4:	60fb      	str	r3, [r7, #12]
  err_t result = ERR_OK;
 80061a6:	2300      	movs	r3, #0
 80061a8:	72fb      	strb	r3, [r7, #11]
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
 80061aa:	210c      	movs	r1, #12
 80061ac:	68f8      	ldr	r0, [r7, #12]
 80061ae:	f000 f85b 	bl	8006268 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
 80061b2:	6878      	ldr	r0, [r7, #4]
 80061b4:	f000 f8f6 	bl	80063a4 <dhcp_create_request>
 80061b8:	4603      	mov	r3, r0
 80061ba:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
 80061bc:	f997 300b 	ldrsb.w	r3, [r7, #11]
 80061c0:	2b00      	cmp	r3, #0
 80061c2:	d131      	bne.n	8006228 <dhcp_decline+0x90>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
 80061c4:	2201      	movs	r2, #1
 80061c6:	2135      	movs	r1, #53	; 0x35
 80061c8:	68f8      	ldr	r0, [r7, #12]
 80061ca:	f000 f864 	bl	8006296 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
 80061ce:	2104      	movs	r1, #4
 80061d0:	68f8      	ldr	r0, [r7, #12]
 80061d2:	f000 f886 	bl	80062e2 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 80061d6:	2204      	movs	r2, #4
 80061d8:	2132      	movs	r1, #50	; 0x32
 80061da:	68f8      	ldr	r0, [r7, #12]
 80061dc:	f000 f85b 	bl	8006296 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
 80061e0:	68fb      	ldr	r3, [r7, #12]
 80061e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80061e4:	4618      	mov	r0, r3
 80061e6:	f000 fd7b 	bl	8006ce0 <ntohl>
 80061ea:	4603      	mov	r3, r0
 80061ec:	4619      	mov	r1, r3
 80061ee:	68f8      	ldr	r0, [r7, #12]
 80061f0:	f000 f88f 	bl	8006312 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
 80061f4:	68f8      	ldr	r0, [r7, #12]
 80061f6:	f000 f9ee 	bl	80065d6 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 80061fa:	68fb      	ldr	r3, [r7, #12]
 80061fc:	695a      	ldr	r2, [r3, #20]
 80061fe:	68fb      	ldr	r3, [r7, #12]
 8006200:	8b9b      	ldrh	r3, [r3, #28]
 8006202:	33f0      	adds	r3, #240	; 0xf0
 8006204:	b29b      	uxth	r3, r3
 8006206:	4619      	mov	r1, r3
 8006208:	4610      	mov	r0, r2
 800620a:	f002 f9fb 	bl	8008604 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 800620e:	68fb      	ldr	r3, [r7, #12]
 8006210:	6858      	ldr	r0, [r3, #4]
 8006212:	68fb      	ldr	r3, [r7, #12]
 8006214:	6959      	ldr	r1, [r3, #20]
 8006216:	687b      	ldr	r3, [r7, #4]
 8006218:	9300      	str	r3, [sp, #0]
 800621a:	2343      	movs	r3, #67	; 0x43
 800621c:	4a10      	ldr	r2, [pc, #64]	; (8006260 <dhcp_decline+0xc8>)
 800621e:	f006 fb10 	bl	800c842 <udp_sendto_if>
    dhcp_delete_request(netif);
 8006222:	6878      	ldr	r0, [r7, #4]
 8006224:	f000 f9b4 	bl	8006590 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 8006228:	68fb      	ldr	r3, [r7, #12]
 800622a:	7cdb      	ldrb	r3, [r3, #19]
 800622c:	3301      	adds	r3, #1
 800622e:	b2da      	uxtb	r2, r3
 8006230:	68fb      	ldr	r3, [r7, #12]
 8006232:	74da      	strb	r2, [r3, #19]
  msecs = 10*1000;
 8006234:	f242 7310 	movw	r3, #10000	; 0x2710
 8006238:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 800623a:	893b      	ldrh	r3, [r7, #8]
 800623c:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 8006240:	4a08      	ldr	r2, [pc, #32]	; (8006264 <dhcp_decline+0xcc>)
 8006242:	fb82 1203 	smull	r1, r2, r2, r3
 8006246:	1152      	asrs	r2, r2, #5
 8006248:	17db      	asrs	r3, r3, #31
 800624a:	1ad3      	subs	r3, r2, r3
 800624c:	b29a      	uxth	r2, r3
 800624e:	68fb      	ldr	r3, [r7, #12]
 8006250:	83da      	strh	r2, [r3, #30]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 8006252:	f997 300b 	ldrsb.w	r3, [r7, #11]
}
 8006256:	4618      	mov	r0, r3
 8006258:	3710      	adds	r7, #16
 800625a:	46bd      	mov	sp, r7
 800625c:	bd80      	pop	{r7, pc}
 800625e:	bf00      	nop
 8006260:	0801b56c 	.word	0x0801b56c
 8006264:	10624dd3 	.word	0x10624dd3

08006268 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
 8006268:	b480      	push	{r7}
 800626a:	b083      	sub	sp, #12
 800626c:	af00      	add	r7, sp, #0
 800626e:	6078      	str	r0, [r7, #4]
 8006270:	460b      	mov	r3, r1
 8006272:	70fb      	strb	r3, [r7, #3]
  if (new_state != dhcp->state) {
 8006274:	687b      	ldr	r3, [r7, #4]
 8006276:	7c9b      	ldrb	r3, [r3, #18]
 8006278:	78fa      	ldrb	r2, [r7, #3]
 800627a:	429a      	cmp	r2, r3
 800627c:	d005      	beq.n	800628a <dhcp_set_state+0x22>
    dhcp->state = new_state;
 800627e:	687b      	ldr	r3, [r7, #4]
 8006280:	78fa      	ldrb	r2, [r7, #3]
 8006282:	749a      	strb	r2, [r3, #18]
    dhcp->tries = 0;
 8006284:	687b      	ldr	r3, [r7, #4]
 8006286:	2200      	movs	r2, #0
 8006288:	74da      	strb	r2, [r3, #19]
  }
}
 800628a:	bf00      	nop
 800628c:	370c      	adds	r7, #12
 800628e:	46bd      	mov	sp, r7
 8006290:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006294:	4770      	bx	lr

08006296 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
 8006296:	b480      	push	{r7}
 8006298:	b083      	sub	sp, #12
 800629a:	af00      	add	r7, sp, #0
 800629c:	6078      	str	r0, [r7, #4]
 800629e:	460b      	mov	r3, r1
 80062a0:	70fb      	strb	r3, [r7, #3]
 80062a2:	4613      	mov	r3, r2
 80062a4:	70bb      	strb	r3, [r7, #2]
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 80062a6:	687b      	ldr	r3, [r7, #4]
 80062a8:	699a      	ldr	r2, [r3, #24]
 80062aa:	687b      	ldr	r3, [r7, #4]
 80062ac:	8b9b      	ldrh	r3, [r3, #28]
 80062ae:	1c59      	adds	r1, r3, #1
 80062b0:	b288      	uxth	r0, r1
 80062b2:	6879      	ldr	r1, [r7, #4]
 80062b4:	8388      	strh	r0, [r1, #28]
 80062b6:	4413      	add	r3, r2
 80062b8:	78fa      	ldrb	r2, [r7, #3]
 80062ba:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 80062be:	687b      	ldr	r3, [r7, #4]
 80062c0:	699a      	ldr	r2, [r3, #24]
 80062c2:	687b      	ldr	r3, [r7, #4]
 80062c4:	8b9b      	ldrh	r3, [r3, #28]
 80062c6:	1c59      	adds	r1, r3, #1
 80062c8:	b288      	uxth	r0, r1
 80062ca:	6879      	ldr	r1, [r7, #4]
 80062cc:	8388      	strh	r0, [r1, #28]
 80062ce:	4413      	add	r3, r2
 80062d0:	78ba      	ldrb	r2, [r7, #2]
 80062d2:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
 80062d6:	bf00      	nop
 80062d8:	370c      	adds	r7, #12
 80062da:	46bd      	mov	sp, r7
 80062dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062e0:	4770      	bx	lr

080062e2 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
 80062e2:	b480      	push	{r7}
 80062e4:	b083      	sub	sp, #12
 80062e6:	af00      	add	r7, sp, #0
 80062e8:	6078      	str	r0, [r7, #4]
 80062ea:	460b      	mov	r3, r1
 80062ec:	70fb      	strb	r3, [r7, #3]
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 80062ee:	687b      	ldr	r3, [r7, #4]
 80062f0:	699a      	ldr	r2, [r3, #24]
 80062f2:	687b      	ldr	r3, [r7, #4]
 80062f4:	8b9b      	ldrh	r3, [r3, #28]
 80062f6:	1c59      	adds	r1, r3, #1
 80062f8:	b288      	uxth	r0, r1
 80062fa:	6879      	ldr	r1, [r7, #4]
 80062fc:	8388      	strh	r0, [r1, #28]
 80062fe:	4413      	add	r3, r2
 8006300:	78fa      	ldrb	r2, [r7, #3]
 8006302:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
 8006306:	bf00      	nop
 8006308:	370c      	adds	r7, #12
 800630a:	46bd      	mov	sp, r7
 800630c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006310:	4770      	bx	lr

08006312 <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
 8006312:	b480      	push	{r7}
 8006314:	b083      	sub	sp, #12
 8006316:	af00      	add	r7, sp, #0
 8006318:	6078      	str	r0, [r7, #4]
 800631a:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 800631c:	687b      	ldr	r3, [r7, #4]
 800631e:	699a      	ldr	r2, [r3, #24]
 8006320:	687b      	ldr	r3, [r7, #4]
 8006322:	8b9b      	ldrh	r3, [r3, #28]
 8006324:	1c59      	adds	r1, r3, #1
 8006326:	b288      	uxth	r0, r1
 8006328:	6879      	ldr	r1, [r7, #4]
 800632a:	8388      	strh	r0, [r1, #28]
 800632c:	4618      	mov	r0, r3
 800632e:	683b      	ldr	r3, [r7, #0]
 8006330:	0e1b      	lsrs	r3, r3, #24
 8006332:	b2d9      	uxtb	r1, r3
 8006334:	1813      	adds	r3, r2, r0
 8006336:	460a      	mov	r2, r1
 8006338:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 800633c:	687b      	ldr	r3, [r7, #4]
 800633e:	699a      	ldr	r2, [r3, #24]
 8006340:	687b      	ldr	r3, [r7, #4]
 8006342:	8b9b      	ldrh	r3, [r3, #28]
 8006344:	1c59      	adds	r1, r3, #1
 8006346:	b288      	uxth	r0, r1
 8006348:	6879      	ldr	r1, [r7, #4]
 800634a:	8388      	strh	r0, [r1, #28]
 800634c:	4618      	mov	r0, r3
 800634e:	683b      	ldr	r3, [r7, #0]
 8006350:	0c1b      	lsrs	r3, r3, #16
 8006352:	b2d9      	uxtb	r1, r3
 8006354:	1813      	adds	r3, r2, r0
 8006356:	460a      	mov	r2, r1
 8006358:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 800635c:	687b      	ldr	r3, [r7, #4]
 800635e:	699a      	ldr	r2, [r3, #24]
 8006360:	687b      	ldr	r3, [r7, #4]
 8006362:	8b9b      	ldrh	r3, [r3, #28]
 8006364:	1c59      	adds	r1, r3, #1
 8006366:	b288      	uxth	r0, r1
 8006368:	6879      	ldr	r1, [r7, #4]
 800636a:	8388      	strh	r0, [r1, #28]
 800636c:	4618      	mov	r0, r3
 800636e:	683b      	ldr	r3, [r7, #0]
 8006370:	0a1b      	lsrs	r3, r3, #8
 8006372:	b2d9      	uxtb	r1, r3
 8006374:	1813      	adds	r3, r2, r0
 8006376:	460a      	mov	r2, r1
 8006378:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 800637c:	687b      	ldr	r3, [r7, #4]
 800637e:	699a      	ldr	r2, [r3, #24]
 8006380:	687b      	ldr	r3, [r7, #4]
 8006382:	8b9b      	ldrh	r3, [r3, #28]
 8006384:	1c59      	adds	r1, r3, #1
 8006386:	b288      	uxth	r0, r1
 8006388:	6879      	ldr	r1, [r7, #4]
 800638a:	8388      	strh	r0, [r1, #28]
 800638c:	6839      	ldr	r1, [r7, #0]
 800638e:	b2c9      	uxtb	r1, r1
 8006390:	4413      	add	r3, r2
 8006392:	460a      	mov	r2, r1
 8006394:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
 8006398:	bf00      	nop
 800639a:	370c      	adds	r7, #12
 800639c:	46bd      	mov	sp, r7
 800639e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063a2:	4770      	bx	lr

080063a4 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
 80063a4:	b590      	push	{r4, r7, lr}
 80063a6:	b085      	sub	sp, #20
 80063a8:	af00      	add	r7, sp, #0
 80063aa:	6078      	str	r0, [r7, #4]
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
 80063ac:	687b      	ldr	r3, [r7, #4]
 80063ae:	2b00      	cmp	r3, #0
 80063b0:	d102      	bne.n	80063b8 <dhcp_create_request+0x14>
 80063b2:	f06f 0309 	mvn.w	r3, #9
 80063b6:	e0e3      	b.n	8006580 <dhcp_create_request+0x1dc>
  dhcp = netif->dhcp;
 80063b8:	687b      	ldr	r3, [r7, #4]
 80063ba:	6a1b      	ldr	r3, [r3, #32]
 80063bc:	60bb      	str	r3, [r7, #8]
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
 80063be:	68bb      	ldr	r3, [r7, #8]
 80063c0:	2b00      	cmp	r3, #0
 80063c2:	d102      	bne.n	80063ca <dhcp_create_request+0x26>
 80063c4:	f06f 0308 	mvn.w	r3, #8
 80063c8:	e0da      	b.n	8006580 <dhcp_create_request+0x1dc>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 80063ca:	2200      	movs	r2, #0
 80063cc:	f44f 719a 	mov.w	r1, #308	; 0x134
 80063d0:	2000      	movs	r0, #0
 80063d2:	f002 f81d 	bl	8008410 <pbuf_alloc>
 80063d6:	4602      	mov	r2, r0
 80063d8:	68bb      	ldr	r3, [r7, #8]
 80063da:	615a      	str	r2, [r3, #20]
  if (dhcp->p_out == NULL) {
 80063dc:	68bb      	ldr	r3, [r7, #8]
 80063de:	695b      	ldr	r3, [r3, #20]
 80063e0:	2b00      	cmp	r3, #0
 80063e2:	d102      	bne.n	80063ea <dhcp_create_request+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
 80063e4:	f04f 33ff 	mov.w	r3, #4294967295
 80063e8:	e0ca      	b.n	8006580 <dhcp_create_request+0x1dc>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries==0)
 80063ea:	68bb      	ldr	r3, [r7, #8]
 80063ec:	7cdb      	ldrb	r3, [r3, #19]
 80063ee:	2b00      	cmp	r3, #0
 80063f0:	d104      	bne.n	80063fc <dhcp_create_request+0x58>
      xid++;
 80063f2:	4b65      	ldr	r3, [pc, #404]	; (8006588 <dhcp_create_request+0x1e4>)
 80063f4:	681b      	ldr	r3, [r3, #0]
 80063f6:	3301      	adds	r3, #1
 80063f8:	4a63      	ldr	r2, [pc, #396]	; (8006588 <dhcp_create_request+0x1e4>)
 80063fa:	6013      	str	r3, [r2, #0]
  dhcp->xid = xid;
 80063fc:	4b62      	ldr	r3, [pc, #392]	; (8006588 <dhcp_create_request+0x1e4>)
 80063fe:	681a      	ldr	r2, [r3, #0]
 8006400:	68bb      	ldr	r3, [r7, #8]
 8006402:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 8006404:	68bb      	ldr	r3, [r7, #8]
 8006406:	695b      	ldr	r3, [r3, #20]
 8006408:	685a      	ldr	r2, [r3, #4]
 800640a:	68bb      	ldr	r3, [r7, #8]
 800640c:	619a      	str	r2, [r3, #24]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 800640e:	68bb      	ldr	r3, [r7, #8]
 8006410:	699b      	ldr	r3, [r3, #24]
 8006412:	2201      	movs	r2, #1
 8006414:	701a      	strb	r2, [r3, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 8006416:	68bb      	ldr	r3, [r7, #8]
 8006418:	699b      	ldr	r3, [r3, #24]
 800641a:	2201      	movs	r2, #1
 800641c:	705a      	strb	r2, [r3, #1]
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
 800641e:	68bb      	ldr	r3, [r7, #8]
 8006420:	699b      	ldr	r3, [r3, #24]
 8006422:	2206      	movs	r2, #6
 8006424:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
 8006426:	68bb      	ldr	r3, [r7, #8]
 8006428:	699b      	ldr	r3, [r3, #24]
 800642a:	2200      	movs	r2, #0
 800642c:	70da      	strb	r2, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
 800642e:	68bb      	ldr	r3, [r7, #8]
 8006430:	699c      	ldr	r4, [r3, #24]
 8006432:	68bb      	ldr	r3, [r7, #8]
 8006434:	681b      	ldr	r3, [r3, #0]
 8006436:	4618      	mov	r0, r3
 8006438:	f000 fc39 	bl	8006cae <htonl>
 800643c:	4603      	mov	r3, r0
 800643e:	6063      	str	r3, [r4, #4]
  dhcp->msg_out->secs = 0;
 8006440:	68bb      	ldr	r3, [r7, #8]
 8006442:	699b      	ldr	r3, [r3, #24]
 8006444:	2200      	movs	r2, #0
 8006446:	721a      	strb	r2, [r3, #8]
 8006448:	2200      	movs	r2, #0
 800644a:	725a      	strb	r2, [r3, #9]
  dhcp->msg_out->flags = 0;
 800644c:	68bb      	ldr	r3, [r7, #8]
 800644e:	699b      	ldr	r3, [r3, #24]
 8006450:	2200      	movs	r2, #0
 8006452:	729a      	strb	r2, [r3, #10]
 8006454:	2200      	movs	r2, #0
 8006456:	72da      	strb	r2, [r3, #11]
  dhcp->msg_out->ciaddr.addr = 0;
 8006458:	68bb      	ldr	r3, [r7, #8]
 800645a:	699b      	ldr	r3, [r3, #24]
 800645c:	2200      	movs	r2, #0
 800645e:	731a      	strb	r2, [r3, #12]
 8006460:	2200      	movs	r2, #0
 8006462:	735a      	strb	r2, [r3, #13]
 8006464:	2200      	movs	r2, #0
 8006466:	739a      	strb	r2, [r3, #14]
 8006468:	2200      	movs	r2, #0
 800646a:	73da      	strb	r2, [r3, #15]
  if (dhcp->state==DHCP_BOUND || dhcp->state==DHCP_RENEWING || dhcp->state==DHCP_REBINDING) {
 800646c:	68bb      	ldr	r3, [r7, #8]
 800646e:	7c9b      	ldrb	r3, [r3, #18]
 8006470:	2b0a      	cmp	r3, #10
 8006472:	d007      	beq.n	8006484 <dhcp_create_request+0xe0>
 8006474:	68bb      	ldr	r3, [r7, #8]
 8006476:	7c9b      	ldrb	r3, [r3, #18]
 8006478:	2b05      	cmp	r3, #5
 800647a:	d003      	beq.n	8006484 <dhcp_create_request+0xe0>
 800647c:	68bb      	ldr	r3, [r7, #8]
 800647e:	7c9b      	ldrb	r3, [r3, #18]
 8006480:	2b04      	cmp	r3, #4
 8006482:	d104      	bne.n	800648e <dhcp_create_request+0xea>
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
 8006484:	68bb      	ldr	r3, [r7, #8]
 8006486:	699b      	ldr	r3, [r3, #24]
 8006488:	687a      	ldr	r2, [r7, #4]
 800648a:	6852      	ldr	r2, [r2, #4]
 800648c:	60da      	str	r2, [r3, #12]
  }
  dhcp->msg_out->yiaddr.addr = 0;
 800648e:	68bb      	ldr	r3, [r7, #8]
 8006490:	699b      	ldr	r3, [r3, #24]
 8006492:	2200      	movs	r2, #0
 8006494:	741a      	strb	r2, [r3, #16]
 8006496:	2200      	movs	r2, #0
 8006498:	745a      	strb	r2, [r3, #17]
 800649a:	2200      	movs	r2, #0
 800649c:	749a      	strb	r2, [r3, #18]
 800649e:	2200      	movs	r2, #0
 80064a0:	74da      	strb	r2, [r3, #19]
  dhcp->msg_out->siaddr.addr = 0;
 80064a2:	68bb      	ldr	r3, [r7, #8]
 80064a4:	699b      	ldr	r3, [r3, #24]
 80064a6:	2200      	movs	r2, #0
 80064a8:	751a      	strb	r2, [r3, #20]
 80064aa:	2200      	movs	r2, #0
 80064ac:	755a      	strb	r2, [r3, #21]
 80064ae:	2200      	movs	r2, #0
 80064b0:	759a      	strb	r2, [r3, #22]
 80064b2:	2200      	movs	r2, #0
 80064b4:	75da      	strb	r2, [r3, #23]
  dhcp->msg_out->giaddr.addr = 0;
 80064b6:	68bb      	ldr	r3, [r7, #8]
 80064b8:	699b      	ldr	r3, [r3, #24]
 80064ba:	2200      	movs	r2, #0
 80064bc:	761a      	strb	r2, [r3, #24]
 80064be:	2200      	movs	r2, #0
 80064c0:	765a      	strb	r2, [r3, #25]
 80064c2:	2200      	movs	r2, #0
 80064c4:	769a      	strb	r2, [r3, #26]
 80064c6:	2200      	movs	r2, #0
 80064c8:	76da      	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
 80064ca:	2300      	movs	r3, #0
 80064cc:	81fb      	strh	r3, [r7, #14]
 80064ce:	e016      	b.n	80064fe <dhcp_create_request+0x15a>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 80064d0:	68bb      	ldr	r3, [r7, #8]
 80064d2:	699a      	ldr	r2, [r3, #24]
 80064d4:	89fb      	ldrh	r3, [r7, #14]
 80064d6:	6879      	ldr	r1, [r7, #4]
 80064d8:	f891 102a 	ldrb.w	r1, [r1, #42]	; 0x2a
 80064dc:	b289      	uxth	r1, r1
 80064de:	89f8      	ldrh	r0, [r7, #14]
 80064e0:	4288      	cmp	r0, r1
 80064e2:	d205      	bcs.n	80064f0 <dhcp_create_request+0x14c>
 80064e4:	89f9      	ldrh	r1, [r7, #14]
 80064e6:	6878      	ldr	r0, [r7, #4]
 80064e8:	4401      	add	r1, r0
 80064ea:	f891 102b 	ldrb.w	r1, [r1, #43]	; 0x2b
 80064ee:	e000      	b.n	80064f2 <dhcp_create_request+0x14e>
 80064f0:	2100      	movs	r1, #0
 80064f2:	4413      	add	r3, r2
 80064f4:	460a      	mov	r2, r1
 80064f6:	771a      	strb	r2, [r3, #28]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
 80064f8:	89fb      	ldrh	r3, [r7, #14]
 80064fa:	3301      	adds	r3, #1
 80064fc:	81fb      	strh	r3, [r7, #14]
 80064fe:	89fb      	ldrh	r3, [r7, #14]
 8006500:	2b0f      	cmp	r3, #15
 8006502:	d9e5      	bls.n	80064d0 <dhcp_create_request+0x12c>
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8006504:	2300      	movs	r3, #0
 8006506:	81fb      	strh	r3, [r7, #14]
 8006508:	e009      	b.n	800651e <dhcp_create_request+0x17a>
    dhcp->msg_out->sname[i] = 0;
 800650a:	68bb      	ldr	r3, [r7, #8]
 800650c:	699a      	ldr	r2, [r3, #24]
 800650e:	89fb      	ldrh	r3, [r7, #14]
 8006510:	4413      	add	r3, r2
 8006512:	2200      	movs	r2, #0
 8006514:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 8006518:	89fb      	ldrh	r3, [r7, #14]
 800651a:	3301      	adds	r3, #1
 800651c:	81fb      	strh	r3, [r7, #14]
 800651e:	89fb      	ldrh	r3, [r7, #14]
 8006520:	2b3f      	cmp	r3, #63	; 0x3f
 8006522:	d9f2      	bls.n	800650a <dhcp_create_request+0x166>
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8006524:	2300      	movs	r3, #0
 8006526:	81fb      	strh	r3, [r7, #14]
 8006528:	e009      	b.n	800653e <dhcp_create_request+0x19a>
    dhcp->msg_out->file[i] = 0;
 800652a:	68bb      	ldr	r3, [r7, #8]
 800652c:	699a      	ldr	r2, [r3, #24]
 800652e:	89fb      	ldrh	r3, [r7, #14]
 8006530:	4413      	add	r3, r2
 8006532:	2200      	movs	r2, #0
 8006534:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 8006538:	89fb      	ldrh	r3, [r7, #14]
 800653a:	3301      	adds	r3, #1
 800653c:	81fb      	strh	r3, [r7, #14]
 800653e:	89fb      	ldrh	r3, [r7, #14]
 8006540:	2b7f      	cmp	r3, #127	; 0x7f
 8006542:	d9f2      	bls.n	800652a <dhcp_create_request+0x186>
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
 8006544:	68bb      	ldr	r3, [r7, #8]
 8006546:	699c      	ldr	r4, [r3, #24]
 8006548:	4810      	ldr	r0, [pc, #64]	; (800658c <dhcp_create_request+0x1e8>)
 800654a:	f000 fbb0 	bl	8006cae <htonl>
 800654e:	4603      	mov	r3, r0
 8006550:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
  dhcp->options_out_len = 0;
 8006554:	68bb      	ldr	r3, [r7, #8]
 8006556:	2200      	movs	r2, #0
 8006558:	839a      	strh	r2, [r3, #28]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 800655a:	2300      	movs	r3, #0
 800655c:	81fb      	strh	r3, [r7, #14]
 800655e:	e00b      	b.n	8006578 <dhcp_create_request+0x1d4>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 8006560:	68bb      	ldr	r3, [r7, #8]
 8006562:	699a      	ldr	r2, [r3, #24]
 8006564:	89fb      	ldrh	r3, [r7, #14]
 8006566:	89f9      	ldrh	r1, [r7, #14]
 8006568:	b2c9      	uxtb	r1, r1
 800656a:	4413      	add	r3, r2
 800656c:	460a      	mov	r2, r1
 800656e:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 8006572:	89fb      	ldrh	r3, [r7, #14]
 8006574:	3301      	adds	r3, #1
 8006576:	81fb      	strh	r3, [r7, #14]
 8006578:	89fb      	ldrh	r3, [r7, #14]
 800657a:	2b43      	cmp	r3, #67	; 0x43
 800657c:	d9f0      	bls.n	8006560 <dhcp_create_request+0x1bc>
  }
  return ERR_OK;
 800657e:	2300      	movs	r3, #0
}
 8006580:	4618      	mov	r0, r3
 8006582:	3714      	adds	r7, #20
 8006584:	46bd      	mov	sp, r7
 8006586:	bd90      	pop	{r4, r7, pc}
 8006588:	2000003c 	.word	0x2000003c
 800658c:	63825363 	.word	0x63825363

08006590 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
 8006590:	b580      	push	{r7, lr}
 8006592:	b084      	sub	sp, #16
 8006594:	af00      	add	r7, sp, #0
 8006596:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
 8006598:	687b      	ldr	r3, [r7, #4]
 800659a:	2b00      	cmp	r3, #0
 800659c:	d015      	beq.n	80065ca <dhcp_delete_request+0x3a>
  dhcp = netif->dhcp;
 800659e:	687b      	ldr	r3, [r7, #4]
 80065a0:	6a1b      	ldr	r3, [r3, #32]
 80065a2:	60fb      	str	r3, [r7, #12]
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
 80065a4:	68fb      	ldr	r3, [r7, #12]
 80065a6:	2b00      	cmp	r3, #0
 80065a8:	d011      	beq.n	80065ce <dhcp_delete_request+0x3e>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 80065aa:	68fb      	ldr	r3, [r7, #12]
 80065ac:	695b      	ldr	r3, [r3, #20]
 80065ae:	2b00      	cmp	r3, #0
 80065b0:	d004      	beq.n	80065bc <dhcp_delete_request+0x2c>
    pbuf_free(dhcp->p_out);
 80065b2:	68fb      	ldr	r3, [r7, #12]
 80065b4:	695b      	ldr	r3, [r3, #20]
 80065b6:	4618      	mov	r0, r3
 80065b8:	f002 f8f7 	bl	80087aa <pbuf_free>
  }
  dhcp->p_out = NULL;
 80065bc:	68fb      	ldr	r3, [r7, #12]
 80065be:	2200      	movs	r2, #0
 80065c0:	615a      	str	r2, [r3, #20]
  dhcp->msg_out = NULL;
 80065c2:	68fb      	ldr	r3, [r7, #12]
 80065c4:	2200      	movs	r2, #0
 80065c6:	619a      	str	r2, [r3, #24]
 80065c8:	e002      	b.n	80065d0 <dhcp_delete_request+0x40>
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
 80065ca:	bf00      	nop
 80065cc:	e000      	b.n	80065d0 <dhcp_delete_request+0x40>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
 80065ce:	bf00      	nop
}
 80065d0:	3710      	adds	r7, #16
 80065d2:	46bd      	mov	sp, r7
 80065d4:	bd80      	pop	{r7, pc}

080065d6 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
 80065d6:	b480      	push	{r7}
 80065d8:	b083      	sub	sp, #12
 80065da:	af00      	add	r7, sp, #0
 80065dc:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
 80065de:	687b      	ldr	r3, [r7, #4]
 80065e0:	2b00      	cmp	r3, #0
 80065e2:	d023      	beq.n	800662c <dhcp_option_trailer+0x56>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 80065e4:	687b      	ldr	r3, [r7, #4]
 80065e6:	699a      	ldr	r2, [r3, #24]
 80065e8:	687b      	ldr	r3, [r7, #4]
 80065ea:	8b9b      	ldrh	r3, [r3, #28]
 80065ec:	1c59      	adds	r1, r3, #1
 80065ee:	b288      	uxth	r0, r1
 80065f0:	6879      	ldr	r1, [r7, #4]
 80065f2:	8388      	strh	r0, [r1, #28]
 80065f4:	4413      	add	r3, r2
 80065f6:	22ff      	movs	r2, #255	; 0xff
 80065f8:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
 80065fc:	e00b      	b.n	8006616 <dhcp_option_trailer+0x40>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 80065fe:	687b      	ldr	r3, [r7, #4]
 8006600:	699a      	ldr	r2, [r3, #24]
 8006602:	687b      	ldr	r3, [r7, #4]
 8006604:	8b9b      	ldrh	r3, [r3, #28]
 8006606:	1c59      	adds	r1, r3, #1
 8006608:	b288      	uxth	r0, r1
 800660a:	6879      	ldr	r1, [r7, #4]
 800660c:	8388      	strh	r0, [r1, #28]
 800660e:	4413      	add	r3, r2
 8006610:	2200      	movs	r2, #0
 8006612:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
 8006616:	687b      	ldr	r3, [r7, #4]
 8006618:	8b9b      	ldrh	r3, [r3, #28]
 800661a:	2b43      	cmp	r3, #67	; 0x43
 800661c:	d9ef      	bls.n	80065fe <dhcp_option_trailer+0x28>
 800661e:	687b      	ldr	r3, [r7, #4]
 8006620:	8b9b      	ldrh	r3, [r3, #28]
 8006622:	f003 0303 	and.w	r3, r3, #3
 8006626:	2b00      	cmp	r3, #0
 8006628:	d1e9      	bne.n	80065fe <dhcp_option_trailer+0x28>
 800662a:	e000      	b.n	800662e <dhcp_option_trailer+0x58>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
 800662c:	bf00      	nop
  }
}
 800662e:	370c      	adds	r7, #12
 8006630:	46bd      	mov	sp, r7
 8006632:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006636:	4770      	bx	lr

08006638 <autoip_handle_arp_conflict>:
/**
 * Handle a IP address conflict after an ARP conflict detection
 */
static void
autoip_handle_arp_conflict(struct netif *netif)
{
 8006638:	b580      	push	{r7, lr}
 800663a:	b084      	sub	sp, #16
 800663c:	af00      	add	r7, sp, #0
 800663e:	6078      	str	r0, [r7, #4]
  /* Somehow detect if we are defending or retreating */
  unsigned char defend = 1; /* tbd */
 8006640:	2301      	movs	r3, #1
 8006642:	73fb      	strb	r3, [r7, #15]

  if(defend) {
 8006644:	7bfb      	ldrb	r3, [r7, #15]
 8006646:	2b00      	cmp	r3, #0
 8006648:	d010      	beq.n	800666c <autoip_handle_arp_conflict+0x34>
    if(netif->autoip->lastconflict > 0) {
 800664a:	687b      	ldr	r3, [r7, #4]
 800664c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800664e:	7a1b      	ldrb	r3, [r3, #8]
 8006650:	2b00      	cmp	r3, #0
 8006652:	d003      	beq.n	800665c <autoip_handle_arp_conflict+0x24>
       */
      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
        ("autoip_handle_arp_conflict(): we are defending, but in DEFEND_INTERVAL, retreating\n"));

      /* TODO: close all TCP sessions */
      autoip_start(netif);
 8006654:	6878      	ldr	r0, [r7, #4]
 8006656:	f000 f87b 	bl	8006750 <autoip_start>
    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
      ("autoip_handle_arp_conflict(): we do not defend, retreating\n"));
    /* TODO: close all TCP sessions */
    autoip_start(netif);
  }
}
 800665a:	e00a      	b.n	8006672 <autoip_handle_arp_conflict+0x3a>
      autoip_arp_announce(netif);
 800665c:	6878      	ldr	r0, [r7, #4]
 800665e:	f000 f853 	bl	8006708 <autoip_arp_announce>
      netif->autoip->lastconflict = DEFEND_INTERVAL * AUTOIP_TICKS_PER_SECOND;
 8006662:	687b      	ldr	r3, [r7, #4]
 8006664:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006666:	2264      	movs	r2, #100	; 0x64
 8006668:	721a      	strb	r2, [r3, #8]
}
 800666a:	e002      	b.n	8006672 <autoip_handle_arp_conflict+0x3a>
    autoip_start(netif);
 800666c:	6878      	ldr	r0, [r7, #4]
 800666e:	f000 f86f 	bl	8006750 <autoip_start>
}
 8006672:	bf00      	nop
 8006674:	3710      	adds	r7, #16
 8006676:	46bd      	mov	sp, r7
 8006678:	bd80      	pop	{r7, pc}
	...

0800667c <autoip_create_addr>:
 * @param netif network interface on which create the IP-Address
 * @param ipaddr ip address to initialize
 */
static void
autoip_create_addr(struct netif *netif, struct ip_addr *ipaddr)
{
 800667c:	b580      	push	{r7, lr}
 800667e:	b084      	sub	sp, #16
 8006680:	af00      	add	r7, sp, #0
 8006682:	6078      	str	r0, [r7, #4]
 8006684:	6039      	str	r1, [r7, #0]
  /* Here we create an IP-Address out of range 169.254.1.0 to 169.254.254.255
   * compliant to RFC 3927 Section 2.1
   * We have 254 * 256 possibilities */

  u32_t addr = ntohl(LWIP_AUTOIP_CREATE_SEED_ADDR(netif));
 8006686:	687b      	ldr	r3, [r7, #4]
 8006688:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800668c:	461a      	mov	r2, r3
 800668e:	687b      	ldr	r3, [r7, #4]
 8006690:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8006694:	021b      	lsls	r3, r3, #8
 8006696:	431a      	orrs	r2, r3
 8006698:	4b18      	ldr	r3, [pc, #96]	; (80066fc <autoip_create_addr+0x80>)
 800669a:	4413      	add	r3, r2
 800669c:	4618      	mov	r0, r3
 800669e:	f000 fb06 	bl	8006cae <htonl>
 80066a2:	4603      	mov	r3, r0
 80066a4:	4618      	mov	r0, r3
 80066a6:	f000 fb1b 	bl	8006ce0 <ntohl>
 80066aa:	60f8      	str	r0, [r7, #12]
  addr += netif->autoip->tried_llipaddr;
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80066b0:	7a5b      	ldrb	r3, [r3, #9]
 80066b2:	461a      	mov	r2, r3
 80066b4:	68fb      	ldr	r3, [r7, #12]
 80066b6:	4413      	add	r3, r2
 80066b8:	60fb      	str	r3, [r7, #12]
  addr = AUTOIP_NET | (addr & 0xffff);
 80066ba:	68fb      	ldr	r3, [r7, #12]
 80066bc:	b29b      	uxth	r3, r3
 80066be:	f043 4329 	orr.w	r3, r3, #2835349504	; 0xa9000000
 80066c2:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
 80066c6:	60fb      	str	r3, [r7, #12]
  /* Now, 169.254.0.0 <= addr <= 169.254.255.255 */ 

  if (addr < AUTOIP_RANGE_START) {
 80066c8:	68fb      	ldr	r3, [r7, #12]
 80066ca:	4a0d      	ldr	r2, [pc, #52]	; (8006700 <autoip_create_addr+0x84>)
 80066cc:	4293      	cmp	r3, r2
 80066ce:	d803      	bhi.n	80066d8 <autoip_create_addr+0x5c>
    addr += AUTOIP_RANGE_END - AUTOIP_RANGE_START + 1;
 80066d0:	68fb      	ldr	r3, [r7, #12]
 80066d2:	f503 437e 	add.w	r3, r3, #65024	; 0xfe00
 80066d6:	60fb      	str	r3, [r7, #12]
  }
  if (addr > AUTOIP_RANGE_END) {
 80066d8:	68fb      	ldr	r3, [r7, #12]
 80066da:	4a0a      	ldr	r2, [pc, #40]	; (8006704 <autoip_create_addr+0x88>)
 80066dc:	4293      	cmp	r3, r2
 80066de:	d903      	bls.n	80066e8 <autoip_create_addr+0x6c>
    addr -= AUTOIP_RANGE_END - AUTOIP_RANGE_START + 1;
 80066e0:	68fb      	ldr	r3, [r7, #12]
 80066e2:	f5a3 437e 	sub.w	r3, r3, #65024	; 0xfe00
 80066e6:	60fb      	str	r3, [r7, #12]
  }
  LWIP_ASSERT("AUTOIP address not in range", (addr >= AUTOIP_RANGE_START) &&
    (addr <= AUTOIP_RANGE_END));
  ipaddr->addr = htonl(addr);
 80066e8:	68f8      	ldr	r0, [r7, #12]
 80066ea:	f000 fae0 	bl	8006cae <htonl>
 80066ee:	4602      	mov	r2, r0
 80066f0:	683b      	ldr	r3, [r7, #0]
 80066f2:	601a      	str	r2, [r3, #0]
  
  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    ("autoip_create_addr(): tried_llipaddr=%"U16_F", 0x%08"X32_F"\n",
    (u16_t)(netif->autoip->tried_llipaddr), (u32_t)(ipaddr->addr)));
}
 80066f4:	bf00      	nop
 80066f6:	3710      	adds	r7, #16
 80066f8:	46bd      	mov	sp, r7
 80066fa:	bd80      	pop	{r7, pc}
 80066fc:	a9fe0100 	.word	0xa9fe0100
 8006700:	a9fe00ff 	.word	0xa9fe00ff
 8006704:	a9fefeff 	.word	0xa9fefeff

08006708 <autoip_arp_announce>:
 *
 * @param netif network interface used to send the announce
 */
static err_t
autoip_arp_announce(struct netif *netif)
{
 8006708:	b590      	push	{r4, r7, lr}
 800670a:	b087      	sub	sp, #28
 800670c:	af04      	add	r7, sp, #16
 800670e:	6078      	str	r0, [r7, #4]
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8006710:	687b      	ldr	r3, [r7, #4]
 8006712:	f103 012b 	add.w	r1, r3, #43	; 0x2b
    (struct eth_addr *)netif->hwaddr, &netif->autoip->llipaddr, &ethzero,
 8006716:	687b      	ldr	r3, [r7, #4]
 8006718:	f103 022b 	add.w	r2, r3, #43	; 0x2b
 800671c:	687b      	ldr	r3, [r7, #4]
 800671e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006720:	4618      	mov	r0, r3
    &netif->autoip->llipaddr, ARP_REQUEST);
 8006722:	687b      	ldr	r3, [r7, #4]
 8006724:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006726:	461c      	mov	r4, r3
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8006728:	2301      	movs	r3, #1
 800672a:	9303      	str	r3, [sp, #12]
 800672c:	9402      	str	r4, [sp, #8]
 800672e:	4b06      	ldr	r3, [pc, #24]	; (8006748 <autoip_arp_announce+0x40>)
 8006730:	9301      	str	r3, [sp, #4]
 8006732:	9000      	str	r0, [sp, #0]
 8006734:	4613      	mov	r3, r2
 8006736:	4a05      	ldr	r2, [pc, #20]	; (800674c <autoip_arp_announce+0x44>)
 8006738:	6878      	ldr	r0, [r7, #4]
 800673a:	f007 f969 	bl	800da10 <etharp_raw>
 800673e:	4603      	mov	r3, r0
}
 8006740:	4618      	mov	r0, r3
 8006742:	370c      	adds	r7, #12
 8006744:	46bd      	mov	sp, r7
 8006746:	bd90      	pop	{r4, r7, pc}
 8006748:	0801b5b8 	.word	0x0801b5b8
 800674c:	0801b5b0 	.word	0x0801b5b0

08006750 <autoip_start>:
 *
 * @param netif network interface on which start the AutoIP client
 */
err_t
autoip_start(struct netif *netif)
{
 8006750:	b580      	push	{r7, lr}
 8006752:	b084      	sub	sp, #16
 8006754:	af00      	add	r7, sp, #0
 8006756:	6078      	str	r0, [r7, #4]
  struct autoip *autoip = netif->autoip;
 8006758:	687b      	ldr	r3, [r7, #4]
 800675a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800675c:	60fb      	str	r3, [r7, #12]
  err_t result = ERR_OK;
 800675e:	2300      	movs	r3, #0
 8006760:	72fb      	strb	r3, [r7, #11]

  if(netif_is_up(netif)) {
 8006762:	6878      	ldr	r0, [r7, #4]
 8006764:	f001 fe3f 	bl	80083e6 <netif_is_up>
 8006768:	4603      	mov	r3, r0
 800676a:	2b00      	cmp	r3, #0
 800676c:	d002      	beq.n	8006774 <autoip_start+0x24>
    netif_set_down(netif);
 800676e:	6878      	ldr	r0, [r7, #4]
 8006770:	f001 fe1f 	bl	80083b2 <netif_set_down>
  }

  /* Set IP-Address, Netmask and Gateway to 0 to make sure that
   * ARP Packets are formed correctly
   */
  netif->ip_addr.addr = 0;
 8006774:	687b      	ldr	r3, [r7, #4]
 8006776:	2200      	movs	r2, #0
 8006778:	605a      	str	r2, [r3, #4]
  netif->netmask.addr = 0;
 800677a:	687b      	ldr	r3, [r7, #4]
 800677c:	2200      	movs	r2, #0
 800677e:	609a      	str	r2, [r3, #8]
  netif->gw.addr      = 0;
 8006780:	687b      	ldr	r3, [r7, #4]
 8006782:	2200      	movs	r2, #0
 8006784:	60da      	str	r2, [r3, #12]

  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    ("autoip_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0],
    netif->name[1], (u16_t)netif->num));
  if(autoip == NULL) {
 8006786:	68fb      	ldr	r3, [r7, #12]
 8006788:	2b00      	cmp	r3, #0
 800678a:	d112      	bne.n	80067b2 <autoip_start+0x62>
    /* no AutoIP client attached yet? */
    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
      ("autoip_start(): starting new AUTOIP client\n"));
    autoip = mem_malloc(sizeof(struct autoip));
 800678c:	200a      	movs	r0, #10
 800678e:	f001 fbc7 	bl	8007f20 <mem_malloc>
 8006792:	60f8      	str	r0, [r7, #12]
    if(autoip == NULL) {
 8006794:	68fb      	ldr	r3, [r7, #12]
 8006796:	2b00      	cmp	r3, #0
 8006798:	d102      	bne.n	80067a0 <autoip_start+0x50>
      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
        ("autoip_start(): could not allocate autoip\n"));
      return ERR_MEM;
 800679a:	f04f 33ff 	mov.w	r3, #4294967295
 800679e:	e02a      	b.n	80067f6 <autoip_start+0xa6>
    }
    memset( autoip, 0, sizeof(struct autoip));
 80067a0:	220a      	movs	r2, #10
 80067a2:	2100      	movs	r1, #0
 80067a4:	68f8      	ldr	r0, [r7, #12]
 80067a6:	f007 ff69 	bl	800e67c <memset>
    /* store this AutoIP client in the netif */
    netif->autoip = autoip;
 80067aa:	687b      	ldr	r3, [r7, #4]
 80067ac:	68fa      	ldr	r2, [r7, #12]
 80067ae:	625a      	str	r2, [r3, #36]	; 0x24
 80067b0:	e011      	b.n	80067d6 <autoip_start+0x86>
    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_start(): allocated autoip"));
  } else {
    autoip->state = AUTOIP_STATE_OFF;
 80067b2:	68fb      	ldr	r3, [r7, #12]
 80067b4:	2200      	movs	r2, #0
 80067b6:	711a      	strb	r2, [r3, #4]
    autoip->ttw = 0;
 80067b8:	68fb      	ldr	r3, [r7, #12]
 80067ba:	2200      	movs	r2, #0
 80067bc:	80da      	strh	r2, [r3, #6]
    autoip->sent_num = 0;
 80067be:	68fb      	ldr	r3, [r7, #12]
 80067c0:	2200      	movs	r2, #0
 80067c2:	715a      	strb	r2, [r3, #5]
    memset(&autoip->llipaddr, 0, sizeof(struct ip_addr));
 80067c4:	68fb      	ldr	r3, [r7, #12]
 80067c6:	2204      	movs	r2, #4
 80067c8:	2100      	movs	r1, #0
 80067ca:	4618      	mov	r0, r3
 80067cc:	f007 ff56 	bl	800e67c <memset>
    autoip->lastconflict = 0;
 80067d0:	68fb      	ldr	r3, [r7, #12]
 80067d2:	2200      	movs	r2, #0
 80067d4:	721a      	strb	r2, [r3, #8]
  }

  autoip_create_addr(netif, &(autoip->llipaddr));
 80067d6:	68fb      	ldr	r3, [r7, #12]
 80067d8:	4619      	mov	r1, r3
 80067da:	6878      	ldr	r0, [r7, #4]
 80067dc:	f7ff ff4e 	bl	800667c <autoip_create_addr>
  autoip->tried_llipaddr++;
 80067e0:	68fb      	ldr	r3, [r7, #12]
 80067e2:	7a5b      	ldrb	r3, [r3, #9]
 80067e4:	3301      	adds	r3, #1
 80067e6:	b2da      	uxtb	r2, r3
 80067e8:	68fb      	ldr	r3, [r7, #12]
 80067ea:	725a      	strb	r2, [r3, #9]
  autoip_start_probing(netif);
 80067ec:	6878      	ldr	r0, [r7, #4]
 80067ee:	f000 f807 	bl	8006800 <autoip_start_probing>

  return result;
 80067f2:	f997 300b 	ldrsb.w	r3, [r7, #11]
}
 80067f6:	4618      	mov	r0, r3
 80067f8:	3710      	adds	r7, #16
 80067fa:	46bd      	mov	sp, r7
 80067fc:	bd80      	pop	{r7, pc}
	...

08006800 <autoip_start_probing>:

static void
autoip_start_probing(struct netif *netif)
{
 8006800:	b480      	push	{r7}
 8006802:	b085      	sub	sp, #20
 8006804:	af00      	add	r7, sp, #0
 8006806:	6078      	str	r0, [r7, #4]
  struct autoip *autoip = netif->autoip;
 8006808:	687b      	ldr	r3, [r7, #4]
 800680a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800680c:	60fb      	str	r3, [r7, #12]

  autoip->state = AUTOIP_STATE_PROBING;
 800680e:	68fb      	ldr	r3, [r7, #12]
 8006810:	2201      	movs	r2, #1
 8006812:	711a      	strb	r2, [r3, #4]
  autoip->sent_num = 0;
 8006814:	68fb      	ldr	r3, [r7, #12]
 8006816:	2200      	movs	r2, #0
 8006818:	715a      	strb	r2, [r3, #5]

  /* time to wait to first probe, this is randomly
   * choosen out of 0 to PROBE_WAIT seconds.
   * compliant to RFC 3927 Section 2.2.1
   */
  autoip->ttw = (u16_t)(LWIP_AUTOIP_RAND(netif) % (PROBE_WAIT * AUTOIP_TICKS_PER_SECOND));
 800681a:	687b      	ldr	r3, [r7, #4]
 800681c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8006820:	061a      	lsls	r2, r3, #24
 8006822:	687b      	ldr	r3, [r7, #4]
 8006824:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8006828:	041b      	lsls	r3, r3, #16
 800682a:	431a      	orrs	r2, r3
 800682c:	687b      	ldr	r3, [r7, #4]
 800682e:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8006832:	021b      	lsls	r3, r3, #8
 8006834:	4313      	orrs	r3, r2
 8006836:	687a      	ldr	r2, [r7, #4]
 8006838:	f892 202f 	ldrb.w	r2, [r2, #47]	; 0x2f
 800683c:	4313      	orrs	r3, r2
 800683e:	687a      	ldr	r2, [r7, #4]
 8006840:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006842:	2a00      	cmp	r2, #0
 8006844:	d003      	beq.n	800684e <autoip_start_probing+0x4e>
 8006846:	687a      	ldr	r2, [r7, #4]
 8006848:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800684a:	7a52      	ldrb	r2, [r2, #9]
 800684c:	e000      	b.n	8006850 <autoip_start_probing+0x50>
 800684e:	2200      	movs	r2, #0
 8006850:	1899      	adds	r1, r3, r2
 8006852:	4b0d      	ldr	r3, [pc, #52]	; (8006888 <autoip_start_probing+0x88>)
 8006854:	fba3 2301 	umull	r2, r3, r3, r1
 8006858:	08da      	lsrs	r2, r3, #3
 800685a:	4613      	mov	r3, r2
 800685c:	009b      	lsls	r3, r3, #2
 800685e:	4413      	add	r3, r2
 8006860:	005b      	lsls	r3, r3, #1
 8006862:	1aca      	subs	r2, r1, r3
 8006864:	b292      	uxth	r2, r2
 8006866:	68fb      	ldr	r3, [r7, #12]
 8006868:	80da      	strh	r2, [r3, #6]
  /*
   * if we tried more then MAX_CONFLICTS we must limit our rate for
   * accquiring and probing address
   * compliant to RFC 3927 Section 2.2.1
   */
  if(autoip->tried_llipaddr > MAX_CONFLICTS) {
 800686a:	68fb      	ldr	r3, [r7, #12]
 800686c:	7a5b      	ldrb	r3, [r3, #9]
 800686e:	2b0a      	cmp	r3, #10
 8006870:	d903      	bls.n	800687a <autoip_start_probing+0x7a>
    autoip->ttw = RATE_LIMIT_INTERVAL * AUTOIP_TICKS_PER_SECOND;
 8006872:	68fb      	ldr	r3, [r7, #12]
 8006874:	f44f 7216 	mov.w	r2, #600	; 0x258
 8006878:	80da      	strh	r2, [r3, #6]
  }
}
 800687a:	bf00      	nop
 800687c:	3714      	adds	r7, #20
 800687e:	46bd      	mov	sp, r7
 8006880:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006884:	4770      	bx	lr
 8006886:	bf00      	nop
 8006888:	cccccccd 	.word	0xcccccccd

0800688c <autoip_arp_reply>:
 * @param netif network interface to use for autoip processing
 * @param hdr Incoming ARP packet
 */
void
autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr)
{
 800688c:	b580      	push	{r7, lr}
 800688e:	b086      	sub	sp, #24
 8006890:	af00      	add	r7, sp, #0
 8006892:	6078      	str	r0, [r7, #4]
 8006894:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_arp_reply()\n"));
  if ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) {
 8006896:	687b      	ldr	r3, [r7, #4]
 8006898:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800689a:	2b00      	cmp	r3, #0
 800689c:	d066      	beq.n	800696c <autoip_arp_reply+0xe0>
 800689e:	687b      	ldr	r3, [r7, #4]
 80068a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80068a2:	791b      	ldrb	r3, [r3, #4]
 80068a4:	2b00      	cmp	r3, #0
 80068a6:	d061      	beq.n	800696c <autoip_arp_reply+0xe0>
    * when probing  ip.dst == llipaddr && hw.src != netif->hwaddr
    * we have a conflict and must solve it
    */
    struct ip_addr sipaddr, dipaddr;
    struct eth_addr netifaddr;
    netifaddr.addr[0] = netif->hwaddr[0];
 80068a8:	687b      	ldr	r3, [r7, #4]
 80068aa:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 80068ae:	723b      	strb	r3, [r7, #8]
    netifaddr.addr[1] = netif->hwaddr[1];
 80068b0:	687b      	ldr	r3, [r7, #4]
 80068b2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80068b6:	727b      	strb	r3, [r7, #9]
    netifaddr.addr[2] = netif->hwaddr[2];
 80068b8:	687b      	ldr	r3, [r7, #4]
 80068ba:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 80068be:	72bb      	strb	r3, [r7, #10]
    netifaddr.addr[3] = netif->hwaddr[3];
 80068c0:	687b      	ldr	r3, [r7, #4]
 80068c2:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 80068c6:	72fb      	strb	r3, [r7, #11]
    netifaddr.addr[4] = netif->hwaddr[4];
 80068c8:	687b      	ldr	r3, [r7, #4]
 80068ca:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 80068ce:	733b      	strb	r3, [r7, #12]
    netifaddr.addr[5] = netif->hwaddr[5];
 80068d0:	687b      	ldr	r3, [r7, #4]
 80068d2:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80068d6:	737b      	strb	r3, [r7, #13]

    /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
     * structure packing (not using structure copy which breaks strict-aliasing rules).
     */
    SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
 80068d8:	683b      	ldr	r3, [r7, #0]
 80068da:	330e      	adds	r3, #14
 80068dc:	681b      	ldr	r3, [r3, #0]
 80068de:	617b      	str	r3, [r7, #20]
    SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
 80068e0:	683b      	ldr	r3, [r7, #0]
 80068e2:	3318      	adds	r3, #24
 80068e4:	681b      	ldr	r3, [r3, #0]
 80068e6:	613b      	str	r3, [r7, #16]
      
    if ((netif->autoip->state == AUTOIP_STATE_PROBING) ||
 80068e8:	687b      	ldr	r3, [r7, #4]
 80068ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80068ec:	791b      	ldrb	r3, [r3, #4]
 80068ee:	2b01      	cmp	r3, #1
 80068f0:	d009      	beq.n	8006906 <autoip_arp_reply+0x7a>
        ((netif->autoip->state == AUTOIP_STATE_ANNOUNCING) &&
 80068f2:	687b      	ldr	r3, [r7, #4]
 80068f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80068f6:	791b      	ldrb	r3, [r3, #4]
    if ((netif->autoip->state == AUTOIP_STATE_PROBING) ||
 80068f8:	2b02      	cmp	r3, #2
 80068fa:	d120      	bne.n	800693e <autoip_arp_reply+0xb2>
         (netif->autoip->sent_num == 0))) {
 80068fc:	687b      	ldr	r3, [r7, #4]
 80068fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006900:	795b      	ldrb	r3, [r3, #5]
        ((netif->autoip->state == AUTOIP_STATE_ANNOUNCING) &&
 8006902:	2b00      	cmp	r3, #0
 8006904:	d11b      	bne.n	800693e <autoip_arp_reply+0xb2>
      * from beginning to after ANNOUNCE_WAIT
      * seconds we have a conflict if
      * ip.src == llipaddr OR
      * ip.dst == llipaddr && hw.src != own hwaddr
      */
      if ((ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr)) ||
 8006906:	697a      	ldr	r2, [r7, #20]
 8006908:	687b      	ldr	r3, [r7, #4]
 800690a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800690c:	681b      	ldr	r3, [r3, #0]
 800690e:	429a      	cmp	r2, r3
 8006910:	d011      	beq.n	8006936 <autoip_arp_reply+0xaa>
          (ip_addr_cmp(&dipaddr, &netif->autoip->llipaddr) &&
 8006912:	693a      	ldr	r2, [r7, #16]
 8006914:	687b      	ldr	r3, [r7, #4]
 8006916:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006918:	681b      	ldr	r3, [r3, #0]
      if ((ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr)) ||
 800691a:	429a      	cmp	r2, r3
 800691c:	d125      	bne.n	800696a <autoip_arp_reply+0xde>
           !eth_addr_cmp(&netifaddr, &hdr->shwaddr))) {
 800691e:	683b      	ldr	r3, [r7, #0]
 8006920:	f103 0108 	add.w	r1, r3, #8
 8006924:	f107 0308 	add.w	r3, r7, #8
 8006928:	2206      	movs	r2, #6
 800692a:	4618      	mov	r0, r3
 800692c:	f007 fe8c 	bl	800e648 <memcmp>
 8006930:	4603      	mov	r3, r0
          (ip_addr_cmp(&dipaddr, &netif->autoip->llipaddr) &&
 8006932:	2b00      	cmp	r3, #0
 8006934:	d019      	beq.n	800696a <autoip_arp_reply+0xde>
        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
          ("autoip_arp_reply(): Probe Conflict detected\n"));
        autoip_start(netif);
 8006936:	6878      	ldr	r0, [r7, #4]
 8006938:	f7ff ff0a 	bl	8006750 <autoip_start>
      if ((ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr)) ||
 800693c:	e015      	b.n	800696a <autoip_arp_reply+0xde>
    } else {
     /* RFC 3927 Section 2.5:
      * in any state we have a conflict if
      * ip.src == llipaddr && hw.src != own hwaddr
      */
      if (ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr) &&
 800693e:	697a      	ldr	r2, [r7, #20]
 8006940:	687b      	ldr	r3, [r7, #4]
 8006942:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006944:	681b      	ldr	r3, [r3, #0]
 8006946:	429a      	cmp	r2, r3
 8006948:	d110      	bne.n	800696c <autoip_arp_reply+0xe0>
          !eth_addr_cmp(&netifaddr, &hdr->shwaddr)) {
 800694a:	683b      	ldr	r3, [r7, #0]
 800694c:	f103 0108 	add.w	r1, r3, #8
 8006950:	f107 0308 	add.w	r3, r7, #8
 8006954:	2206      	movs	r2, #6
 8006956:	4618      	mov	r0, r3
 8006958:	f007 fe76 	bl	800e648 <memcmp>
 800695c:	4603      	mov	r3, r0
      if (ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr) &&
 800695e:	2b00      	cmp	r3, #0
 8006960:	d004      	beq.n	800696c <autoip_arp_reply+0xe0>
        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
          ("autoip_arp_reply(): Conflicting ARP-Packet detected\n"));
        autoip_handle_arp_conflict(netif);
 8006962:	6878      	ldr	r0, [r7, #4]
 8006964:	f7ff fe68 	bl	8006638 <autoip_handle_arp_conflict>
      }
    }
  }
}
 8006968:	e000      	b.n	800696c <autoip_arp_reply+0xe0>
      if ((ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr)) ||
 800696a:	bf00      	nop
}
 800696c:	bf00      	nop
 800696e:	3718      	adds	r7, #24
 8006970:	46bd      	mov	sp, r7
 8006972:	bd80      	pop	{r7, pc}

08006974 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8006974:	b590      	push	{r4, r7, lr}
 8006976:	b08f      	sub	sp, #60	; 0x3c
 8006978:	af04      	add	r7, sp, #16
 800697a:	6078      	str	r0, [r7, #4]
 800697c:	6039      	str	r1, [r7, #0]

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
 800697e:	687b      	ldr	r3, [r7, #4]
 8006980:	685b      	ldr	r3, [r3, #4]
 8006982:	627b      	str	r3, [r7, #36]	; 0x24
  hlen = IPH_HL(iphdr) * 4;
 8006984:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006986:	881b      	ldrh	r3, [r3, #0]
 8006988:	b29b      	uxth	r3, r3
 800698a:	4618      	mov	r0, r3
 800698c:	f000 f981 	bl	8006c92 <ntohs>
 8006990:	4603      	mov	r3, r0
 8006992:	0a1b      	lsrs	r3, r3, #8
 8006994:	b29b      	uxth	r3, r3
 8006996:	f003 030f 	and.w	r3, r3, #15
 800699a:	b29b      	uxth	r3, r3
 800699c:	009b      	lsls	r3, r3, #2
 800699e:	b29b      	uxth	r3, r3
 80069a0:	83fb      	strh	r3, [r7, #30]
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 80069a2:	8bfb      	ldrh	r3, [r7, #30]
 80069a4:	425b      	negs	r3, r3
 80069a6:	b29b      	uxth	r3, r3
 80069a8:	b21b      	sxth	r3, r3
 80069aa:	4619      	mov	r1, r3
 80069ac:	6878      	ldr	r0, [r7, #4]
 80069ae:	f001 fe8d 	bl	80086cc <pbuf_header>
 80069b2:	4603      	mov	r3, r0
 80069b4:	2b00      	cmp	r3, #0
 80069b6:	f040 80cf 	bne.w	8006b58 <icmp_input+0x1e4>
 80069ba:	687b      	ldr	r3, [r7, #4]
 80069bc:	891b      	ldrh	r3, [r3, #8]
 80069be:	2b03      	cmp	r3, #3
 80069c0:	f240 80ca 	bls.w	8006b58 <icmp_input+0x1e4>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 80069c4:	687b      	ldr	r3, [r7, #4]
 80069c6:	685b      	ldr	r3, [r3, #4]
 80069c8:	781b      	ldrb	r3, [r3, #0]
 80069ca:	777b      	strb	r3, [r7, #29]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
 80069cc:	687b      	ldr	r3, [r7, #4]
 80069ce:	685b      	ldr	r3, [r3, #4]
 80069d0:	785b      	ldrb	r3, [r3, #1]
 80069d2:	773b      	strb	r3, [r7, #28]
#endif /* LWIP_DEBUG */
  switch (type) {
 80069d4:	7f7b      	ldrb	r3, [r7, #29]
 80069d6:	2b08      	cmp	r3, #8
 80069d8:	f040 80b9 	bne.w	8006b4e <icmp_input+0x1da>
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
 80069dc:	2301      	movs	r3, #1
 80069de:	623b      	str	r3, [r7, #32]
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&iphdr->dest)) {
 80069e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80069e2:	691c      	ldr	r4, [r3, #16]
 80069e4:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 80069e8:	f000 f97a 	bl	8006ce0 <ntohl>
 80069ec:	4603      	mov	r3, r0
 80069ee:	401c      	ands	r4, r3
 80069f0:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 80069f4:	f000 f974 	bl	8006ce0 <ntohl>
 80069f8:	4603      	mov	r3, r0
 80069fa:	429c      	cmp	r4, r3
 80069fc:	d101      	bne.n	8006a02 <icmp_input+0x8e>
        accepted = 0;
 80069fe:	2300      	movs	r3, #0
 8006a00:	623b      	str	r3, [r7, #32]
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&iphdr->dest, inp)) {
 8006a02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006a04:	3310      	adds	r3, #16
 8006a06:	6839      	ldr	r1, [r7, #0]
 8006a08:	4618      	mov	r0, r3
 8006a0a:	f000 fc98 	bl	800733e <ip_addr_isbroadcast>
 8006a0e:	4603      	mov	r3, r0
 8006a10:	2b00      	cmp	r3, #0
 8006a12:	d001      	beq.n	8006a18 <icmp_input+0xa4>
        accepted = 0;
 8006a14:	2300      	movs	r3, #0
 8006a16:	623b      	str	r3, [r7, #32]
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
 8006a18:	6a3b      	ldr	r3, [r7, #32]
 8006a1a:	2b00      	cmp	r3, #0
 8006a1c:	d103      	bne.n	8006a26 <icmp_input+0xb2>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
        pbuf_free(p);
 8006a1e:	6878      	ldr	r0, [r7, #4]
 8006a20:	f001 fec3 	bl	80087aa <pbuf_free>
        return;
 8006a24:	e0a9      	b.n	8006b7a <icmp_input+0x206>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8006a26:	687b      	ldr	r3, [r7, #4]
 8006a28:	891b      	ldrh	r3, [r3, #8]
 8006a2a:	2b07      	cmp	r3, #7
 8006a2c:	f240 8093 	bls.w	8006b56 <icmp_input+0x1e2>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
 8006a30:	6878      	ldr	r0, [r7, #4]
 8006a32:	f000 f9c0 	bl	8006db6 <inet_chksum_pbuf>
 8006a36:	4603      	mov	r3, r0
 8006a38:	2b00      	cmp	r3, #0
 8006a3a:	d003      	beq.n	8006a44 <icmp_input+0xd0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
 8006a3c:	6878      	ldr	r0, [r7, #4]
 8006a3e:	f001 feb4 	bl	80087aa <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
 8006a42:	e09a      	b.n	8006b7a <icmp_input+0x206>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8006a44:	2122      	movs	r1, #34	; 0x22
 8006a46:	6878      	ldr	r0, [r7, #4]
 8006a48:	f001 fe40 	bl	80086cc <pbuf_header>
 8006a4c:	4603      	mov	r3, r0
 8006a4e:	2b00      	cmp	r3, #0
 8006a50:	d02e      	beq.n	8006ab0 <icmp_input+0x13c>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
 8006a52:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8006a56:	4619      	mov	r1, r3
 8006a58:	6878      	ldr	r0, [r7, #4]
 8006a5a:	f001 fe37 	bl	80086cc <pbuf_header>
 8006a5e:	4603      	mov	r3, r0
 8006a60:	2b00      	cmp	r3, #0
 8006a62:	d17d      	bne.n	8006b60 <icmp_input+0x1ec>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 8006a64:	687b      	ldr	r3, [r7, #4]
 8006a66:	891b      	ldrh	r3, [r3, #8]
 8006a68:	2200      	movs	r2, #0
 8006a6a:	4619      	mov	r1, r3
 8006a6c:	2002      	movs	r0, #2
 8006a6e:	f001 fccf 	bl	8008410 <pbuf_alloc>
 8006a72:	61b8      	str	r0, [r7, #24]
      if (r == NULL) {
 8006a74:	69bb      	ldr	r3, [r7, #24]
 8006a76:	2b00      	cmp	r3, #0
 8006a78:	d074      	beq.n	8006b64 <icmp_input+0x1f0>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
 8006a7a:	6879      	ldr	r1, [r7, #4]
 8006a7c:	69b8      	ldr	r0, [r7, #24]
 8006a7e:	f001 ff4c 	bl	800891a <pbuf_copy>
 8006a82:	4603      	mov	r3, r0
 8006a84:	2b00      	cmp	r3, #0
 8006a86:	d16f      	bne.n	8006b68 <icmp_input+0x1f4>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = r->payload;
 8006a88:	69bb      	ldr	r3, [r7, #24]
 8006a8a:	685b      	ldr	r3, [r3, #4]
 8006a8c:	627b      	str	r3, [r7, #36]	; 0x24
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 8006a8e:	8bfb      	ldrh	r3, [r7, #30]
 8006a90:	425b      	negs	r3, r3
 8006a92:	b29b      	uxth	r3, r3
 8006a94:	b21b      	sxth	r3, r3
 8006a96:	4619      	mov	r1, r3
 8006a98:	69b8      	ldr	r0, [r7, #24]
 8006a9a:	f001 fe17 	bl	80086cc <pbuf_header>
 8006a9e:	4603      	mov	r3, r0
 8006aa0:	2b00      	cmp	r3, #0
 8006aa2:	d163      	bne.n	8006b6c <icmp_input+0x1f8>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 8006aa4:	6878      	ldr	r0, [r7, #4]
 8006aa6:	f001 fe80 	bl	80087aa <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
 8006aaa:	69bb      	ldr	r3, [r7, #24]
 8006aac:	607b      	str	r3, [r7, #4]
 8006aae:	e007      	b.n	8006ac0 <icmp_input+0x14c>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8006ab0:	f06f 0121 	mvn.w	r1, #33	; 0x21
 8006ab4:	6878      	ldr	r0, [r7, #4]
 8006ab6:	f001 fe09 	bl	80086cc <pbuf_header>
 8006aba:	4603      	mov	r3, r0
 8006abc:	2b00      	cmp	r3, #0
 8006abe:	d157      	bne.n	8006b70 <icmp_input+0x1fc>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
 8006ac0:	687b      	ldr	r3, [r7, #4]
 8006ac2:	685b      	ldr	r3, [r3, #4]
 8006ac4:	617b      	str	r3, [r7, #20]
    tmpaddr.addr = iphdr->src.addr;
 8006ac6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ac8:	68db      	ldr	r3, [r3, #12]
 8006aca:	60fb      	str	r3, [r7, #12]
    iphdr->src.addr = iphdr->dest.addr;
 8006acc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ace:	691a      	ldr	r2, [r3, #16]
 8006ad0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ad2:	60da      	str	r2, [r3, #12]
    iphdr->dest.addr = tmpaddr.addr;
 8006ad4:	68fa      	ldr	r2, [r7, #12]
 8006ad6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ad8:	611a      	str	r2, [r3, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 8006ada:	697b      	ldr	r3, [r7, #20]
 8006adc:	2200      	movs	r2, #0
 8006ade:	701a      	strb	r2, [r3, #0]

/* This part of code has been modified by ST's MCD Application Team */
/* To use the Checksum Offload Engine for the putgoing ICMP packets,
   the ICMP checksum field should be set to 0, this is required only for Tx ICMP*/
#ifdef CHECKSUM_BY_HARDWARE
    iecho->chksum = 0;
 8006ae0:	697b      	ldr	r3, [r7, #20]
 8006ae2:	2200      	movs	r2, #0
 8006ae4:	709a      	strb	r2, [r3, #2]
 8006ae6:	2200      	movs	r2, #0
 8006ae8:	70da      	strb	r2, [r3, #3]
      iecho->chksum += htons(ICMP_ECHO << 8);
    }	
#endif

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 8006aea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006aec:	891b      	ldrh	r3, [r3, #8]
 8006aee:	b29b      	uxth	r3, r3
 8006af0:	4618      	mov	r0, r3
 8006af2:	f000 f8ce 	bl	8006c92 <ntohs>
 8006af6:	4603      	mov	r3, r0
 8006af8:	b21b      	sxth	r3, r3
 8006afa:	f063 03ff 	orn	r3, r3, #255	; 0xff
 8006afe:	b21b      	sxth	r3, r3
 8006b00:	b29b      	uxth	r3, r3
 8006b02:	4618      	mov	r0, r3
 8006b04:	f000 f8b0 	bl	8006c68 <htons>
 8006b08:	4603      	mov	r3, r0
 8006b0a:	461a      	mov	r2, r3
 8006b0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006b0e:	811a      	strh	r2, [r3, #8]
    IPH_CHKSUM_SET(iphdr, 0);
 8006b10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006b12:	2200      	movs	r2, #0
 8006b14:	729a      	strb	r2, [r3, #10]
 8006b16:	2200      	movs	r2, #0
 8006b18:	72da      	strb	r2, [r3, #11]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 8006b1a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8006b1e:	4619      	mov	r1, r3
 8006b20:	6878      	ldr	r0, [r7, #4]
 8006b22:	f001 fdd3 	bl	80086cc <pbuf_header>
 8006b26:	4603      	mov	r3, r0
 8006b28:	2b00      	cmp	r3, #0
 8006b2a:	d10f      	bne.n	8006b4c <icmp_input+0x1d8>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
 8006b2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006b2e:	f103 010c 	add.w	r1, r3, #12
 8006b32:	683b      	ldr	r3, [r7, #0]
 8006b34:	9302      	str	r3, [sp, #8]
 8006b36:	2301      	movs	r3, #1
 8006b38:	9301      	str	r3, [sp, #4]
 8006b3a:	2300      	movs	r3, #0
 8006b3c:	9300      	str	r3, [sp, #0]
 8006b3e:	23ff      	movs	r3, #255	; 0xff
 8006b40:	2200      	movs	r2, #0
 8006b42:	6878      	ldr	r0, [r7, #4]
 8006b44:	f000 fafa 	bl	800713c <ip_output_if>
 8006b48:	4603      	mov	r3, r0
 8006b4a:	74fb      	strb	r3, [r7, #19]
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 8006b4c:	bf00      	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 8006b4e:	6878      	ldr	r0, [r7, #4]
 8006b50:	f001 fe2b 	bl	80087aa <pbuf_free>
  return;
 8006b54:	e011      	b.n	8006b7a <icmp_input+0x206>
      goto lenerr;
 8006b56:	bf00      	nop
lenerr:
  pbuf_free(p);
 8006b58:	6878      	ldr	r0, [r7, #4]
 8006b5a:	f001 fe26 	bl	80087aa <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
 8006b5e:	e00c      	b.n	8006b7a <icmp_input+0x206>
        goto memerr;
 8006b60:	bf00      	nop
 8006b62:	e006      	b.n	8006b72 <icmp_input+0x1fe>
        goto memerr;
 8006b64:	bf00      	nop
 8006b66:	e004      	b.n	8006b72 <icmp_input+0x1fe>
        goto memerr;
 8006b68:	bf00      	nop
 8006b6a:	e002      	b.n	8006b72 <icmp_input+0x1fe>
        goto memerr;
 8006b6c:	bf00      	nop
 8006b6e:	e000      	b.n	8006b72 <icmp_input+0x1fe>
        goto memerr;
 8006b70:	bf00      	nop
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 8006b72:	6878      	ldr	r0, [r7, #4]
 8006b74:	f001 fe19 	bl	80087aa <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
 8006b78:	bf00      	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 8006b7a:	372c      	adds	r7, #44	; 0x2c
 8006b7c:	46bd      	mov	sp, r7
 8006b7e:	bd90      	pop	{r4, r7, pc}

08006b80 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 8006b80:	b580      	push	{r7, lr}
 8006b82:	b082      	sub	sp, #8
 8006b84:	af00      	add	r7, sp, #0
 8006b86:	6078      	str	r0, [r7, #4]
 8006b88:	460b      	mov	r3, r1
 8006b8a:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_DUR, t);
 8006b8c:	78fb      	ldrb	r3, [r7, #3]
 8006b8e:	461a      	mov	r2, r3
 8006b90:	2103      	movs	r1, #3
 8006b92:	6878      	ldr	r0, [r7, #4]
 8006b94:	f000 f814 	bl	8006bc0 <icmp_send_response>
}
 8006b98:	bf00      	nop
 8006b9a:	3708      	adds	r7, #8
 8006b9c:	46bd      	mov	sp, r7
 8006b9e:	bd80      	pop	{r7, pc}

08006ba0 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 8006ba0:	b580      	push	{r7, lr}
 8006ba2:	b082      	sub	sp, #8
 8006ba4:	af00      	add	r7, sp, #0
 8006ba6:	6078      	str	r0, [r7, #4]
 8006ba8:	460b      	mov	r3, r1
 8006baa:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_TE, t);
 8006bac:	78fb      	ldrb	r3, [r7, #3]
 8006bae:	461a      	mov	r2, r3
 8006bb0:	210b      	movs	r1, #11
 8006bb2:	6878      	ldr	r0, [r7, #4]
 8006bb4:	f000 f804 	bl	8006bc0 <icmp_send_response>
}
 8006bb8:	bf00      	nop
 8006bba:	3708      	adds	r7, #8
 8006bbc:	46bd      	mov	sp, r7
 8006bbe:	bd80      	pop	{r7, pc}

08006bc0 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8006bc0:	b580      	push	{r7, lr}
 8006bc2:	b088      	sub	sp, #32
 8006bc4:	af02      	add	r7, sp, #8
 8006bc6:	6078      	str	r0, [r7, #4]
 8006bc8:	460b      	mov	r3, r1
 8006bca:	70fb      	strb	r3, [r7, #3]
 8006bcc:	4613      	mov	r3, r2
 8006bce:	70bb      	strb	r3, [r7, #2]
  struct ip_hdr *iphdr;
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8006bd0:	2200      	movs	r2, #0
 8006bd2:	2124      	movs	r1, #36	; 0x24
 8006bd4:	2001      	movs	r0, #1
 8006bd6:	f001 fc1b 	bl	8008410 <pbuf_alloc>
 8006bda:	6178      	str	r0, [r7, #20]
                 PBUF_RAM);
  if (q == NULL) {
 8006bdc:	697b      	ldr	r3, [r7, #20]
 8006bde:	2b00      	cmp	r3, #0
 8006be0:	d03e      	beq.n	8006c60 <icmp_send_response+0xa0>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
 8006be2:	687b      	ldr	r3, [r7, #4]
 8006be4:	685b      	ldr	r3, [r3, #4]
 8006be6:	613b      	str	r3, [r7, #16]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = q->payload;
 8006be8:	697b      	ldr	r3, [r7, #20]
 8006bea:	685b      	ldr	r3, [r3, #4]
 8006bec:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
 8006bee:	68fb      	ldr	r3, [r7, #12]
 8006bf0:	78fa      	ldrb	r2, [r7, #3]
 8006bf2:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 8006bf4:	68fb      	ldr	r3, [r7, #12]
 8006bf6:	78ba      	ldrb	r2, [r7, #2]
 8006bf8:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 8006bfa:	68fb      	ldr	r3, [r7, #12]
 8006bfc:	2200      	movs	r2, #0
 8006bfe:	711a      	strb	r2, [r3, #4]
 8006c00:	2200      	movs	r2, #0
 8006c02:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 8006c04:	68fb      	ldr	r3, [r7, #12]
 8006c06:	2200      	movs	r2, #0
 8006c08:	719a      	strb	r2, [r3, #6]
 8006c0a:	2200      	movs	r2, #0
 8006c0c:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8006c0e:	697b      	ldr	r3, [r7, #20]
 8006c10:	685b      	ldr	r3, [r3, #4]
 8006c12:	f103 0008 	add.w	r0, r3, #8
 8006c16:	687b      	ldr	r3, [r7, #4]
 8006c18:	685b      	ldr	r3, [r3, #4]
 8006c1a:	221c      	movs	r2, #28
 8006c1c:	4619      	mov	r1, r3
 8006c1e:	f007 fd22 	bl	800e666 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 8006c22:	68fb      	ldr	r3, [r7, #12]
 8006c24:	2200      	movs	r2, #0
 8006c26:	709a      	strb	r2, [r3, #2]
 8006c28:	2200      	movs	r2, #0
 8006c2a:	70da      	strb	r2, [r3, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8006c2c:	697b      	ldr	r3, [r7, #20]
 8006c2e:	895b      	ldrh	r3, [r3, #10]
 8006c30:	4619      	mov	r1, r3
 8006c32:	68f8      	ldr	r0, [r7, #12]
 8006c34:	f000 f8ad 	bl	8006d92 <inet_chksum>
 8006c38:	4603      	mov	r3, r0
 8006c3a:	461a      	mov	r2, r3
 8006c3c:	68fb      	ldr	r3, [r7, #12]
 8006c3e:	805a      	strh	r2, [r3, #2]
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
 8006c40:	693b      	ldr	r3, [r7, #16]
 8006c42:	f103 020c 	add.w	r2, r3, #12
 8006c46:	2301      	movs	r3, #1
 8006c48:	9301      	str	r3, [sp, #4]
 8006c4a:	2300      	movs	r3, #0
 8006c4c:	9300      	str	r3, [sp, #0]
 8006c4e:	23ff      	movs	r3, #255	; 0xff
 8006c50:	2100      	movs	r1, #0
 8006c52:	6978      	ldr	r0, [r7, #20]
 8006c54:	f000 fb3e 	bl	80072d4 <ip_output>
  pbuf_free(q);
 8006c58:	6978      	ldr	r0, [r7, #20]
 8006c5a:	f001 fda6 	bl	80087aa <pbuf_free>
 8006c5e:	e000      	b.n	8006c62 <icmp_send_response+0xa2>
    return;
 8006c60:	bf00      	nop
}
 8006c62:	3718      	adds	r7, #24
 8006c64:	46bd      	mov	sp, r7
 8006c66:	bd80      	pop	{r7, pc}

08006c68 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
 8006c68:	b480      	push	{r7}
 8006c6a:	b083      	sub	sp, #12
 8006c6c:	af00      	add	r7, sp, #0
 8006c6e:	4603      	mov	r3, r0
 8006c70:	80fb      	strh	r3, [r7, #6]
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 8006c72:	88fb      	ldrh	r3, [r7, #6]
 8006c74:	021b      	lsls	r3, r3, #8
 8006c76:	b21a      	sxth	r2, r3
 8006c78:	88fb      	ldrh	r3, [r7, #6]
 8006c7a:	0a1b      	lsrs	r3, r3, #8
 8006c7c:	b29b      	uxth	r3, r3
 8006c7e:	b21b      	sxth	r3, r3
 8006c80:	4313      	orrs	r3, r2
 8006c82:	b21b      	sxth	r3, r3
 8006c84:	b29b      	uxth	r3, r3
}
 8006c86:	4618      	mov	r0, r3
 8006c88:	370c      	adds	r7, #12
 8006c8a:	46bd      	mov	sp, r7
 8006c8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c90:	4770      	bx	lr

08006c92 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
 8006c92:	b580      	push	{r7, lr}
 8006c94:	b082      	sub	sp, #8
 8006c96:	af00      	add	r7, sp, #0
 8006c98:	4603      	mov	r3, r0
 8006c9a:	80fb      	strh	r3, [r7, #6]
  return htons(n);
 8006c9c:	88fb      	ldrh	r3, [r7, #6]
 8006c9e:	4618      	mov	r0, r3
 8006ca0:	f7ff ffe2 	bl	8006c68 <htons>
 8006ca4:	4603      	mov	r3, r0
}
 8006ca6:	4618      	mov	r0, r3
 8006ca8:	3708      	adds	r7, #8
 8006caa:	46bd      	mov	sp, r7
 8006cac:	bd80      	pop	{r7, pc}

08006cae <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
 8006cae:	b480      	push	{r7}
 8006cb0:	b083      	sub	sp, #12
 8006cb2:	af00      	add	r7, sp, #0
 8006cb4:	6078      	str	r0, [r7, #4]
  return ((n & 0xff) << 24) |
 8006cb6:	687b      	ldr	r3, [r7, #4]
 8006cb8:	061a      	lsls	r2, r3, #24
    ((n & 0xff00) << 8) |
 8006cba:	687b      	ldr	r3, [r7, #4]
 8006cbc:	021b      	lsls	r3, r3, #8
 8006cbe:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  return ((n & 0xff) << 24) |
 8006cc2:	431a      	orrs	r2, r3
    ((n & 0xff0000UL) >> 8) |
 8006cc4:	687b      	ldr	r3, [r7, #4]
 8006cc6:	0a1b      	lsrs	r3, r3, #8
 8006cc8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    ((n & 0xff00) << 8) |
 8006ccc:	431a      	orrs	r2, r3
    ((n & 0xff000000UL) >> 24);
 8006cce:	687b      	ldr	r3, [r7, #4]
 8006cd0:	0e1b      	lsrs	r3, r3, #24
    ((n & 0xff0000UL) >> 8) |
 8006cd2:	4313      	orrs	r3, r2
}
 8006cd4:	4618      	mov	r0, r3
 8006cd6:	370c      	adds	r7, #12
 8006cd8:	46bd      	mov	sp, r7
 8006cda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006cde:	4770      	bx	lr

08006ce0 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
 8006ce0:	b580      	push	{r7, lr}
 8006ce2:	b082      	sub	sp, #8
 8006ce4:	af00      	add	r7, sp, #0
 8006ce6:	6078      	str	r0, [r7, #4]
  return htonl(n);
 8006ce8:	6878      	ldr	r0, [r7, #4]
 8006cea:	f7ff ffe0 	bl	8006cae <htonl>
 8006cee:	4603      	mov	r3, r0
}
 8006cf0:	4618      	mov	r0, r3
 8006cf2:	3708      	adds	r7, #8
 8006cf4:	46bd      	mov	sp, r7
 8006cf6:	bd80      	pop	{r7, pc}

08006cf8 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
 8006cf8:	b580      	push	{r7, lr}
 8006cfa:	b086      	sub	sp, #24
 8006cfc:	af00      	add	r7, sp, #0
 8006cfe:	6078      	str	r0, [r7, #4]
 8006d00:	460b      	mov	r3, r1
 8006d02:	807b      	strh	r3, [r7, #2]
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
 8006d04:	2300      	movs	r3, #0
 8006d06:	617b      	str	r3, [r7, #20]
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
 8006d08:	687b      	ldr	r3, [r7, #4]
 8006d0a:	613b      	str	r3, [r7, #16]
  while (len > 1) {
 8006d0c:	e017      	b.n	8006d3e <lwip_standard_chksum+0x46>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
 8006d0e:	693b      	ldr	r3, [r7, #16]
 8006d10:	781b      	ldrb	r3, [r3, #0]
 8006d12:	b29b      	uxth	r3, r3
 8006d14:	021b      	lsls	r3, r3, #8
 8006d16:	81fb      	strh	r3, [r7, #14]
    octetptr++;
 8006d18:	693b      	ldr	r3, [r7, #16]
 8006d1a:	3301      	adds	r3, #1
 8006d1c:	613b      	str	r3, [r7, #16]
    /* declare second octet as least significant */
    src |= (*octetptr);
 8006d1e:	693b      	ldr	r3, [r7, #16]
 8006d20:	781b      	ldrb	r3, [r3, #0]
 8006d22:	b29a      	uxth	r2, r3
 8006d24:	89fb      	ldrh	r3, [r7, #14]
 8006d26:	4313      	orrs	r3, r2
 8006d28:	81fb      	strh	r3, [r7, #14]
    octetptr++;
 8006d2a:	693b      	ldr	r3, [r7, #16]
 8006d2c:	3301      	adds	r3, #1
 8006d2e:	613b      	str	r3, [r7, #16]
    acc += src;
 8006d30:	89fb      	ldrh	r3, [r7, #14]
 8006d32:	697a      	ldr	r2, [r7, #20]
 8006d34:	4413      	add	r3, r2
 8006d36:	617b      	str	r3, [r7, #20]
    len -= 2;
 8006d38:	887b      	ldrh	r3, [r7, #2]
 8006d3a:	3b02      	subs	r3, #2
 8006d3c:	807b      	strh	r3, [r7, #2]
  while (len > 1) {
 8006d3e:	887b      	ldrh	r3, [r7, #2]
 8006d40:	2b01      	cmp	r3, #1
 8006d42:	d8e4      	bhi.n	8006d0e <lwip_standard_chksum+0x16>
  }
  if (len > 0) {
 8006d44:	887b      	ldrh	r3, [r7, #2]
 8006d46:	2b00      	cmp	r3, #0
 8006d48:	d008      	beq.n	8006d5c <lwip_standard_chksum+0x64>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
 8006d4a:	693b      	ldr	r3, [r7, #16]
 8006d4c:	781b      	ldrb	r3, [r3, #0]
 8006d4e:	b29b      	uxth	r3, r3
 8006d50:	021b      	lsls	r3, r3, #8
 8006d52:	81fb      	strh	r3, [r7, #14]
    acc += src;
 8006d54:	89fb      	ldrh	r3, [r7, #14]
 8006d56:	697a      	ldr	r2, [r7, #20]
 8006d58:	4413      	add	r3, r2
 8006d5a:	617b      	str	r3, [r7, #20]
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
 8006d5c:	697b      	ldr	r3, [r7, #20]
 8006d5e:	0c1a      	lsrs	r2, r3, #16
 8006d60:	697b      	ldr	r3, [r7, #20]
 8006d62:	b29b      	uxth	r3, r3
 8006d64:	4413      	add	r3, r2
 8006d66:	617b      	str	r3, [r7, #20]
  if ((acc & 0xffff0000UL) != 0) {
 8006d68:	697b      	ldr	r3, [r7, #20]
 8006d6a:	0c1b      	lsrs	r3, r3, #16
 8006d6c:	041b      	lsls	r3, r3, #16
 8006d6e:	2b00      	cmp	r3, #0
 8006d70:	d005      	beq.n	8006d7e <lwip_standard_chksum+0x86>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
 8006d72:	697b      	ldr	r3, [r7, #20]
 8006d74:	0c1a      	lsrs	r2, r3, #16
 8006d76:	697b      	ldr	r3, [r7, #20]
 8006d78:	b29b      	uxth	r3, r3
 8006d7a:	4413      	add	r3, r2
 8006d7c:	617b      	str	r3, [r7, #20]
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
 8006d7e:	697b      	ldr	r3, [r7, #20]
 8006d80:	b29b      	uxth	r3, r3
 8006d82:	4618      	mov	r0, r3
 8006d84:	f7ff ff70 	bl	8006c68 <htons>
 8006d88:	4603      	mov	r3, r0
}
 8006d8a:	4618      	mov	r0, r3
 8006d8c:	3718      	adds	r7, #24
 8006d8e:	46bd      	mov	sp, r7
 8006d90:	bd80      	pop	{r7, pc}

08006d92 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 8006d92:	b580      	push	{r7, lr}
 8006d94:	b082      	sub	sp, #8
 8006d96:	af00      	add	r7, sp, #0
 8006d98:	6078      	str	r0, [r7, #4]
 8006d9a:	460b      	mov	r3, r1
 8006d9c:	807b      	strh	r3, [r7, #2]
  return ~LWIP_CHKSUM(dataptr, len);
 8006d9e:	887b      	ldrh	r3, [r7, #2]
 8006da0:	4619      	mov	r1, r3
 8006da2:	6878      	ldr	r0, [r7, #4]
 8006da4:	f7ff ffa8 	bl	8006cf8 <lwip_standard_chksum>
 8006da8:	4603      	mov	r3, r0
 8006daa:	43db      	mvns	r3, r3
 8006dac:	b29b      	uxth	r3, r3
}
 8006dae:	4618      	mov	r0, r3
 8006db0:	3708      	adds	r7, #8
 8006db2:	46bd      	mov	sp, r7
 8006db4:	bd80      	pop	{r7, pc}

08006db6 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 8006db6:	b580      	push	{r7, lr}
 8006db8:	b086      	sub	sp, #24
 8006dba:	af00      	add	r7, sp, #0
 8006dbc:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 8006dbe:	2300      	movs	r3, #0
 8006dc0:	617b      	str	r3, [r7, #20]
  swapped = 0;
 8006dc2:	2300      	movs	r3, #0
 8006dc4:	73fb      	strb	r3, [r7, #15]
  for(q = p; q != NULL; q = q->next) {
 8006dc6:	687b      	ldr	r3, [r7, #4]
 8006dc8:	613b      	str	r3, [r7, #16]
 8006dca:	e028      	b.n	8006e1e <inet_chksum_pbuf+0x68>
    acc += LWIP_CHKSUM(q->payload, q->len);
 8006dcc:	693b      	ldr	r3, [r7, #16]
 8006dce:	685a      	ldr	r2, [r3, #4]
 8006dd0:	693b      	ldr	r3, [r7, #16]
 8006dd2:	895b      	ldrh	r3, [r3, #10]
 8006dd4:	4619      	mov	r1, r3
 8006dd6:	4610      	mov	r0, r2
 8006dd8:	f7ff ff8e 	bl	8006cf8 <lwip_standard_chksum>
 8006ddc:	4603      	mov	r3, r0
 8006dde:	461a      	mov	r2, r3
 8006de0:	697b      	ldr	r3, [r7, #20]
 8006de2:	4413      	add	r3, r2
 8006de4:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 8006de6:	697b      	ldr	r3, [r7, #20]
 8006de8:	0c1a      	lsrs	r2, r3, #16
 8006dea:	697b      	ldr	r3, [r7, #20]
 8006dec:	b29b      	uxth	r3, r3
 8006dee:	4413      	add	r3, r2
 8006df0:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 8006df2:	693b      	ldr	r3, [r7, #16]
 8006df4:	895b      	ldrh	r3, [r3, #10]
 8006df6:	f003 0301 	and.w	r3, r3, #1
 8006dfa:	b29b      	uxth	r3, r3
 8006dfc:	2b00      	cmp	r3, #0
 8006dfe:	d00b      	beq.n	8006e18 <inet_chksum_pbuf+0x62>
      swapped = 1 - swapped;
 8006e00:	7bfb      	ldrb	r3, [r7, #15]
 8006e02:	f1c3 0301 	rsb	r3, r3, #1
 8006e06:	73fb      	strb	r3, [r7, #15]
      acc = SWAP_BYTES_IN_WORD(acc);
 8006e08:	697b      	ldr	r3, [r7, #20]
 8006e0a:	021b      	lsls	r3, r3, #8
 8006e0c:	b29a      	uxth	r2, r3
 8006e0e:	697b      	ldr	r3, [r7, #20]
 8006e10:	0a1b      	lsrs	r3, r3, #8
 8006e12:	b2db      	uxtb	r3, r3
 8006e14:	4313      	orrs	r3, r2
 8006e16:	617b      	str	r3, [r7, #20]
  for(q = p; q != NULL; q = q->next) {
 8006e18:	693b      	ldr	r3, [r7, #16]
 8006e1a:	681b      	ldr	r3, [r3, #0]
 8006e1c:	613b      	str	r3, [r7, #16]
 8006e1e:	693b      	ldr	r3, [r7, #16]
 8006e20:	2b00      	cmp	r3, #0
 8006e22:	d1d3      	bne.n	8006dcc <inet_chksum_pbuf+0x16>
    }
  }

  if (swapped) {
 8006e24:	7bfb      	ldrb	r3, [r7, #15]
 8006e26:	2b00      	cmp	r3, #0
 8006e28:	d007      	beq.n	8006e3a <inet_chksum_pbuf+0x84>
    acc = SWAP_BYTES_IN_WORD(acc);
 8006e2a:	697b      	ldr	r3, [r7, #20]
 8006e2c:	021b      	lsls	r3, r3, #8
 8006e2e:	b29a      	uxth	r2, r3
 8006e30:	697b      	ldr	r3, [r7, #20]
 8006e32:	0a1b      	lsrs	r3, r3, #8
 8006e34:	b2db      	uxtb	r3, r3
 8006e36:	4313      	orrs	r3, r2
 8006e38:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 8006e3a:	697b      	ldr	r3, [r7, #20]
 8006e3c:	b29b      	uxth	r3, r3
 8006e3e:	43db      	mvns	r3, r3
 8006e40:	b29b      	uxth	r3, r3
}
 8006e42:	4618      	mov	r0, r3
 8006e44:	3718      	adds	r7, #24
 8006e46:	46bd      	mov	sp, r7
 8006e48:	bd80      	pop	{r7, pc}
	...

08006e4c <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
 8006e4c:	b580      	push	{r7, lr}
 8006e4e:	b084      	sub	sp, #16
 8006e50:	af00      	add	r7, sp, #0
 8006e52:	6078      	str	r0, [r7, #4]
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
 8006e54:	4b17      	ldr	r3, [pc, #92]	; (8006eb4 <ip_route+0x68>)
 8006e56:	681b      	ldr	r3, [r3, #0]
 8006e58:	60fb      	str	r3, [r7, #12]
 8006e5a:	e014      	b.n	8006e86 <ip_route+0x3a>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 8006e5c:	68f8      	ldr	r0, [r7, #12]
 8006e5e:	f001 fac2 	bl	80083e6 <netif_is_up>
 8006e62:	4603      	mov	r3, r0
 8006e64:	2b00      	cmp	r3, #0
 8006e66:	d00b      	beq.n	8006e80 <ip_route+0x34>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 8006e68:	687b      	ldr	r3, [r7, #4]
 8006e6a:	681a      	ldr	r2, [r3, #0]
 8006e6c:	68fb      	ldr	r3, [r7, #12]
 8006e6e:	685b      	ldr	r3, [r3, #4]
 8006e70:	405a      	eors	r2, r3
 8006e72:	68fb      	ldr	r3, [r7, #12]
 8006e74:	689b      	ldr	r3, [r3, #8]
 8006e76:	4013      	ands	r3, r2
 8006e78:	2b00      	cmp	r3, #0
 8006e7a:	d101      	bne.n	8006e80 <ip_route+0x34>
        /* return netif on which to forward IP packet */
        return netif;
 8006e7c:	68fb      	ldr	r3, [r7, #12]
 8006e7e:	e015      	b.n	8006eac <ip_route+0x60>
  for(netif = netif_list; netif != NULL; netif = netif->next) {
 8006e80:	68fb      	ldr	r3, [r7, #12]
 8006e82:	681b      	ldr	r3, [r3, #0]
 8006e84:	60fb      	str	r3, [r7, #12]
 8006e86:	68fb      	ldr	r3, [r7, #12]
 8006e88:	2b00      	cmp	r3, #0
 8006e8a:	d1e7      	bne.n	8006e5c <ip_route+0x10>
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 8006e8c:	4b0a      	ldr	r3, [pc, #40]	; (8006eb8 <ip_route+0x6c>)
 8006e8e:	681b      	ldr	r3, [r3, #0]
 8006e90:	2b00      	cmp	r3, #0
 8006e92:	d007      	beq.n	8006ea4 <ip_route+0x58>
 8006e94:	4b08      	ldr	r3, [pc, #32]	; (8006eb8 <ip_route+0x6c>)
 8006e96:	681b      	ldr	r3, [r3, #0]
 8006e98:	4618      	mov	r0, r3
 8006e9a:	f001 faa4 	bl	80083e6 <netif_is_up>
 8006e9e:	4603      	mov	r3, r0
 8006ea0:	2b00      	cmp	r3, #0
 8006ea2:	d101      	bne.n	8006ea8 <ip_route+0x5c>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
 8006ea4:	2300      	movs	r3, #0
 8006ea6:	e001      	b.n	8006eac <ip_route+0x60>
  }
  /* no matching netif found, use default netif */
  return netif_default;
 8006ea8:	4b03      	ldr	r3, [pc, #12]	; (8006eb8 <ip_route+0x6c>)
 8006eaa:	681b      	ldr	r3, [r3, #0]
}
 8006eac:	4618      	mov	r0, r3
 8006eae:	3710      	adds	r7, #16
 8006eb0:	46bd      	mov	sp, r7
 8006eb2:	bd80      	pop	{r7, pc}
 8006eb4:	2000a31c 	.word	0x2000a31c
 8006eb8:	2000a320 	.word	0x2000a320

08006ebc <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 8006ebc:	b590      	push	{r4, r7, lr}
 8006ebe:	b089      	sub	sp, #36	; 0x24
 8006ec0:	af00      	add	r7, sp, #0
 8006ec2:	6078      	str	r0, [r7, #4]
 8006ec4:	6039      	str	r1, [r7, #0]
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP || LWIP_UPNP
  int check_ip_src=1;
 8006ec6:	2301      	movs	r3, #1
 8006ec8:	617b      	str	r3, [r7, #20]

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
 8006eca:	687b      	ldr	r3, [r7, #4]
 8006ecc:	685b      	ldr	r3, [r3, #4]
 8006ece:	61fb      	str	r3, [r7, #28]
  if (IPH_V(iphdr) != 4) {
 8006ed0:	69fb      	ldr	r3, [r7, #28]
 8006ed2:	881b      	ldrh	r3, [r3, #0]
 8006ed4:	b29b      	uxth	r3, r3
 8006ed6:	4618      	mov	r0, r3
 8006ed8:	f7ff fedb 	bl	8006c92 <ntohs>
 8006edc:	4603      	mov	r3, r0
 8006ede:	0b1b      	lsrs	r3, r3, #12
 8006ee0:	b29b      	uxth	r3, r3
 8006ee2:	2b04      	cmp	r3, #4
 8006ee4:	d007      	beq.n	8006ef6 <ip_input+0x3a>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
 8006ee6:	6878      	ldr	r0, [r7, #4]
 8006ee8:	f000 fa19 	bl	800731e <ip_debug_print>
    pbuf_free(p);
 8006eec:	6878      	ldr	r0, [r7, #4]
 8006eee:	f001 fc5c 	bl	80087aa <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
 8006ef2:	2300      	movs	r3, #0
 8006ef4:	e118      	b.n	8007128 <ip_input+0x26c>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
 8006ef6:	69fb      	ldr	r3, [r7, #28]
 8006ef8:	881b      	ldrh	r3, [r3, #0]
 8006efa:	b29b      	uxth	r3, r3
 8006efc:	4618      	mov	r0, r3
 8006efe:	f7ff fec8 	bl	8006c92 <ntohs>
 8006f02:	4603      	mov	r3, r0
 8006f04:	0a1b      	lsrs	r3, r3, #8
 8006f06:	b29b      	uxth	r3, r3
 8006f08:	f003 030f 	and.w	r3, r3, #15
 8006f0c:	81fb      	strh	r3, [r7, #14]
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
 8006f0e:	89fb      	ldrh	r3, [r7, #14]
 8006f10:	009b      	lsls	r3, r3, #2
 8006f12:	81fb      	strh	r3, [r7, #14]
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 8006f14:	69fb      	ldr	r3, [r7, #28]
 8006f16:	885b      	ldrh	r3, [r3, #2]
 8006f18:	b29b      	uxth	r3, r3
 8006f1a:	4618      	mov	r0, r3
 8006f1c:	f7ff feb9 	bl	8006c92 <ntohs>
 8006f20:	4603      	mov	r3, r0
 8006f22:	81bb      	strh	r3, [r7, #12]

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 8006f24:	687b      	ldr	r3, [r7, #4]
 8006f26:	895b      	ldrh	r3, [r3, #10]
 8006f28:	89fa      	ldrh	r2, [r7, #14]
 8006f2a:	429a      	cmp	r2, r3
 8006f2c:	d804      	bhi.n	8006f38 <ip_input+0x7c>
 8006f2e:	687b      	ldr	r3, [r7, #4]
 8006f30:	891b      	ldrh	r3, [r3, #8]
 8006f32:	89ba      	ldrh	r2, [r7, #12]
 8006f34:	429a      	cmp	r2, r3
 8006f36:	d904      	bls.n	8006f42 <ip_input+0x86>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 8006f38:	6878      	ldr	r0, [r7, #4]
 8006f3a:	f001 fc36 	bl	80087aa <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
 8006f3e:	2300      	movs	r3, #0
 8006f40:	e0f2      	b.n	8007128 <ip_input+0x26c>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 8006f42:	89bb      	ldrh	r3, [r7, #12]
 8006f44:	4619      	mov	r1, r3
 8006f46:	6878      	ldr	r0, [r7, #4]
 8006f48:	f001 fb5c 	bl	8008604 <pbuf_realloc>
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 8006f4c:	2301      	movs	r3, #1
 8006f4e:	613b      	str	r3, [r7, #16]
    netif = inp;
 8006f50:	683b      	ldr	r3, [r7, #0]
 8006f52:	61bb      	str	r3, [r7, #24]
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 8006f54:	69b8      	ldr	r0, [r7, #24]
 8006f56:	f001 fa46 	bl	80083e6 <netif_is_up>
 8006f5a:	4603      	mov	r3, r0
 8006f5c:	2b00      	cmp	r3, #0
 8006f5e:	d016      	beq.n	8006f8e <ip_input+0xd2>
 8006f60:	69bb      	ldr	r3, [r7, #24]
 8006f62:	3304      	adds	r3, #4
 8006f64:	2b00      	cmp	r3, #0
 8006f66:	d012      	beq.n	8006f8e <ip_input+0xd2>
 8006f68:	69bb      	ldr	r3, [r7, #24]
 8006f6a:	685b      	ldr	r3, [r3, #4]
 8006f6c:	2b00      	cmp	r3, #0
 8006f6e:	d00e      	beq.n	8006f8e <ip_input+0xd2>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
 8006f70:	69fb      	ldr	r3, [r7, #28]
 8006f72:	691a      	ldr	r2, [r3, #16]
 8006f74:	69bb      	ldr	r3, [r7, #24]
 8006f76:	685b      	ldr	r3, [r3, #4]
 8006f78:	429a      	cmp	r2, r3
 8006f7a:	d01e      	beq.n	8006fba <ip_input+0xfe>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
 8006f7c:	69fb      	ldr	r3, [r7, #28]
 8006f7e:	3310      	adds	r3, #16
 8006f80:	69b9      	ldr	r1, [r7, #24]
 8006f82:	4618      	mov	r0, r3
 8006f84:	f000 f9db 	bl	800733e <ip_addr_isbroadcast>
 8006f88:	4603      	mov	r3, r0
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
 8006f8a:	2b00      	cmp	r3, #0
 8006f8c:	d115      	bne.n	8006fba <ip_input+0xfe>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
 8006f8e:	693b      	ldr	r3, [r7, #16]
 8006f90:	2b00      	cmp	r3, #0
 8006f92:	d005      	beq.n	8006fa0 <ip_input+0xe4>
        first = 0;
 8006f94:	2300      	movs	r3, #0
 8006f96:	613b      	str	r3, [r7, #16]
        netif = netif_list;
 8006f98:	4b65      	ldr	r3, [pc, #404]	; (8007130 <ip_input+0x274>)
 8006f9a:	681b      	ldr	r3, [r3, #0]
 8006f9c:	61bb      	str	r3, [r7, #24]
 8006f9e:	e002      	b.n	8006fa6 <ip_input+0xea>
      } else {
        netif = netif->next;
 8006fa0:	69bb      	ldr	r3, [r7, #24]
 8006fa2:	681b      	ldr	r3, [r3, #0]
 8006fa4:	61bb      	str	r3, [r7, #24]
      }
      if (netif == inp) {
 8006fa6:	69ba      	ldr	r2, [r7, #24]
 8006fa8:	683b      	ldr	r3, [r7, #0]
 8006faa:	429a      	cmp	r2, r3
 8006fac:	d102      	bne.n	8006fb4 <ip_input+0xf8>
        netif = netif->next;
 8006fae:	69bb      	ldr	r3, [r7, #24]
 8006fb0:	681b      	ldr	r3, [r3, #0]
 8006fb2:	61bb      	str	r3, [r7, #24]
      }
    } while(netif != NULL);
 8006fb4:	69bb      	ldr	r3, [r7, #24]
 8006fb6:	2b00      	cmp	r3, #0
 8006fb8:	d1cc      	bne.n	8006f54 <ip_input+0x98>
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
 8006fba:	69bb      	ldr	r3, [r7, #24]
 8006fbc:	2b00      	cmp	r3, #0
 8006fbe:	d118      	bne.n	8006ff2 <ip_input+0x136>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 8006fc0:	69fb      	ldr	r3, [r7, #28]
 8006fc2:	891b      	ldrh	r3, [r3, #8]
 8006fc4:	b29b      	uxth	r3, r3
 8006fc6:	4618      	mov	r0, r3
 8006fc8:	f7ff fe63 	bl	8006c92 <ntohs>
 8006fcc:	4603      	mov	r3, r0
 8006fce:	b2db      	uxtb	r3, r3
 8006fd0:	2b11      	cmp	r3, #17
 8006fd2:	d10e      	bne.n	8006ff2 <ip_input+0x136>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
 8006fd4:	89fb      	ldrh	r3, [r7, #14]
 8006fd6:	69fa      	ldr	r2, [r7, #28]
 8006fd8:	4413      	add	r3, r2
 8006fda:	885b      	ldrh	r3, [r3, #2]
 8006fdc:	b29b      	uxth	r3, r3
 8006fde:	4618      	mov	r0, r3
 8006fe0:	f7ff fe57 	bl	8006c92 <ntohs>
 8006fe4:	4603      	mov	r3, r0
 8006fe6:	2b44      	cmp	r3, #68	; 0x44
 8006fe8:	d103      	bne.n	8006ff2 <ip_input+0x136>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
 8006fea:	683b      	ldr	r3, [r7, #0]
 8006fec:	61bb      	str	r3, [r7, #24]
        check_ip_src = 0;
 8006fee:	2300      	movs	r3, #0
 8006ff0:	617b      	str	r3, [r7, #20]
#endif /* LWIP_UPNP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP || LWIP_UPNP
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && (iphdr->src.addr != 0))
 8006ff2:	697b      	ldr	r3, [r7, #20]
 8006ff4:	2b00      	cmp	r3, #0
 8006ff6:	d020      	beq.n	800703a <ip_input+0x17e>
 8006ff8:	69fb      	ldr	r3, [r7, #28]
 8006ffa:	68db      	ldr	r3, [r3, #12]
 8006ffc:	2b00      	cmp	r3, #0
 8006ffe:	d01c      	beq.n	800703a <ip_input+0x17e>
#endif /* LWIP_DHCP || LWIP_UPNP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
 8007000:	69fb      	ldr	r3, [r7, #28]
 8007002:	330c      	adds	r3, #12
 8007004:	6839      	ldr	r1, [r7, #0]
 8007006:	4618      	mov	r0, r3
 8007008:	f000 f999 	bl	800733e <ip_addr_isbroadcast>
 800700c:	4603      	mov	r3, r0
 800700e:	2b00      	cmp	r3, #0
 8007010:	d10e      	bne.n	8007030 <ip_input+0x174>
         (ip_addr_ismulticast(&(iphdr->src)))) {
 8007012:	69fb      	ldr	r3, [r7, #28]
 8007014:	68dc      	ldr	r4, [r3, #12]
 8007016:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 800701a:	f7ff fe61 	bl	8006ce0 <ntohl>
 800701e:	4603      	mov	r3, r0
 8007020:	401c      	ands	r4, r3
 8007022:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8007026:	f7ff fe5b 	bl	8006ce0 <ntohl>
 800702a:	4603      	mov	r3, r0
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
 800702c:	429c      	cmp	r4, r3
 800702e:	d104      	bne.n	800703a <ip_input+0x17e>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 8007030:	6878      	ldr	r0, [r7, #4]
 8007032:	f001 fbba 	bl	80087aa <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
 8007036:	2300      	movs	r3, #0
 8007038:	e076      	b.n	8007128 <ip_input+0x26c>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 800703a:	69bb      	ldr	r3, [r7, #24]
 800703c:	2b00      	cmp	r3, #0
 800703e:	d104      	bne.n	800704a <ip_input+0x18e>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
 8007040:	6878      	ldr	r0, [r7, #4]
 8007042:	f001 fbb2 	bl	80087aa <pbuf_free>
    return ERR_OK;
 8007046:	2300      	movs	r3, #0
 8007048:	e06e      	b.n	8007128 <ip_input+0x26c>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
 800704a:	69fb      	ldr	r3, [r7, #28]
 800704c:	88db      	ldrh	r3, [r3, #6]
 800704e:	b29c      	uxth	r4, r3
 8007050:	f643 70ff 	movw	r0, #16383	; 0x3fff
 8007054:	f7ff fe08 	bl	8006c68 <htons>
 8007058:	4603      	mov	r3, r0
 800705a:	4023      	ands	r3, r4
 800705c:	b29b      	uxth	r3, r3
 800705e:	2b00      	cmp	r3, #0
 8007060:	d00b      	beq.n	800707a <ip_input+0x1be>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 8007062:	6878      	ldr	r0, [r7, #4]
 8007064:	f000 fbc2 	bl	80077ec <ip_reass>
 8007068:	6078      	str	r0, [r7, #4]
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 800706a:	687b      	ldr	r3, [r7, #4]
 800706c:	2b00      	cmp	r3, #0
 800706e:	d101      	bne.n	8007074 <ip_input+0x1b8>
      return ERR_OK;
 8007070:	2300      	movs	r3, #0
 8007072:	e059      	b.n	8007128 <ip_input+0x26c>
    }
    iphdr = p->payload;
 8007074:	687b      	ldr	r3, [r7, #4]
 8007076:	685b      	ldr	r3, [r3, #4]
 8007078:	61fb      	str	r3, [r7, #28]
  }
#endif /* IP_OPTIONS_ALLOWED == 0 */

  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
 800707a:	6878      	ldr	r0, [r7, #4]
 800707c:	f000 f94f 	bl	800731e <ip_debug_print>
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 8007080:	4a2c      	ldr	r2, [pc, #176]	; (8007134 <ip_input+0x278>)
 8007082:	683b      	ldr	r3, [r7, #0]
 8007084:	6013      	str	r3, [r2, #0]
  current_header = iphdr;
 8007086:	4a2c      	ldr	r2, [pc, #176]	; (8007138 <ip_input+0x27c>)
 8007088:	69fb      	ldr	r3, [r7, #28]
 800708a:	6013      	str	r3, [r2, #0]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 800708c:	6839      	ldr	r1, [r7, #0]
 800708e:	6878      	ldr	r0, [r7, #4]
 8007090:	f001 fd26 	bl	8008ae0 <raw_input>
 8007094:	4603      	mov	r3, r0
 8007096:	2b00      	cmp	r3, #0
 8007098:	d13f      	bne.n	800711a <ip_input+0x25e>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
 800709a:	69fb      	ldr	r3, [r7, #28]
 800709c:	891b      	ldrh	r3, [r3, #8]
 800709e:	b29b      	uxth	r3, r3
 80070a0:	4618      	mov	r0, r3
 80070a2:	f7ff fdf6 	bl	8006c92 <ntohs>
 80070a6:	4603      	mov	r3, r0
 80070a8:	b2db      	uxtb	r3, r3
 80070aa:	2b06      	cmp	r3, #6
 80070ac:	d009      	beq.n	80070c2 <ip_input+0x206>
 80070ae:	2b11      	cmp	r3, #17
 80070b0:	d002      	beq.n	80070b8 <ip_input+0x1fc>
 80070b2:	2b01      	cmp	r3, #1
 80070b4:	d00a      	beq.n	80070cc <ip_input+0x210>
 80070b6:	e00e      	b.n	80070d6 <ip_input+0x21a>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 80070b8:	6839      	ldr	r1, [r7, #0]
 80070ba:	6878      	ldr	r0, [r7, #4]
 80070bc:	f005 fa46 	bl	800c54c <udp_input>
      break;
 80070c0:	e02b      	b.n	800711a <ip_input+0x25e>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 80070c2:	6839      	ldr	r1, [r7, #0]
 80070c4:	6878      	ldr	r0, [r7, #4]
 80070c6:	f002 fdd5 	bl	8009c74 <tcp_input>
      break;
 80070ca:	e026      	b.n	800711a <ip_input+0x25e>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 80070cc:	6839      	ldr	r1, [r7, #0]
 80070ce:	6878      	ldr	r0, [r7, #4]
 80070d0:	f7ff fc50 	bl	8006974 <icmp_input>
      break;
 80070d4:	e021      	b.n	800711a <ip_input+0x25e>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
 80070d6:	69fb      	ldr	r3, [r7, #28]
 80070d8:	3310      	adds	r3, #16
 80070da:	6839      	ldr	r1, [r7, #0]
 80070dc:	4618      	mov	r0, r3
 80070de:	f000 f92e 	bl	800733e <ip_addr_isbroadcast>
 80070e2:	4603      	mov	r3, r0
 80070e4:	2b00      	cmp	r3, #0
 80070e6:	d115      	bne.n	8007114 <ip_input+0x258>
          !ip_addr_ismulticast(&(iphdr->dest))) {
 80070e8:	69fb      	ldr	r3, [r7, #28]
 80070ea:	691c      	ldr	r4, [r3, #16]
 80070ec:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 80070f0:	f7ff fdf6 	bl	8006ce0 <ntohl>
 80070f4:	4603      	mov	r3, r0
 80070f6:	401c      	ands	r4, r3
 80070f8:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 80070fc:	f7ff fdf0 	bl	8006ce0 <ntohl>
 8007100:	4603      	mov	r3, r0
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
 8007102:	429c      	cmp	r4, r3
 8007104:	d006      	beq.n	8007114 <ip_input+0x258>
        p->payload = iphdr;
 8007106:	687b      	ldr	r3, [r7, #4]
 8007108:	69fa      	ldr	r2, [r7, #28]
 800710a:	605a      	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 800710c:	2102      	movs	r1, #2
 800710e:	6878      	ldr	r0, [r7, #4]
 8007110:	f7ff fd36 	bl	8006b80 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 8007114:	6878      	ldr	r0, [r7, #4]
 8007116:	f001 fb48 	bl	80087aa <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 800711a:	4b06      	ldr	r3, [pc, #24]	; (8007134 <ip_input+0x278>)
 800711c:	2200      	movs	r2, #0
 800711e:	601a      	str	r2, [r3, #0]
  current_header = NULL;
 8007120:	4b05      	ldr	r3, [pc, #20]	; (8007138 <ip_input+0x27c>)
 8007122:	2200      	movs	r2, #0
 8007124:	601a      	str	r2, [r3, #0]

  return ERR_OK;
 8007126:	2300      	movs	r3, #0
}
 8007128:	4618      	mov	r0, r3
 800712a:	3724      	adds	r7, #36	; 0x24
 800712c:	46bd      	mov	sp, r7
 800712e:	bd90      	pop	{r4, r7, pc}
 8007130:	2000a31c 	.word	0x2000a31c
 8007134:	2000a314 	.word	0x2000a314
 8007138:	2000a318 	.word	0x2000a318

0800713c <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800713c:	b590      	push	{r4, r7, lr}
 800713e:	b087      	sub	sp, #28
 8007140:	af00      	add	r7, sp, #0
 8007142:	60f8      	str	r0, [r7, #12]
 8007144:	60b9      	str	r1, [r7, #8]
 8007146:	607a      	str	r2, [r7, #4]
 8007148:	70fb      	strb	r3, [r7, #3]
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 800714a:	687b      	ldr	r3, [r7, #4]
 800714c:	2b00      	cmp	r3, #0
 800714e:	f000 809a 	beq.w	8007286 <ip_output_if+0x14a>
    u16_t ip_hlen = IP_HLEN;
 8007152:	2314      	movs	r3, #20
 8007154:	82fb      	strh	r3, [r7, #22]
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
      }
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 8007156:	2114      	movs	r1, #20
 8007158:	68f8      	ldr	r0, [r7, #12]
 800715a:	f001 fab7 	bl	80086cc <pbuf_header>
 800715e:	4603      	mov	r3, r0
 8007160:	2b00      	cmp	r3, #0
 8007162:	d002      	beq.n	800716a <ip_output_if+0x2e>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 8007164:	f06f 0301 	mvn.w	r3, #1
 8007168:	e0ae      	b.n	80072c8 <ip_output_if+0x18c>
    }

    iphdr = p->payload;
 800716a:	68fb      	ldr	r3, [r7, #12]
 800716c:	685b      	ldr	r3, [r3, #4]
 800716e:	613b      	str	r3, [r7, #16]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8007170:	693b      	ldr	r3, [r7, #16]
 8007172:	891b      	ldrh	r3, [r3, #8]
 8007174:	b29b      	uxth	r3, r3
 8007176:	4618      	mov	r0, r3
 8007178:	f7ff fd8b 	bl	8006c92 <ntohs>
 800717c:	4603      	mov	r3, r0
 800717e:	b21b      	sxth	r3, r3
 8007180:	b2db      	uxtb	r3, r3
 8007182:	b21a      	sxth	r2, r3
 8007184:	78fb      	ldrb	r3, [r7, #3]
 8007186:	021b      	lsls	r3, r3, #8
 8007188:	b21b      	sxth	r3, r3
 800718a:	4313      	orrs	r3, r2
 800718c:	b21b      	sxth	r3, r3
 800718e:	b29b      	uxth	r3, r3
 8007190:	4618      	mov	r0, r3
 8007192:	f7ff fd69 	bl	8006c68 <htons>
 8007196:	4603      	mov	r3, r0
 8007198:	461a      	mov	r2, r3
 800719a:	693b      	ldr	r3, [r7, #16]
 800719c:	811a      	strh	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 800719e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 80071a2:	b21c      	sxth	r4, r3
 80071a4:	693b      	ldr	r3, [r7, #16]
 80071a6:	891b      	ldrh	r3, [r3, #8]
 80071a8:	b29b      	uxth	r3, r3
 80071aa:	4618      	mov	r0, r3
 80071ac:	f7ff fd71 	bl	8006c92 <ntohs>
 80071b0:	4603      	mov	r3, r0
 80071b2:	0a1b      	lsrs	r3, r3, #8
 80071b4:	b29b      	uxth	r3, r3
 80071b6:	021b      	lsls	r3, r3, #8
 80071b8:	b21b      	sxth	r3, r3
 80071ba:	4323      	orrs	r3, r4
 80071bc:	b21b      	sxth	r3, r3
 80071be:	b29b      	uxth	r3, r3
 80071c0:	4618      	mov	r0, r3
 80071c2:	f7ff fd51 	bl	8006c68 <htons>
 80071c6:	4603      	mov	r3, r0
 80071c8:	461a      	mov	r2, r3
 80071ca:	693b      	ldr	r3, [r7, #16]
 80071cc:	811a      	strh	r2, [r3, #8]

    ip_addr_set(&(iphdr->dest), dest);
 80071ce:	687b      	ldr	r3, [r7, #4]
 80071d0:	2b00      	cmp	r3, #0
 80071d2:	d002      	beq.n	80071da <ip_output_if+0x9e>
 80071d4:	687b      	ldr	r3, [r7, #4]
 80071d6:	681b      	ldr	r3, [r3, #0]
 80071d8:	e000      	b.n	80071dc <ip_output_if+0xa0>
 80071da:	2300      	movs	r3, #0
 80071dc:	693a      	ldr	r2, [r7, #16]
 80071de:	6113      	str	r3, [r2, #16]

    IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
 80071e0:	8afb      	ldrh	r3, [r7, #22]
 80071e2:	089b      	lsrs	r3, r3, #2
 80071e4:	b29b      	uxth	r3, r3
 80071e6:	021b      	lsls	r3, r3, #8
 80071e8:	b21b      	sxth	r3, r3
 80071ea:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80071ee:	b21a      	sxth	r2, r3
 80071f0:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80071f4:	b21b      	sxth	r3, r3
 80071f6:	4313      	orrs	r3, r2
 80071f8:	b21b      	sxth	r3, r3
 80071fa:	b29b      	uxth	r3, r3
 80071fc:	4618      	mov	r0, r3
 80071fe:	f7ff fd33 	bl	8006c68 <htons>
 8007202:	4603      	mov	r3, r0
 8007204:	461a      	mov	r2, r3
 8007206:	693b      	ldr	r3, [r7, #16]
 8007208:	801a      	strh	r2, [r3, #0]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800720a:	68fb      	ldr	r3, [r7, #12]
 800720c:	891b      	ldrh	r3, [r3, #8]
 800720e:	4618      	mov	r0, r3
 8007210:	f7ff fd2a 	bl	8006c68 <htons>
 8007214:	4603      	mov	r3, r0
 8007216:	461a      	mov	r2, r3
 8007218:	693b      	ldr	r3, [r7, #16]
 800721a:	805a      	strh	r2, [r3, #2]
    IPH_OFFSET_SET(iphdr, 0);
 800721c:	693b      	ldr	r3, [r7, #16]
 800721e:	2200      	movs	r2, #0
 8007220:	719a      	strb	r2, [r3, #6]
 8007222:	2200      	movs	r2, #0
 8007224:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 8007226:	4b2a      	ldr	r3, [pc, #168]	; (80072d0 <ip_output_if+0x194>)
 8007228:	881b      	ldrh	r3, [r3, #0]
 800722a:	4618      	mov	r0, r3
 800722c:	f7ff fd1c 	bl	8006c68 <htons>
 8007230:	4603      	mov	r3, r0
 8007232:	461a      	mov	r2, r3
 8007234:	693b      	ldr	r3, [r7, #16]
 8007236:	809a      	strh	r2, [r3, #4]
    ++ip_id;
 8007238:	4b25      	ldr	r3, [pc, #148]	; (80072d0 <ip_output_if+0x194>)
 800723a:	881b      	ldrh	r3, [r3, #0]
 800723c:	3301      	adds	r3, #1
 800723e:	b29a      	uxth	r2, r3
 8007240:	4b23      	ldr	r3, [pc, #140]	; (80072d0 <ip_output_if+0x194>)
 8007242:	801a      	strh	r2, [r3, #0]

    if (ip_addr_isany(src)) {
 8007244:	68bb      	ldr	r3, [r7, #8]
 8007246:	2b00      	cmp	r3, #0
 8007248:	d003      	beq.n	8007252 <ip_output_if+0x116>
 800724a:	68bb      	ldr	r3, [r7, #8]
 800724c:	681b      	ldr	r3, [r3, #0]
 800724e:	2b00      	cmp	r3, #0
 8007250:	d10a      	bne.n	8007268 <ip_output_if+0x12c>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
 8007252:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007254:	3304      	adds	r3, #4
 8007256:	2b00      	cmp	r3, #0
 8007258:	d002      	beq.n	8007260 <ip_output_if+0x124>
 800725a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800725c:	685b      	ldr	r3, [r3, #4]
 800725e:	e000      	b.n	8007262 <ip_output_if+0x126>
 8007260:	2300      	movs	r3, #0
 8007262:	693a      	ldr	r2, [r7, #16]
 8007264:	60d3      	str	r3, [r2, #12]
 8007266:	e008      	b.n	800727a <ip_output_if+0x13e>
    } else {
      ip_addr_set(&(iphdr->src), src);
 8007268:	68bb      	ldr	r3, [r7, #8]
 800726a:	2b00      	cmp	r3, #0
 800726c:	d002      	beq.n	8007274 <ip_output_if+0x138>
 800726e:	68bb      	ldr	r3, [r7, #8]
 8007270:	681b      	ldr	r3, [r3, #0]
 8007272:	e000      	b.n	8007276 <ip_output_if+0x13a>
 8007274:	2300      	movs	r3, #0
 8007276:	693a      	ldr	r2, [r7, #16]
 8007278:	60d3      	str	r3, [r2, #12]
    }

    IPH_CHKSUM_SET(iphdr, 0);
 800727a:	693b      	ldr	r3, [r7, #16]
 800727c:	2200      	movs	r2, #0
 800727e:	729a      	strb	r2, [r3, #10]
 8007280:	2200      	movs	r2, #0
 8007282:	72da      	strb	r2, [r3, #11]
 8007284:	e005      	b.n	8007292 <ip_output_if+0x156>
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
 8007286:	68fb      	ldr	r3, [r7, #12]
 8007288:	685b      	ldr	r3, [r3, #4]
 800728a:	613b      	str	r3, [r7, #16]
    dest = &(iphdr->dest);
 800728c:	693b      	ldr	r3, [r7, #16]
 800728e:	3310      	adds	r3, #16
 8007290:	607b      	str	r3, [r7, #4]
  }

  IP_STATS_INC(ip.xmit);

  LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
  ip_debug_print(p);
 8007292:	68f8      	ldr	r0, [r7, #12]
 8007294:	f000 f843 	bl	800731e <ip_debug_print>
    return netif_loop_output(netif, p, dest);
  }
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 8007298:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800729a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800729c:	2b00      	cmp	r3, #0
 800729e:	d00c      	beq.n	80072ba <ip_output_if+0x17e>
 80072a0:	68fb      	ldr	r3, [r7, #12]
 80072a2:	891a      	ldrh	r2, [r3, #8]
 80072a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80072a6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80072a8:	429a      	cmp	r2, r3
 80072aa:	d906      	bls.n	80072ba <ip_output_if+0x17e>
    return ip_frag(p,netif,dest);
 80072ac:	687a      	ldr	r2, [r7, #4]
 80072ae:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80072b0:	68f8      	ldr	r0, [r7, #12]
 80072b2:	f000 fbcd 	bl	8007a50 <ip_frag>
 80072b6:	4603      	mov	r3, r0
 80072b8:	e006      	b.n	80072c8 <ip_output_if+0x18c>
  }
#endif

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 80072ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80072bc:	695b      	ldr	r3, [r3, #20]
 80072be:	687a      	ldr	r2, [r7, #4]
 80072c0:	68f9      	ldr	r1, [r7, #12]
 80072c2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80072c4:	4798      	blx	r3
 80072c6:	4603      	mov	r3, r0
}
 80072c8:	4618      	mov	r0, r3
 80072ca:	371c      	adds	r7, #28
 80072cc:	46bd      	mov	sp, r7
 80072ce:	bd90      	pop	{r4, r7, pc}
 80072d0:	200029e8 	.word	0x200029e8

080072d4 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 80072d4:	b580      	push	{r7, lr}
 80072d6:	b08a      	sub	sp, #40	; 0x28
 80072d8:	af04      	add	r7, sp, #16
 80072da:	60f8      	str	r0, [r7, #12]
 80072dc:	60b9      	str	r1, [r7, #8]
 80072de:	607a      	str	r2, [r7, #4]
 80072e0:	70fb      	strb	r3, [r7, #3]
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
 80072e2:	6878      	ldr	r0, [r7, #4]
 80072e4:	f7ff fdb2 	bl	8006e4c <ip_route>
 80072e8:	6178      	str	r0, [r7, #20]
 80072ea:	697b      	ldr	r3, [r7, #20]
 80072ec:	2b00      	cmp	r3, #0
 80072ee:	d102      	bne.n	80072f6 <ip_output+0x22>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
 80072f0:	f06f 0303 	mvn.w	r3, #3
 80072f4:	e00f      	b.n	8007316 <ip_output+0x42>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 80072f6:	78fa      	ldrb	r2, [r7, #3]
 80072f8:	697b      	ldr	r3, [r7, #20]
 80072fa:	9302      	str	r3, [sp, #8]
 80072fc:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8007300:	9301      	str	r3, [sp, #4]
 8007302:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007306:	9300      	str	r3, [sp, #0]
 8007308:	4613      	mov	r3, r2
 800730a:	687a      	ldr	r2, [r7, #4]
 800730c:	68b9      	ldr	r1, [r7, #8]
 800730e:	68f8      	ldr	r0, [r7, #12]
 8007310:	f7ff ff14 	bl	800713c <ip_output_if>
 8007314:	4603      	mov	r3, r0
}
 8007316:	4618      	mov	r0, r3
 8007318:	3718      	adds	r7, #24
 800731a:	46bd      	mov	sp, r7
 800731c:	bd80      	pop	{r7, pc}

0800731e <ip_debug_print>:
/* Print an IP header by using LWIP_DEBUGF
 * @param p an IP packet, p->payload pointing to the IP header
 */
void
ip_debug_print(struct pbuf *p)
{
 800731e:	b480      	push	{r7}
 8007320:	b085      	sub	sp, #20
 8007322:	af00      	add	r7, sp, #0
 8007324:	6078      	str	r0, [r7, #4]
  struct ip_hdr *iphdr = p->payload;
 8007326:	687b      	ldr	r3, [r7, #4]
 8007328:	685b      	ldr	r3, [r3, #4]
 800732a:	60fb      	str	r3, [r7, #12]
  u8_t *payload;

  payload = (u8_t *)iphdr + IP_HLEN;
 800732c:	68fb      	ldr	r3, [r7, #12]
 800732e:	3314      	adds	r3, #20
 8007330:	60bb      	str	r3, [r7, #8]
                    ip4_addr1(&iphdr->dest),
                    ip4_addr2(&iphdr->dest),
                    ip4_addr3(&iphdr->dest),
                    ip4_addr4(&iphdr->dest)));
  LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
}
 8007332:	bf00      	nop
 8007334:	3714      	adds	r7, #20
 8007336:	46bd      	mov	sp, r7
 8007338:	f85d 7b04 	ldr.w	r7, [sp], #4
 800733c:	4770      	bx	lr

0800733e <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
 800733e:	b480      	push	{r7}
 8007340:	b085      	sub	sp, #20
 8007342:	af00      	add	r7, sp, #0
 8007344:	6078      	str	r0, [r7, #4]
 8007346:	6039      	str	r1, [r7, #0]
  u32_t addr2test;

  addr2test = addr->addr;
 8007348:	687b      	ldr	r3, [r7, #4]
 800734a:	681b      	ldr	r3, [r3, #0]
 800734c:	60fb      	str	r3, [r7, #12]
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
 800734e:	68fb      	ldr	r3, [r7, #12]
 8007350:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007354:	d002      	beq.n	800735c <ip_addr_isbroadcast+0x1e>
 8007356:	68fb      	ldr	r3, [r7, #12]
 8007358:	2b00      	cmp	r3, #0
 800735a:	d101      	bne.n	8007360 <ip_addr_isbroadcast+0x22>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
 800735c:	2301      	movs	r3, #1
 800735e:	e026      	b.n	80073ae <ip_addr_isbroadcast+0x70>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
 8007360:	683b      	ldr	r3, [r7, #0]
 8007362:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8007366:	f003 0302 	and.w	r3, r3, #2
 800736a:	2b00      	cmp	r3, #0
 800736c:	d101      	bne.n	8007372 <ip_addr_isbroadcast+0x34>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 800736e:	2300      	movs	r3, #0
 8007370:	e01d      	b.n	80073ae <ip_addr_isbroadcast+0x70>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
 8007372:	683b      	ldr	r3, [r7, #0]
 8007374:	685a      	ldr	r2, [r3, #4]
 8007376:	68fb      	ldr	r3, [r7, #12]
 8007378:	429a      	cmp	r2, r3
 800737a:	d101      	bne.n	8007380 <ip_addr_isbroadcast+0x42>
    return 0;
 800737c:	2300      	movs	r3, #0
 800737e:	e016      	b.n	80073ae <ip_addr_isbroadcast+0x70>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
 8007380:	687b      	ldr	r3, [r7, #4]
 8007382:	681a      	ldr	r2, [r3, #0]
 8007384:	683b      	ldr	r3, [r7, #0]
 8007386:	685b      	ldr	r3, [r3, #4]
 8007388:	405a      	eors	r2, r3
 800738a:	683b      	ldr	r3, [r7, #0]
 800738c:	689b      	ldr	r3, [r3, #8]
 800738e:	4013      	ands	r3, r2
 8007390:	2b00      	cmp	r3, #0
 8007392:	d10b      	bne.n	80073ac <ip_addr_isbroadcast+0x6e>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
 8007394:	683b      	ldr	r3, [r7, #0]
 8007396:	689b      	ldr	r3, [r3, #8]
 8007398:	43da      	mvns	r2, r3
 800739a:	68fb      	ldr	r3, [r7, #12]
 800739c:	401a      	ands	r2, r3
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
 800739e:	683b      	ldr	r3, [r7, #0]
 80073a0:	689b      	ldr	r3, [r3, #8]
 80073a2:	43db      	mvns	r3, r3
          && ((addr2test & ~netif->netmask.addr) ==
 80073a4:	429a      	cmp	r2, r3
 80073a6:	d101      	bne.n	80073ac <ip_addr_isbroadcast+0x6e>
    /* => network broadcast address */
    return 1;
 80073a8:	2301      	movs	r3, #1
 80073aa:	e000      	b.n	80073ae <ip_addr_isbroadcast+0x70>
  else
    return 0;
 80073ac:	2300      	movs	r3, #0
}
 80073ae:	4618      	mov	r0, r3
 80073b0:	3714      	adds	r7, #20
 80073b2:	46bd      	mov	sp, r7
 80073b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80073b8:	4770      	bx	lr
	...

080073bc <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 80073bc:	b580      	push	{r7, lr}
 80073be:	b086      	sub	sp, #24
 80073c0:	af00      	add	r7, sp, #0
 80073c2:	6078      	str	r0, [r7, #4]
 80073c4:	6039      	str	r1, [r7, #0]
  int pbufs_freed = 0;
 80073c6:	2300      	movs	r3, #0
 80073c8:	617b      	str	r3, [r7, #20]
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  if (prev != NULL) {
 80073ca:	683b      	ldr	r3, [r7, #0]
 80073cc:	2b00      	cmp	r3, #0
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 80073ce:	687b      	ldr	r3, [r7, #4]
 80073d0:	685b      	ldr	r3, [r3, #4]
 80073d2:	685b      	ldr	r3, [r3, #4]
 80073d4:	60fb      	str	r3, [r7, #12]
  if (iprh->start == 0) {
 80073d6:	68fb      	ldr	r3, [r7, #12]
 80073d8:	889b      	ldrh	r3, [r3, #4]
 80073da:	b29b      	uxth	r3, r3
 80073dc:	2b00      	cmp	r3, #0
 80073de:	d11d      	bne.n	800741c <ip_reass_free_complete_datagram+0x60>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
 80073e0:	687b      	ldr	r3, [r7, #4]
 80073e2:	685b      	ldr	r3, [r3, #4]
 80073e4:	613b      	str	r3, [r7, #16]
    ipr->p = iprh->next_pbuf;
 80073e6:	68fb      	ldr	r3, [r7, #12]
 80073e8:	681a      	ldr	r2, [r3, #0]
 80073ea:	687b      	ldr	r3, [r7, #4]
 80073ec:	605a      	str	r2, [r3, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 80073ee:	693b      	ldr	r3, [r7, #16]
 80073f0:	6858      	ldr	r0, [r3, #4]
 80073f2:	687b      	ldr	r3, [r7, #4]
 80073f4:	3308      	adds	r3, #8
 80073f6:	2214      	movs	r2, #20
 80073f8:	4619      	mov	r1, r3
 80073fa:	f007 f934 	bl	800e666 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 80073fe:	2101      	movs	r1, #1
 8007400:	6938      	ldr	r0, [r7, #16]
 8007402:	f7ff fbcd 	bl	8006ba0 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
 8007406:	6938      	ldr	r0, [r7, #16]
 8007408:	f001 fa1e 	bl	8008848 <pbuf_clen>
 800740c:	4603      	mov	r3, r0
 800740e:	461a      	mov	r2, r3
 8007410:	697b      	ldr	r3, [r7, #20]
 8007412:	4413      	add	r3, r2
 8007414:	617b      	str	r3, [r7, #20]
    pbuf_free(p);
 8007416:	6938      	ldr	r0, [r7, #16]
 8007418:	f001 f9c7 	bl	80087aa <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 800741c:	687b      	ldr	r3, [r7, #4]
 800741e:	685b      	ldr	r3, [r3, #4]
 8007420:	613b      	str	r3, [r7, #16]
  while (p != NULL) {
 8007422:	e012      	b.n	800744a <ip_reass_free_complete_datagram+0x8e>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 8007424:	693b      	ldr	r3, [r7, #16]
 8007426:	685b      	ldr	r3, [r3, #4]
 8007428:	60fb      	str	r3, [r7, #12]
    pcur = p;
 800742a:	693b      	ldr	r3, [r7, #16]
 800742c:	60bb      	str	r3, [r7, #8]
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 800742e:	68fb      	ldr	r3, [r7, #12]
 8007430:	681b      	ldr	r3, [r3, #0]
 8007432:	613b      	str	r3, [r7, #16]
    pbufs_freed += pbuf_clen(pcur);
 8007434:	68b8      	ldr	r0, [r7, #8]
 8007436:	f001 fa07 	bl	8008848 <pbuf_clen>
 800743a:	4603      	mov	r3, r0
 800743c:	461a      	mov	r2, r3
 800743e:	697b      	ldr	r3, [r7, #20]
 8007440:	4413      	add	r3, r2
 8007442:	617b      	str	r3, [r7, #20]
    pbuf_free(pcur);    
 8007444:	68b8      	ldr	r0, [r7, #8]
 8007446:	f001 f9b0 	bl	80087aa <pbuf_free>
  while (p != NULL) {
 800744a:	693b      	ldr	r3, [r7, #16]
 800744c:	2b00      	cmp	r3, #0
 800744e:	d1e9      	bne.n	8007424 <ip_reass_free_complete_datagram+0x68>
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 8007450:	6839      	ldr	r1, [r7, #0]
 8007452:	6878      	ldr	r0, [r7, #4]
 8007454:	f000 f8a6 	bl	80075a4 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 8007458:	4b06      	ldr	r3, [pc, #24]	; (8007474 <ip_reass_free_complete_datagram+0xb8>)
 800745a:	881a      	ldrh	r2, [r3, #0]
 800745c:	697b      	ldr	r3, [r7, #20]
 800745e:	b29b      	uxth	r3, r3
 8007460:	1ad3      	subs	r3, r2, r3
 8007462:	b29a      	uxth	r2, r3
 8007464:	4b03      	ldr	r3, [pc, #12]	; (8007474 <ip_reass_free_complete_datagram+0xb8>)
 8007466:	801a      	strh	r2, [r3, #0]

  return pbufs_freed;
 8007468:	697b      	ldr	r3, [r7, #20]
}
 800746a:	4618      	mov	r0, r3
 800746c:	3718      	adds	r7, #24
 800746e:	46bd      	mov	sp, r7
 8007470:	bd80      	pop	{r7, pc}
 8007472:	bf00      	nop
 8007474:	200029f0 	.word	0x200029f0

08007478 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 8007478:	b580      	push	{r7, lr}
 800747a:	b088      	sub	sp, #32
 800747c:	af00      	add	r7, sp, #0
 800747e:	6078      	str	r0, [r7, #4]
 8007480:	6039      	str	r1, [r7, #0]
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 8007482:	2300      	movs	r3, #0
 8007484:	613b      	str	r3, [r7, #16]
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
 8007486:	2300      	movs	r3, #0
 8007488:	61bb      	str	r3, [r7, #24]
    prev = NULL;
 800748a:	2300      	movs	r3, #0
 800748c:	617b      	str	r3, [r7, #20]
    other_datagrams = 0;
 800748e:	2300      	movs	r3, #0
 8007490:	60fb      	str	r3, [r7, #12]
    r = reassdatagrams;
 8007492:	4b26      	ldr	r3, [pc, #152]	; (800752c <ip_reass_remove_oldest_datagram+0xb4>)
 8007494:	681b      	ldr	r3, [r3, #0]
 8007496:	61fb      	str	r3, [r7, #28]
    while (r != NULL) {
 8007498:	e02c      	b.n	80074f4 <ip_reass_remove_oldest_datagram+0x7c>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 800749a:	69fb      	ldr	r3, [r7, #28]
 800749c:	695a      	ldr	r2, [r3, #20]
 800749e:	687b      	ldr	r3, [r7, #4]
 80074a0:	68db      	ldr	r3, [r3, #12]
 80074a2:	429a      	cmp	r2, r3
 80074a4:	d10c      	bne.n	80074c0 <ip_reass_remove_oldest_datagram+0x48>
 80074a6:	69fb      	ldr	r3, [r7, #28]
 80074a8:	699a      	ldr	r2, [r3, #24]
 80074aa:	687b      	ldr	r3, [r7, #4]
 80074ac:	691b      	ldr	r3, [r3, #16]
 80074ae:	429a      	cmp	r2, r3
 80074b0:	d106      	bne.n	80074c0 <ip_reass_remove_oldest_datagram+0x48>
 80074b2:	69fb      	ldr	r3, [r7, #28]
 80074b4:	899a      	ldrh	r2, [r3, #12]
 80074b6:	687b      	ldr	r3, [r7, #4]
 80074b8:	889b      	ldrh	r3, [r3, #4]
 80074ba:	b29b      	uxth	r3, r3
 80074bc:	429a      	cmp	r2, r3
 80074be:	d010      	beq.n	80074e2 <ip_reass_remove_oldest_datagram+0x6a>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 80074c0:	68fb      	ldr	r3, [r7, #12]
 80074c2:	3301      	adds	r3, #1
 80074c4:	60fb      	str	r3, [r7, #12]
        if (oldest == NULL) {
 80074c6:	69bb      	ldr	r3, [r7, #24]
 80074c8:	2b00      	cmp	r3, #0
 80074ca:	d102      	bne.n	80074d2 <ip_reass_remove_oldest_datagram+0x5a>
          oldest = r;
 80074cc:	69fb      	ldr	r3, [r7, #28]
 80074ce:	61bb      	str	r3, [r7, #24]
 80074d0:	e007      	b.n	80074e2 <ip_reass_remove_oldest_datagram+0x6a>
        } else if (r->timer <= oldest->timer) {
 80074d2:	69fb      	ldr	r3, [r7, #28]
 80074d4:	7fda      	ldrb	r2, [r3, #31]
 80074d6:	69bb      	ldr	r3, [r7, #24]
 80074d8:	7fdb      	ldrb	r3, [r3, #31]
 80074da:	429a      	cmp	r2, r3
 80074dc:	d801      	bhi.n	80074e2 <ip_reass_remove_oldest_datagram+0x6a>
          /* older than the previous oldest */
          oldest = r;
 80074de:	69fb      	ldr	r3, [r7, #28]
 80074e0:	61bb      	str	r3, [r7, #24]
        }
      }
      if (r->next != NULL) {
 80074e2:	69fb      	ldr	r3, [r7, #28]
 80074e4:	681b      	ldr	r3, [r3, #0]
 80074e6:	2b00      	cmp	r3, #0
 80074e8:	d001      	beq.n	80074ee <ip_reass_remove_oldest_datagram+0x76>
        prev = r;
 80074ea:	69fb      	ldr	r3, [r7, #28]
 80074ec:	617b      	str	r3, [r7, #20]
      }
      r = r->next;
 80074ee:	69fb      	ldr	r3, [r7, #28]
 80074f0:	681b      	ldr	r3, [r3, #0]
 80074f2:	61fb      	str	r3, [r7, #28]
    while (r != NULL) {
 80074f4:	69fb      	ldr	r3, [r7, #28]
 80074f6:	2b00      	cmp	r3, #0
 80074f8:	d1cf      	bne.n	800749a <ip_reass_remove_oldest_datagram+0x22>
    }
    if (oldest != NULL) {
 80074fa:	69bb      	ldr	r3, [r7, #24]
 80074fc:	2b00      	cmp	r3, #0
 80074fe:	d008      	beq.n	8007512 <ip_reass_remove_oldest_datagram+0x9a>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 8007500:	6979      	ldr	r1, [r7, #20]
 8007502:	69b8      	ldr	r0, [r7, #24]
 8007504:	f7ff ff5a 	bl	80073bc <ip_reass_free_complete_datagram>
 8007508:	60b8      	str	r0, [r7, #8]
      pbufs_freed += pbufs_freed_current;
 800750a:	693a      	ldr	r2, [r7, #16]
 800750c:	68bb      	ldr	r3, [r7, #8]
 800750e:	4413      	add	r3, r2
 8007510:	613b      	str	r3, [r7, #16]
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8007512:	693a      	ldr	r2, [r7, #16]
 8007514:	683b      	ldr	r3, [r7, #0]
 8007516:	429a      	cmp	r2, r3
 8007518:	da02      	bge.n	8007520 <ip_reass_remove_oldest_datagram+0xa8>
 800751a:	68fb      	ldr	r3, [r7, #12]
 800751c:	2b01      	cmp	r3, #1
 800751e:	dcb2      	bgt.n	8007486 <ip_reass_remove_oldest_datagram+0xe>
  return pbufs_freed;
 8007520:	693b      	ldr	r3, [r7, #16]
}
 8007522:	4618      	mov	r0, r3
 8007524:	3720      	adds	r7, #32
 8007526:	46bd      	mov	sp, r7
 8007528:	bd80      	pop	{r7, pc}
 800752a:	bf00      	nop
 800752c:	200029ec 	.word	0x200029ec

08007530 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
 8007530:	b580      	push	{r7, lr}
 8007532:	b084      	sub	sp, #16
 8007534:	af00      	add	r7, sp, #0
 8007536:	6078      	str	r0, [r7, #4]
 8007538:	6039      	str	r1, [r7, #0]
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
 800753a:	2005      	movs	r0, #5
 800753c:	f000 fde4 	bl	8008108 <memp_malloc>
 8007540:	60f8      	str	r0, [r7, #12]
  if (ipr == NULL) {
 8007542:	68fb      	ldr	r3, [r7, #12]
 8007544:	2b00      	cmp	r3, #0
 8007546:	d110      	bne.n	800756a <ip_reass_enqueue_new_datagram+0x3a>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8007548:	6839      	ldr	r1, [r7, #0]
 800754a:	6878      	ldr	r0, [r7, #4]
 800754c:	f7ff ff94 	bl	8007478 <ip_reass_remove_oldest_datagram>
 8007550:	4602      	mov	r2, r0
 8007552:	683b      	ldr	r3, [r7, #0]
 8007554:	429a      	cmp	r2, r3
 8007556:	db03      	blt.n	8007560 <ip_reass_enqueue_new_datagram+0x30>
      ipr = memp_malloc(MEMP_REASSDATA);
 8007558:	2005      	movs	r0, #5
 800755a:	f000 fdd5 	bl	8008108 <memp_malloc>
 800755e:	60f8      	str	r0, [r7, #12]
    }
    if (ipr == NULL)
 8007560:	68fb      	ldr	r3, [r7, #12]
 8007562:	2b00      	cmp	r3, #0
 8007564:	d101      	bne.n	800756a <ip_reass_enqueue_new_datagram+0x3a>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
 8007566:	2300      	movs	r3, #0
 8007568:	e016      	b.n	8007598 <ip_reass_enqueue_new_datagram+0x68>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 800756a:	2220      	movs	r2, #32
 800756c:	2100      	movs	r1, #0
 800756e:	68f8      	ldr	r0, [r7, #12]
 8007570:	f007 f884 	bl	800e67c <memset>
  ipr->timer = IP_REASS_MAXAGE;
 8007574:	68fb      	ldr	r3, [r7, #12]
 8007576:	2203      	movs	r2, #3
 8007578:	77da      	strb	r2, [r3, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 800757a:	4b09      	ldr	r3, [pc, #36]	; (80075a0 <ip_reass_enqueue_new_datagram+0x70>)
 800757c:	681a      	ldr	r2, [r3, #0]
 800757e:	68fb      	ldr	r3, [r7, #12]
 8007580:	601a      	str	r2, [r3, #0]
  reassdatagrams = ipr;
 8007582:	4a07      	ldr	r2, [pc, #28]	; (80075a0 <ip_reass_enqueue_new_datagram+0x70>)
 8007584:	68fb      	ldr	r3, [r7, #12]
 8007586:	6013      	str	r3, [r2, #0]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8007588:	68fb      	ldr	r3, [r7, #12]
 800758a:	3308      	adds	r3, #8
 800758c:	2214      	movs	r2, #20
 800758e:	6879      	ldr	r1, [r7, #4]
 8007590:	4618      	mov	r0, r3
 8007592:	f007 f868 	bl	800e666 <memcpy>
  return ipr;
 8007596:	68fb      	ldr	r3, [r7, #12]
}
 8007598:	4618      	mov	r0, r3
 800759a:	3710      	adds	r7, #16
 800759c:	46bd      	mov	sp, r7
 800759e:	bd80      	pop	{r7, pc}
 80075a0:	200029ec 	.word	0x200029ec

080075a4 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 80075a4:	b580      	push	{r7, lr}
 80075a6:	b082      	sub	sp, #8
 80075a8:	af00      	add	r7, sp, #0
 80075aa:	6078      	str	r0, [r7, #4]
 80075ac:	6039      	str	r1, [r7, #0]
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 80075ae:	4b0b      	ldr	r3, [pc, #44]	; (80075dc <ip_reass_dequeue_datagram+0x38>)
 80075b0:	681a      	ldr	r2, [r3, #0]
 80075b2:	687b      	ldr	r3, [r7, #4]
 80075b4:	429a      	cmp	r2, r3
 80075b6:	d104      	bne.n	80075c2 <ip_reass_dequeue_datagram+0x1e>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 80075b8:	687b      	ldr	r3, [r7, #4]
 80075ba:	681b      	ldr	r3, [r3, #0]
 80075bc:	4a07      	ldr	r2, [pc, #28]	; (80075dc <ip_reass_dequeue_datagram+0x38>)
 80075be:	6013      	str	r3, [r2, #0]
 80075c0:	e003      	b.n	80075ca <ip_reass_dequeue_datagram+0x26>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 80075c2:	687b      	ldr	r3, [r7, #4]
 80075c4:	681a      	ldr	r2, [r3, #0]
 80075c6:	683b      	ldr	r3, [r7, #0]
 80075c8:	601a      	str	r2, [r3, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 80075ca:	6879      	ldr	r1, [r7, #4]
 80075cc:	2005      	movs	r0, #5
 80075ce:	f000 fdbd 	bl	800814c <memp_free>
}
 80075d2:	bf00      	nop
 80075d4:	3708      	adds	r7, #8
 80075d6:	46bd      	mov	sp, r7
 80075d8:	bd80      	pop	{r7, pc}
 80075da:	bf00      	nop
 80075dc:	200029ec 	.word	0x200029ec

080075e0 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
 80075e0:	b590      	push	{r4, r7, lr}
 80075e2:	b08b      	sub	sp, #44	; 0x2c
 80075e4:	af00      	add	r7, sp, #0
 80075e6:	6078      	str	r0, [r7, #4]
 80075e8:	6039      	str	r1, [r7, #0]
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
 80075ea:	2300      	movs	r3, #0
 80075ec:	623b      	str	r3, [r7, #32]
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
 80075ee:	2301      	movs	r3, #1
 80075f0:	61bb      	str	r3, [r7, #24]

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 80075f2:	683b      	ldr	r3, [r7, #0]
 80075f4:	685b      	ldr	r3, [r3, #4]
 80075f6:	617b      	str	r3, [r7, #20]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 80075f8:	697b      	ldr	r3, [r7, #20]
 80075fa:	885b      	ldrh	r3, [r3, #2]
 80075fc:	b29b      	uxth	r3, r3
 80075fe:	4618      	mov	r0, r3
 8007600:	f7ff fb47 	bl	8006c92 <ntohs>
 8007604:	4603      	mov	r3, r0
 8007606:	461c      	mov	r4, r3
 8007608:	697b      	ldr	r3, [r7, #20]
 800760a:	881b      	ldrh	r3, [r3, #0]
 800760c:	b29b      	uxth	r3, r3
 800760e:	4618      	mov	r0, r3
 8007610:	f7ff fb3f 	bl	8006c92 <ntohs>
 8007614:	4603      	mov	r3, r0
 8007616:	0a1b      	lsrs	r3, r3, #8
 8007618:	b29b      	uxth	r3, r3
 800761a:	f003 030f 	and.w	r3, r3, #15
 800761e:	b29b      	uxth	r3, r3
 8007620:	009b      	lsls	r3, r3, #2
 8007622:	b29b      	uxth	r3, r3
 8007624:	1ae3      	subs	r3, r4, r3
 8007626:	827b      	strh	r3, [r7, #18]
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8007628:	697b      	ldr	r3, [r7, #20]
 800762a:	88db      	ldrh	r3, [r3, #6]
 800762c:	b29b      	uxth	r3, r3
 800762e:	4618      	mov	r0, r3
 8007630:	f7ff fb2f 	bl	8006c92 <ntohs>
 8007634:	4603      	mov	r3, r0
 8007636:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800763a:	b29b      	uxth	r3, r3
 800763c:	00db      	lsls	r3, r3, #3
 800763e:	823b      	strh	r3, [r7, #16]
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 8007640:	683b      	ldr	r3, [r7, #0]
 8007642:	685b      	ldr	r3, [r3, #4]
 8007644:	627b      	str	r3, [r7, #36]	; 0x24
  iprh->next_pbuf = NULL;
 8007646:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007648:	2200      	movs	r2, #0
 800764a:	701a      	strb	r2, [r3, #0]
 800764c:	2200      	movs	r2, #0
 800764e:	705a      	strb	r2, [r3, #1]
 8007650:	2200      	movs	r2, #0
 8007652:	709a      	strb	r2, [r3, #2]
 8007654:	2200      	movs	r2, #0
 8007656:	70da      	strb	r2, [r3, #3]
  iprh->start = offset;
 8007658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800765a:	8a3a      	ldrh	r2, [r7, #16]
 800765c:	809a      	strh	r2, [r3, #4]
  iprh->end = offset + len;
 800765e:	8a3a      	ldrh	r2, [r7, #16]
 8007660:	8a7b      	ldrh	r3, [r7, #18]
 8007662:	4413      	add	r3, r2
 8007664:	b29a      	uxth	r2, r3
 8007666:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007668:	80da      	strh	r2, [r3, #6]

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 800766a:	687b      	ldr	r3, [r7, #4]
 800766c:	685b      	ldr	r3, [r3, #4]
 800766e:	61fb      	str	r3, [r7, #28]
 8007670:	e04c      	b.n	800770c <ip_reass_chain_frag_into_datagram_and_validate+0x12c>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8007672:	69fb      	ldr	r3, [r7, #28]
 8007674:	685b      	ldr	r3, [r3, #4]
 8007676:	60fb      	str	r3, [r7, #12]
    if (iprh->start < iprh_tmp->start) {
 8007678:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800767a:	889b      	ldrh	r3, [r3, #4]
 800767c:	b29a      	uxth	r2, r3
 800767e:	68fb      	ldr	r3, [r7, #12]
 8007680:	889b      	ldrh	r3, [r3, #4]
 8007682:	b29b      	uxth	r3, r3
 8007684:	429a      	cmp	r2, r3
 8007686:	d21f      	bcs.n	80076c8 <ip_reass_chain_frag_into_datagram_and_validate+0xe8>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 8007688:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800768a:	69fa      	ldr	r2, [r7, #28]
 800768c:	601a      	str	r2, [r3, #0]
      if (iprh_prev != NULL) {
 800768e:	6a3b      	ldr	r3, [r7, #32]
 8007690:	2b00      	cmp	r3, #0
 8007692:	d015      	beq.n	80076c0 <ip_reass_chain_frag_into_datagram_and_validate+0xe0>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8007694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007696:	889b      	ldrh	r3, [r3, #4]
 8007698:	b29a      	uxth	r2, r3
 800769a:	6a3b      	ldr	r3, [r7, #32]
 800769c:	88db      	ldrh	r3, [r3, #6]
 800769e:	b29b      	uxth	r3, r3
 80076a0:	429a      	cmp	r2, r3
 80076a2:	f0c0 808c 	bcc.w	80077be <ip_reass_chain_frag_into_datagram_and_validate+0x1de>
 80076a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80076a8:	88db      	ldrh	r3, [r3, #6]
 80076aa:	b29a      	uxth	r2, r3
 80076ac:	68fb      	ldr	r3, [r7, #12]
 80076ae:	889b      	ldrh	r3, [r3, #4]
 80076b0:	b29b      	uxth	r3, r3
 80076b2:	429a      	cmp	r2, r3
 80076b4:	f200 8083 	bhi.w	80077be <ip_reass_chain_frag_into_datagram_and_validate+0x1de>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 80076b8:	6a3b      	ldr	r3, [r7, #32]
 80076ba:	683a      	ldr	r2, [r7, #0]
 80076bc:	601a      	str	r2, [r3, #0]
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 80076be:	e028      	b.n	8007712 <ip_reass_chain_frag_into_datagram_and_validate+0x132>
        ipr->p = new_p;
 80076c0:	687b      	ldr	r3, [r7, #4]
 80076c2:	683a      	ldr	r2, [r7, #0]
 80076c4:	605a      	str	r2, [r3, #4]
      break;
 80076c6:	e024      	b.n	8007712 <ip_reass_chain_frag_into_datagram_and_validate+0x132>
    } else if(iprh->start == iprh_tmp->start) {
 80076c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80076ca:	889b      	ldrh	r3, [r3, #4]
 80076cc:	b29a      	uxth	r2, r3
 80076ce:	68fb      	ldr	r3, [r7, #12]
 80076d0:	889b      	ldrh	r3, [r3, #4]
 80076d2:	b29b      	uxth	r3, r3
 80076d4:	429a      	cmp	r2, r3
 80076d6:	d06f      	beq.n	80077b8 <ip_reass_chain_frag_into_datagram_and_validate+0x1d8>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 80076d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80076da:	889b      	ldrh	r3, [r3, #4]
 80076dc:	b29a      	uxth	r2, r3
 80076de:	68fb      	ldr	r3, [r7, #12]
 80076e0:	88db      	ldrh	r3, [r3, #6]
 80076e2:	b29b      	uxth	r3, r3
 80076e4:	429a      	cmp	r2, r3
 80076e6:	d369      	bcc.n	80077bc <ip_reass_chain_frag_into_datagram_and_validate+0x1dc>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
 80076e8:	6a3b      	ldr	r3, [r7, #32]
 80076ea:	2b00      	cmp	r3, #0
 80076ec:	d009      	beq.n	8007702 <ip_reass_chain_frag_into_datagram_and_validate+0x122>
        if (iprh_prev->end != iprh_tmp->start) {
 80076ee:	6a3b      	ldr	r3, [r7, #32]
 80076f0:	88db      	ldrh	r3, [r3, #6]
 80076f2:	b29a      	uxth	r2, r3
 80076f4:	68fb      	ldr	r3, [r7, #12]
 80076f6:	889b      	ldrh	r3, [r3, #4]
 80076f8:	b29b      	uxth	r3, r3
 80076fa:	429a      	cmp	r2, r3
 80076fc:	d001      	beq.n	8007702 <ip_reass_chain_frag_into_datagram_and_validate+0x122>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 80076fe:	2300      	movs	r3, #0
 8007700:	61bb      	str	r3, [r7, #24]
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 8007702:	68fb      	ldr	r3, [r7, #12]
 8007704:	681b      	ldr	r3, [r3, #0]
 8007706:	61fb      	str	r3, [r7, #28]
    iprh_prev = iprh_tmp;
 8007708:	68fb      	ldr	r3, [r7, #12]
 800770a:	623b      	str	r3, [r7, #32]
  for (q = ipr->p; q != NULL;) {
 800770c:	69fb      	ldr	r3, [r7, #28]
 800770e:	2b00      	cmp	r3, #0
 8007710:	d1af      	bne.n	8007672 <ip_reass_chain_frag_into_datagram_and_validate+0x92>
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
 8007712:	69fb      	ldr	r3, [r7, #28]
 8007714:	2b00      	cmp	r3, #0
 8007716:	d117      	bne.n	8007748 <ip_reass_chain_frag_into_datagram_and_validate+0x168>
    if (iprh_prev != NULL) {
 8007718:	6a3b      	ldr	r3, [r7, #32]
 800771a:	2b00      	cmp	r3, #0
 800771c:	d011      	beq.n	8007742 <ip_reass_chain_frag_into_datagram_and_validate+0x162>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800771e:	6a3b      	ldr	r3, [r7, #32]
 8007720:	88db      	ldrh	r3, [r3, #6]
 8007722:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007724:	889b      	ldrh	r3, [r3, #4]
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 8007726:	6a3b      	ldr	r3, [r7, #32]
 8007728:	683a      	ldr	r2, [r7, #0]
 800772a:	601a      	str	r2, [r3, #0]
      if (iprh_prev->end != iprh->start) {
 800772c:	6a3b      	ldr	r3, [r7, #32]
 800772e:	88db      	ldrh	r3, [r3, #6]
 8007730:	b29a      	uxth	r2, r3
 8007732:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007734:	889b      	ldrh	r3, [r3, #4]
 8007736:	b29b      	uxth	r3, r3
 8007738:	429a      	cmp	r2, r3
 800773a:	d005      	beq.n	8007748 <ip_reass_chain_frag_into_datagram_and_validate+0x168>
        valid = 0;
 800773c:	2300      	movs	r3, #0
 800773e:	61bb      	str	r3, [r7, #24]
 8007740:	e002      	b.n	8007748 <ip_reass_chain_frag_into_datagram_and_validate+0x168>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 8007742:	687b      	ldr	r3, [r7, #4]
 8007744:	683a      	ldr	r2, [r7, #0]
 8007746:	605a      	str	r2, [r3, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 8007748:	687b      	ldr	r3, [r7, #4]
 800774a:	7f9b      	ldrb	r3, [r3, #30]
 800774c:	f003 0301 	and.w	r3, r3, #1
 8007750:	2b00      	cmp	r3, #0
 8007752:	d02f      	beq.n	80077b4 <ip_reass_chain_frag_into_datagram_and_validate+0x1d4>
    /* and had no wholes so far */
    if (valid) {
 8007754:	69bb      	ldr	r3, [r7, #24]
 8007756:	2b00      	cmp	r3, #0
 8007758:	d02a      	beq.n	80077b0 <ip_reass_chain_frag_into_datagram_and_validate+0x1d0>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 800775a:	687b      	ldr	r3, [r7, #4]
 800775c:	685b      	ldr	r3, [r3, #4]
 800775e:	685b      	ldr	r3, [r3, #4]
 8007760:	889b      	ldrh	r3, [r3, #4]
 8007762:	b29b      	uxth	r3, r3
 8007764:	2b00      	cmp	r3, #0
 8007766:	d002      	beq.n	800776e <ip_reass_chain_frag_into_datagram_and_validate+0x18e>
        valid = 0;
 8007768:	2300      	movs	r3, #0
 800776a:	61bb      	str	r3, [r7, #24]
 800776c:	e020      	b.n	80077b0 <ip_reass_chain_frag_into_datagram_and_validate+0x1d0>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
 800776e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007770:	623b      	str	r3, [r7, #32]
        q = iprh->next_pbuf;
 8007772:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007774:	681b      	ldr	r3, [r3, #0]
 8007776:	61fb      	str	r3, [r7, #28]
        while (q != NULL) {
 8007778:	e012      	b.n	80077a0 <ip_reass_chain_frag_into_datagram_and_validate+0x1c0>
          iprh = (struct ip_reass_helper*)q->payload;
 800777a:	69fb      	ldr	r3, [r7, #28]
 800777c:	685b      	ldr	r3, [r3, #4]
 800777e:	627b      	str	r3, [r7, #36]	; 0x24
          if (iprh_prev->end != iprh->start) {
 8007780:	6a3b      	ldr	r3, [r7, #32]
 8007782:	88db      	ldrh	r3, [r3, #6]
 8007784:	b29a      	uxth	r2, r3
 8007786:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007788:	889b      	ldrh	r3, [r3, #4]
 800778a:	b29b      	uxth	r3, r3
 800778c:	429a      	cmp	r2, r3
 800778e:	d002      	beq.n	8007796 <ip_reass_chain_frag_into_datagram_and_validate+0x1b6>
            valid = 0;
 8007790:	2300      	movs	r3, #0
 8007792:	61bb      	str	r3, [r7, #24]
            break;
 8007794:	e007      	b.n	80077a6 <ip_reass_chain_frag_into_datagram_and_validate+0x1c6>
          }
          iprh_prev = iprh;
 8007796:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007798:	623b      	str	r3, [r7, #32]
          q = iprh->next_pbuf;
 800779a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800779c:	681b      	ldr	r3, [r3, #0]
 800779e:	61fb      	str	r3, [r7, #28]
        while (q != NULL) {
 80077a0:	69fb      	ldr	r3, [r7, #28]
 80077a2:	2b00      	cmp	r3, #0
 80077a4:	d1e9      	bne.n	800777a <ip_reass_chain_frag_into_datagram_and_validate+0x19a>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
 80077a6:	69bb      	ldr	r3, [r7, #24]
 80077a8:	2b00      	cmp	r3, #0
 80077aa:	d001      	beq.n	80077b0 <ip_reass_chain_frag_into_datagram_and_validate+0x1d0>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
 80077ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80077ae:	88db      	ldrh	r3, [r3, #6]
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
 80077b0:	69bb      	ldr	r3, [r7, #24]
 80077b2:	e014      	b.n	80077de <ip_reass_chain_frag_into_datagram_and_validate+0x1fe>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
 80077b4:	2300      	movs	r3, #0
 80077b6:	e012      	b.n	80077de <ip_reass_chain_frag_into_datagram_and_validate+0x1fe>
      goto freepbuf;
 80077b8:	bf00      	nop
 80077ba:	e000      	b.n	80077be <ip_reass_chain_frag_into_datagram_and_validate+0x1de>
      goto freepbuf;
 80077bc:	bf00      	nop
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 80077be:	6838      	ldr	r0, [r7, #0]
 80077c0:	f001 f842 	bl	8008848 <pbuf_clen>
 80077c4:	4603      	mov	r3, r0
 80077c6:	4619      	mov	r1, r3
 80077c8:	4b07      	ldr	r3, [pc, #28]	; (80077e8 <ip_reass_chain_frag_into_datagram_and_validate+0x208>)
 80077ca:	881a      	ldrh	r2, [r3, #0]
 80077cc:	b28b      	uxth	r3, r1
 80077ce:	1ad3      	subs	r3, r2, r3
 80077d0:	b29a      	uxth	r2, r3
 80077d2:	4b05      	ldr	r3, [pc, #20]	; (80077e8 <ip_reass_chain_frag_into_datagram_and_validate+0x208>)
 80077d4:	801a      	strh	r2, [r3, #0]
  pbuf_free(new_p);
 80077d6:	6838      	ldr	r0, [r7, #0]
 80077d8:	f000 ffe7 	bl	80087aa <pbuf_free>
  return 0;
 80077dc:	2300      	movs	r3, #0
#endif /* IP_REASS_CHECK_OVERLAP */
}
 80077de:	4618      	mov	r0, r3
 80077e0:	372c      	adds	r7, #44	; 0x2c
 80077e2:	46bd      	mov	sp, r7
 80077e4:	bd90      	pop	{r4, r7, pc}
 80077e6:	bf00      	nop
 80077e8:	200029f0 	.word	0x200029f0

080077ec <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 80077ec:	b590      	push	{r4, r7, lr}
 80077ee:	b08b      	sub	sp, #44	; 0x2c
 80077f0:	af00      	add	r7, sp, #0
 80077f2:	6078      	str	r0, [r7, #4]
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
 80077f4:	2300      	movs	r3, #0
 80077f6:	61fb      	str	r3, [r7, #28]

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 80077f8:	687b      	ldr	r3, [r7, #4]
 80077fa:	685b      	ldr	r3, [r3, #4]
 80077fc:	61bb      	str	r3, [r7, #24]

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 80077fe:	69bb      	ldr	r3, [r7, #24]
 8007800:	881b      	ldrh	r3, [r3, #0]
 8007802:	b29b      	uxth	r3, r3
 8007804:	4618      	mov	r0, r3
 8007806:	f7ff fa44 	bl	8006c92 <ntohs>
 800780a:	4603      	mov	r3, r0
 800780c:	0a1b      	lsrs	r3, r3, #8
 800780e:	b29b      	uxth	r3, r3
 8007810:	f003 030f 	and.w	r3, r3, #15
 8007814:	009b      	lsls	r3, r3, #2
 8007816:	2b14      	cmp	r3, #20
 8007818:	f040 810d 	bne.w	8007a36 <ip_reass+0x24a>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800781c:	69bb      	ldr	r3, [r7, #24]
 800781e:	88db      	ldrh	r3, [r3, #6]
 8007820:	b29b      	uxth	r3, r3
 8007822:	4618      	mov	r0, r3
 8007824:	f7ff fa35 	bl	8006c92 <ntohs>
 8007828:	4603      	mov	r3, r0
 800782a:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800782e:	b29b      	uxth	r3, r3
 8007830:	00db      	lsls	r3, r3, #3
 8007832:	82fb      	strh	r3, [r7, #22]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8007834:	69bb      	ldr	r3, [r7, #24]
 8007836:	885b      	ldrh	r3, [r3, #2]
 8007838:	b29b      	uxth	r3, r3
 800783a:	4618      	mov	r0, r3
 800783c:	f7ff fa29 	bl	8006c92 <ntohs>
 8007840:	4603      	mov	r3, r0
 8007842:	461c      	mov	r4, r3
 8007844:	69bb      	ldr	r3, [r7, #24]
 8007846:	881b      	ldrh	r3, [r3, #0]
 8007848:	b29b      	uxth	r3, r3
 800784a:	4618      	mov	r0, r3
 800784c:	f7ff fa21 	bl	8006c92 <ntohs>
 8007850:	4603      	mov	r3, r0
 8007852:	0a1b      	lsrs	r3, r3, #8
 8007854:	b29b      	uxth	r3, r3
 8007856:	f003 030f 	and.w	r3, r3, #15
 800785a:	b29b      	uxth	r3, r3
 800785c:	009b      	lsls	r3, r3, #2
 800785e:	b29b      	uxth	r3, r3
 8007860:	1ae3      	subs	r3, r4, r3
 8007862:	82bb      	strh	r3, [r7, #20]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 8007864:	6878      	ldr	r0, [r7, #4]
 8007866:	f000 ffef 	bl	8008848 <pbuf_clen>
 800786a:	4603      	mov	r3, r0
 800786c:	74fb      	strb	r3, [r7, #19]
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800786e:	4b76      	ldr	r3, [pc, #472]	; (8007a48 <ip_reass+0x25c>)
 8007870:	881b      	ldrh	r3, [r3, #0]
 8007872:	461a      	mov	r2, r3
 8007874:	7cfb      	ldrb	r3, [r7, #19]
 8007876:	4413      	add	r3, r2
 8007878:	2b0a      	cmp	r3, #10
 800787a:	dd10      	ble.n	800789e <ip_reass+0xb2>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 800787c:	7cfb      	ldrb	r3, [r7, #19]
 800787e:	4619      	mov	r1, r3
 8007880:	69b8      	ldr	r0, [r7, #24]
 8007882:	f7ff fdf9 	bl	8007478 <ip_reass_remove_oldest_datagram>
 8007886:	4603      	mov	r3, r0
 8007888:	2b00      	cmp	r3, #0
 800788a:	f000 80d5 	beq.w	8007a38 <ip_reass+0x24c>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 800788e:	4b6e      	ldr	r3, [pc, #440]	; (8007a48 <ip_reass+0x25c>)
 8007890:	881b      	ldrh	r3, [r3, #0]
 8007892:	461a      	mov	r2, r3
 8007894:	7cfb      	ldrb	r3, [r7, #19]
 8007896:	4413      	add	r3, r2
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8007898:	2b0a      	cmp	r3, #10
 800789a:	f300 80cd 	bgt.w	8007a38 <ip_reass+0x24c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 800789e:	4b6b      	ldr	r3, [pc, #428]	; (8007a4c <ip_reass+0x260>)
 80078a0:	681b      	ldr	r3, [r3, #0]
 80078a2:	623b      	str	r3, [r7, #32]
 80078a4:	e017      	b.n	80078d6 <ip_reass+0xea>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 80078a6:	6a3b      	ldr	r3, [r7, #32]
 80078a8:	695a      	ldr	r2, [r3, #20]
 80078aa:	69bb      	ldr	r3, [r7, #24]
 80078ac:	68db      	ldr	r3, [r3, #12]
 80078ae:	429a      	cmp	r2, r3
 80078b0:	d10c      	bne.n	80078cc <ip_reass+0xe0>
 80078b2:	6a3b      	ldr	r3, [r7, #32]
 80078b4:	699a      	ldr	r2, [r3, #24]
 80078b6:	69bb      	ldr	r3, [r7, #24]
 80078b8:	691b      	ldr	r3, [r3, #16]
 80078ba:	429a      	cmp	r2, r3
 80078bc:	d106      	bne.n	80078cc <ip_reass+0xe0>
 80078be:	6a3b      	ldr	r3, [r7, #32]
 80078c0:	899a      	ldrh	r2, [r3, #12]
 80078c2:	69bb      	ldr	r3, [r7, #24]
 80078c4:	889b      	ldrh	r3, [r3, #4]
 80078c6:	b29b      	uxth	r3, r3
 80078c8:	429a      	cmp	r2, r3
 80078ca:	d008      	beq.n	80078de <ip_reass+0xf2>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
 80078cc:	6a3b      	ldr	r3, [r7, #32]
 80078ce:	61fb      	str	r3, [r7, #28]
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 80078d0:	6a3b      	ldr	r3, [r7, #32]
 80078d2:	681b      	ldr	r3, [r3, #0]
 80078d4:	623b      	str	r3, [r7, #32]
 80078d6:	6a3b      	ldr	r3, [r7, #32]
 80078d8:	2b00      	cmp	r3, #0
 80078da:	d1e4      	bne.n	80078a6 <ip_reass+0xba>
 80078dc:	e000      	b.n	80078e0 <ip_reass+0xf4>
      break;
 80078de:	bf00      	nop
  }

  if (ipr == NULL) {
 80078e0:	6a3b      	ldr	r3, [r7, #32]
 80078e2:	2b00      	cmp	r3, #0
 80078e4:	d109      	bne.n	80078fa <ip_reass+0x10e>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 80078e6:	7cfb      	ldrb	r3, [r7, #19]
 80078e8:	4619      	mov	r1, r3
 80078ea:	69b8      	ldr	r0, [r7, #24]
 80078ec:	f7ff fe20 	bl	8007530 <ip_reass_enqueue_new_datagram>
 80078f0:	6238      	str	r0, [r7, #32]
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
 80078f2:	6a3b      	ldr	r3, [r7, #32]
 80078f4:	2b00      	cmp	r3, #0
 80078f6:	d11c      	bne.n	8007932 <ip_reass+0x146>
      goto nullreturn;
 80078f8:	e09e      	b.n	8007a38 <ip_reass+0x24c>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 80078fa:	69bb      	ldr	r3, [r7, #24]
 80078fc:	88db      	ldrh	r3, [r3, #6]
 80078fe:	b29b      	uxth	r3, r3
 8007900:	4618      	mov	r0, r3
 8007902:	f7ff f9c6 	bl	8006c92 <ntohs>
 8007906:	4603      	mov	r3, r0
 8007908:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800790c:	2b00      	cmp	r3, #0
 800790e:	d110      	bne.n	8007932 <ip_reass+0x146>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 8007910:	6a3b      	ldr	r3, [r7, #32]
 8007912:	89db      	ldrh	r3, [r3, #14]
 8007914:	4618      	mov	r0, r3
 8007916:	f7ff f9bc 	bl	8006c92 <ntohs>
 800791a:	4603      	mov	r3, r0
 800791c:	f3c3 030c 	ubfx	r3, r3, #0, #13
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8007920:	2b00      	cmp	r3, #0
 8007922:	d006      	beq.n	8007932 <ip_reass+0x146>
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 8007924:	6a3b      	ldr	r3, [r7, #32]
 8007926:	3308      	adds	r3, #8
 8007928:	2214      	movs	r2, #20
 800792a:	69b9      	ldr	r1, [r7, #24]
 800792c:	4618      	mov	r0, r3
 800792e:	f006 fe9a 	bl	800e666 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 8007932:	7cfb      	ldrb	r3, [r7, #19]
 8007934:	b29a      	uxth	r2, r3
 8007936:	4b44      	ldr	r3, [pc, #272]	; (8007a48 <ip_reass+0x25c>)
 8007938:	881b      	ldrh	r3, [r3, #0]
 800793a:	4413      	add	r3, r2
 800793c:	b29a      	uxth	r2, r3
 800793e:	4b42      	ldr	r3, [pc, #264]	; (8007a48 <ip_reass+0x25c>)
 8007940:	801a      	strh	r2, [r3, #0]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
 8007942:	69bb      	ldr	r3, [r7, #24]
 8007944:	88db      	ldrh	r3, [r3, #6]
 8007946:	b29b      	uxth	r3, r3
 8007948:	4618      	mov	r0, r3
 800794a:	f7ff f9a2 	bl	8006c92 <ntohs>
 800794e:	4603      	mov	r3, r0
 8007950:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8007954:	2b00      	cmp	r3, #0
 8007956:	d10c      	bne.n	8007972 <ip_reass+0x186>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8007958:	6a3b      	ldr	r3, [r7, #32]
 800795a:	7f9b      	ldrb	r3, [r3, #30]
 800795c:	f043 0301 	orr.w	r3, r3, #1
 8007960:	b2da      	uxtb	r2, r3
 8007962:	6a3b      	ldr	r3, [r7, #32]
 8007964:	779a      	strb	r2, [r3, #30]
    ipr->datagram_len = offset + len;
 8007966:	8afa      	ldrh	r2, [r7, #22]
 8007968:	8abb      	ldrh	r3, [r7, #20]
 800796a:	4413      	add	r3, r2
 800796c:	b29a      	uxth	r2, r3
 800796e:	6a3b      	ldr	r3, [r7, #32]
 8007970:	839a      	strh	r2, [r3, #28]
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
 8007972:	6879      	ldr	r1, [r7, #4]
 8007974:	6a38      	ldr	r0, [r7, #32]
 8007976:	f7ff fe33 	bl	80075e0 <ip_reass_chain_frag_into_datagram_and_validate>
 800797a:	4603      	mov	r3, r0
 800797c:	2b00      	cmp	r3, #0
 800797e:	d058      	beq.n	8007a32 <ip_reass+0x246>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 8007980:	6a3b      	ldr	r3, [r7, #32]
 8007982:	8b9b      	ldrh	r3, [r3, #28]
 8007984:	3314      	adds	r3, #20
 8007986:	b29a      	uxth	r2, r3
 8007988:	6a3b      	ldr	r3, [r7, #32]
 800798a:	839a      	strh	r2, [r3, #28]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800798c:	6a3b      	ldr	r3, [r7, #32]
 800798e:	685b      	ldr	r3, [r3, #4]
 8007990:	685b      	ldr	r3, [r3, #4]
 8007992:	681b      	ldr	r3, [r3, #0]
 8007994:	627b      	str	r3, [r7, #36]	; 0x24

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
 8007996:	6a3b      	ldr	r3, [r7, #32]
 8007998:	685b      	ldr	r3, [r3, #4]
 800799a:	685b      	ldr	r3, [r3, #4]
 800799c:	61bb      	str	r3, [r7, #24]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800799e:	6a3b      	ldr	r3, [r7, #32]
 80079a0:	3308      	adds	r3, #8
 80079a2:	2214      	movs	r2, #20
 80079a4:	4619      	mov	r1, r3
 80079a6:	69b8      	ldr	r0, [r7, #24]
 80079a8:	f006 fe5d 	bl	800e666 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 80079ac:	6a3b      	ldr	r3, [r7, #32]
 80079ae:	8b9b      	ldrh	r3, [r3, #28]
 80079b0:	4618      	mov	r0, r3
 80079b2:	f7ff f959 	bl	8006c68 <htons>
 80079b6:	4603      	mov	r3, r0
 80079b8:	461a      	mov	r2, r3
 80079ba:	69bb      	ldr	r3, [r7, #24]
 80079bc:	805a      	strh	r2, [r3, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 80079be:	69bb      	ldr	r3, [r7, #24]
 80079c0:	2200      	movs	r2, #0
 80079c2:	719a      	strb	r2, [r3, #6]
 80079c4:	2200      	movs	r2, #0
 80079c6:	71da      	strb	r2, [r3, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 80079c8:	69bb      	ldr	r3, [r7, #24]
 80079ca:	2200      	movs	r2, #0
 80079cc:	729a      	strb	r2, [r3, #10]
 80079ce:	2200      	movs	r2, #0
 80079d0:	72da      	strb	r2, [r3, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 80079d2:	2114      	movs	r1, #20
 80079d4:	69b8      	ldr	r0, [r7, #24]
 80079d6:	f7ff f9dc 	bl	8006d92 <inet_chksum>
 80079da:	4603      	mov	r3, r0
 80079dc:	461a      	mov	r2, r3
 80079de:	69bb      	ldr	r3, [r7, #24]
 80079e0:	815a      	strh	r2, [r3, #10]

    p = ipr->p;
 80079e2:	6a3b      	ldr	r3, [r7, #32]
 80079e4:	685b      	ldr	r3, [r3, #4]
 80079e6:	607b      	str	r3, [r7, #4]

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 80079e8:	e00e      	b.n	8007a08 <ip_reass+0x21c>
      iprh = (struct ip_reass_helper*)r->payload;
 80079ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80079ec:	685b      	ldr	r3, [r3, #4]
 80079ee:	60fb      	str	r3, [r7, #12]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 80079f0:	f06f 0113 	mvn.w	r1, #19
 80079f4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80079f6:	f000 fe69 	bl	80086cc <pbuf_header>
      pbuf_cat(p, r);
 80079fa:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80079fc:	6878      	ldr	r0, [r7, #4]
 80079fe:	f000 ff4d 	bl	800889c <pbuf_cat>
      r = iprh->next_pbuf;
 8007a02:	68fb      	ldr	r3, [r7, #12]
 8007a04:	681b      	ldr	r3, [r3, #0]
 8007a06:	627b      	str	r3, [r7, #36]	; 0x24
    while(r != NULL) {
 8007a08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007a0a:	2b00      	cmp	r3, #0
 8007a0c:	d1ed      	bne.n	80079ea <ip_reass+0x1fe>
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 8007a0e:	69f9      	ldr	r1, [r7, #28]
 8007a10:	6a38      	ldr	r0, [r7, #32]
 8007a12:	f7ff fdc7 	bl	80075a4 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 8007a16:	6878      	ldr	r0, [r7, #4]
 8007a18:	f000 ff16 	bl	8008848 <pbuf_clen>
 8007a1c:	4603      	mov	r3, r0
 8007a1e:	4619      	mov	r1, r3
 8007a20:	4b09      	ldr	r3, [pc, #36]	; (8007a48 <ip_reass+0x25c>)
 8007a22:	881a      	ldrh	r2, [r3, #0]
 8007a24:	b28b      	uxth	r3, r1
 8007a26:	1ad3      	subs	r3, r2, r3
 8007a28:	b29a      	uxth	r2, r3
 8007a2a:	4b07      	ldr	r3, [pc, #28]	; (8007a48 <ip_reass+0x25c>)
 8007a2c:	801a      	strh	r2, [r3, #0]

    /* Return the pbuf chain */
    return p;
 8007a2e:	687b      	ldr	r3, [r7, #4]
 8007a30:	e006      	b.n	8007a40 <ip_reass+0x254>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 8007a32:	2300      	movs	r3, #0
 8007a34:	e004      	b.n	8007a40 <ip_reass+0x254>
    goto nullreturn;
 8007a36:	bf00      	nop

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 8007a38:	6878      	ldr	r0, [r7, #4]
 8007a3a:	f000 feb6 	bl	80087aa <pbuf_free>
  return NULL;
 8007a3e:	2300      	movs	r3, #0
}
 8007a40:	4618      	mov	r0, r3
 8007a42:	372c      	adds	r7, #44	; 0x2c
 8007a44:	46bd      	mov	sp, r7
 8007a46:	bd90      	pop	{r4, r7, pc}
 8007a48:	200029f0 	.word	0x200029f0
 8007a4c:	200029ec 	.word	0x200029ec

08007a50 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
 8007a50:	b580      	push	{r7, lr}
 8007a52:	b08c      	sub	sp, #48	; 0x30
 8007a54:	af00      	add	r7, sp, #0
 8007a56:	60f8      	str	r0, [r7, #12]
 8007a58:	60b9      	str	r1, [r7, #8]
 8007a5a:	607a      	str	r2, [r7, #4]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 8007a5c:	68bb      	ldr	r3, [r7, #8]
 8007a5e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8007a60:	84fb      	strh	r3, [r7, #38]	; 0x26
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
 8007a62:	2314      	movs	r3, #20
 8007a64:	857b      	strh	r3, [r7, #42]	; 0x2a
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
 8007a66:	2202      	movs	r2, #2
 8007a68:	2100      	movs	r1, #0
 8007a6a:	2002      	movs	r0, #2
 8007a6c:	f000 fcd0 	bl	8008410 <pbuf_alloc>
 8007a70:	6238      	str	r0, [r7, #32]
  if (rambuf == NULL) {
 8007a72:	6a3b      	ldr	r3, [r7, #32]
 8007a74:	2b00      	cmp	r3, #0
 8007a76:	d102      	bne.n	8007a7e <ip_frag+0x2e>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
 8007a78:	f04f 33ff 	mov.w	r3, #4294967295
 8007a7c:	e0b5      	b.n	8007bea <ip_frag+0x19a>
  }
  rambuf->tot_len = rambuf->len = mtu;
 8007a7e:	6a3b      	ldr	r3, [r7, #32]
 8007a80:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8007a82:	815a      	strh	r2, [r3, #10]
 8007a84:	6a3b      	ldr	r3, [r7, #32]
 8007a86:	895a      	ldrh	r2, [r3, #10]
 8007a88:	6a3b      	ldr	r3, [r7, #32]
 8007a8a:	811a      	strh	r2, [r3, #8]
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
 8007a8c:	4b59      	ldr	r3, [pc, #356]	; (8007bf4 <ip_frag+0x1a4>)
 8007a8e:	3303      	adds	r3, #3
 8007a90:	f023 0303 	bic.w	r3, r3, #3
 8007a94:	461a      	mov	r2, r3
 8007a96:	6a3b      	ldr	r3, [r7, #32]
 8007a98:	605a      	str	r2, [r3, #4]

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
 8007a9a:	6a3b      	ldr	r3, [r7, #32]
 8007a9c:	685b      	ldr	r3, [r3, #4]
 8007a9e:	61fb      	str	r3, [r7, #28]
  SMEMCPY(iphdr, p->payload, IP_HLEN);
 8007aa0:	68fb      	ldr	r3, [r7, #12]
 8007aa2:	685b      	ldr	r3, [r3, #4]
 8007aa4:	2214      	movs	r2, #20
 8007aa6:	4619      	mov	r1, r3
 8007aa8:	69f8      	ldr	r0, [r7, #28]
 8007aaa:	f006 fddc 	bl	800e666 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 8007aae:	69fb      	ldr	r3, [r7, #28]
 8007ab0:	88db      	ldrh	r3, [r3, #6]
 8007ab2:	b29b      	uxth	r3, r3
 8007ab4:	4618      	mov	r0, r3
 8007ab6:	f7ff f8ec 	bl	8006c92 <ntohs>
 8007aba:	4603      	mov	r3, r0
 8007abc:	853b      	strh	r3, [r7, #40]	; 0x28
  ofo = tmp & IP_OFFMASK;
 8007abe:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8007ac0:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8007ac4:	85bb      	strh	r3, [r7, #44]	; 0x2c
  omf = tmp & IP_MF;
 8007ac6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8007ac8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8007acc:	837b      	strh	r3, [r7, #26]

  left = p->tot_len - IP_HLEN;
 8007ace:	68fb      	ldr	r3, [r7, #12]
 8007ad0:	891b      	ldrh	r3, [r3, #8]
 8007ad2:	3b14      	subs	r3, #20
 8007ad4:	85fb      	strh	r3, [r7, #46]	; 0x2e

  nfb = (mtu - IP_HLEN) / 8;
 8007ad6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8007ad8:	3b14      	subs	r3, #20
 8007ada:	2b00      	cmp	r3, #0
 8007adc:	da00      	bge.n	8007ae0 <ip_frag+0x90>
 8007ade:	3307      	adds	r3, #7
 8007ae0:	10db      	asrs	r3, r3, #3
 8007ae2:	833b      	strh	r3, [r7, #24]

  while (left) {
 8007ae4:	e07a      	b.n	8007bdc <ip_frag+0x18c>
    last = (left <= mtu - IP_HLEN);
 8007ae6:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 8007ae8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8007aea:	3b14      	subs	r3, #20
 8007aec:	429a      	cmp	r2, r3
 8007aee:	bfd4      	ite	le
 8007af0:	2301      	movle	r3, #1
 8007af2:	2300      	movgt	r3, #0
 8007af4:	b2db      	uxtb	r3, r3
 8007af6:	82fb      	strh	r3, [r7, #22]

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 8007af8:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8007afa:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8007afe:	b29a      	uxth	r2, r3
 8007b00:	8b7b      	ldrh	r3, [r7, #26]
 8007b02:	4313      	orrs	r3, r2
 8007b04:	853b      	strh	r3, [r7, #40]	; 0x28
    if (!last)
 8007b06:	8afb      	ldrh	r3, [r7, #22]
 8007b08:	2b00      	cmp	r3, #0
 8007b0a:	d103      	bne.n	8007b14 <ip_frag+0xc4>
      tmp = tmp | IP_MF;
 8007b0c:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8007b0e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8007b12:	853b      	strh	r3, [r7, #40]	; 0x28

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8007b14:	8afb      	ldrh	r3, [r7, #22]
 8007b16:	2b00      	cmp	r3, #0
 8007b18:	d103      	bne.n	8007b22 <ip_frag+0xd2>
 8007b1a:	8b3b      	ldrh	r3, [r7, #24]
 8007b1c:	00db      	lsls	r3, r3, #3
 8007b1e:	b29b      	uxth	r3, r3
 8007b20:	e000      	b.n	8007b24 <ip_frag+0xd4>
 8007b22:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8007b24:	82bb      	strh	r3, [r7, #20]

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 8007b26:	69fb      	ldr	r3, [r7, #28]
 8007b28:	f103 0114 	add.w	r1, r3, #20
 8007b2c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007b2e:	8aba      	ldrh	r2, [r7, #20]
 8007b30:	68f8      	ldr	r0, [r7, #12]
 8007b32:	f000 ff71 	bl	8008a18 <pbuf_copy_partial>
 8007b36:	4603      	mov	r3, r0
 8007b38:	461a      	mov	r2, r3
 8007b3a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007b3c:	4413      	add	r3, r2
 8007b3e:	857b      	strh	r3, [r7, #42]	; 0x2a
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 8007b40:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8007b42:	4618      	mov	r0, r3
 8007b44:	f7ff f890 	bl	8006c68 <htons>
 8007b48:	4603      	mov	r3, r0
 8007b4a:	461a      	mov	r2, r3
 8007b4c:	69fb      	ldr	r3, [r7, #28]
 8007b4e:	80da      	strh	r2, [r3, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 8007b50:	8abb      	ldrh	r3, [r7, #20]
 8007b52:	3314      	adds	r3, #20
 8007b54:	b29b      	uxth	r3, r3
 8007b56:	4618      	mov	r0, r3
 8007b58:	f7ff f886 	bl	8006c68 <htons>
 8007b5c:	4603      	mov	r3, r0
 8007b5e:	461a      	mov	r2, r3
 8007b60:	69fb      	ldr	r3, [r7, #28]
 8007b62:	805a      	strh	r2, [r3, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 8007b64:	69fb      	ldr	r3, [r7, #28]
 8007b66:	2200      	movs	r2, #0
 8007b68:	729a      	strb	r2, [r3, #10]
 8007b6a:	2200      	movs	r2, #0
 8007b6c:	72da      	strb	r2, [r3, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 8007b6e:	2114      	movs	r1, #20
 8007b70:	69f8      	ldr	r0, [r7, #28]
 8007b72:	f7ff f90e 	bl	8006d92 <inet_chksum>
 8007b76:	4603      	mov	r3, r0
 8007b78:	461a      	mov	r2, r3
 8007b7a:	69fb      	ldr	r3, [r7, #28]
 8007b7c:	815a      	strh	r2, [r3, #10]

#if IP_FRAG_USES_STATIC_BUF
    if (last)
 8007b7e:	8afb      	ldrh	r3, [r7, #22]
 8007b80:	2b00      	cmp	r3, #0
 8007b82:	d006      	beq.n	8007b92 <ip_frag+0x142>
      pbuf_realloc(rambuf, left + IP_HLEN);
 8007b84:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8007b86:	3314      	adds	r3, #20
 8007b88:	b29b      	uxth	r3, r3
 8007b8a:	4619      	mov	r1, r3
 8007b8c:	6a38      	ldr	r0, [r7, #32]
 8007b8e:	f000 fd39 	bl	8008604 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
 8007b92:	2200      	movs	r2, #0
 8007b94:	2100      	movs	r1, #0
 8007b96:	2002      	movs	r0, #2
 8007b98:	f000 fc3a 	bl	8008410 <pbuf_alloc>
 8007b9c:	6138      	str	r0, [r7, #16]
    if (header != NULL) {
 8007b9e:	693b      	ldr	r3, [r7, #16]
 8007ba0:	2b00      	cmp	r3, #0
 8007ba2:	d00d      	beq.n	8007bc0 <ip_frag+0x170>
      pbuf_chain(header, rambuf);
 8007ba4:	6a39      	ldr	r1, [r7, #32]
 8007ba6:	6938      	ldr	r0, [r7, #16]
 8007ba8:	f000 fea7 	bl	80088fa <pbuf_chain>
      netif->output(netif, header, dest);
 8007bac:	68bb      	ldr	r3, [r7, #8]
 8007bae:	695b      	ldr	r3, [r3, #20]
 8007bb0:	687a      	ldr	r2, [r7, #4]
 8007bb2:	6939      	ldr	r1, [r7, #16]
 8007bb4:	68b8      	ldr	r0, [r7, #8]
 8007bb6:	4798      	blx	r3
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
 8007bb8:	6938      	ldr	r0, [r7, #16]
 8007bba:	f000 fdf6 	bl	80087aa <pbuf_free>
 8007bbe:	e005      	b.n	8007bcc <ip_frag+0x17c>
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
 8007bc0:	6a38      	ldr	r0, [r7, #32]
 8007bc2:	f000 fdf2 	bl	80087aa <pbuf_free>
      return ERR_MEM;
 8007bc6:	f04f 33ff 	mov.w	r3, #4294967295
 8007bca:	e00e      	b.n	8007bea <ip_frag+0x19a>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 8007bcc:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 8007bce:	8abb      	ldrh	r3, [r7, #20]
 8007bd0:	1ad3      	subs	r3, r2, r3
 8007bd2:	85fb      	strh	r3, [r7, #46]	; 0x2e
    ofo += nfb;
 8007bd4:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 8007bd6:	8b3b      	ldrh	r3, [r7, #24]
 8007bd8:	4413      	add	r3, r2
 8007bda:	85bb      	strh	r3, [r7, #44]	; 0x2c
  while (left) {
 8007bdc:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8007bde:	2b00      	cmp	r3, #0
 8007be0:	d181      	bne.n	8007ae6 <ip_frag+0x96>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
 8007be2:	6a38      	ldr	r0, [r7, #32]
 8007be4:	f000 fde1 	bl	80087aa <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 8007be8:	2300      	movs	r3, #0
}
 8007bea:	4618      	mov	r0, r3
 8007bec:	3730      	adds	r7, #48	; 0x30
 8007bee:	46bd      	mov	sp, r7
 8007bf0:	bd80      	pop	{r7, pc}
 8007bf2:	bf00      	nop
 8007bf4:	200029f4 	.word	0x200029f4

08007bf8 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 8007bf8:	b480      	push	{r7}
 8007bfa:	b085      	sub	sp, #20
 8007bfc:	af00      	add	r7, sp, #0
 8007bfe:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)&ram[mem->next];
 8007c00:	4b2a      	ldr	r3, [pc, #168]	; (8007cac <plug_holes+0xb4>)
 8007c02:	681b      	ldr	r3, [r3, #0]
 8007c04:	687a      	ldr	r2, [r7, #4]
 8007c06:	8812      	ldrh	r2, [r2, #0]
 8007c08:	4413      	add	r3, r2
 8007c0a:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 8007c0c:	687a      	ldr	r2, [r7, #4]
 8007c0e:	68fb      	ldr	r3, [r7, #12]
 8007c10:	429a      	cmp	r2, r3
 8007c12:	d01f      	beq.n	8007c54 <plug_holes+0x5c>
 8007c14:	68fb      	ldr	r3, [r7, #12]
 8007c16:	791b      	ldrb	r3, [r3, #4]
 8007c18:	2b00      	cmp	r3, #0
 8007c1a:	d11b      	bne.n	8007c54 <plug_holes+0x5c>
 8007c1c:	4b24      	ldr	r3, [pc, #144]	; (8007cb0 <plug_holes+0xb8>)
 8007c1e:	681b      	ldr	r3, [r3, #0]
 8007c20:	68fa      	ldr	r2, [r7, #12]
 8007c22:	429a      	cmp	r2, r3
 8007c24:	d016      	beq.n	8007c54 <plug_holes+0x5c>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8007c26:	4b23      	ldr	r3, [pc, #140]	; (8007cb4 <plug_holes+0xbc>)
 8007c28:	681a      	ldr	r2, [r3, #0]
 8007c2a:	68fb      	ldr	r3, [r7, #12]
 8007c2c:	429a      	cmp	r2, r3
 8007c2e:	d102      	bne.n	8007c36 <plug_holes+0x3e>
      lfree = mem;
 8007c30:	4a20      	ldr	r2, [pc, #128]	; (8007cb4 <plug_holes+0xbc>)
 8007c32:	687b      	ldr	r3, [r7, #4]
 8007c34:	6013      	str	r3, [r2, #0]
    }
    mem->next = nmem->next;
 8007c36:	68fb      	ldr	r3, [r7, #12]
 8007c38:	881a      	ldrh	r2, [r3, #0]
 8007c3a:	687b      	ldr	r3, [r7, #4]
 8007c3c:	801a      	strh	r2, [r3, #0]
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
 8007c3e:	4b1b      	ldr	r3, [pc, #108]	; (8007cac <plug_holes+0xb4>)
 8007c40:	681b      	ldr	r3, [r3, #0]
 8007c42:	68fa      	ldr	r2, [r7, #12]
 8007c44:	8812      	ldrh	r2, [r2, #0]
 8007c46:	4413      	add	r3, r2
 8007c48:	687a      	ldr	r2, [r7, #4]
 8007c4a:	4918      	ldr	r1, [pc, #96]	; (8007cac <plug_holes+0xb4>)
 8007c4c:	6809      	ldr	r1, [r1, #0]
 8007c4e:	1a52      	subs	r2, r2, r1
 8007c50:	b292      	uxth	r2, r2
 8007c52:	805a      	strh	r2, [r3, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
 8007c54:	4b15      	ldr	r3, [pc, #84]	; (8007cac <plug_holes+0xb4>)
 8007c56:	681b      	ldr	r3, [r3, #0]
 8007c58:	687a      	ldr	r2, [r7, #4]
 8007c5a:	8852      	ldrh	r2, [r2, #2]
 8007c5c:	4413      	add	r3, r2
 8007c5e:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
 8007c60:	68ba      	ldr	r2, [r7, #8]
 8007c62:	687b      	ldr	r3, [r7, #4]
 8007c64:	429a      	cmp	r2, r3
 8007c66:	d01a      	beq.n	8007c9e <plug_holes+0xa6>
 8007c68:	68bb      	ldr	r3, [r7, #8]
 8007c6a:	791b      	ldrb	r3, [r3, #4]
 8007c6c:	2b00      	cmp	r3, #0
 8007c6e:	d116      	bne.n	8007c9e <plug_holes+0xa6>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 8007c70:	4b10      	ldr	r3, [pc, #64]	; (8007cb4 <plug_holes+0xbc>)
 8007c72:	681a      	ldr	r2, [r3, #0]
 8007c74:	687b      	ldr	r3, [r7, #4]
 8007c76:	429a      	cmp	r2, r3
 8007c78:	d102      	bne.n	8007c80 <plug_holes+0x88>
      lfree = pmem;
 8007c7a:	4a0e      	ldr	r2, [pc, #56]	; (8007cb4 <plug_holes+0xbc>)
 8007c7c:	68bb      	ldr	r3, [r7, #8]
 8007c7e:	6013      	str	r3, [r2, #0]
    }
    pmem->next = mem->next;
 8007c80:	687b      	ldr	r3, [r7, #4]
 8007c82:	881a      	ldrh	r2, [r3, #0]
 8007c84:	68bb      	ldr	r3, [r7, #8]
 8007c86:	801a      	strh	r2, [r3, #0]
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
 8007c88:	4b08      	ldr	r3, [pc, #32]	; (8007cac <plug_holes+0xb4>)
 8007c8a:	681b      	ldr	r3, [r3, #0]
 8007c8c:	687a      	ldr	r2, [r7, #4]
 8007c8e:	8812      	ldrh	r2, [r2, #0]
 8007c90:	4413      	add	r3, r2
 8007c92:	68ba      	ldr	r2, [r7, #8]
 8007c94:	4905      	ldr	r1, [pc, #20]	; (8007cac <plug_holes+0xb4>)
 8007c96:	6809      	ldr	r1, [r1, #0]
 8007c98:	1a52      	subs	r2, r2, r1
 8007c9a:	b292      	uxth	r2, r2
 8007c9c:	805a      	strh	r2, [r3, #2]
  }
}
 8007c9e:	bf00      	nop
 8007ca0:	3714      	adds	r7, #20
 8007ca2:	46bd      	mov	sp, r7
 8007ca4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ca8:	4770      	bx	lr
 8007caa:	bf00      	nop
 8007cac:	200057e8 	.word	0x200057e8
 8007cb0:	200057ec 	.word	0x200057ec
 8007cb4:	200057f0 	.word	0x200057f0

08007cb8 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8007cb8:	b480      	push	{r7}
 8007cba:	b083      	sub	sp, #12
 8007cbc:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
 8007cbe:	4b1a      	ldr	r3, [pc, #104]	; (8007d28 <mem_init+0x70>)
 8007cc0:	3303      	adds	r3, #3
 8007cc2:	f023 0303 	bic.w	r3, r3, #3
 8007cc6:	461a      	mov	r2, r3
 8007cc8:	4b18      	ldr	r3, [pc, #96]	; (8007d2c <mem_init+0x74>)
 8007cca:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
 8007ccc:	4b17      	ldr	r3, [pc, #92]	; (8007d2c <mem_init+0x74>)
 8007cce:	681b      	ldr	r3, [r3, #0]
 8007cd0:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
 8007cd2:	687b      	ldr	r3, [r7, #4]
 8007cd4:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8007cd8:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 8007cda:	687b      	ldr	r3, [r7, #4]
 8007cdc:	2200      	movs	r2, #0
 8007cde:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 8007ce0:	687b      	ldr	r3, [r7, #4]
 8007ce2:	2200      	movs	r2, #0
 8007ce4:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
 8007ce6:	4b11      	ldr	r3, [pc, #68]	; (8007d2c <mem_init+0x74>)
 8007ce8:	681b      	ldr	r3, [r3, #0]
 8007cea:	f503 5320 	add.w	r3, r3, #10240	; 0x2800
 8007cee:	4a10      	ldr	r2, [pc, #64]	; (8007d30 <mem_init+0x78>)
 8007cf0:	6013      	str	r3, [r2, #0]
  ram_end->used = 1;
 8007cf2:	4b0f      	ldr	r3, [pc, #60]	; (8007d30 <mem_init+0x78>)
 8007cf4:	681b      	ldr	r3, [r3, #0]
 8007cf6:	2201      	movs	r2, #1
 8007cf8:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8007cfa:	4b0d      	ldr	r3, [pc, #52]	; (8007d30 <mem_init+0x78>)
 8007cfc:	681b      	ldr	r3, [r3, #0]
 8007cfe:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8007d02:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 8007d04:	4b0a      	ldr	r3, [pc, #40]	; (8007d30 <mem_init+0x78>)
 8007d06:	681b      	ldr	r3, [r3, #0]
 8007d08:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8007d0c:	805a      	strh	r2, [r3, #2]

  mem_sem = sys_sem_new(1);
 8007d0e:	4b09      	ldr	r3, [pc, #36]	; (8007d34 <mem_init+0x7c>)
 8007d10:	2201      	movs	r2, #1
 8007d12:	701a      	strb	r2, [r3, #0]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
 8007d14:	4b05      	ldr	r3, [pc, #20]	; (8007d2c <mem_init+0x74>)
 8007d16:	681b      	ldr	r3, [r3, #0]
 8007d18:	4a07      	ldr	r2, [pc, #28]	; (8007d38 <mem_init+0x80>)
 8007d1a:	6013      	str	r3, [r2, #0]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
 8007d1c:	bf00      	nop
 8007d1e:	370c      	adds	r7, #12
 8007d20:	46bd      	mov	sp, r7
 8007d22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d26:	4770      	bx	lr
 8007d28:	20002fd4 	.word	0x20002fd4
 8007d2c:	200057e8 	.word	0x200057e8
 8007d30:	200057ec 	.word	0x200057ec
 8007d34:	200057f4 	.word	0x200057f4
 8007d38:	200057f0 	.word	0x200057f0

08007d3c <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 8007d3c:	b580      	push	{r7, lr}
 8007d3e:	b084      	sub	sp, #16
 8007d40:	af00      	add	r7, sp, #0
 8007d42:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 8007d44:	687b      	ldr	r3, [r7, #4]
 8007d46:	2b00      	cmp	r3, #0
 8007d48:	d01f      	beq.n	8007d8a <mem_free+0x4e>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8007d4a:	4b13      	ldr	r3, [pc, #76]	; (8007d98 <mem_free+0x5c>)
 8007d4c:	681b      	ldr	r3, [r3, #0]
 8007d4e:	687a      	ldr	r2, [r7, #4]
 8007d50:	429a      	cmp	r2, r3
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8007d52:	4b11      	ldr	r3, [pc, #68]	; (8007d98 <mem_free+0x5c>)
 8007d54:	681b      	ldr	r3, [r3, #0]
 8007d56:	687a      	ldr	r2, [r7, #4]
 8007d58:	429a      	cmp	r2, r3
 8007d5a:	d318      	bcc.n	8007d8e <mem_free+0x52>
 8007d5c:	4b0f      	ldr	r3, [pc, #60]	; (8007d9c <mem_free+0x60>)
 8007d5e:	681b      	ldr	r3, [r3, #0]
 8007d60:	687a      	ldr	r2, [r7, #4]
 8007d62:	429a      	cmp	r2, r3
 8007d64:	d213      	bcs.n	8007d8e <mem_free+0x52>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8007d66:	687b      	ldr	r3, [r7, #4]
 8007d68:	3b08      	subs	r3, #8
 8007d6a:	60fb      	str	r3, [r7, #12]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 8007d6c:	68fb      	ldr	r3, [r7, #12]
 8007d6e:	2200      	movs	r2, #0
 8007d70:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 8007d72:	4b0b      	ldr	r3, [pc, #44]	; (8007da0 <mem_free+0x64>)
 8007d74:	681b      	ldr	r3, [r3, #0]
 8007d76:	68fa      	ldr	r2, [r7, #12]
 8007d78:	429a      	cmp	r2, r3
 8007d7a:	d202      	bcs.n	8007d82 <mem_free+0x46>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8007d7c:	4a08      	ldr	r2, [pc, #32]	; (8007da0 <mem_free+0x64>)
 8007d7e:	68fb      	ldr	r3, [r7, #12]
 8007d80:	6013      	str	r3, [r2, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 8007d82:	68f8      	ldr	r0, [r7, #12]
 8007d84:	f7ff ff38 	bl	8007bf8 <plug_holes>
 8007d88:	e002      	b.n	8007d90 <mem_free+0x54>
    return;
 8007d8a:	bf00      	nop
 8007d8c:	e000      	b.n	8007d90 <mem_free+0x54>
    return;
 8007d8e:	bf00      	nop
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8007d90:	3710      	adds	r7, #16
 8007d92:	46bd      	mov	sp, r7
 8007d94:	bd80      	pop	{r7, pc}
 8007d96:	bf00      	nop
 8007d98:	200057e8 	.word	0x200057e8
 8007d9c:	200057ec 	.word	0x200057ec
 8007da0:	200057f0 	.word	0x200057f0

08007da4 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
 8007da4:	b480      	push	{r7}
 8007da6:	b087      	sub	sp, #28
 8007da8:	af00      	add	r7, sp, #0
 8007daa:	6078      	str	r0, [r7, #4]
 8007dac:	460b      	mov	r3, r1
 8007dae:	807b      	strh	r3, [r7, #2]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8007db0:	887b      	ldrh	r3, [r7, #2]
 8007db2:	3303      	adds	r3, #3
 8007db4:	b29b      	uxth	r3, r3
 8007db6:	f023 0303 	bic.w	r3, r3, #3
 8007dba:	807b      	strh	r3, [r7, #2]

  if(newsize < MIN_SIZE_ALIGNED) {
 8007dbc:	887b      	ldrh	r3, [r7, #2]
 8007dbe:	2b0b      	cmp	r3, #11
 8007dc0:	d801      	bhi.n	8007dc6 <mem_realloc+0x22>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 8007dc2:	230c      	movs	r3, #12
 8007dc4:	807b      	strh	r3, [r7, #2]
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 8007dc6:	887b      	ldrh	r3, [r7, #2]
 8007dc8:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 8007dcc:	d901      	bls.n	8007dd2 <mem_realloc+0x2e>
    return NULL;
 8007dce:	2300      	movs	r3, #0
 8007dd0:	e099      	b.n	8007f06 <mem_realloc+0x162>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8007dd2:	4b50      	ldr	r3, [pc, #320]	; (8007f14 <mem_realloc+0x170>)
 8007dd4:	681b      	ldr	r3, [r3, #0]
 8007dd6:	687a      	ldr	r2, [r7, #4]
 8007dd8:	429a      	cmp	r2, r3
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8007dda:	4b4e      	ldr	r3, [pc, #312]	; (8007f14 <mem_realloc+0x170>)
 8007ddc:	681b      	ldr	r3, [r3, #0]
 8007dde:	687a      	ldr	r2, [r7, #4]
 8007de0:	429a      	cmp	r2, r3
 8007de2:	d304      	bcc.n	8007dee <mem_realloc+0x4a>
 8007de4:	4b4c      	ldr	r3, [pc, #304]	; (8007f18 <mem_realloc+0x174>)
 8007de6:	681b      	ldr	r3, [r3, #0]
 8007de8:	687a      	ldr	r2, [r7, #4]
 8007dea:	429a      	cmp	r2, r3
 8007dec:	d301      	bcc.n	8007df2 <mem_realloc+0x4e>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
 8007dee:	687b      	ldr	r3, [r7, #4]
 8007df0:	e089      	b.n	8007f06 <mem_realloc+0x162>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8007df2:	687b      	ldr	r3, [r7, #4]
 8007df4:	3b08      	subs	r3, #8
 8007df6:	617b      	str	r3, [r7, #20]
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
 8007df8:	697b      	ldr	r3, [r7, #20]
 8007dfa:	4a46      	ldr	r2, [pc, #280]	; (8007f14 <mem_realloc+0x170>)
 8007dfc:	6812      	ldr	r2, [r2, #0]
 8007dfe:	1a9b      	subs	r3, r3, r2
 8007e00:	827b      	strh	r3, [r7, #18]

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8007e02:	697b      	ldr	r3, [r7, #20]
 8007e04:	881a      	ldrh	r2, [r3, #0]
 8007e06:	8a7b      	ldrh	r3, [r7, #18]
 8007e08:	1ad3      	subs	r3, r2, r3
 8007e0a:	b29b      	uxth	r3, r3
 8007e0c:	3b08      	subs	r3, #8
 8007e0e:	823b      	strh	r3, [r7, #16]
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
 8007e10:	887a      	ldrh	r2, [r7, #2]
 8007e12:	8a3b      	ldrh	r3, [r7, #16]
 8007e14:	429a      	cmp	r2, r3
 8007e16:	d901      	bls.n	8007e1c <mem_realloc+0x78>
    /* not supported */
    return NULL;
 8007e18:	2300      	movs	r3, #0
 8007e1a:	e074      	b.n	8007f06 <mem_realloc+0x162>
  }
  if (newsize == size) {
 8007e1c:	887a      	ldrh	r2, [r7, #2]
 8007e1e:	8a3b      	ldrh	r3, [r7, #16]
 8007e20:	429a      	cmp	r2, r3
 8007e22:	d101      	bne.n	8007e28 <mem_realloc+0x84>
    /* No change in size, simply return */
    return rmem;
 8007e24:	687b      	ldr	r3, [r7, #4]
 8007e26:	e06e      	b.n	8007f06 <mem_realloc+0x162>
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
 8007e28:	4b3a      	ldr	r3, [pc, #232]	; (8007f14 <mem_realloc+0x170>)
 8007e2a:	681b      	ldr	r3, [r3, #0]
 8007e2c:	697a      	ldr	r2, [r7, #20]
 8007e2e:	8812      	ldrh	r2, [r2, #0]
 8007e30:	4413      	add	r3, r2
 8007e32:	60fb      	str	r3, [r7, #12]
  if(mem2->used == 0) {
 8007e34:	68fb      	ldr	r3, [r7, #12]
 8007e36:	791b      	ldrb	r3, [r3, #4]
 8007e38:	2b00      	cmp	r3, #0
 8007e3a:	d131      	bne.n	8007ea0 <mem_realloc+0xfc>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 8007e3c:	68fb      	ldr	r3, [r7, #12]
 8007e3e:	881b      	ldrh	r3, [r3, #0]
 8007e40:	817b      	strh	r3, [r7, #10]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8007e42:	8a7a      	ldrh	r2, [r7, #18]
 8007e44:	887b      	ldrh	r3, [r7, #2]
 8007e46:	4413      	add	r3, r2
 8007e48:	b29b      	uxth	r3, r3
 8007e4a:	3308      	adds	r3, #8
 8007e4c:	813b      	strh	r3, [r7, #8]
    if (lfree == mem2) {
 8007e4e:	4b33      	ldr	r3, [pc, #204]	; (8007f1c <mem_realloc+0x178>)
 8007e50:	681a      	ldr	r2, [r3, #0]
 8007e52:	68fb      	ldr	r3, [r7, #12]
 8007e54:	429a      	cmp	r2, r3
 8007e56:	d105      	bne.n	8007e64 <mem_realloc+0xc0>
      lfree = (struct mem *)&ram[ptr2];
 8007e58:	4b2e      	ldr	r3, [pc, #184]	; (8007f14 <mem_realloc+0x170>)
 8007e5a:	681a      	ldr	r2, [r3, #0]
 8007e5c:	893b      	ldrh	r3, [r7, #8]
 8007e5e:	4413      	add	r3, r2
 8007e60:	4a2e      	ldr	r2, [pc, #184]	; (8007f1c <mem_realloc+0x178>)
 8007e62:	6013      	str	r3, [r2, #0]
    }
    mem2 = (struct mem *)&ram[ptr2];
 8007e64:	4b2b      	ldr	r3, [pc, #172]	; (8007f14 <mem_realloc+0x170>)
 8007e66:	681a      	ldr	r2, [r3, #0]
 8007e68:	893b      	ldrh	r3, [r7, #8]
 8007e6a:	4413      	add	r3, r2
 8007e6c:	60fb      	str	r3, [r7, #12]
    mem2->used = 0;
 8007e6e:	68fb      	ldr	r3, [r7, #12]
 8007e70:	2200      	movs	r2, #0
 8007e72:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 8007e74:	68fb      	ldr	r3, [r7, #12]
 8007e76:	897a      	ldrh	r2, [r7, #10]
 8007e78:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 8007e7a:	68fb      	ldr	r3, [r7, #12]
 8007e7c:	8a7a      	ldrh	r2, [r7, #18]
 8007e7e:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 8007e80:	697b      	ldr	r3, [r7, #20]
 8007e82:	893a      	ldrh	r2, [r7, #8]
 8007e84:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8007e86:	68fb      	ldr	r3, [r7, #12]
 8007e88:	881b      	ldrh	r3, [r3, #0]
 8007e8a:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 8007e8e:	d039      	beq.n	8007f04 <mem_realloc+0x160>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
 8007e90:	4b20      	ldr	r3, [pc, #128]	; (8007f14 <mem_realloc+0x170>)
 8007e92:	681b      	ldr	r3, [r3, #0]
 8007e94:	68fa      	ldr	r2, [r7, #12]
 8007e96:	8812      	ldrh	r2, [r2, #0]
 8007e98:	4413      	add	r3, r2
 8007e9a:	893a      	ldrh	r2, [r7, #8]
 8007e9c:	805a      	strh	r2, [r3, #2]
 8007e9e:	e031      	b.n	8007f04 <mem_realloc+0x160>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8007ea0:	887b      	ldrh	r3, [r7, #2]
 8007ea2:	f103 0214 	add.w	r2, r3, #20
 8007ea6:	8a3b      	ldrh	r3, [r7, #16]
 8007ea8:	429a      	cmp	r2, r3
 8007eaa:	d82b      	bhi.n	8007f04 <mem_realloc+0x160>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8007eac:	8a7a      	ldrh	r2, [r7, #18]
 8007eae:	887b      	ldrh	r3, [r7, #2]
 8007eb0:	4413      	add	r3, r2
 8007eb2:	b29b      	uxth	r3, r3
 8007eb4:	3308      	adds	r3, #8
 8007eb6:	813b      	strh	r3, [r7, #8]
    mem2 = (struct mem *)&ram[ptr2];
 8007eb8:	4b16      	ldr	r3, [pc, #88]	; (8007f14 <mem_realloc+0x170>)
 8007eba:	681a      	ldr	r2, [r3, #0]
 8007ebc:	893b      	ldrh	r3, [r7, #8]
 8007ebe:	4413      	add	r3, r2
 8007ec0:	60fb      	str	r3, [r7, #12]
    if (mem2 < lfree) {
 8007ec2:	4b16      	ldr	r3, [pc, #88]	; (8007f1c <mem_realloc+0x178>)
 8007ec4:	681b      	ldr	r3, [r3, #0]
 8007ec6:	68fa      	ldr	r2, [r7, #12]
 8007ec8:	429a      	cmp	r2, r3
 8007eca:	d202      	bcs.n	8007ed2 <mem_realloc+0x12e>
      lfree = mem2;
 8007ecc:	4a13      	ldr	r2, [pc, #76]	; (8007f1c <mem_realloc+0x178>)
 8007ece:	68fb      	ldr	r3, [r7, #12]
 8007ed0:	6013      	str	r3, [r2, #0]
    }
    mem2->used = 0;
 8007ed2:	68fb      	ldr	r3, [r7, #12]
 8007ed4:	2200      	movs	r2, #0
 8007ed6:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 8007ed8:	697b      	ldr	r3, [r7, #20]
 8007eda:	881a      	ldrh	r2, [r3, #0]
 8007edc:	68fb      	ldr	r3, [r7, #12]
 8007ede:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 8007ee0:	68fb      	ldr	r3, [r7, #12]
 8007ee2:	8a7a      	ldrh	r2, [r7, #18]
 8007ee4:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 8007ee6:	697b      	ldr	r3, [r7, #20]
 8007ee8:	893a      	ldrh	r2, [r7, #8]
 8007eea:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8007eec:	68fb      	ldr	r3, [r7, #12]
 8007eee:	881b      	ldrh	r3, [r3, #0]
 8007ef0:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 8007ef4:	d006      	beq.n	8007f04 <mem_realloc+0x160>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
 8007ef6:	4b07      	ldr	r3, [pc, #28]	; (8007f14 <mem_realloc+0x170>)
 8007ef8:	681b      	ldr	r3, [r3, #0]
 8007efa:	68fa      	ldr	r2, [r7, #12]
 8007efc:	8812      	ldrh	r2, [r2, #0]
 8007efe:	4413      	add	r3, r2
 8007f00:	893a      	ldrh	r2, [r7, #8]
 8007f02:	805a      	strh	r2, [r3, #2]
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
 8007f04:	687b      	ldr	r3, [r7, #4]
}
 8007f06:	4618      	mov	r0, r3
 8007f08:	371c      	adds	r7, #28
 8007f0a:	46bd      	mov	sp, r7
 8007f0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f10:	4770      	bx	lr
 8007f12:	bf00      	nop
 8007f14:	200057e8 	.word	0x200057e8
 8007f18:	200057ec 	.word	0x200057ec
 8007f1c:	200057f0 	.word	0x200057f0

08007f20 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 8007f20:	b480      	push	{r7}
 8007f22:	b087      	sub	sp, #28
 8007f24:	af00      	add	r7, sp, #0
 8007f26:	4603      	mov	r3, r0
 8007f28:	80fb      	strh	r3, [r7, #6]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 8007f2a:	88fb      	ldrh	r3, [r7, #6]
 8007f2c:	2b00      	cmp	r3, #0
 8007f2e:	d101      	bne.n	8007f34 <mem_malloc+0x14>
    return NULL;
 8007f30:	2300      	movs	r3, #0
 8007f32:	e08f      	b.n	8008054 <mem_malloc+0x134>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 8007f34:	88fb      	ldrh	r3, [r7, #6]
 8007f36:	3303      	adds	r3, #3
 8007f38:	b29b      	uxth	r3, r3
 8007f3a:	f023 0303 	bic.w	r3, r3, #3
 8007f3e:	80fb      	strh	r3, [r7, #6]

  if(size < MIN_SIZE_ALIGNED) {
 8007f40:	88fb      	ldrh	r3, [r7, #6]
 8007f42:	2b0b      	cmp	r3, #11
 8007f44:	d801      	bhi.n	8007f4a <mem_malloc+0x2a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 8007f46:	230c      	movs	r3, #12
 8007f48:	80fb      	strh	r3, [r7, #6]
  }

  if (size > MEM_SIZE_ALIGNED) {
 8007f4a:	88fb      	ldrh	r3, [r7, #6]
 8007f4c:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 8007f50:	d901      	bls.n	8007f56 <mem_malloc+0x36>
    return NULL;
 8007f52:	2300      	movs	r3, #0
 8007f54:	e07e      	b.n	8008054 <mem_malloc+0x134>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
 8007f56:	4b42      	ldr	r3, [pc, #264]	; (8008060 <mem_malloc+0x140>)
 8007f58:	681b      	ldr	r3, [r3, #0]
 8007f5a:	461a      	mov	r2, r3
 8007f5c:	4b41      	ldr	r3, [pc, #260]	; (8008064 <mem_malloc+0x144>)
 8007f5e:	681b      	ldr	r3, [r3, #0]
 8007f60:	1ad3      	subs	r3, r2, r3
 8007f62:	82fb      	strh	r3, [r7, #22]
 8007f64:	e06f      	b.n	8008046 <mem_malloc+0x126>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
 8007f66:	4b3f      	ldr	r3, [pc, #252]	; (8008064 <mem_malloc+0x144>)
 8007f68:	681a      	ldr	r2, [r3, #0]
 8007f6a:	8afb      	ldrh	r3, [r7, #22]
 8007f6c:	4413      	add	r3, r2
 8007f6e:	613b      	str	r3, [r7, #16]
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8007f70:	693b      	ldr	r3, [r7, #16]
 8007f72:	791b      	ldrb	r3, [r3, #4]
 8007f74:	2b00      	cmp	r3, #0
 8007f76:	d160      	bne.n	800803a <mem_malloc+0x11a>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8007f78:	693b      	ldr	r3, [r7, #16]
 8007f7a:	881b      	ldrh	r3, [r3, #0]
 8007f7c:	461a      	mov	r2, r3
 8007f7e:	8afb      	ldrh	r3, [r7, #22]
 8007f80:	1ad3      	subs	r3, r2, r3
 8007f82:	f1a3 0208 	sub.w	r2, r3, #8
 8007f86:	88fb      	ldrh	r3, [r7, #6]
      if ((!mem->used) &&
 8007f88:	429a      	cmp	r2, r3
 8007f8a:	d356      	bcc.n	800803a <mem_malloc+0x11a>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8007f8c:	693b      	ldr	r3, [r7, #16]
 8007f8e:	881b      	ldrh	r3, [r3, #0]
 8007f90:	461a      	mov	r2, r3
 8007f92:	8afb      	ldrh	r3, [r7, #22]
 8007f94:	1ad3      	subs	r3, r2, r3
 8007f96:	f1a3 0208 	sub.w	r2, r3, #8
 8007f9a:	88fb      	ldrh	r3, [r7, #6]
 8007f9c:	3314      	adds	r3, #20
 8007f9e:	429a      	cmp	r2, r3
 8007fa0:	d327      	bcc.n	8007ff2 <mem_malloc+0xd2>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8007fa2:	8afa      	ldrh	r2, [r7, #22]
 8007fa4:	88fb      	ldrh	r3, [r7, #6]
 8007fa6:	4413      	add	r3, r2
 8007fa8:	b29b      	uxth	r3, r3
 8007faa:	3308      	adds	r3, #8
 8007fac:	81fb      	strh	r3, [r7, #14]
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
 8007fae:	4b2d      	ldr	r3, [pc, #180]	; (8008064 <mem_malloc+0x144>)
 8007fb0:	681a      	ldr	r2, [r3, #0]
 8007fb2:	89fb      	ldrh	r3, [r7, #14]
 8007fb4:	4413      	add	r3, r2
 8007fb6:	60bb      	str	r3, [r7, #8]
          mem2->used = 0;
 8007fb8:	68bb      	ldr	r3, [r7, #8]
 8007fba:	2200      	movs	r2, #0
 8007fbc:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 8007fbe:	693b      	ldr	r3, [r7, #16]
 8007fc0:	881a      	ldrh	r2, [r3, #0]
 8007fc2:	68bb      	ldr	r3, [r7, #8]
 8007fc4:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 8007fc6:	68bb      	ldr	r3, [r7, #8]
 8007fc8:	8afa      	ldrh	r2, [r7, #22]
 8007fca:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 8007fcc:	693b      	ldr	r3, [r7, #16]
 8007fce:	89fa      	ldrh	r2, [r7, #14]
 8007fd0:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 8007fd2:	693b      	ldr	r3, [r7, #16]
 8007fd4:	2201      	movs	r2, #1
 8007fd6:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 8007fd8:	68bb      	ldr	r3, [r7, #8]
 8007fda:	881b      	ldrh	r3, [r3, #0]
 8007fdc:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 8007fe0:	d00a      	beq.n	8007ff8 <mem_malloc+0xd8>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
 8007fe2:	4b20      	ldr	r3, [pc, #128]	; (8008064 <mem_malloc+0x144>)
 8007fe4:	681b      	ldr	r3, [r3, #0]
 8007fe6:	68ba      	ldr	r2, [r7, #8]
 8007fe8:	8812      	ldrh	r2, [r2, #0]
 8007fea:	4413      	add	r3, r2
 8007fec:	89fa      	ldrh	r2, [r7, #14]
 8007fee:	805a      	strh	r2, [r3, #2]
 8007ff0:	e002      	b.n	8007ff8 <mem_malloc+0xd8>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8007ff2:	693b      	ldr	r3, [r7, #16]
 8007ff4:	2201      	movs	r2, #1
 8007ff6:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
 8007ff8:	4b19      	ldr	r3, [pc, #100]	; (8008060 <mem_malloc+0x140>)
 8007ffa:	681b      	ldr	r3, [r3, #0]
 8007ffc:	693a      	ldr	r2, [r7, #16]
 8007ffe:	429a      	cmp	r2, r3
 8008000:	d118      	bne.n	8008034 <mem_malloc+0x114>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
 8008002:	e007      	b.n	8008014 <mem_malloc+0xf4>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
 8008004:	4b17      	ldr	r3, [pc, #92]	; (8008064 <mem_malloc+0x144>)
 8008006:	681b      	ldr	r3, [r3, #0]
 8008008:	4a15      	ldr	r2, [pc, #84]	; (8008060 <mem_malloc+0x140>)
 800800a:	6812      	ldr	r2, [r2, #0]
 800800c:	8812      	ldrh	r2, [r2, #0]
 800800e:	4413      	add	r3, r2
 8008010:	4a13      	ldr	r2, [pc, #76]	; (8008060 <mem_malloc+0x140>)
 8008012:	6013      	str	r3, [r2, #0]
          while (lfree->used && lfree != ram_end) {
 8008014:	4b12      	ldr	r3, [pc, #72]	; (8008060 <mem_malloc+0x140>)
 8008016:	681b      	ldr	r3, [r3, #0]
 8008018:	791b      	ldrb	r3, [r3, #4]
 800801a:	2b00      	cmp	r3, #0
 800801c:	d005      	beq.n	800802a <mem_malloc+0x10a>
 800801e:	4b10      	ldr	r3, [pc, #64]	; (8008060 <mem_malloc+0x140>)
 8008020:	681a      	ldr	r2, [r3, #0]
 8008022:	4b11      	ldr	r3, [pc, #68]	; (8008068 <mem_malloc+0x148>)
 8008024:	681b      	ldr	r3, [r3, #0]
 8008026:	429a      	cmp	r2, r3
 8008028:	d1ec      	bne.n	8008004 <mem_malloc+0xe4>
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 800802a:	4b0d      	ldr	r3, [pc, #52]	; (8008060 <mem_malloc+0x140>)
 800802c:	681a      	ldr	r2, [r3, #0]
 800802e:	4b0e      	ldr	r3, [pc, #56]	; (8008068 <mem_malloc+0x148>)
 8008030:	681b      	ldr	r3, [r3, #0]
 8008032:	429a      	cmp	r2, r3
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 8008034:	693b      	ldr	r3, [r7, #16]
 8008036:	3308      	adds	r3, #8
 8008038:	e00c      	b.n	8008054 <mem_malloc+0x134>
         ptr = ((struct mem *)&ram[ptr])->next) {
 800803a:	4b0a      	ldr	r3, [pc, #40]	; (8008064 <mem_malloc+0x144>)
 800803c:	681a      	ldr	r2, [r3, #0]
 800803e:	8afb      	ldrh	r3, [r7, #22]
 8008040:	4413      	add	r3, r2
 8008042:	881b      	ldrh	r3, [r3, #0]
 8008044:	82fb      	strh	r3, [r7, #22]
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
 8008046:	8afa      	ldrh	r2, [r7, #22]
 8008048:	88fb      	ldrh	r3, [r7, #6]
 800804a:	f5c3 5320 	rsb	r3, r3, #10240	; 0x2800
 800804e:	429a      	cmp	r2, r3
 8008050:	db89      	blt.n	8007f66 <mem_malloc+0x46>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
 8008052:	2300      	movs	r3, #0
}
 8008054:	4618      	mov	r0, r3
 8008056:	371c      	adds	r7, #28
 8008058:	46bd      	mov	sp, r7
 800805a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800805e:	4770      	bx	lr
 8008060:	200057f0 	.word	0x200057f0
 8008064:	200057e8 	.word	0x200057e8
 8008068:	200057ec 	.word	0x200057ec

0800806c <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 800806c:	b480      	push	{r7}
 800806e:	b083      	sub	sp, #12
 8008070:	af00      	add	r7, sp, #0
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
 8008072:	2300      	movs	r3, #0
 8008074:	807b      	strh	r3, [r7, #2]
 8008076:	e002      	b.n	800807e <memp_init+0x12>
 8008078:	887b      	ldrh	r3, [r7, #2]
 800807a:	3301      	adds	r3, #1
 800807c:	807b      	strh	r3, [r7, #2]
 800807e:	887b      	ldrh	r3, [r7, #2]
 8008080:	2b08      	cmp	r3, #8
 8008082:	d9f9      	bls.n	8008078 <memp_init+0xc>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
 8008084:	4b1c      	ldr	r3, [pc, #112]	; (80080f8 <memp_init+0x8c>)
 8008086:	3303      	adds	r3, #3
 8008088:	f023 0303 	bic.w	r3, r3, #3
 800808c:	607b      	str	r3, [r7, #4]
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 800808e:	2300      	movs	r3, #0
 8008090:	807b      	strh	r3, [r7, #2]
 8008092:	e027      	b.n	80080e4 <memp_init+0x78>
    memp_tab[i] = NULL;
 8008094:	887b      	ldrh	r3, [r7, #2]
 8008096:	4a19      	ldr	r2, [pc, #100]	; (80080fc <memp_init+0x90>)
 8008098:	2100      	movs	r1, #0
 800809a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 800809e:	2300      	movs	r3, #0
 80080a0:	803b      	strh	r3, [r7, #0]
 80080a2:	e015      	b.n	80080d0 <memp_init+0x64>
      memp->next = memp_tab[i];
 80080a4:	887b      	ldrh	r3, [r7, #2]
 80080a6:	4a15      	ldr	r2, [pc, #84]	; (80080fc <memp_init+0x90>)
 80080a8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80080ac:	687b      	ldr	r3, [r7, #4]
 80080ae:	601a      	str	r2, [r3, #0]
      memp_tab[i] = memp;
 80080b0:	887b      	ldrh	r3, [r7, #2]
 80080b2:	4912      	ldr	r1, [pc, #72]	; (80080fc <memp_init+0x90>)
 80080b4:	687a      	ldr	r2, [r7, #4]
 80080b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 80080ba:	887b      	ldrh	r3, [r7, #2]
 80080bc:	4a10      	ldr	r2, [pc, #64]	; (8008100 <memp_init+0x94>)
 80080be:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80080c2:	461a      	mov	r2, r3
 80080c4:	687b      	ldr	r3, [r7, #4]
 80080c6:	4413      	add	r3, r2
 80080c8:	607b      	str	r3, [r7, #4]
    for (j = 0; j < memp_num[i]; ++j) {
 80080ca:	883b      	ldrh	r3, [r7, #0]
 80080cc:	3301      	adds	r3, #1
 80080ce:	803b      	strh	r3, [r7, #0]
 80080d0:	887b      	ldrh	r3, [r7, #2]
 80080d2:	4a0c      	ldr	r2, [pc, #48]	; (8008104 <memp_init+0x98>)
 80080d4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80080d8:	883a      	ldrh	r2, [r7, #0]
 80080da:	429a      	cmp	r2, r3
 80080dc:	d3e2      	bcc.n	80080a4 <memp_init+0x38>
  for (i = 0; i < MEMP_MAX; ++i) {
 80080de:	887b      	ldrh	r3, [r7, #2]
 80080e0:	3301      	adds	r3, #1
 80080e2:	807b      	strh	r3, [r7, #2]
 80080e4:	887b      	ldrh	r3, [r7, #2]
 80080e6:	2b08      	cmp	r3, #8
 80080e8:	d9d4      	bls.n	8008094 <memp_init+0x28>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 80080ea:	bf00      	nop
 80080ec:	370c      	adds	r7, #12
 80080ee:	46bd      	mov	sp, r7
 80080f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080f4:	4770      	bx	lr
 80080f6:	bf00      	nop
 80080f8:	2000581c 	.word	0x2000581c
 80080fc:	200057f8 	.word	0x200057f8
 8008100:	0801b570 	.word	0x0801b570
 8008104:	0801b584 	.word	0x0801b584

08008108 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
 8008108:	b480      	push	{r7}
 800810a:	b085      	sub	sp, #20
 800810c:	af00      	add	r7, sp, #0
 800810e:	4603      	mov	r3, r0
 8008110:	71fb      	strb	r3, [r7, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8008112:	79fb      	ldrb	r3, [r7, #7]
 8008114:	2b08      	cmp	r3, #8
 8008116:	d901      	bls.n	800811c <memp_malloc+0x14>
 8008118:	2300      	movs	r3, #0
 800811a:	e00e      	b.n	800813a <memp_malloc+0x32>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 800811c:	79fb      	ldrb	r3, [r7, #7]
 800811e:	4a0a      	ldr	r2, [pc, #40]	; (8008148 <memp_malloc+0x40>)
 8008120:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008124:	60fb      	str	r3, [r7, #12]
  
  if (memp != NULL) {
 8008126:	68fb      	ldr	r3, [r7, #12]
 8008128:	2b00      	cmp	r3, #0
 800812a:	d005      	beq.n	8008138 <memp_malloc+0x30>
    memp_tab[type] = memp->next;
 800812c:	79fb      	ldrb	r3, [r7, #7]
 800812e:	68fa      	ldr	r2, [r7, #12]
 8008130:	6812      	ldr	r2, [r2, #0]
 8008132:	4905      	ldr	r1, [pc, #20]	; (8008148 <memp_malloc+0x40>)
 8008134:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
 8008138:	68fb      	ldr	r3, [r7, #12]
}
 800813a:	4618      	mov	r0, r3
 800813c:	3714      	adds	r7, #20
 800813e:	46bd      	mov	sp, r7
 8008140:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008144:	4770      	bx	lr
 8008146:	bf00      	nop
 8008148:	200057f8 	.word	0x200057f8

0800814c <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 800814c:	b480      	push	{r7}
 800814e:	b085      	sub	sp, #20
 8008150:	af00      	add	r7, sp, #0
 8008152:	4603      	mov	r3, r0
 8008154:	6039      	str	r1, [r7, #0]
 8008156:	71fb      	strb	r3, [r7, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 8008158:	683b      	ldr	r3, [r7, #0]
 800815a:	2b00      	cmp	r3, #0
 800815c:	d00d      	beq.n	800817a <memp_free+0x2e>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
 800815e:	683b      	ldr	r3, [r7, #0]
 8008160:	60fb      	str	r3, [r7, #12]
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
 8008162:	79fb      	ldrb	r3, [r7, #7]
 8008164:	4a08      	ldr	r2, [pc, #32]	; (8008188 <memp_free+0x3c>)
 8008166:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800816a:	68fb      	ldr	r3, [r7, #12]
 800816c:	601a      	str	r2, [r3, #0]
  memp_tab[type] = memp;
 800816e:	79fb      	ldrb	r3, [r7, #7]
 8008170:	4905      	ldr	r1, [pc, #20]	; (8008188 <memp_free+0x3c>)
 8008172:	68fa      	ldr	r2, [r7, #12]
 8008174:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8008178:	e000      	b.n	800817c <memp_free+0x30>
    return;
 800817a:	bf00      	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 800817c:	3714      	adds	r7, #20
 800817e:	46bd      	mov	sp, r7
 8008180:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008184:	4770      	bx	lr
 8008186:	bf00      	nop
 8008188:	200057f8 	.word	0x200057f8

0800818c <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
 800818c:	b580      	push	{r7, lr}
 800818e:	b084      	sub	sp, #16
 8008190:	af00      	add	r7, sp, #0
 8008192:	60f8      	str	r0, [r7, #12]
 8008194:	60b9      	str	r1, [r7, #8]
 8008196:	607a      	str	r2, [r7, #4]
 8008198:	603b      	str	r3, [r7, #0]
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
 800819a:	68fb      	ldr	r3, [r7, #12]
 800819c:	2200      	movs	r2, #0
 800819e:	605a      	str	r2, [r3, #4]
  netif->netmask.addr = 0;
 80081a0:	68fb      	ldr	r3, [r7, #12]
 80081a2:	2200      	movs	r2, #0
 80081a4:	609a      	str	r2, [r3, #8]
  netif->gw.addr = 0;
 80081a6:	68fb      	ldr	r3, [r7, #12]
 80081a8:	2200      	movs	r2, #0
 80081aa:	60da      	str	r2, [r3, #12]
  netif->flags = 0;
 80081ac:	68fb      	ldr	r3, [r7, #12]
 80081ae:	2200      	movs	r2, #0
 80081b0:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
 80081b4:	68fb      	ldr	r3, [r7, #12]
 80081b6:	2200      	movs	r2, #0
 80081b8:	621a      	str	r2, [r3, #32]
#endif /* LWIP_DHCP */
#if LWIP_AUTOIP
  /* netif not under AutoIP control by default */
  netif->autoip = NULL;
 80081ba:	68fb      	ldr	r3, [r7, #12]
 80081bc:	2200      	movs	r2, #0
 80081be:	625a      	str	r2, [r3, #36]	; 0x24
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 80081c0:	68fb      	ldr	r3, [r7, #12]
 80081c2:	69ba      	ldr	r2, [r7, #24]
 80081c4:	61da      	str	r2, [r3, #28]
  netif->num = netifnum++;
 80081c6:	4b13      	ldr	r3, [pc, #76]	; (8008214 <netif_add+0x88>)
 80081c8:	781b      	ldrb	r3, [r3, #0]
 80081ca:	1c5a      	adds	r2, r3, #1
 80081cc:	b2d1      	uxtb	r1, r2
 80081ce:	4a11      	ldr	r2, [pc, #68]	; (8008214 <netif_add+0x88>)
 80081d0:	7011      	strb	r1, [r2, #0]
 80081d2:	68fa      	ldr	r2, [r7, #12]
 80081d4:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
  netif->input = input;
 80081d8:	68fb      	ldr	r3, [r7, #12]
 80081da:	6a3a      	ldr	r2, [r7, #32]
 80081dc:	611a      	str	r2, [r3, #16]
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
 80081de:	683b      	ldr	r3, [r7, #0]
 80081e0:	687a      	ldr	r2, [r7, #4]
 80081e2:	68b9      	ldr	r1, [r7, #8]
 80081e4:	68f8      	ldr	r0, [r7, #12]
 80081e6:	f000 f819 	bl	800821c <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 80081ea:	69fb      	ldr	r3, [r7, #28]
 80081ec:	68f8      	ldr	r0, [r7, #12]
 80081ee:	4798      	blx	r3
 80081f0:	4603      	mov	r3, r0
 80081f2:	2b00      	cmp	r3, #0
 80081f4:	d001      	beq.n	80081fa <netif_add+0x6e>
    return NULL;
 80081f6:	2300      	movs	r3, #0
 80081f8:	e007      	b.n	800820a <netif_add+0x7e>
  }

  /* add this netif to the list */
  netif->next = netif_list;
 80081fa:	4b07      	ldr	r3, [pc, #28]	; (8008218 <netif_add+0x8c>)
 80081fc:	681a      	ldr	r2, [r3, #0]
 80081fe:	68fb      	ldr	r3, [r7, #12]
 8008200:	601a      	str	r2, [r3, #0]
  netif_list = netif;
 8008202:	4a05      	ldr	r2, [pc, #20]	; (8008218 <netif_add+0x8c>)
 8008204:	68fb      	ldr	r3, [r7, #12]
 8008206:	6013      	str	r3, [r2, #0]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 8008208:	68fb      	ldr	r3, [r7, #12]
}
 800820a:	4618      	mov	r0, r3
 800820c:	3710      	adds	r7, #16
 800820e:	46bd      	mov	sp, r7
 8008210:	bd80      	pop	{r7, pc}
 8008212:	bf00      	nop
 8008214:	20007c2f 	.word	0x20007c2f
 8008218:	2000a31c 	.word	0x2000a31c

0800821c <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
 800821c:	b580      	push	{r7, lr}
 800821e:	b084      	sub	sp, #16
 8008220:	af00      	add	r7, sp, #0
 8008222:	60f8      	str	r0, [r7, #12]
 8008224:	60b9      	str	r1, [r7, #8]
 8008226:	607a      	str	r2, [r7, #4]
 8008228:	603b      	str	r3, [r7, #0]
  netif_set_ipaddr(netif, ipaddr);
 800822a:	68b9      	ldr	r1, [r7, #8]
 800822c:	68f8      	ldr	r0, [r7, #12]
 800822e:	f000 f80d 	bl	800824c <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
 8008232:	6879      	ldr	r1, [r7, #4]
 8008234:	68f8      	ldr	r0, [r7, #12]
 8008236:	f000 f873 	bl	8008320 <netif_set_netmask>
  netif_set_gw(netif, gw);
 800823a:	6839      	ldr	r1, [r7, #0]
 800823c:	68f8      	ldr	r0, [r7, #12]
 800823e:	f000 f85b 	bl	80082f8 <netif_set_gw>
}
 8008242:	bf00      	nop
 8008244:	3710      	adds	r7, #16
 8008246:	46bd      	mov	sp, r7
 8008248:	bd80      	pop	{r7, pc}
	...

0800824c <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
 800824c:	b580      	push	{r7, lr}
 800824e:	b086      	sub	sp, #24
 8008250:	af00      	add	r7, sp, #0
 8008252:	6078      	str	r0, [r7, #4]
 8008254:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
 8008256:	683b      	ldr	r3, [r7, #0]
 8008258:	681a      	ldr	r2, [r3, #0]
 800825a:	687b      	ldr	r3, [r7, #4]
 800825c:	685b      	ldr	r3, [r3, #4]
 800825e:	429a      	cmp	r2, r3
 8008260:	d039      	beq.n	80082d6 <netif_set_ipaddr+0x8a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 8008262:	4b23      	ldr	r3, [pc, #140]	; (80082f0 <netif_set_ipaddr+0xa4>)
 8008264:	681b      	ldr	r3, [r3, #0]
 8008266:	617b      	str	r3, [r7, #20]
    while (pcb != NULL) {
 8008268:	e012      	b.n	8008290 <netif_set_ipaddr+0x44>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 800826a:	697b      	ldr	r3, [r7, #20]
 800826c:	681a      	ldr	r2, [r3, #0]
 800826e:	687b      	ldr	r3, [r7, #4]
 8008270:	685b      	ldr	r3, [r3, #4]
 8008272:	429a      	cmp	r2, r3
 8008274:	d109      	bne.n	800828a <netif_set_ipaddr+0x3e>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 8008276:	697b      	ldr	r3, [r7, #20]
 8008278:	68db      	ldr	r3, [r3, #12]
 800827a:	60fb      	str	r3, [r7, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 800827c:	2101      	movs	r1, #1
 800827e:	6978      	ldr	r0, [r7, #20]
 8008280:	f000 fd54 	bl	8008d2c <tcp_abandon>
        pcb = next;
 8008284:	68fb      	ldr	r3, [r7, #12]
 8008286:	617b      	str	r3, [r7, #20]
 8008288:	e002      	b.n	8008290 <netif_set_ipaddr+0x44>
      } else {
        pcb = pcb->next;
 800828a:	697b      	ldr	r3, [r7, #20]
 800828c:	68db      	ldr	r3, [r3, #12]
 800828e:	617b      	str	r3, [r7, #20]
    while (pcb != NULL) {
 8008290:	697b      	ldr	r3, [r7, #20]
 8008292:	2b00      	cmp	r3, #0
 8008294:	d1e9      	bne.n	800826a <netif_set_ipaddr+0x1e>
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8008296:	4b17      	ldr	r3, [pc, #92]	; (80082f4 <netif_set_ipaddr+0xa8>)
 8008298:	681b      	ldr	r3, [r3, #0]
 800829a:	613b      	str	r3, [r7, #16]
 800829c:	e018      	b.n	80082d0 <netif_set_ipaddr+0x84>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 800829e:	693b      	ldr	r3, [r7, #16]
 80082a0:	2b00      	cmp	r3, #0
 80082a2:	d012      	beq.n	80082ca <netif_set_ipaddr+0x7e>
 80082a4:	693b      	ldr	r3, [r7, #16]
 80082a6:	681b      	ldr	r3, [r3, #0]
 80082a8:	2b00      	cmp	r3, #0
 80082aa:	d00e      	beq.n	80082ca <netif_set_ipaddr+0x7e>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
 80082ac:	693b      	ldr	r3, [r7, #16]
 80082ae:	681a      	ldr	r2, [r3, #0]
 80082b0:	687b      	ldr	r3, [r7, #4]
 80082b2:	685b      	ldr	r3, [r3, #4]
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 80082b4:	429a      	cmp	r2, r3
 80082b6:	d108      	bne.n	80082ca <netif_set_ipaddr+0x7e>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 80082b8:	683b      	ldr	r3, [r7, #0]
 80082ba:	2b00      	cmp	r3, #0
 80082bc:	d002      	beq.n	80082c4 <netif_set_ipaddr+0x78>
 80082be:	683b      	ldr	r3, [r7, #0]
 80082c0:	681b      	ldr	r3, [r3, #0]
 80082c2:	e000      	b.n	80082c6 <netif_set_ipaddr+0x7a>
 80082c4:	2300      	movs	r3, #0
 80082c6:	693a      	ldr	r2, [r7, #16]
 80082c8:	6013      	str	r3, [r2, #0]
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80082ca:	693b      	ldr	r3, [r7, #16]
 80082cc:	68db      	ldr	r3, [r3, #12]
 80082ce:	613b      	str	r3, [r7, #16]
 80082d0:	693b      	ldr	r3, [r7, #16]
 80082d2:	2b00      	cmp	r3, #0
 80082d4:	d1e3      	bne.n	800829e <netif_set_ipaddr+0x52>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 80082d6:	683b      	ldr	r3, [r7, #0]
 80082d8:	2b00      	cmp	r3, #0
 80082da:	d002      	beq.n	80082e2 <netif_set_ipaddr+0x96>
 80082dc:	683b      	ldr	r3, [r7, #0]
 80082de:	681b      	ldr	r3, [r3, #0]
 80082e0:	e000      	b.n	80082e4 <netif_set_ipaddr+0x98>
 80082e2:	2300      	movs	r3, #0
 80082e4:	687a      	ldr	r2, [r7, #4]
 80082e6:	6053      	str	r3, [r2, #4]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
 80082e8:	bf00      	nop
 80082ea:	3718      	adds	r7, #24
 80082ec:	46bd      	mov	sp, r7
 80082ee:	bd80      	pop	{r7, pc}
 80082f0:	2000a324 	.word	0x2000a324
 80082f4:	2000a32c 	.word	0x2000a32c

080082f8 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
 80082f8:	b480      	push	{r7}
 80082fa:	b083      	sub	sp, #12
 80082fc:	af00      	add	r7, sp, #0
 80082fe:	6078      	str	r0, [r7, #4]
 8008300:	6039      	str	r1, [r7, #0]
  ip_addr_set(&(netif->gw), gw);
 8008302:	683b      	ldr	r3, [r7, #0]
 8008304:	2b00      	cmp	r3, #0
 8008306:	d002      	beq.n	800830e <netif_set_gw+0x16>
 8008308:	683b      	ldr	r3, [r7, #0]
 800830a:	681b      	ldr	r3, [r3, #0]
 800830c:	e000      	b.n	8008310 <netif_set_gw+0x18>
 800830e:	2300      	movs	r3, #0
 8008310:	687a      	ldr	r2, [r7, #4]
 8008312:	60d3      	str	r3, [r2, #12]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
 8008314:	bf00      	nop
 8008316:	370c      	adds	r7, #12
 8008318:	46bd      	mov	sp, r7
 800831a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800831e:	4770      	bx	lr

08008320 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
 8008320:	b480      	push	{r7}
 8008322:	b083      	sub	sp, #12
 8008324:	af00      	add	r7, sp, #0
 8008326:	6078      	str	r0, [r7, #4]
 8008328:	6039      	str	r1, [r7, #0]
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 800832a:	683b      	ldr	r3, [r7, #0]
 800832c:	2b00      	cmp	r3, #0
 800832e:	d002      	beq.n	8008336 <netif_set_netmask+0x16>
 8008330:	683b      	ldr	r3, [r7, #0]
 8008332:	681b      	ldr	r3, [r3, #0]
 8008334:	e000      	b.n	8008338 <netif_set_netmask+0x18>
 8008336:	2300      	movs	r3, #0
 8008338:	687a      	ldr	r2, [r7, #4]
 800833a:	6093      	str	r3, [r2, #8]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
 800833c:	bf00      	nop
 800833e:	370c      	adds	r7, #12
 8008340:	46bd      	mov	sp, r7
 8008342:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008346:	4770      	bx	lr

08008348 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 8008348:	b480      	push	{r7}
 800834a:	b083      	sub	sp, #12
 800834c:	af00      	add	r7, sp, #0
 800834e:	6078      	str	r0, [r7, #4]
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 8008350:	4a04      	ldr	r2, [pc, #16]	; (8008364 <netif_set_default+0x1c>)
 8008352:	687b      	ldr	r3, [r7, #4]
 8008354:	6013      	str	r3, [r2, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 8008356:	bf00      	nop
 8008358:	370c      	adds	r7, #12
 800835a:	46bd      	mov	sp, r7
 800835c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008360:	4770      	bx	lr
 8008362:	bf00      	nop
 8008364:	2000a320 	.word	0x2000a320

08008368 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 8008368:	b580      	push	{r7, lr}
 800836a:	b082      	sub	sp, #8
 800836c:	af00      	add	r7, sp, #0
 800836e:	6078      	str	r0, [r7, #4]
  if ( !(netif->flags & NETIF_FLAG_UP )) {
 8008370:	687b      	ldr	r3, [r7, #4]
 8008372:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8008376:	f003 0301 	and.w	r3, r3, #1
 800837a:	2b00      	cmp	r3, #0
 800837c:	d115      	bne.n	80083aa <netif_set_up+0x42>
    netif->flags |= NETIF_FLAG_UP;
 800837e:	687b      	ldr	r3, [r7, #4]
 8008380:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8008384:	f043 0301 	orr.w	r3, r3, #1
 8008388:	b2da      	uxtb	r2, r3
 800838a:	687b      	ldr	r3, [r7, #4]
 800838c:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
    NETIF_LINK_CALLBACK(netif);
    NETIF_STATUS_CALLBACK(netif);

#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8008390:	687b      	ldr	r3, [r7, #4]
 8008392:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8008396:	f003 0320 	and.w	r3, r3, #32
 800839a:	2b00      	cmp	r3, #0
 800839c:	d005      	beq.n	80083aa <netif_set_up+0x42>
      etharp_gratuitous(netif);
 800839e:	687b      	ldr	r3, [r7, #4]
 80083a0:	3304      	adds	r3, #4
 80083a2:	4619      	mov	r1, r3
 80083a4:	6878      	ldr	r0, [r7, #4]
 80083a6:	f005 fbd7 	bl	800db58 <etharp_request>
    if (netif->flags & NETIF_FLAG_IGMP) {
      igmp_report_groups( netif);
    }
#endif /* LWIP_IGMP */
  }
}
 80083aa:	bf00      	nop
 80083ac:	3708      	adds	r7, #8
 80083ae:	46bd      	mov	sp, r7
 80083b0:	bd80      	pop	{r7, pc}

080083b2 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
 80083b2:	b480      	push	{r7}
 80083b4:	b083      	sub	sp, #12
 80083b6:	af00      	add	r7, sp, #0
 80083b8:	6078      	str	r0, [r7, #4]
  if ( netif->flags & NETIF_FLAG_UP )
 80083ba:	687b      	ldr	r3, [r7, #4]
 80083bc:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 80083c0:	f003 0301 	and.w	r3, r3, #1
 80083c4:	2b00      	cmp	r3, #0
 80083c6:	d008      	beq.n	80083da <netif_set_down+0x28>
    {
      netif->flags &= ~NETIF_FLAG_UP;
 80083c8:	687b      	ldr	r3, [r7, #4]
 80083ca:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 80083ce:	f023 0301 	bic.w	r3, r3, #1
 80083d2:	b2da      	uxtb	r2, r3
 80083d4:	687b      	ldr	r3, [r7, #4]
 80083d6:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
 80083da:	bf00      	nop
 80083dc:	370c      	adds	r7, #12
 80083de:	46bd      	mov	sp, r7
 80083e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80083e4:	4770      	bx	lr

080083e6 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
 80083e6:	b480      	push	{r7}
 80083e8:	b083      	sub	sp, #12
 80083ea:	af00      	add	r7, sp, #0
 80083ec:	6078      	str	r0, [r7, #4]
  return (netif->flags & NETIF_FLAG_UP)?1:0;
 80083ee:	687b      	ldr	r3, [r7, #4]
 80083f0:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 80083f4:	f003 0301 	and.w	r3, r3, #1
 80083f8:	2b00      	cmp	r3, #0
 80083fa:	bf14      	ite	ne
 80083fc:	2301      	movne	r3, #1
 80083fe:	2300      	moveq	r3, #0
 8008400:	b2db      	uxtb	r3, r3
}
 8008402:	4618      	mov	r0, r3
 8008404:	370c      	adds	r7, #12
 8008406:	46bd      	mov	sp, r7
 8008408:	f85d 7b04 	ldr.w	r7, [sp], #4
 800840c:	4770      	bx	lr
	...

08008410 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 8008410:	b580      	push	{r7, lr}
 8008412:	b088      	sub	sp, #32
 8008414:	af00      	add	r7, sp, #0
 8008416:	4603      	mov	r3, r0
 8008418:	71fb      	strb	r3, [r7, #7]
 800841a:	460b      	mov	r3, r1
 800841c:	80bb      	strh	r3, [r7, #4]
 800841e:	4613      	mov	r3, r2
 8008420:	71bb      	strb	r3, [r7, #6]
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
 8008422:	2300      	movs	r3, #0
 8008424:	82fb      	strh	r3, [r7, #22]
  switch (layer) {
 8008426:	79fb      	ldrb	r3, [r7, #7]
 8008428:	2b03      	cmp	r3, #3
 800842a:	d815      	bhi.n	8008458 <pbuf_alloc+0x48>
 800842c:	a201      	add	r2, pc, #4	; (adr r2, 8008434 <pbuf_alloc+0x24>)
 800842e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008432:	bf00      	nop
 8008434:	08008445 	.word	0x08008445
 8008438:	0800844b 	.word	0x0800844b
 800843c:	08008451 	.word	0x08008451
 8008440:	0800845d 	.word	0x0800845d
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
 8008444:	8afb      	ldrh	r3, [r7, #22]
 8008446:	3314      	adds	r3, #20
 8008448:	82fb      	strh	r3, [r7, #22]
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
 800844a:	8afb      	ldrh	r3, [r7, #22]
 800844c:	3314      	adds	r3, #20
 800844e:	82fb      	strh	r3, [r7, #22]
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
 8008450:	8afb      	ldrh	r3, [r7, #22]
 8008452:	330e      	adds	r3, #14
 8008454:	82fb      	strh	r3, [r7, #22]
    break;
 8008456:	e002      	b.n	800845e <pbuf_alloc+0x4e>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
 8008458:	2300      	movs	r3, #0
 800845a:	e0cf      	b.n	80085fc <pbuf_alloc+0x1ec>
    break;
 800845c:	bf00      	nop
  }

  switch (type) {
 800845e:	79bb      	ldrb	r3, [r7, #6]
 8008460:	2b03      	cmp	r3, #3
 8008462:	f200 80c2 	bhi.w	80085ea <pbuf_alloc+0x1da>
 8008466:	a201      	add	r2, pc, #4	; (adr r2, 800846c <pbuf_alloc+0x5c>)
 8008468:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800846c:	08008559 	.word	0x08008559
 8008470:	080085b7 	.word	0x080085b7
 8008474:	080085b7 	.word	0x080085b7
 8008478:	0800847d 	.word	0x0800847d
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = memp_malloc(MEMP_PBUF_POOL);
 800847c:	2008      	movs	r0, #8
 800847e:	f7ff fe43 	bl	8008108 <memp_malloc>
 8008482:	61f8      	str	r0, [r7, #28]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 8008484:	69fb      	ldr	r3, [r7, #28]
 8008486:	2b00      	cmp	r3, #0
 8008488:	d101      	bne.n	800848e <pbuf_alloc+0x7e>
      PBUF_POOL_IS_EMPTY();
      return NULL;
 800848a:	2300      	movs	r3, #0
 800848c:	e0b6      	b.n	80085fc <pbuf_alloc+0x1ec>
    }
    p->type = type;
 800848e:	69fb      	ldr	r3, [r7, #28]
 8008490:	79ba      	ldrb	r2, [r7, #6]
 8008492:	731a      	strb	r2, [r3, #12]
    p->next = NULL;
 8008494:	69fb      	ldr	r3, [r7, #28]
 8008496:	2200      	movs	r2, #0
 8008498:	601a      	str	r2, [r3, #0]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 800849a:	8afb      	ldrh	r3, [r7, #22]
 800849c:	3310      	adds	r3, #16
 800849e:	69fa      	ldr	r2, [r7, #28]
 80084a0:	4413      	add	r3, r2
 80084a2:	3303      	adds	r3, #3
 80084a4:	f023 0303 	bic.w	r3, r3, #3
 80084a8:	461a      	mov	r2, r3
 80084aa:	69fb      	ldr	r3, [r7, #28]
 80084ac:	605a      	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 80084ae:	69fb      	ldr	r3, [r7, #28]
 80084b0:	88ba      	ldrh	r2, [r7, #4]
 80084b2:	811a      	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 80084b4:	8afb      	ldrh	r3, [r7, #22]
 80084b6:	3303      	adds	r3, #3
 80084b8:	f023 0303 	bic.w	r3, r3, #3
 80084bc:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
 80084c0:	88bb      	ldrh	r3, [r7, #4]
 80084c2:	4293      	cmp	r3, r2
 80084c4:	bfa8      	it	ge
 80084c6:	4613      	movge	r3, r2
 80084c8:	b29a      	uxth	r2, r3
 80084ca:	69fb      	ldr	r3, [r7, #28]
 80084cc:	815a      	strh	r2, [r3, #10]
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 80084ce:	69fb      	ldr	r3, [r7, #28]
 80084d0:	2201      	movs	r2, #1
 80084d2:	81da      	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
 80084d4:	69fb      	ldr	r3, [r7, #28]
 80084d6:	61bb      	str	r3, [r7, #24]
    /* remaining length to be allocated */
    rem_len = length - p->len;
 80084d8:	88bb      	ldrh	r3, [r7, #4]
 80084da:	69fa      	ldr	r2, [r7, #28]
 80084dc:	8952      	ldrh	r2, [r2, #10]
 80084de:	1a9b      	subs	r3, r3, r2
 80084e0:	613b      	str	r3, [r7, #16]
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 80084e2:	e035      	b.n	8008550 <pbuf_alloc+0x140>
      q = memp_malloc(MEMP_PBUF_POOL);
 80084e4:	2008      	movs	r0, #8
 80084e6:	f7ff fe0f 	bl	8008108 <memp_malloc>
 80084ea:	60f8      	str	r0, [r7, #12]
      if (q == NULL) {
 80084ec:	68fb      	ldr	r3, [r7, #12]
 80084ee:	2b00      	cmp	r3, #0
 80084f0:	d104      	bne.n	80084fc <pbuf_alloc+0xec>
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
 80084f2:	69f8      	ldr	r0, [r7, #28]
 80084f4:	f000 f959 	bl	80087aa <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
 80084f8:	2300      	movs	r3, #0
 80084fa:	e07f      	b.n	80085fc <pbuf_alloc+0x1ec>
      }
      q->type = type;
 80084fc:	68fb      	ldr	r3, [r7, #12]
 80084fe:	79ba      	ldrb	r2, [r7, #6]
 8008500:	731a      	strb	r2, [r3, #12]
      q->flags = 0;
 8008502:	68fb      	ldr	r3, [r7, #12]
 8008504:	2200      	movs	r2, #0
 8008506:	735a      	strb	r2, [r3, #13]
      q->next = NULL;
 8008508:	68fb      	ldr	r3, [r7, #12]
 800850a:	2200      	movs	r2, #0
 800850c:	601a      	str	r2, [r3, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
 800850e:	69bb      	ldr	r3, [r7, #24]
 8008510:	68fa      	ldr	r2, [r7, #12]
 8008512:	601a      	str	r2, [r3, #0]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 8008514:	693b      	ldr	r3, [r7, #16]
 8008516:	b29a      	uxth	r2, r3
 8008518:	68fb      	ldr	r3, [r7, #12]
 800851a:	811a      	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 800851c:	693b      	ldr	r3, [r7, #16]
 800851e:	b29b      	uxth	r3, r3
 8008520:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008524:	bf28      	it	cs
 8008526:	f44f 7300 	movcs.w	r3, #512	; 0x200
 800852a:	b29a      	uxth	r2, r3
 800852c:	68fb      	ldr	r3, [r7, #12]
 800852e:	815a      	strh	r2, [r3, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8008530:	68fb      	ldr	r3, [r7, #12]
 8008532:	f103 0210 	add.w	r2, r3, #16
 8008536:	68fb      	ldr	r3, [r7, #12]
 8008538:	605a      	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 800853a:	68fb      	ldr	r3, [r7, #12]
 800853c:	2201      	movs	r2, #1
 800853e:	81da      	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 8008540:	68fb      	ldr	r3, [r7, #12]
 8008542:	895b      	ldrh	r3, [r3, #10]
 8008544:	461a      	mov	r2, r3
 8008546:	693b      	ldr	r3, [r7, #16]
 8008548:	1a9b      	subs	r3, r3, r2
 800854a:	613b      	str	r3, [r7, #16]
      /* remember this pbuf for linkage in next iteration */
      r = q;
 800854c:	68fb      	ldr	r3, [r7, #12]
 800854e:	61bb      	str	r3, [r7, #24]
    while (rem_len > 0) {
 8008550:	693b      	ldr	r3, [r7, #16]
 8008552:	2b00      	cmp	r3, #0
 8008554:	dcc6      	bgt.n	80084e4 <pbuf_alloc+0xd4>
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
 8008556:	e04a      	b.n	80085ee <pbuf_alloc+0x1de>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 8008558:	8afb      	ldrh	r3, [r7, #22]
 800855a:	3313      	adds	r3, #19
 800855c:	b29b      	uxth	r3, r3
 800855e:	f023 0303 	bic.w	r3, r3, #3
 8008562:	b29a      	uxth	r2, r3
 8008564:	88bb      	ldrh	r3, [r7, #4]
 8008566:	3303      	adds	r3, #3
 8008568:	b29b      	uxth	r3, r3
 800856a:	f023 0303 	bic.w	r3, r3, #3
 800856e:	b29b      	uxth	r3, r3
 8008570:	4413      	add	r3, r2
 8008572:	b29b      	uxth	r3, r3
 8008574:	4618      	mov	r0, r3
 8008576:	f7ff fcd3 	bl	8007f20 <mem_malloc>
 800857a:	61f8      	str	r0, [r7, #28]
    if (p == NULL) {
 800857c:	69fb      	ldr	r3, [r7, #28]
 800857e:	2b00      	cmp	r3, #0
 8008580:	d101      	bne.n	8008586 <pbuf_alloc+0x176>
      return NULL;
 8008582:	2300      	movs	r3, #0
 8008584:	e03a      	b.n	80085fc <pbuf_alloc+0x1ec>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8008586:	8afb      	ldrh	r3, [r7, #22]
 8008588:	3310      	adds	r3, #16
 800858a:	69fa      	ldr	r2, [r7, #28]
 800858c:	4413      	add	r3, r2
 800858e:	3303      	adds	r3, #3
 8008590:	f023 0303 	bic.w	r3, r3, #3
 8008594:	461a      	mov	r2, r3
 8008596:	69fb      	ldr	r3, [r7, #28]
 8008598:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
 800859a:	69fb      	ldr	r3, [r7, #28]
 800859c:	88ba      	ldrh	r2, [r7, #4]
 800859e:	811a      	strh	r2, [r3, #8]
 80085a0:	69fb      	ldr	r3, [r7, #28]
 80085a2:	891a      	ldrh	r2, [r3, #8]
 80085a4:	69fb      	ldr	r3, [r7, #28]
 80085a6:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
 80085a8:	69fb      	ldr	r3, [r7, #28]
 80085aa:	2200      	movs	r2, #0
 80085ac:	601a      	str	r2, [r3, #0]
    p->type = type;
 80085ae:	69fb      	ldr	r3, [r7, #28]
 80085b0:	79ba      	ldrb	r2, [r7, #6]
 80085b2:	731a      	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
 80085b4:	e01b      	b.n	80085ee <pbuf_alloc+0x1de>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
 80085b6:	2007      	movs	r0, #7
 80085b8:	f7ff fda6 	bl	8008108 <memp_malloc>
 80085bc:	61f8      	str	r0, [r7, #28]
    if (p == NULL) {
 80085be:	69fb      	ldr	r3, [r7, #28]
 80085c0:	2b00      	cmp	r3, #0
 80085c2:	d101      	bne.n	80085c8 <pbuf_alloc+0x1b8>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
 80085c4:	2300      	movs	r3, #0
 80085c6:	e019      	b.n	80085fc <pbuf_alloc+0x1ec>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 80085c8:	69fb      	ldr	r3, [r7, #28]
 80085ca:	2200      	movs	r2, #0
 80085cc:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
 80085ce:	69fb      	ldr	r3, [r7, #28]
 80085d0:	88ba      	ldrh	r2, [r7, #4]
 80085d2:	811a      	strh	r2, [r3, #8]
 80085d4:	69fb      	ldr	r3, [r7, #28]
 80085d6:	891a      	ldrh	r2, [r3, #8]
 80085d8:	69fb      	ldr	r3, [r7, #28]
 80085da:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
 80085dc:	69fb      	ldr	r3, [r7, #28]
 80085de:	2200      	movs	r2, #0
 80085e0:	601a      	str	r2, [r3, #0]
    p->type = type;
 80085e2:	69fb      	ldr	r3, [r7, #28]
 80085e4:	79ba      	ldrb	r2, [r7, #6]
 80085e6:	731a      	strb	r2, [r3, #12]
    break;
 80085e8:	e001      	b.n	80085ee <pbuf_alloc+0x1de>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
 80085ea:	2300      	movs	r3, #0
 80085ec:	e006      	b.n	80085fc <pbuf_alloc+0x1ec>
  }
  /* set reference count */
  p->ref = 1;
 80085ee:	69fb      	ldr	r3, [r7, #28]
 80085f0:	2201      	movs	r2, #1
 80085f2:	81da      	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
 80085f4:	69fb      	ldr	r3, [r7, #28]
 80085f6:	2200      	movs	r2, #0
 80085f8:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 80085fa:	69fb      	ldr	r3, [r7, #28]
}
 80085fc:	4618      	mov	r0, r3
 80085fe:	3720      	adds	r7, #32
 8008600:	46bd      	mov	sp, r7
 8008602:	bd80      	pop	{r7, pc}

08008604 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 8008604:	b580      	push	{r7, lr}
 8008606:	b086      	sub	sp, #24
 8008608:	af00      	add	r7, sp, #0
 800860a:	6078      	str	r0, [r7, #4]
 800860c:	460b      	mov	r3, r1
 800860e:	807b      	strh	r3, [r7, #2]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8008610:	687b      	ldr	r3, [r7, #4]
 8008612:	7b1b      	ldrb	r3, [r3, #12]
 8008614:	2b03      	cmp	r3, #3
 8008616:	d006      	beq.n	8008626 <pbuf_realloc+0x22>
 8008618:	687b      	ldr	r3, [r7, #4]
 800861a:	7b1b      	ldrb	r3, [r3, #12]
 800861c:	2b01      	cmp	r3, #1
 800861e:	d002      	beq.n	8008626 <pbuf_realloc+0x22>
 8008620:	687b      	ldr	r3, [r7, #4]
 8008622:	7b1b      	ldrb	r3, [r3, #12]
 8008624:	2b00      	cmp	r3, #0
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 8008626:	687b      	ldr	r3, [r7, #4]
 8008628:	891b      	ldrh	r3, [r3, #8]
 800862a:	887a      	ldrh	r2, [r7, #2]
 800862c:	429a      	cmp	r2, r3
 800862e:	d249      	bcs.n	80086c4 <pbuf_realloc+0xc0>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
 8008630:	887b      	ldrh	r3, [r7, #2]
 8008632:	687a      	ldr	r2, [r7, #4]
 8008634:	8912      	ldrh	r2, [r2, #8]
 8008636:	1a9b      	subs	r3, r3, r2
 8008638:	60fb      	str	r3, [r7, #12]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 800863a:	887b      	ldrh	r3, [r7, #2]
 800863c:	827b      	strh	r3, [r7, #18]
  q = p;
 800863e:	687b      	ldr	r3, [r7, #4]
 8008640:	617b      	str	r3, [r7, #20]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 8008642:	e00f      	b.n	8008664 <pbuf_realloc+0x60>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 8008644:	697b      	ldr	r3, [r7, #20]
 8008646:	895b      	ldrh	r3, [r3, #10]
 8008648:	8a7a      	ldrh	r2, [r7, #18]
 800864a:	1ad3      	subs	r3, r2, r3
 800864c:	827b      	strh	r3, [r7, #18]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 800864e:	697b      	ldr	r3, [r7, #20]
 8008650:	891a      	ldrh	r2, [r3, #8]
 8008652:	68fb      	ldr	r3, [r7, #12]
 8008654:	b29b      	uxth	r3, r3
 8008656:	4413      	add	r3, r2
 8008658:	b29a      	uxth	r2, r3
 800865a:	697b      	ldr	r3, [r7, #20]
 800865c:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 800865e:	697b      	ldr	r3, [r7, #20]
 8008660:	681b      	ldr	r3, [r3, #0]
 8008662:	617b      	str	r3, [r7, #20]
  while (rem_len > q->len) {
 8008664:	697b      	ldr	r3, [r7, #20]
 8008666:	895b      	ldrh	r3, [r3, #10]
 8008668:	8a7a      	ldrh	r2, [r7, #18]
 800866a:	429a      	cmp	r2, r3
 800866c:	d8ea      	bhi.n	8008644 <pbuf_realloc+0x40>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 800866e:	697b      	ldr	r3, [r7, #20]
 8008670:	7b1b      	ldrb	r3, [r3, #12]
 8008672:	2b00      	cmp	r3, #0
 8008674:	d112      	bne.n	800869c <pbuf_realloc+0x98>
 8008676:	697b      	ldr	r3, [r7, #20]
 8008678:	895b      	ldrh	r3, [r3, #10]
 800867a:	8a7a      	ldrh	r2, [r7, #18]
 800867c:	429a      	cmp	r2, r3
 800867e:	d00d      	beq.n	800869c <pbuf_realloc+0x98>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
 8008680:	697b      	ldr	r3, [r7, #20]
 8008682:	685b      	ldr	r3, [r3, #4]
 8008684:	461a      	mov	r2, r3
 8008686:	697b      	ldr	r3, [r7, #20]
 8008688:	1ad3      	subs	r3, r2, r3
 800868a:	b29a      	uxth	r2, r3
 800868c:	8a7b      	ldrh	r3, [r7, #18]
 800868e:	4413      	add	r3, r2
 8008690:	b29b      	uxth	r3, r3
 8008692:	4619      	mov	r1, r3
 8008694:	6978      	ldr	r0, [r7, #20]
 8008696:	f7ff fb85 	bl	8007da4 <mem_realloc>
 800869a:	6178      	str	r0, [r7, #20]
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 800869c:	697b      	ldr	r3, [r7, #20]
 800869e:	8a7a      	ldrh	r2, [r7, #18]
 80086a0:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 80086a2:	697b      	ldr	r3, [r7, #20]
 80086a4:	895a      	ldrh	r2, [r3, #10]
 80086a6:	697b      	ldr	r3, [r7, #20]
 80086a8:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 80086aa:	697b      	ldr	r3, [r7, #20]
 80086ac:	681b      	ldr	r3, [r3, #0]
 80086ae:	2b00      	cmp	r3, #0
 80086b0:	d004      	beq.n	80086bc <pbuf_realloc+0xb8>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 80086b2:	697b      	ldr	r3, [r7, #20]
 80086b4:	681b      	ldr	r3, [r3, #0]
 80086b6:	4618      	mov	r0, r3
 80086b8:	f000 f877 	bl	80087aa <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 80086bc:	697b      	ldr	r3, [r7, #20]
 80086be:	2200      	movs	r2, #0
 80086c0:	601a      	str	r2, [r3, #0]
 80086c2:	e000      	b.n	80086c6 <pbuf_realloc+0xc2>
    return;
 80086c4:	bf00      	nop

}
 80086c6:	3718      	adds	r7, #24
 80086c8:	46bd      	mov	sp, r7
 80086ca:	bd80      	pop	{r7, pc}

080086cc <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 80086cc:	b480      	push	{r7}
 80086ce:	b085      	sub	sp, #20
 80086d0:	af00      	add	r7, sp, #0
 80086d2:	6078      	str	r0, [r7, #4]
 80086d4:	460b      	mov	r3, r1
 80086d6:	807b      	strh	r3, [r7, #2]
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
 80086d8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80086dc:	2b00      	cmp	r3, #0
 80086de:	d002      	beq.n	80086e6 <pbuf_header+0x1a>
 80086e0:	687b      	ldr	r3, [r7, #4]
 80086e2:	2b00      	cmp	r3, #0
 80086e4:	d101      	bne.n	80086ea <pbuf_header+0x1e>
    return 0;
 80086e6:	2300      	movs	r3, #0
 80086e8:	e059      	b.n	800879e <pbuf_header+0xd2>
 
  if (header_size_increment < 0){
 80086ea:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80086ee:	2b00      	cmp	r3, #0
 80086f0:	da09      	bge.n	8008706 <pbuf_header+0x3a>
    increment_magnitude = -header_size_increment;
 80086f2:	887b      	ldrh	r3, [r7, #2]
 80086f4:	425b      	negs	r3, r3
 80086f6:	81fb      	strh	r3, [r7, #14]
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 80086f8:	687b      	ldr	r3, [r7, #4]
 80086fa:	895b      	ldrh	r3, [r3, #10]
 80086fc:	89fa      	ldrh	r2, [r7, #14]
 80086fe:	429a      	cmp	r2, r3
 8008700:	d903      	bls.n	800870a <pbuf_header+0x3e>
 8008702:	2301      	movs	r3, #1
 8008704:	e04b      	b.n	800879e <pbuf_header+0xd2>
  } else {
    increment_magnitude = header_size_increment;
 8008706:	887b      	ldrh	r3, [r7, #2]
 8008708:	81fb      	strh	r3, [r7, #14]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 800870a:	687b      	ldr	r3, [r7, #4]
 800870c:	7b1b      	ldrb	r3, [r3, #12]
 800870e:	81bb      	strh	r3, [r7, #12]
  /* remember current payload pointer */
  payload = p->payload;
 8008710:	687b      	ldr	r3, [r7, #4]
 8008712:	685b      	ldr	r3, [r3, #4]
 8008714:	60bb      	str	r3, [r7, #8]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8008716:	89bb      	ldrh	r3, [r7, #12]
 8008718:	2b00      	cmp	r3, #0
 800871a:	d002      	beq.n	8008722 <pbuf_header+0x56>
 800871c:	89bb      	ldrh	r3, [r7, #12]
 800871e:	2b03      	cmp	r3, #3
 8008720:	d112      	bne.n	8008748 <pbuf_header+0x7c>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 8008722:	687b      	ldr	r3, [r7, #4]
 8008724:	685a      	ldr	r2, [r3, #4]
 8008726:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800872a:	425b      	negs	r3, r3
 800872c:	441a      	add	r2, r3
 800872e:	687b      	ldr	r3, [r7, #4]
 8008730:	605a      	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8008732:	687b      	ldr	r3, [r7, #4]
 8008734:	685a      	ldr	r2, [r3, #4]
 8008736:	687b      	ldr	r3, [r7, #4]
 8008738:	3310      	adds	r3, #16
 800873a:	429a      	cmp	r2, r3
 800873c:	d220      	bcs.n	8008780 <pbuf_header+0xb4>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 800873e:	687b      	ldr	r3, [r7, #4]
 8008740:	68ba      	ldr	r2, [r7, #8]
 8008742:	605a      	str	r2, [r3, #4]
      /* bail out unsuccesfully */
      return 1;
 8008744:	2301      	movs	r3, #1
 8008746:	e02a      	b.n	800879e <pbuf_header+0xd2>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8008748:	89bb      	ldrh	r3, [r7, #12]
 800874a:	2b02      	cmp	r3, #2
 800874c:	d002      	beq.n	8008754 <pbuf_header+0x88>
 800874e:	89bb      	ldrh	r3, [r7, #12]
 8008750:	2b01      	cmp	r3, #1
 8008752:	d113      	bne.n	800877c <pbuf_header+0xb0>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8008754:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8008758:	2b00      	cmp	r3, #0
 800875a:	da0d      	bge.n	8008778 <pbuf_header+0xac>
 800875c:	687b      	ldr	r3, [r7, #4]
 800875e:	895b      	ldrh	r3, [r3, #10]
 8008760:	89fa      	ldrh	r2, [r7, #14]
 8008762:	429a      	cmp	r2, r3
 8008764:	d808      	bhi.n	8008778 <pbuf_header+0xac>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 8008766:	687b      	ldr	r3, [r7, #4]
 8008768:	685a      	ldr	r2, [r3, #4]
 800876a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800876e:	425b      	negs	r3, r3
 8008770:	441a      	add	r2, r3
 8008772:	687b      	ldr	r3, [r7, #4]
 8008774:	605a      	str	r2, [r3, #4]
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8008776:	e003      	b.n	8008780 <pbuf_header+0xb4>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
 8008778:	2301      	movs	r3, #1
 800877a:	e010      	b.n	800879e <pbuf_header+0xd2>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 800877c:	2301      	movs	r3, #1
 800877e:	e00e      	b.n	800879e <pbuf_header+0xd2>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8008780:	687b      	ldr	r3, [r7, #4]
 8008782:	895a      	ldrh	r2, [r3, #10]
 8008784:	887b      	ldrh	r3, [r7, #2]
 8008786:	4413      	add	r3, r2
 8008788:	b29a      	uxth	r2, r3
 800878a:	687b      	ldr	r3, [r7, #4]
 800878c:	815a      	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
 800878e:	687b      	ldr	r3, [r7, #4]
 8008790:	891a      	ldrh	r2, [r3, #8]
 8008792:	887b      	ldrh	r3, [r7, #2]
 8008794:	4413      	add	r3, r2
 8008796:	b29a      	uxth	r2, r3
 8008798:	687b      	ldr	r3, [r7, #4]
 800879a:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 800879c:	2300      	movs	r3, #0
}
 800879e:	4618      	mov	r0, r3
 80087a0:	3714      	adds	r7, #20
 80087a2:	46bd      	mov	sp, r7
 80087a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087a8:	4770      	bx	lr

080087aa <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 80087aa:	b580      	push	{r7, lr}
 80087ac:	b086      	sub	sp, #24
 80087ae:	af00      	add	r7, sp, #0
 80087b0:	6078      	str	r0, [r7, #4]
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 80087b2:	687b      	ldr	r3, [r7, #4]
 80087b4:	2b00      	cmp	r3, #0
 80087b6:	d101      	bne.n	80087bc <pbuf_free+0x12>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 80087b8:	2300      	movs	r3, #0
 80087ba:	e041      	b.n	8008840 <pbuf_free+0x96>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 80087bc:	687b      	ldr	r3, [r7, #4]
 80087be:	7b1b      	ldrb	r3, [r3, #12]
 80087c0:	2b00      	cmp	r3, #0
 80087c2:	d006      	beq.n	80087d2 <pbuf_free+0x28>
 80087c4:	687b      	ldr	r3, [r7, #4]
 80087c6:	7b1b      	ldrb	r3, [r3, #12]
 80087c8:	2b01      	cmp	r3, #1
 80087ca:	d002      	beq.n	80087d2 <pbuf_free+0x28>
 80087cc:	687b      	ldr	r3, [r7, #4]
 80087ce:	7b1b      	ldrb	r3, [r3, #12]
 80087d0:	2b02      	cmp	r3, #2
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
 80087d2:	2300      	movs	r3, #0
 80087d4:	75fb      	strb	r3, [r7, #23]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 80087d6:	e02f      	b.n	8008838 <pbuf_free+0x8e>
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 80087d8:	687b      	ldr	r3, [r7, #4]
 80087da:	89db      	ldrh	r3, [r3, #14]
 80087dc:	3b01      	subs	r3, #1
 80087de:	b29a      	uxth	r2, r3
 80087e0:	687b      	ldr	r3, [r7, #4]
 80087e2:	81da      	strh	r2, [r3, #14]
 80087e4:	687b      	ldr	r3, [r7, #4]
 80087e6:	89db      	ldrh	r3, [r3, #14]
 80087e8:	82bb      	strh	r3, [r7, #20]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 80087ea:	8abb      	ldrh	r3, [r7, #20]
 80087ec:	2b00      	cmp	r3, #0
 80087ee:	d121      	bne.n	8008834 <pbuf_free+0x8a>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 80087f0:	687b      	ldr	r3, [r7, #4]
 80087f2:	681b      	ldr	r3, [r3, #0]
 80087f4:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 80087f6:	687b      	ldr	r3, [r7, #4]
 80087f8:	7b1b      	ldrb	r3, [r3, #12]
 80087fa:	81fb      	strh	r3, [r7, #14]
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
 80087fc:	89fb      	ldrh	r3, [r7, #14]
 80087fe:	2b03      	cmp	r3, #3
 8008800:	d104      	bne.n	800880c <pbuf_free+0x62>
        memp_free(MEMP_PBUF_POOL, p);
 8008802:	6879      	ldr	r1, [r7, #4]
 8008804:	2008      	movs	r0, #8
 8008806:	f7ff fca1 	bl	800814c <memp_free>
 800880a:	e00d      	b.n	8008828 <pbuf_free+0x7e>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
 800880c:	89fb      	ldrh	r3, [r7, #14]
 800880e:	2b01      	cmp	r3, #1
 8008810:	d002      	beq.n	8008818 <pbuf_free+0x6e>
 8008812:	89fb      	ldrh	r3, [r7, #14]
 8008814:	2b02      	cmp	r3, #2
 8008816:	d104      	bne.n	8008822 <pbuf_free+0x78>
        memp_free(MEMP_PBUF, p);
 8008818:	6879      	ldr	r1, [r7, #4]
 800881a:	2007      	movs	r0, #7
 800881c:	f7ff fc96 	bl	800814c <memp_free>
 8008820:	e002      	b.n	8008828 <pbuf_free+0x7e>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
 8008822:	6878      	ldr	r0, [r7, #4]
 8008824:	f7ff fa8a 	bl	8007d3c <mem_free>
      }
      count++;
 8008828:	7dfb      	ldrb	r3, [r7, #23]
 800882a:	3301      	adds	r3, #1
 800882c:	75fb      	strb	r3, [r7, #23]
      /* proceed to next pbuf */
      p = q;
 800882e:	693b      	ldr	r3, [r7, #16]
 8008830:	607b      	str	r3, [r7, #4]
 8008832:	e001      	b.n	8008838 <pbuf_free+0x8e>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
 8008834:	2300      	movs	r3, #0
 8008836:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 8008838:	687b      	ldr	r3, [r7, #4]
 800883a:	2b00      	cmp	r3, #0
 800883c:	d1cc      	bne.n	80087d8 <pbuf_free+0x2e>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 800883e:	7dfb      	ldrb	r3, [r7, #23]
}
 8008840:	4618      	mov	r0, r3
 8008842:	3718      	adds	r7, #24
 8008844:	46bd      	mov	sp, r7
 8008846:	bd80      	pop	{r7, pc}

08008848 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
 8008848:	b480      	push	{r7}
 800884a:	b085      	sub	sp, #20
 800884c:	af00      	add	r7, sp, #0
 800884e:	6078      	str	r0, [r7, #4]
  u8_t len;

  len = 0;
 8008850:	2300      	movs	r3, #0
 8008852:	73fb      	strb	r3, [r7, #15]
  while (p != NULL) {
 8008854:	e005      	b.n	8008862 <pbuf_clen+0x1a>
    ++len;
 8008856:	7bfb      	ldrb	r3, [r7, #15]
 8008858:	3301      	adds	r3, #1
 800885a:	73fb      	strb	r3, [r7, #15]
    p = p->next;
 800885c:	687b      	ldr	r3, [r7, #4]
 800885e:	681b      	ldr	r3, [r3, #0]
 8008860:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 8008862:	687b      	ldr	r3, [r7, #4]
 8008864:	2b00      	cmp	r3, #0
 8008866:	d1f6      	bne.n	8008856 <pbuf_clen+0xe>
  }
  return len;
 8008868:	7bfb      	ldrb	r3, [r7, #15]
}
 800886a:	4618      	mov	r0, r3
 800886c:	3714      	adds	r7, #20
 800886e:	46bd      	mov	sp, r7
 8008870:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008874:	4770      	bx	lr

08008876 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 8008876:	b480      	push	{r7}
 8008878:	b083      	sub	sp, #12
 800887a:	af00      	add	r7, sp, #0
 800887c:	6078      	str	r0, [r7, #4]
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 800887e:	687b      	ldr	r3, [r7, #4]
 8008880:	2b00      	cmp	r3, #0
 8008882:	d005      	beq.n	8008890 <pbuf_ref+0x1a>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 8008884:	687b      	ldr	r3, [r7, #4]
 8008886:	89db      	ldrh	r3, [r3, #14]
 8008888:	3301      	adds	r3, #1
 800888a:	b29a      	uxth	r2, r3
 800888c:	687b      	ldr	r3, [r7, #4]
 800888e:	81da      	strh	r2, [r3, #14]
    SYS_ARCH_UNPROTECT(old_level);
  }
}
 8008890:	bf00      	nop
 8008892:	370c      	adds	r7, #12
 8008894:	46bd      	mov	sp, r7
 8008896:	f85d 7b04 	ldr.w	r7, [sp], #4
 800889a:	4770      	bx	lr

0800889c <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 800889c:	b480      	push	{r7}
 800889e:	b085      	sub	sp, #20
 80088a0:	af00      	add	r7, sp, #0
 80088a2:	6078      	str	r0, [r7, #4]
 80088a4:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80088a6:	687b      	ldr	r3, [r7, #4]
 80088a8:	2b00      	cmp	r3, #0
 80088aa:	d020      	beq.n	80088ee <pbuf_cat+0x52>
 80088ac:	683b      	ldr	r3, [r7, #0]
 80088ae:	2b00      	cmp	r3, #0
 80088b0:	d01d      	beq.n	80088ee <pbuf_cat+0x52>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 80088b2:	687b      	ldr	r3, [r7, #4]
 80088b4:	60fb      	str	r3, [r7, #12]
 80088b6:	e00a      	b.n	80088ce <pbuf_cat+0x32>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 80088b8:	68fb      	ldr	r3, [r7, #12]
 80088ba:	891a      	ldrh	r2, [r3, #8]
 80088bc:	683b      	ldr	r3, [r7, #0]
 80088be:	891b      	ldrh	r3, [r3, #8]
 80088c0:	4413      	add	r3, r2
 80088c2:	b29a      	uxth	r2, r3
 80088c4:	68fb      	ldr	r3, [r7, #12]
 80088c6:	811a      	strh	r2, [r3, #8]
  for (p = h; p->next != NULL; p = p->next) {
 80088c8:	68fb      	ldr	r3, [r7, #12]
 80088ca:	681b      	ldr	r3, [r3, #0]
 80088cc:	60fb      	str	r3, [r7, #12]
 80088ce:	68fb      	ldr	r3, [r7, #12]
 80088d0:	681b      	ldr	r3, [r3, #0]
 80088d2:	2b00      	cmp	r3, #0
 80088d4:	d1f0      	bne.n	80088b8 <pbuf_cat+0x1c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80088d6:	68fb      	ldr	r3, [r7, #12]
 80088d8:	891a      	ldrh	r2, [r3, #8]
 80088da:	683b      	ldr	r3, [r7, #0]
 80088dc:	891b      	ldrh	r3, [r3, #8]
 80088de:	4413      	add	r3, r2
 80088e0:	b29a      	uxth	r2, r3
 80088e2:	68fb      	ldr	r3, [r7, #12]
 80088e4:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 80088e6:	68fb      	ldr	r3, [r7, #12]
 80088e8:	683a      	ldr	r2, [r7, #0]
 80088ea:	601a      	str	r2, [r3, #0]
 80088ec:	e000      	b.n	80088f0 <pbuf_cat+0x54>
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80088ee:	bf00      	nop
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 80088f0:	3714      	adds	r7, #20
 80088f2:	46bd      	mov	sp, r7
 80088f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088f8:	4770      	bx	lr

080088fa <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 80088fa:	b580      	push	{r7, lr}
 80088fc:	b082      	sub	sp, #8
 80088fe:	af00      	add	r7, sp, #0
 8008900:	6078      	str	r0, [r7, #4]
 8008902:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 8008904:	6839      	ldr	r1, [r7, #0]
 8008906:	6878      	ldr	r0, [r7, #4]
 8008908:	f7ff ffc8 	bl	800889c <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 800890c:	6838      	ldr	r0, [r7, #0]
 800890e:	f7ff ffb2 	bl	8008876 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 8008912:	bf00      	nop
 8008914:	3708      	adds	r7, #8
 8008916:	46bd      	mov	sp, r7
 8008918:	bd80      	pop	{r7, pc}

0800891a <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 800891a:	b580      	push	{r7, lr}
 800891c:	b084      	sub	sp, #16
 800891e:	af00      	add	r7, sp, #0
 8008920:	6078      	str	r0, [r7, #4]
 8008922:	6039      	str	r1, [r7, #0]
  u16_t offset_to=0, offset_from=0, len;
 8008924:	2300      	movs	r3, #0
 8008926:	81fb      	strh	r3, [r7, #14]
 8008928:	2300      	movs	r3, #0
 800892a:	81bb      	strh	r3, [r7, #12]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 800892c:	687b      	ldr	r3, [r7, #4]
 800892e:	2b00      	cmp	r3, #0
 8008930:	d008      	beq.n	8008944 <pbuf_copy+0x2a>
 8008932:	683b      	ldr	r3, [r7, #0]
 8008934:	2b00      	cmp	r3, #0
 8008936:	d005      	beq.n	8008944 <pbuf_copy+0x2a>
 8008938:	687b      	ldr	r3, [r7, #4]
 800893a:	891a      	ldrh	r2, [r3, #8]
 800893c:	683b      	ldr	r3, [r7, #0]
 800893e:	891b      	ldrh	r3, [r3, #8]
 8008940:	429a      	cmp	r2, r3
 8008942:	d202      	bcs.n	800894a <pbuf_copy+0x30>
 8008944:	f06f 0309 	mvn.w	r3, #9
 8008948:	e062      	b.n	8008a10 <pbuf_copy+0xf6>
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 800894a:	687b      	ldr	r3, [r7, #4]
 800894c:	895b      	ldrh	r3, [r3, #10]
 800894e:	461a      	mov	r2, r3
 8008950:	89fb      	ldrh	r3, [r7, #14]
 8008952:	1ad2      	subs	r2, r2, r3
 8008954:	683b      	ldr	r3, [r7, #0]
 8008956:	895b      	ldrh	r3, [r3, #10]
 8008958:	4619      	mov	r1, r3
 800895a:	89bb      	ldrh	r3, [r7, #12]
 800895c:	1acb      	subs	r3, r1, r3
 800895e:	429a      	cmp	r2, r3
 8008960:	db05      	blt.n	800896e <pbuf_copy+0x54>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 8008962:	683b      	ldr	r3, [r7, #0]
 8008964:	895a      	ldrh	r2, [r3, #10]
 8008966:	89bb      	ldrh	r3, [r7, #12]
 8008968:	1ad3      	subs	r3, r2, r3
 800896a:	817b      	strh	r3, [r7, #10]
 800896c:	e004      	b.n	8008978 <pbuf_copy+0x5e>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 800896e:	687b      	ldr	r3, [r7, #4]
 8008970:	895a      	ldrh	r2, [r3, #10]
 8008972:	89fb      	ldrh	r3, [r7, #14]
 8008974:	1ad3      	subs	r3, r2, r3
 8008976:	817b      	strh	r3, [r7, #10]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8008978:	687b      	ldr	r3, [r7, #4]
 800897a:	685a      	ldr	r2, [r3, #4]
 800897c:	89fb      	ldrh	r3, [r7, #14]
 800897e:	18d0      	adds	r0, r2, r3
 8008980:	683b      	ldr	r3, [r7, #0]
 8008982:	685a      	ldr	r2, [r3, #4]
 8008984:	89bb      	ldrh	r3, [r7, #12]
 8008986:	4413      	add	r3, r2
 8008988:	897a      	ldrh	r2, [r7, #10]
 800898a:	4619      	mov	r1, r3
 800898c:	f005 fe6b 	bl	800e666 <memcpy>
    offset_to += len;
 8008990:	89fa      	ldrh	r2, [r7, #14]
 8008992:	897b      	ldrh	r3, [r7, #10]
 8008994:	4413      	add	r3, r2
 8008996:	81fb      	strh	r3, [r7, #14]
    offset_from += len;
 8008998:	89ba      	ldrh	r2, [r7, #12]
 800899a:	897b      	ldrh	r3, [r7, #10]
 800899c:	4413      	add	r3, r2
 800899e:	81bb      	strh	r3, [r7, #12]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
 80089a0:	687b      	ldr	r3, [r7, #4]
 80089a2:	895b      	ldrh	r3, [r3, #10]
 80089a4:	89fa      	ldrh	r2, [r7, #14]
 80089a6:	429a      	cmp	r2, r3
 80089a8:	d104      	bne.n	80089b4 <pbuf_copy+0x9a>
      /* on to next p_to (if any) */
      offset_to = 0;
 80089aa:	2300      	movs	r3, #0
 80089ac:	81fb      	strh	r3, [r7, #14]
      p_to = p_to->next;
 80089ae:	687b      	ldr	r3, [r7, #4]
 80089b0:	681b      	ldr	r3, [r3, #0]
 80089b2:	607b      	str	r3, [r7, #4]
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 80089b4:	683b      	ldr	r3, [r7, #0]
 80089b6:	895b      	ldrh	r3, [r3, #10]
 80089b8:	89ba      	ldrh	r2, [r7, #12]
 80089ba:	429a      	cmp	r2, r3
 80089bc:	d304      	bcc.n	80089c8 <pbuf_copy+0xae>
      /* on to next p_from (if any) */
      offset_from = 0;
 80089be:	2300      	movs	r3, #0
 80089c0:	81bb      	strh	r3, [r7, #12]
      p_from = p_from->next;
 80089c2:	683b      	ldr	r3, [r7, #0]
 80089c4:	681b      	ldr	r3, [r3, #0]
 80089c6:	603b      	str	r3, [r7, #0]
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 80089c8:	683b      	ldr	r3, [r7, #0]
 80089ca:	2b00      	cmp	r3, #0
 80089cc:	d00c      	beq.n	80089e8 <pbuf_copy+0xce>
 80089ce:	683b      	ldr	r3, [r7, #0]
 80089d0:	895a      	ldrh	r2, [r3, #10]
 80089d2:	683b      	ldr	r3, [r7, #0]
 80089d4:	891b      	ldrh	r3, [r3, #8]
 80089d6:	429a      	cmp	r2, r3
 80089d8:	d106      	bne.n	80089e8 <pbuf_copy+0xce>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 80089da:	683b      	ldr	r3, [r7, #0]
 80089dc:	681b      	ldr	r3, [r3, #0]
 80089de:	2b00      	cmp	r3, #0
 80089e0:	d002      	beq.n	80089e8 <pbuf_copy+0xce>
 80089e2:	f06f 0308 	mvn.w	r3, #8
 80089e6:	e013      	b.n	8008a10 <pbuf_copy+0xf6>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 80089e8:	687b      	ldr	r3, [r7, #4]
 80089ea:	2b00      	cmp	r3, #0
 80089ec:	d00c      	beq.n	8008a08 <pbuf_copy+0xee>
 80089ee:	687b      	ldr	r3, [r7, #4]
 80089f0:	895a      	ldrh	r2, [r3, #10]
 80089f2:	687b      	ldr	r3, [r7, #4]
 80089f4:	891b      	ldrh	r3, [r3, #8]
 80089f6:	429a      	cmp	r2, r3
 80089f8:	d106      	bne.n	8008a08 <pbuf_copy+0xee>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 80089fa:	687b      	ldr	r3, [r7, #4]
 80089fc:	681b      	ldr	r3, [r3, #0]
 80089fe:	2b00      	cmp	r3, #0
 8008a00:	d002      	beq.n	8008a08 <pbuf_copy+0xee>
 8008a02:	f06f 0308 	mvn.w	r3, #8
 8008a06:	e003      	b.n	8008a10 <pbuf_copy+0xf6>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 8008a08:	683b      	ldr	r3, [r7, #0]
 8008a0a:	2b00      	cmp	r3, #0
 8008a0c:	d19d      	bne.n	800894a <pbuf_copy+0x30>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 8008a0e:	2300      	movs	r3, #0
}
 8008a10:	4618      	mov	r0, r3
 8008a12:	3710      	adds	r7, #16
 8008a14:	46bd      	mov	sp, r7
 8008a16:	bd80      	pop	{r7, pc}

08008a18 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8008a18:	b580      	push	{r7, lr}
 8008a1a:	b088      	sub	sp, #32
 8008a1c:	af00      	add	r7, sp, #0
 8008a1e:	60f8      	str	r0, [r7, #12]
 8008a20:	60b9      	str	r1, [r7, #8]
 8008a22:	4611      	mov	r1, r2
 8008a24:	461a      	mov	r2, r3
 8008a26:	460b      	mov	r3, r1
 8008a28:	80fb      	strh	r3, [r7, #6]
 8008a2a:	4613      	mov	r3, r2
 8008a2c:	80bb      	strh	r3, [r7, #4]
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 8008a2e:	2300      	movs	r3, #0
 8008a30:	82fb      	strh	r3, [r7, #22]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8008a32:	68fb      	ldr	r3, [r7, #12]
 8008a34:	2b00      	cmp	r3, #0
 8008a36:	d101      	bne.n	8008a3c <pbuf_copy_partial+0x24>
 8008a38:	2300      	movs	r3, #0
 8008a3a:	e04d      	b.n	8008ad8 <pbuf_copy_partial+0xc0>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8008a3c:	68bb      	ldr	r3, [r7, #8]
 8008a3e:	2b00      	cmp	r3, #0
 8008a40:	d101      	bne.n	8008a46 <pbuf_copy_partial+0x2e>
 8008a42:	2300      	movs	r3, #0
 8008a44:	e048      	b.n	8008ad8 <pbuf_copy_partial+0xc0>

  left = 0;
 8008a46:	2300      	movs	r3, #0
 8008a48:	837b      	strh	r3, [r7, #26]

  if((buf == NULL) || (dataptr == NULL)) {
 8008a4a:	68fb      	ldr	r3, [r7, #12]
 8008a4c:	2b00      	cmp	r3, #0
 8008a4e:	d002      	beq.n	8008a56 <pbuf_copy_partial+0x3e>
 8008a50:	68bb      	ldr	r3, [r7, #8]
 8008a52:	2b00      	cmp	r3, #0
 8008a54:	d101      	bne.n	8008a5a <pbuf_copy_partial+0x42>
    return 0;
 8008a56:	2300      	movs	r3, #0
 8008a58:	e03e      	b.n	8008ad8 <pbuf_copy_partial+0xc0>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8008a5a:	68fb      	ldr	r3, [r7, #12]
 8008a5c:	61fb      	str	r3, [r7, #28]
 8008a5e:	e034      	b.n	8008aca <pbuf_copy_partial+0xb2>
    if ((offset != 0) && (offset >= p->len)) {
 8008a60:	88bb      	ldrh	r3, [r7, #4]
 8008a62:	2b00      	cmp	r3, #0
 8008a64:	d00a      	beq.n	8008a7c <pbuf_copy_partial+0x64>
 8008a66:	69fb      	ldr	r3, [r7, #28]
 8008a68:	895b      	ldrh	r3, [r3, #10]
 8008a6a:	88ba      	ldrh	r2, [r7, #4]
 8008a6c:	429a      	cmp	r2, r3
 8008a6e:	d305      	bcc.n	8008a7c <pbuf_copy_partial+0x64>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 8008a70:	69fb      	ldr	r3, [r7, #28]
 8008a72:	895b      	ldrh	r3, [r3, #10]
 8008a74:	88ba      	ldrh	r2, [r7, #4]
 8008a76:	1ad3      	subs	r3, r2, r3
 8008a78:	80bb      	strh	r3, [r7, #4]
 8008a7a:	e023      	b.n	8008ac4 <pbuf_copy_partial+0xac>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 8008a7c:	69fb      	ldr	r3, [r7, #28]
 8008a7e:	895a      	ldrh	r2, [r3, #10]
 8008a80:	88bb      	ldrh	r3, [r7, #4]
 8008a82:	1ad3      	subs	r3, r2, r3
 8008a84:	833b      	strh	r3, [r7, #24]
      if (buf_copy_len > len)
 8008a86:	8b3a      	ldrh	r2, [r7, #24]
 8008a88:	88fb      	ldrh	r3, [r7, #6]
 8008a8a:	429a      	cmp	r2, r3
 8008a8c:	d901      	bls.n	8008a92 <pbuf_copy_partial+0x7a>
          buf_copy_len = len;
 8008a8e:	88fb      	ldrh	r3, [r7, #6]
 8008a90:	833b      	strh	r3, [r7, #24]
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8008a92:	8b7b      	ldrh	r3, [r7, #26]
 8008a94:	68ba      	ldr	r2, [r7, #8]
 8008a96:	18d0      	adds	r0, r2, r3
 8008a98:	69fb      	ldr	r3, [r7, #28]
 8008a9a:	685a      	ldr	r2, [r3, #4]
 8008a9c:	88bb      	ldrh	r3, [r7, #4]
 8008a9e:	4413      	add	r3, r2
 8008aa0:	8b3a      	ldrh	r2, [r7, #24]
 8008aa2:	4619      	mov	r1, r3
 8008aa4:	f005 fddf 	bl	800e666 <memcpy>
      copied_total += buf_copy_len;
 8008aa8:	8afa      	ldrh	r2, [r7, #22]
 8008aaa:	8b3b      	ldrh	r3, [r7, #24]
 8008aac:	4413      	add	r3, r2
 8008aae:	82fb      	strh	r3, [r7, #22]
      left += buf_copy_len;
 8008ab0:	8b7a      	ldrh	r2, [r7, #26]
 8008ab2:	8b3b      	ldrh	r3, [r7, #24]
 8008ab4:	4413      	add	r3, r2
 8008ab6:	837b      	strh	r3, [r7, #26]
      len -= buf_copy_len;
 8008ab8:	88fa      	ldrh	r2, [r7, #6]
 8008aba:	8b3b      	ldrh	r3, [r7, #24]
 8008abc:	1ad3      	subs	r3, r2, r3
 8008abe:	80fb      	strh	r3, [r7, #6]
      offset = 0;
 8008ac0:	2300      	movs	r3, #0
 8008ac2:	80bb      	strh	r3, [r7, #4]
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8008ac4:	69fb      	ldr	r3, [r7, #28]
 8008ac6:	681b      	ldr	r3, [r3, #0]
 8008ac8:	61fb      	str	r3, [r7, #28]
 8008aca:	88fb      	ldrh	r3, [r7, #6]
 8008acc:	2b00      	cmp	r3, #0
 8008ace:	d002      	beq.n	8008ad6 <pbuf_copy_partial+0xbe>
 8008ad0:	69fb      	ldr	r3, [r7, #28]
 8008ad2:	2b00      	cmp	r3, #0
 8008ad4:	d1c4      	bne.n	8008a60 <pbuf_copy_partial+0x48>
    }
  }
  return copied_total;
 8008ad6:	8afb      	ldrh	r3, [r7, #22]
}
 8008ad8:	4618      	mov	r0, r3
 8008ada:	3720      	adds	r7, #32
 8008adc:	46bd      	mov	sp, r7
 8008ade:	bd80      	pop	{r7, pc}

08008ae0 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 8008ae0:	b590      	push	{r4, r7, lr}
 8008ae2:	b089      	sub	sp, #36	; 0x24
 8008ae4:	af00      	add	r7, sp, #0
 8008ae6:	6078      	str	r0, [r7, #4]
 8008ae8:	6039      	str	r1, [r7, #0]
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
 8008aea:	2300      	movs	r3, #0
 8008aec:	75fb      	strb	r3, [r7, #23]

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
 8008aee:	687b      	ldr	r3, [r7, #4]
 8008af0:	685b      	ldr	r3, [r3, #4]
 8008af2:	613b      	str	r3, [r7, #16]
  proto = IPH_PROTO(iphdr);
 8008af4:	693b      	ldr	r3, [r7, #16]
 8008af6:	891b      	ldrh	r3, [r3, #8]
 8008af8:	b29b      	uxth	r3, r3
 8008afa:	4618      	mov	r0, r3
 8008afc:	f7fe f8c9 	bl	8006c92 <ntohs>
 8008b00:	4603      	mov	r3, r0
 8008b02:	b21b      	sxth	r3, r3
 8008b04:	b2db      	uxtb	r3, r3
 8008b06:	81fb      	strh	r3, [r7, #14]

  prev = NULL;
 8008b08:	2300      	movs	r3, #0
 8008b0a:	61bb      	str	r3, [r7, #24]
  pcb = raw_pcbs;
 8008b0c:	4b1e      	ldr	r3, [pc, #120]	; (8008b88 <raw_input+0xa8>)
 8008b0e:	681b      	ldr	r3, [r3, #0]
 8008b10:	61fb      	str	r3, [r7, #28]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 8008b12:	e02d      	b.n	8008b70 <raw_input+0x90>
    if (pcb->protocol == proto) {
 8008b14:	69fb      	ldr	r3, [r7, #28]
 8008b16:	7c1b      	ldrb	r3, [r3, #16]
 8008b18:	461a      	mov	r2, r3
 8008b1a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8008b1e:	429a      	cmp	r2, r3
 8008b20:	d121      	bne.n	8008b66 <raw_input+0x86>
      /* broadcast filter? */
      if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&(iphdr->dest), inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
 8008b22:	69fb      	ldr	r3, [r7, #28]
 8008b24:	695b      	ldr	r3, [r3, #20]
 8008b26:	2b00      	cmp	r3, #0
 8008b28:	d01d      	beq.n	8008b66 <raw_input+0x86>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
 8008b2a:	69fb      	ldr	r3, [r7, #28]
 8008b2c:	695c      	ldr	r4, [r3, #20]
 8008b2e:	69fb      	ldr	r3, [r7, #28]
 8008b30:	6998      	ldr	r0, [r3, #24]
 8008b32:	693b      	ldr	r3, [r7, #16]
 8008b34:	330c      	adds	r3, #12
 8008b36:	687a      	ldr	r2, [r7, #4]
 8008b38:	69f9      	ldr	r1, [r7, #28]
 8008b3a:	47a0      	blx	r4
 8008b3c:	4603      	mov	r3, r0
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	d011      	beq.n	8008b66 <raw_input+0x86>
            /* receive function ate the packet */
            p = NULL;
 8008b42:	2300      	movs	r3, #0
 8008b44:	607b      	str	r3, [r7, #4]
            eaten = 1;
 8008b46:	2301      	movs	r3, #1
 8008b48:	75fb      	strb	r3, [r7, #23]
            if (prev != NULL) {
 8008b4a:	69bb      	ldr	r3, [r7, #24]
 8008b4c:	2b00      	cmp	r3, #0
 8008b4e:	d00a      	beq.n	8008b66 <raw_input+0x86>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 8008b50:	69fb      	ldr	r3, [r7, #28]
 8008b52:	68da      	ldr	r2, [r3, #12]
 8008b54:	69bb      	ldr	r3, [r7, #24]
 8008b56:	60da      	str	r2, [r3, #12]
              pcb->next = raw_pcbs;
 8008b58:	4b0b      	ldr	r3, [pc, #44]	; (8008b88 <raw_input+0xa8>)
 8008b5a:	681a      	ldr	r2, [r3, #0]
 8008b5c:	69fb      	ldr	r3, [r7, #28]
 8008b5e:	60da      	str	r2, [r3, #12]
              raw_pcbs = pcb;
 8008b60:	4a09      	ldr	r2, [pc, #36]	; (8008b88 <raw_input+0xa8>)
 8008b62:	69fb      	ldr	r3, [r7, #28]
 8008b64:	6013      	str	r3, [r2, #0]
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
 8008b66:	69fb      	ldr	r3, [r7, #28]
 8008b68:	61bb      	str	r3, [r7, #24]
    pcb = pcb->next;
 8008b6a:	69fb      	ldr	r3, [r7, #28]
 8008b6c:	68db      	ldr	r3, [r3, #12]
 8008b6e:	61fb      	str	r3, [r7, #28]
  while ((eaten == 0) && (pcb != NULL)) {
 8008b70:	7dfb      	ldrb	r3, [r7, #23]
 8008b72:	2b00      	cmp	r3, #0
 8008b74:	d102      	bne.n	8008b7c <raw_input+0x9c>
 8008b76:	69fb      	ldr	r3, [r7, #28]
 8008b78:	2b00      	cmp	r3, #0
 8008b7a:	d1cb      	bne.n	8008b14 <raw_input+0x34>
  }
  return eaten;
 8008b7c:	7dfb      	ldrb	r3, [r7, #23]
}
 8008b7e:	4618      	mov	r0, r3
 8008b80:	3724      	adds	r7, #36	; 0x24
 8008b82:	46bd      	mov	sp, r7
 8008b84:	bd90      	pop	{r4, r7, pc}
 8008b86:	bf00      	nop
 8008b88:	20007c30 	.word	0x20007c30

08008b8c <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
 8008b8c:	b580      	push	{r7, lr}
 8008b8e:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 8008b90:	f000 fd40 	bl	8009614 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 8008b94:	4b07      	ldr	r3, [pc, #28]	; (8008bb4 <tcp_tmr+0x28>)
 8008b96:	781b      	ldrb	r3, [r3, #0]
 8008b98:	3301      	adds	r3, #1
 8008b9a:	b2da      	uxtb	r2, r3
 8008b9c:	4b05      	ldr	r3, [pc, #20]	; (8008bb4 <tcp_tmr+0x28>)
 8008b9e:	701a      	strb	r2, [r3, #0]
 8008ba0:	4b04      	ldr	r3, [pc, #16]	; (8008bb4 <tcp_tmr+0x28>)
 8008ba2:	781b      	ldrb	r3, [r3, #0]
 8008ba4:	f003 0301 	and.w	r3, r3, #1
 8008ba8:	2b00      	cmp	r3, #0
 8008baa:	d001      	beq.n	8008bb0 <tcp_tmr+0x24>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 8008bac:	f000 fb4e 	bl	800924c <tcp_slowtmr>
  }
}
 8008bb0:	bf00      	nop
 8008bb2:	bd80      	pop	{r7, pc}
 8008bb4:	20007c34 	.word	0x20007c34

08008bb8 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 8008bb8:	b580      	push	{r7, lr}
 8008bba:	b084      	sub	sp, #16
 8008bbc:	af00      	add	r7, sp, #0
 8008bbe:	6078      	str	r0, [r7, #4]
  err_t err;

#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
 8008bc0:	687b      	ldr	r3, [r7, #4]
 8008bc2:	7c1b      	ldrb	r3, [r3, #16]
 8008bc4:	4618      	mov	r0, r3
 8008bc6:	f001 f81d 	bl	8009c04 <tcp_debug_print_state>
#endif /* TCP_DEBUG */

  switch (pcb->state) {
 8008bca:	687b      	ldr	r3, [r7, #4]
 8008bcc:	7c1b      	ldrb	r3, [r3, #16]
 8008bce:	2b07      	cmp	r3, #7
 8008bd0:	f200 8089 	bhi.w	8008ce6 <tcp_close+0x12e>
 8008bd4:	a201      	add	r2, pc, #4	; (adr r2, 8008bdc <tcp_close+0x24>)
 8008bd6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008bda:	bf00      	nop
 8008bdc:	08008bfd 	.word	0x08008bfd
 8008be0:	08008c5f 	.word	0x08008c5f
 8008be4:	08008c79 	.word	0x08008c79
 8008be8:	08008c93 	.word	0x08008c93
 8008bec:	08008caf 	.word	0x08008caf
 8008bf0:	08008ce7 	.word	0x08008ce7
 8008bf4:	08008ce7 	.word	0x08008ce7
 8008bf8:	08008ccb 	.word	0x08008ccb
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
 8008bfc:	2300      	movs	r3, #0
 8008bfe:	73fb      	strb	r3, [r7, #15]
    TCP_RMV(&tcp_bound_pcbs, pcb);
 8008c00:	4b46      	ldr	r3, [pc, #280]	; (8008d1c <tcp_close+0x164>)
 8008c02:	681a      	ldr	r2, [r3, #0]
 8008c04:	687b      	ldr	r3, [r7, #4]
 8008c06:	429a      	cmp	r2, r3
 8008c08:	d105      	bne.n	8008c16 <tcp_close+0x5e>
 8008c0a:	4b44      	ldr	r3, [pc, #272]	; (8008d1c <tcp_close+0x164>)
 8008c0c:	681b      	ldr	r3, [r3, #0]
 8008c0e:	68db      	ldr	r3, [r3, #12]
 8008c10:	4a42      	ldr	r2, [pc, #264]	; (8008d1c <tcp_close+0x164>)
 8008c12:	6013      	str	r3, [r2, #0]
 8008c14:	e019      	b.n	8008c4a <tcp_close+0x92>
 8008c16:	4b41      	ldr	r3, [pc, #260]	; (8008d1c <tcp_close+0x164>)
 8008c18:	681b      	ldr	r3, [r3, #0]
 8008c1a:	4a41      	ldr	r2, [pc, #260]	; (8008d20 <tcp_close+0x168>)
 8008c1c:	6013      	str	r3, [r2, #0]
 8008c1e:	e010      	b.n	8008c42 <tcp_close+0x8a>
 8008c20:	4b3f      	ldr	r3, [pc, #252]	; (8008d20 <tcp_close+0x168>)
 8008c22:	681b      	ldr	r3, [r3, #0]
 8008c24:	68da      	ldr	r2, [r3, #12]
 8008c26:	687b      	ldr	r3, [r7, #4]
 8008c28:	429a      	cmp	r2, r3
 8008c2a:	d105      	bne.n	8008c38 <tcp_close+0x80>
 8008c2c:	4b3c      	ldr	r3, [pc, #240]	; (8008d20 <tcp_close+0x168>)
 8008c2e:	681b      	ldr	r3, [r3, #0]
 8008c30:	687a      	ldr	r2, [r7, #4]
 8008c32:	68d2      	ldr	r2, [r2, #12]
 8008c34:	60da      	str	r2, [r3, #12]
 8008c36:	e008      	b.n	8008c4a <tcp_close+0x92>
 8008c38:	4b39      	ldr	r3, [pc, #228]	; (8008d20 <tcp_close+0x168>)
 8008c3a:	681b      	ldr	r3, [r3, #0]
 8008c3c:	68db      	ldr	r3, [r3, #12]
 8008c3e:	4a38      	ldr	r2, [pc, #224]	; (8008d20 <tcp_close+0x168>)
 8008c40:	6013      	str	r3, [r2, #0]
 8008c42:	4b37      	ldr	r3, [pc, #220]	; (8008d20 <tcp_close+0x168>)
 8008c44:	681b      	ldr	r3, [r3, #0]
 8008c46:	2b00      	cmp	r3, #0
 8008c48:	d1ea      	bne.n	8008c20 <tcp_close+0x68>
 8008c4a:	687b      	ldr	r3, [r7, #4]
 8008c4c:	2200      	movs	r2, #0
 8008c4e:	60da      	str	r2, [r3, #12]
    memp_free(MEMP_TCP_PCB, pcb);
 8008c50:	6879      	ldr	r1, [r7, #4]
 8008c52:	2002      	movs	r0, #2
 8008c54:	f7ff fa7a 	bl	800814c <memp_free>
    pcb = NULL;
 8008c58:	2300      	movs	r3, #0
 8008c5a:	607b      	str	r3, [r7, #4]
    break;
 8008c5c:	e04d      	b.n	8008cfa <tcp_close+0x142>
  case LISTEN:
    err = ERR_OK;
 8008c5e:	2300      	movs	r3, #0
 8008c60:	73fb      	strb	r3, [r7, #15]
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
 8008c62:	6879      	ldr	r1, [r7, #4]
 8008c64:	482f      	ldr	r0, [pc, #188]	; (8008d24 <tcp_close+0x16c>)
 8008c66:	f000 ff29 	bl	8009abc <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8008c6a:	6879      	ldr	r1, [r7, #4]
 8008c6c:	2003      	movs	r0, #3
 8008c6e:	f7ff fa6d 	bl	800814c <memp_free>
    pcb = NULL;
 8008c72:	2300      	movs	r3, #0
 8008c74:	607b      	str	r3, [r7, #4]
    break;
 8008c76:	e040      	b.n	8008cfa <tcp_close+0x142>
  case SYN_SENT:
    err = ERR_OK;
 8008c78:	2300      	movs	r3, #0
 8008c7a:	73fb      	strb	r3, [r7, #15]
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8008c7c:	6879      	ldr	r1, [r7, #4]
 8008c7e:	482a      	ldr	r0, [pc, #168]	; (8008d28 <tcp_close+0x170>)
 8008c80:	f000 ff1c 	bl	8009abc <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 8008c84:	6879      	ldr	r1, [r7, #4]
 8008c86:	2002      	movs	r0, #2
 8008c88:	f7ff fa60 	bl	800814c <memp_free>
    pcb = NULL;
 8008c8c:	2300      	movs	r3, #0
 8008c8e:	607b      	str	r3, [r7, #4]
    snmp_inc_tcpattemptfails();
    break;
 8008c90:	e033      	b.n	8008cfa <tcp_close+0x142>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
 8008c92:	2101      	movs	r1, #1
 8008c94:	6878      	ldr	r0, [r7, #4]
 8008c96:	f002 fcea 	bl	800b66e <tcp_send_ctrl>
 8008c9a:	4603      	mov	r3, r0
 8008c9c:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
 8008c9e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8008ca2:	2b00      	cmp	r3, #0
 8008ca4:	d124      	bne.n	8008cf0 <tcp_close+0x138>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 8008ca6:	687b      	ldr	r3, [r7, #4]
 8008ca8:	2205      	movs	r2, #5
 8008caa:	741a      	strb	r2, [r3, #16]
    }
    break;
 8008cac:	e020      	b.n	8008cf0 <tcp_close+0x138>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
 8008cae:	2101      	movs	r1, #1
 8008cb0:	6878      	ldr	r0, [r7, #4]
 8008cb2:	f002 fcdc 	bl	800b66e <tcp_send_ctrl>
 8008cb6:	4603      	mov	r3, r0
 8008cb8:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
 8008cba:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8008cbe:	2b00      	cmp	r3, #0
 8008cc0:	d118      	bne.n	8008cf4 <tcp_close+0x13c>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
 8008cc2:	687b      	ldr	r3, [r7, #4]
 8008cc4:	2205      	movs	r2, #5
 8008cc6:	741a      	strb	r2, [r3, #16]
    }
    break;
 8008cc8:	e014      	b.n	8008cf4 <tcp_close+0x13c>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
 8008cca:	2101      	movs	r1, #1
 8008ccc:	6878      	ldr	r0, [r7, #4]
 8008cce:	f002 fcce 	bl	800b66e <tcp_send_ctrl>
 8008cd2:	4603      	mov	r3, r0
 8008cd4:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
 8008cd6:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8008cda:	2b00      	cmp	r3, #0
 8008cdc:	d10c      	bne.n	8008cf8 <tcp_close+0x140>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 8008cde:	687b      	ldr	r3, [r7, #4]
 8008ce0:	2209      	movs	r2, #9
 8008ce2:	741a      	strb	r2, [r3, #16]
    }
    break;
 8008ce4:	e008      	b.n	8008cf8 <tcp_close+0x140>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
 8008ce6:	2300      	movs	r3, #0
 8008ce8:	73fb      	strb	r3, [r7, #15]
    pcb = NULL;
 8008cea:	2300      	movs	r3, #0
 8008cec:	607b      	str	r3, [r7, #4]
    break;
 8008cee:	e004      	b.n	8008cfa <tcp_close+0x142>
    break;
 8008cf0:	bf00      	nop
 8008cf2:	e002      	b.n	8008cfa <tcp_close+0x142>
    break;
 8008cf4:	bf00      	nop
 8008cf6:	e000      	b.n	8008cfa <tcp_close+0x142>
    break;
 8008cf8:	bf00      	nop
  }

  if (pcb != NULL && err == ERR_OK) {
 8008cfa:	687b      	ldr	r3, [r7, #4]
 8008cfc:	2b00      	cmp	r3, #0
 8008cfe:	d006      	beq.n	8008d0e <tcp_close+0x156>
 8008d00:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8008d04:	2b00      	cmp	r3, #0
 8008d06:	d102      	bne.n	8008d0e <tcp_close+0x156>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
 8008d08:	6878      	ldr	r0, [r7, #4]
 8008d0a:	f003 f81f 	bl	800bd4c <tcp_output>
  }
  return err;
 8008d0e:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 8008d12:	4618      	mov	r0, r3
 8008d14:	3710      	adds	r7, #16
 8008d16:	46bd      	mov	sp, r7
 8008d18:	bd80      	pop	{r7, pc}
 8008d1a:	bf00      	nop
 8008d1c:	2000a334 	.word	0x2000a334
 8008d20:	2000a330 	.word	0x2000a330
 8008d24:	2000a32c 	.word	0x2000a32c
 8008d28:	2000a324 	.word	0x2000a324

08008d2c <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 8008d2c:	b580      	push	{r7, lr}
 8008d2e:	b08c      	sub	sp, #48	; 0x30
 8008d30:	af02      	add	r7, sp, #8
 8008d32:	6078      	str	r0, [r7, #4]
 8008d34:	6039      	str	r1, [r7, #0]

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 8008d36:	687b      	ldr	r3, [r7, #4]
 8008d38:	7c1b      	ldrb	r3, [r3, #16]
 8008d3a:	2b0a      	cmp	r3, #10
 8008d3c:	d108      	bne.n	8008d50 <tcp_abandon+0x24>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 8008d3e:	6879      	ldr	r1, [r7, #4]
 8008d40:	4830      	ldr	r0, [pc, #192]	; (8008e04 <tcp_abandon+0xd8>)
 8008d42:	f000 febb 	bl	8009abc <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 8008d46:	6879      	ldr	r1, [r7, #4]
 8008d48:	2002      	movs	r0, #2
 8008d4a:	f7ff f9ff 	bl	800814c <memp_free>
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
    }
  }
}
 8008d4e:	e055      	b.n	8008dfc <tcp_abandon+0xd0>
    seqno = pcb->snd_nxt;
 8008d50:	687b      	ldr	r3, [r7, #4]
 8008d52:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008d54:	627b      	str	r3, [r7, #36]	; 0x24
    ackno = pcb->rcv_nxt;
 8008d56:	687b      	ldr	r3, [r7, #4]
 8008d58:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008d5a:	623b      	str	r3, [r7, #32]
    ip_addr_set(&local_ip, &(pcb->local_ip));
 8008d5c:	687b      	ldr	r3, [r7, #4]
 8008d5e:	2b00      	cmp	r3, #0
 8008d60:	d002      	beq.n	8008d68 <tcp_abandon+0x3c>
 8008d62:	687b      	ldr	r3, [r7, #4]
 8008d64:	681b      	ldr	r3, [r3, #0]
 8008d66:	e000      	b.n	8008d6a <tcp_abandon+0x3e>
 8008d68:	2300      	movs	r3, #0
 8008d6a:	60fb      	str	r3, [r7, #12]
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
 8008d6c:	687b      	ldr	r3, [r7, #4]
 8008d6e:	3304      	adds	r3, #4
 8008d70:	2b00      	cmp	r3, #0
 8008d72:	d002      	beq.n	8008d7a <tcp_abandon+0x4e>
 8008d74:	687b      	ldr	r3, [r7, #4]
 8008d76:	685b      	ldr	r3, [r3, #4]
 8008d78:	e000      	b.n	8008d7c <tcp_abandon+0x50>
 8008d7a:	2300      	movs	r3, #0
 8008d7c:	613b      	str	r3, [r7, #16]
    local_port = pcb->local_port;
 8008d7e:	687b      	ldr	r3, [r7, #4]
 8008d80:	8b1b      	ldrh	r3, [r3, #24]
 8008d82:	83fb      	strh	r3, [r7, #30]
    remote_port = pcb->remote_port;
 8008d84:	687b      	ldr	r3, [r7, #4]
 8008d86:	8c1b      	ldrh	r3, [r3, #32]
 8008d88:	83bb      	strh	r3, [r7, #28]
    errf = pcb->errf;
 8008d8a:	687b      	ldr	r3, [r7, #4]
 8008d8c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008d90:	61bb      	str	r3, [r7, #24]
    errf_arg = pcb->callback_arg;
 8008d92:	687b      	ldr	r3, [r7, #4]
 8008d94:	695b      	ldr	r3, [r3, #20]
 8008d96:	617b      	str	r3, [r7, #20]
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8008d98:	6879      	ldr	r1, [r7, #4]
 8008d9a:	481b      	ldr	r0, [pc, #108]	; (8008e08 <tcp_abandon+0xdc>)
 8008d9c:	f000 fe8e 	bl	8009abc <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
 8008da0:	687b      	ldr	r3, [r7, #4]
 8008da2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008da4:	2b00      	cmp	r3, #0
 8008da6:	d004      	beq.n	8008db2 <tcp_abandon+0x86>
      tcp_segs_free(pcb->unacked);
 8008da8:	687b      	ldr	r3, [r7, #4]
 8008daa:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008dac:	4618      	mov	r0, r3
 8008dae:	f000 fc87 	bl	80096c0 <tcp_segs_free>
    if (pcb->unsent != NULL) {
 8008db2:	687b      	ldr	r3, [r7, #4]
 8008db4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008db6:	2b00      	cmp	r3, #0
 8008db8:	d004      	beq.n	8008dc4 <tcp_abandon+0x98>
      tcp_segs_free(pcb->unsent);
 8008dba:	687b      	ldr	r3, [r7, #4]
 8008dbc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008dbe:	4618      	mov	r0, r3
 8008dc0:	f000 fc7e 	bl	80096c0 <tcp_segs_free>
    memp_free(MEMP_TCP_PCB, pcb);
 8008dc4:	6879      	ldr	r1, [r7, #4]
 8008dc6:	2002      	movs	r0, #2
 8008dc8:	f7ff f9c0 	bl	800814c <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 8008dcc:	69bb      	ldr	r3, [r7, #24]
 8008dce:	2b00      	cmp	r3, #0
 8008dd0:	d004      	beq.n	8008ddc <tcp_abandon+0xb0>
 8008dd2:	69bb      	ldr	r3, [r7, #24]
 8008dd4:	f06f 0104 	mvn.w	r1, #4
 8008dd8:	6978      	ldr	r0, [r7, #20]
 8008dda:	4798      	blx	r3
    if (reset) {
 8008ddc:	683b      	ldr	r3, [r7, #0]
 8008dde:	2b00      	cmp	r3, #0
 8008de0:	d00c      	beq.n	8008dfc <tcp_abandon+0xd0>
      tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
 8008de2:	f107 0110 	add.w	r1, r7, #16
 8008de6:	f107 020c 	add.w	r2, r7, #12
 8008dea:	8bbb      	ldrh	r3, [r7, #28]
 8008dec:	9301      	str	r3, [sp, #4]
 8008dee:	8bfb      	ldrh	r3, [r7, #30]
 8008df0:	9300      	str	r3, [sp, #0]
 8008df2:	460b      	mov	r3, r1
 8008df4:	6a39      	ldr	r1, [r7, #32]
 8008df6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8008df8:	f003 f9c4 	bl	800c184 <tcp_rst>
}
 8008dfc:	bf00      	nop
 8008dfe:	3728      	adds	r7, #40	; 0x28
 8008e00:	46bd      	mov	sp, r7
 8008e02:	bd80      	pop	{r7, pc}
 8008e04:	2000a338 	.word	0x2000a338
 8008e08:	2000a324 	.word	0x2000a324

08008e0c <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
 8008e0c:	b580      	push	{r7, lr}
 8008e0e:	b086      	sub	sp, #24
 8008e10:	af00      	add	r7, sp, #0
 8008e12:	60f8      	str	r0, [r7, #12]
 8008e14:	60b9      	str	r1, [r7, #8]
 8008e16:	4613      	mov	r3, r2
 8008e18:	80fb      	strh	r3, [r7, #6]
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 8008e1a:	68fb      	ldr	r3, [r7, #12]
 8008e1c:	7c1b      	ldrb	r3, [r3, #16]
 8008e1e:	2b00      	cmp	r3, #0
 8008e20:	d002      	beq.n	8008e28 <tcp_bind+0x1c>
 8008e22:	f06f 030c 	mvn.w	r3, #12
 8008e26:	e0a6      	b.n	8008f76 <tcp_bind+0x16a>

  if (port == 0) {
 8008e28:	88fb      	ldrh	r3, [r7, #6]
 8008e2a:	2b00      	cmp	r3, #0
 8008e2c:	d103      	bne.n	8008e36 <tcp_bind+0x2a>
    port = tcp_new_port();
 8008e2e:	f000 f9b7 	bl	80091a0 <tcp_new_port>
 8008e32:	4603      	mov	r3, r0
 8008e34:	80fb      	strh	r3, [r7, #6]
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
 8008e36:	4b52      	ldr	r3, [pc, #328]	; (8008f80 <tcp_bind+0x174>)
 8008e38:	681b      	ldr	r3, [r3, #0]
 8008e3a:	617b      	str	r3, [r7, #20]
 8008e3c:	e01e      	b.n	8008e7c <tcp_bind+0x70>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
 8008e3e:	697b      	ldr	r3, [r7, #20]
 8008e40:	8b1b      	ldrh	r3, [r3, #24]
 8008e42:	88fa      	ldrh	r2, [r7, #6]
 8008e44:	429a      	cmp	r2, r3
 8008e46:	d116      	bne.n	8008e76 <tcp_bind+0x6a>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
 8008e48:	697b      	ldr	r3, [r7, #20]
 8008e4a:	2b00      	cmp	r3, #0
 8008e4c:	d010      	beq.n	8008e70 <tcp_bind+0x64>
 8008e4e:	697b      	ldr	r3, [r7, #20]
 8008e50:	681b      	ldr	r3, [r3, #0]
 8008e52:	2b00      	cmp	r3, #0
 8008e54:	d00c      	beq.n	8008e70 <tcp_bind+0x64>
 8008e56:	68bb      	ldr	r3, [r7, #8]
 8008e58:	2b00      	cmp	r3, #0
 8008e5a:	d009      	beq.n	8008e70 <tcp_bind+0x64>
          ip_addr_isany(ipaddr) ||
 8008e5c:	68bb      	ldr	r3, [r7, #8]
 8008e5e:	681b      	ldr	r3, [r3, #0]
 8008e60:	2b00      	cmp	r3, #0
 8008e62:	d005      	beq.n	8008e70 <tcp_bind+0x64>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 8008e64:	697b      	ldr	r3, [r7, #20]
 8008e66:	681a      	ldr	r2, [r3, #0]
 8008e68:	68bb      	ldr	r3, [r7, #8]
 8008e6a:	681b      	ldr	r3, [r3, #0]
          ip_addr_isany(ipaddr) ||
 8008e6c:	429a      	cmp	r2, r3
 8008e6e:	d102      	bne.n	8008e76 <tcp_bind+0x6a>
        return ERR_USE;
 8008e70:	f06f 030a 	mvn.w	r3, #10
 8008e74:	e07f      	b.n	8008f76 <tcp_bind+0x16a>
      cpcb != NULL; cpcb = cpcb->next) {
 8008e76:	697b      	ldr	r3, [r7, #20]
 8008e78:	68db      	ldr	r3, [r3, #12]
 8008e7a:	617b      	str	r3, [r7, #20]
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
 8008e7c:	697b      	ldr	r3, [r7, #20]
 8008e7e:	2b00      	cmp	r3, #0
 8008e80:	d1dd      	bne.n	8008e3e <tcp_bind+0x32>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
 8008e82:	4b40      	ldr	r3, [pc, #256]	; (8008f84 <tcp_bind+0x178>)
 8008e84:	681b      	ldr	r3, [r3, #0]
 8008e86:	617b      	str	r3, [r7, #20]
 8008e88:	e01e      	b.n	8008ec8 <tcp_bind+0xbc>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
 8008e8a:	697b      	ldr	r3, [r7, #20]
 8008e8c:	8b1b      	ldrh	r3, [r3, #24]
 8008e8e:	88fa      	ldrh	r2, [r7, #6]
 8008e90:	429a      	cmp	r2, r3
 8008e92:	d116      	bne.n	8008ec2 <tcp_bind+0xb6>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
 8008e94:	697b      	ldr	r3, [r7, #20]
 8008e96:	2b00      	cmp	r3, #0
 8008e98:	d010      	beq.n	8008ebc <tcp_bind+0xb0>
 8008e9a:	697b      	ldr	r3, [r7, #20]
 8008e9c:	681b      	ldr	r3, [r3, #0]
 8008e9e:	2b00      	cmp	r3, #0
 8008ea0:	d00c      	beq.n	8008ebc <tcp_bind+0xb0>
 8008ea2:	68bb      	ldr	r3, [r7, #8]
 8008ea4:	2b00      	cmp	r3, #0
 8008ea6:	d009      	beq.n	8008ebc <tcp_bind+0xb0>
          ip_addr_isany(ipaddr) ||
 8008ea8:	68bb      	ldr	r3, [r7, #8]
 8008eaa:	681b      	ldr	r3, [r3, #0]
 8008eac:	2b00      	cmp	r3, #0
 8008eae:	d005      	beq.n	8008ebc <tcp_bind+0xb0>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 8008eb0:	697b      	ldr	r3, [r7, #20]
 8008eb2:	681a      	ldr	r2, [r3, #0]
 8008eb4:	68bb      	ldr	r3, [r7, #8]
 8008eb6:	681b      	ldr	r3, [r3, #0]
          ip_addr_isany(ipaddr) ||
 8008eb8:	429a      	cmp	r2, r3
 8008eba:	d102      	bne.n	8008ec2 <tcp_bind+0xb6>
        return ERR_USE;
 8008ebc:	f06f 030a 	mvn.w	r3, #10
 8008ec0:	e059      	b.n	8008f76 <tcp_bind+0x16a>
      cpcb != NULL; cpcb = cpcb->next) {
 8008ec2:	697b      	ldr	r3, [r7, #20]
 8008ec4:	68db      	ldr	r3, [r3, #12]
 8008ec6:	617b      	str	r3, [r7, #20]
  for(cpcb = tcp_active_pcbs;
 8008ec8:	697b      	ldr	r3, [r7, #20]
 8008eca:	2b00      	cmp	r3, #0
 8008ecc:	d1dd      	bne.n	8008e8a <tcp_bind+0x7e>
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8008ece:	4b2e      	ldr	r3, [pc, #184]	; (8008f88 <tcp_bind+0x17c>)
 8008ed0:	681b      	ldr	r3, [r3, #0]
 8008ed2:	617b      	str	r3, [r7, #20]
 8008ed4:	e01e      	b.n	8008f14 <tcp_bind+0x108>
    if (cpcb->local_port == port) {
 8008ed6:	697b      	ldr	r3, [r7, #20]
 8008ed8:	8b1b      	ldrh	r3, [r3, #24]
 8008eda:	88fa      	ldrh	r2, [r7, #6]
 8008edc:	429a      	cmp	r2, r3
 8008ede:	d116      	bne.n	8008f0e <tcp_bind+0x102>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
 8008ee0:	697b      	ldr	r3, [r7, #20]
 8008ee2:	2b00      	cmp	r3, #0
 8008ee4:	d010      	beq.n	8008f08 <tcp_bind+0xfc>
 8008ee6:	697b      	ldr	r3, [r7, #20]
 8008ee8:	681b      	ldr	r3, [r3, #0]
 8008eea:	2b00      	cmp	r3, #0
 8008eec:	d00c      	beq.n	8008f08 <tcp_bind+0xfc>
 8008eee:	68bb      	ldr	r3, [r7, #8]
 8008ef0:	2b00      	cmp	r3, #0
 8008ef2:	d009      	beq.n	8008f08 <tcp_bind+0xfc>
          ip_addr_isany(ipaddr) ||
 8008ef4:	68bb      	ldr	r3, [r7, #8]
 8008ef6:	681b      	ldr	r3, [r3, #0]
 8008ef8:	2b00      	cmp	r3, #0
 8008efa:	d005      	beq.n	8008f08 <tcp_bind+0xfc>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 8008efc:	697b      	ldr	r3, [r7, #20]
 8008efe:	681a      	ldr	r2, [r3, #0]
 8008f00:	68bb      	ldr	r3, [r7, #8]
 8008f02:	681b      	ldr	r3, [r3, #0]
          ip_addr_isany(ipaddr) ||
 8008f04:	429a      	cmp	r2, r3
 8008f06:	d102      	bne.n	8008f0e <tcp_bind+0x102>
        return ERR_USE;
 8008f08:	f06f 030a 	mvn.w	r3, #10
 8008f0c:	e033      	b.n	8008f76 <tcp_bind+0x16a>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8008f0e:	697b      	ldr	r3, [r7, #20]
 8008f10:	68db      	ldr	r3, [r3, #12]
 8008f12:	617b      	str	r3, [r7, #20]
 8008f14:	697b      	ldr	r3, [r7, #20]
 8008f16:	2b00      	cmp	r3, #0
 8008f18:	d1dd      	bne.n	8008ed6 <tcp_bind+0xca>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8008f1a:	4b1c      	ldr	r3, [pc, #112]	; (8008f8c <tcp_bind+0x180>)
 8008f1c:	681b      	ldr	r3, [r3, #0]
 8008f1e:	617b      	str	r3, [r7, #20]
 8008f20:	e010      	b.n	8008f44 <tcp_bind+0x138>
    if (cpcb->local_port == port) {
 8008f22:	697b      	ldr	r3, [r7, #20]
 8008f24:	8b1b      	ldrh	r3, [r3, #24]
 8008f26:	88fa      	ldrh	r2, [r7, #6]
 8008f28:	429a      	cmp	r2, r3
 8008f2a:	d108      	bne.n	8008f3e <tcp_bind+0x132>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 8008f2c:	697b      	ldr	r3, [r7, #20]
 8008f2e:	681a      	ldr	r2, [r3, #0]
 8008f30:	68bb      	ldr	r3, [r7, #8]
 8008f32:	681b      	ldr	r3, [r3, #0]
 8008f34:	429a      	cmp	r2, r3
 8008f36:	d102      	bne.n	8008f3e <tcp_bind+0x132>
        return ERR_USE;
 8008f38:	f06f 030a 	mvn.w	r3, #10
 8008f3c:	e01b      	b.n	8008f76 <tcp_bind+0x16a>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8008f3e:	697b      	ldr	r3, [r7, #20]
 8008f40:	68db      	ldr	r3, [r3, #12]
 8008f42:	617b      	str	r3, [r7, #20]
 8008f44:	697b      	ldr	r3, [r7, #20]
 8008f46:	2b00      	cmp	r3, #0
 8008f48:	d1eb      	bne.n	8008f22 <tcp_bind+0x116>
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
 8008f4a:	68bb      	ldr	r3, [r7, #8]
 8008f4c:	2b00      	cmp	r3, #0
 8008f4e:	d007      	beq.n	8008f60 <tcp_bind+0x154>
 8008f50:	68bb      	ldr	r3, [r7, #8]
 8008f52:	681b      	ldr	r3, [r3, #0]
 8008f54:	2b00      	cmp	r3, #0
 8008f56:	d003      	beq.n	8008f60 <tcp_bind+0x154>
    pcb->local_ip = *ipaddr;
 8008f58:	68fb      	ldr	r3, [r7, #12]
 8008f5a:	68ba      	ldr	r2, [r7, #8]
 8008f5c:	6810      	ldr	r0, [r2, #0]
 8008f5e:	6018      	str	r0, [r3, #0]
  }
  pcb->local_port = port;
 8008f60:	68fb      	ldr	r3, [r7, #12]
 8008f62:	88fa      	ldrh	r2, [r7, #6]
 8008f64:	831a      	strh	r2, [r3, #24]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8008f66:	4b08      	ldr	r3, [pc, #32]	; (8008f88 <tcp_bind+0x17c>)
 8008f68:	681a      	ldr	r2, [r3, #0]
 8008f6a:	68fb      	ldr	r3, [r7, #12]
 8008f6c:	60da      	str	r2, [r3, #12]
 8008f6e:	4a06      	ldr	r2, [pc, #24]	; (8008f88 <tcp_bind+0x17c>)
 8008f70:	68fb      	ldr	r3, [r7, #12]
 8008f72:	6013      	str	r3, [r2, #0]
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 8008f74:	2300      	movs	r3, #0
}
 8008f76:	4618      	mov	r0, r3
 8008f78:	3718      	adds	r7, #24
 8008f7a:	46bd      	mov	sp, r7
 8008f7c:	bd80      	pop	{r7, pc}
 8008f7e:	bf00      	nop
 8008f80:	2000a32c 	.word	0x2000a32c
 8008f84:	2000a324 	.word	0x2000a324
 8008f88:	2000a334 	.word	0x2000a334
 8008f8c:	2000a338 	.word	0x2000a338

08008f90 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
 8008f90:	b480      	push	{r7}
 8008f92:	b085      	sub	sp, #20
 8008f94:	af00      	add	r7, sp, #0
 8008f96:	60f8      	str	r0, [r7, #12]
 8008f98:	60b9      	str	r1, [r7, #8]
 8008f9a:	4613      	mov	r3, r2
 8008f9c:	71fb      	strb	r3, [r7, #7]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
 8008f9e:	f06f 0304 	mvn.w	r3, #4
}
 8008fa2:	4618      	mov	r0, r3
 8008fa4:	3714      	adds	r7, #20
 8008fa6:	46bd      	mov	sp, r7
 8008fa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008fac:	4770      	bx	lr
	...

08008fb0 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 8008fb0:	b580      	push	{r7, lr}
 8008fb2:	b084      	sub	sp, #16
 8008fb4:	af00      	add	r7, sp, #0
 8008fb6:	6078      	str	r0, [r7, #4]
 8008fb8:	460b      	mov	r3, r1
 8008fba:	70fb      	strb	r3, [r7, #3]
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8008fbc:	687b      	ldr	r3, [r7, #4]
 8008fbe:	7c1b      	ldrb	r3, [r3, #16]
 8008fc0:	2b00      	cmp	r3, #0
 8008fc2:	d001      	beq.n	8008fc8 <tcp_listen_with_backlog+0x18>
 8008fc4:	2300      	movs	r3, #0
 8008fc6:	e06c      	b.n	80090a2 <tcp_listen_with_backlog+0xf2>

  /* already listening? */
  if (pcb->state == LISTEN) {
 8008fc8:	687b      	ldr	r3, [r7, #4]
 8008fca:	7c1b      	ldrb	r3, [r3, #16]
 8008fcc:	2b01      	cmp	r3, #1
 8008fce:	d101      	bne.n	8008fd4 <tcp_listen_with_backlog+0x24>
    return pcb;
 8008fd0:	687b      	ldr	r3, [r7, #4]
 8008fd2:	e066      	b.n	80090a2 <tcp_listen_with_backlog+0xf2>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
 8008fd4:	2003      	movs	r0, #3
 8008fd6:	f7ff f897 	bl	8008108 <memp_malloc>
 8008fda:	60f8      	str	r0, [r7, #12]
  if (lpcb == NULL) {
 8008fdc:	68fb      	ldr	r3, [r7, #12]
 8008fde:	2b00      	cmp	r3, #0
 8008fe0:	d101      	bne.n	8008fe6 <tcp_listen_with_backlog+0x36>
    return NULL;
 8008fe2:	2300      	movs	r3, #0
 8008fe4:	e05d      	b.n	80090a2 <tcp_listen_with_backlog+0xf2>
  }
  lpcb->callback_arg = pcb->callback_arg;
 8008fe6:	687b      	ldr	r3, [r7, #4]
 8008fe8:	695a      	ldr	r2, [r3, #20]
 8008fea:	68fb      	ldr	r3, [r7, #12]
 8008fec:	615a      	str	r2, [r3, #20]
  lpcb->local_port = pcb->local_port;
 8008fee:	687b      	ldr	r3, [r7, #4]
 8008ff0:	8b1a      	ldrh	r2, [r3, #24]
 8008ff2:	68fb      	ldr	r3, [r7, #12]
 8008ff4:	831a      	strh	r2, [r3, #24]
  lpcb->state = LISTEN;
 8008ff6:	68fb      	ldr	r3, [r7, #12]
 8008ff8:	2201      	movs	r2, #1
 8008ffa:	741a      	strb	r2, [r3, #16]
  lpcb->so_options = pcb->so_options;
 8008ffc:	687b      	ldr	r3, [r7, #4]
 8008ffe:	891a      	ldrh	r2, [r3, #8]
 8009000:	68fb      	ldr	r3, [r7, #12]
 8009002:	811a      	strh	r2, [r3, #8]
  lpcb->so_options |= SOF_ACCEPTCONN;
 8009004:	68fb      	ldr	r3, [r7, #12]
 8009006:	891b      	ldrh	r3, [r3, #8]
 8009008:	f043 0302 	orr.w	r3, r3, #2
 800900c:	b29a      	uxth	r2, r3
 800900e:	68fb      	ldr	r3, [r7, #12]
 8009010:	811a      	strh	r2, [r3, #8]
  lpcb->ttl = pcb->ttl;
 8009012:	687b      	ldr	r3, [r7, #4]
 8009014:	7ada      	ldrb	r2, [r3, #11]
 8009016:	68fb      	ldr	r3, [r7, #12]
 8009018:	72da      	strb	r2, [r3, #11]
  lpcb->tos = pcb->tos;
 800901a:	687b      	ldr	r3, [r7, #4]
 800901c:	7a9a      	ldrb	r2, [r3, #10]
 800901e:	68fb      	ldr	r3, [r7, #12]
 8009020:	729a      	strb	r2, [r3, #10]
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
 8009022:	687b      	ldr	r3, [r7, #4]
 8009024:	2b00      	cmp	r3, #0
 8009026:	d002      	beq.n	800902e <tcp_listen_with_backlog+0x7e>
 8009028:	687b      	ldr	r3, [r7, #4]
 800902a:	681b      	ldr	r3, [r3, #0]
 800902c:	e000      	b.n	8009030 <tcp_listen_with_backlog+0x80>
 800902e:	2300      	movs	r3, #0
 8009030:	68fa      	ldr	r2, [r7, #12]
 8009032:	6013      	str	r3, [r2, #0]
  TCP_RMV(&tcp_bound_pcbs, pcb);
 8009034:	4b1d      	ldr	r3, [pc, #116]	; (80090ac <tcp_listen_with_backlog+0xfc>)
 8009036:	681a      	ldr	r2, [r3, #0]
 8009038:	687b      	ldr	r3, [r7, #4]
 800903a:	429a      	cmp	r2, r3
 800903c:	d105      	bne.n	800904a <tcp_listen_with_backlog+0x9a>
 800903e:	4b1b      	ldr	r3, [pc, #108]	; (80090ac <tcp_listen_with_backlog+0xfc>)
 8009040:	681b      	ldr	r3, [r3, #0]
 8009042:	68db      	ldr	r3, [r3, #12]
 8009044:	4a19      	ldr	r2, [pc, #100]	; (80090ac <tcp_listen_with_backlog+0xfc>)
 8009046:	6013      	str	r3, [r2, #0]
 8009048:	e019      	b.n	800907e <tcp_listen_with_backlog+0xce>
 800904a:	4b18      	ldr	r3, [pc, #96]	; (80090ac <tcp_listen_with_backlog+0xfc>)
 800904c:	681b      	ldr	r3, [r3, #0]
 800904e:	4a18      	ldr	r2, [pc, #96]	; (80090b0 <tcp_listen_with_backlog+0x100>)
 8009050:	6013      	str	r3, [r2, #0]
 8009052:	e010      	b.n	8009076 <tcp_listen_with_backlog+0xc6>
 8009054:	4b16      	ldr	r3, [pc, #88]	; (80090b0 <tcp_listen_with_backlog+0x100>)
 8009056:	681b      	ldr	r3, [r3, #0]
 8009058:	68da      	ldr	r2, [r3, #12]
 800905a:	687b      	ldr	r3, [r7, #4]
 800905c:	429a      	cmp	r2, r3
 800905e:	d105      	bne.n	800906c <tcp_listen_with_backlog+0xbc>
 8009060:	4b13      	ldr	r3, [pc, #76]	; (80090b0 <tcp_listen_with_backlog+0x100>)
 8009062:	681b      	ldr	r3, [r3, #0]
 8009064:	687a      	ldr	r2, [r7, #4]
 8009066:	68d2      	ldr	r2, [r2, #12]
 8009068:	60da      	str	r2, [r3, #12]
 800906a:	e008      	b.n	800907e <tcp_listen_with_backlog+0xce>
 800906c:	4b10      	ldr	r3, [pc, #64]	; (80090b0 <tcp_listen_with_backlog+0x100>)
 800906e:	681b      	ldr	r3, [r3, #0]
 8009070:	68db      	ldr	r3, [r3, #12]
 8009072:	4a0f      	ldr	r2, [pc, #60]	; (80090b0 <tcp_listen_with_backlog+0x100>)
 8009074:	6013      	str	r3, [r2, #0]
 8009076:	4b0e      	ldr	r3, [pc, #56]	; (80090b0 <tcp_listen_with_backlog+0x100>)
 8009078:	681b      	ldr	r3, [r3, #0]
 800907a:	2b00      	cmp	r3, #0
 800907c:	d1ea      	bne.n	8009054 <tcp_listen_with_backlog+0xa4>
 800907e:	687b      	ldr	r3, [r7, #4]
 8009080:	2200      	movs	r2, #0
 8009082:	60da      	str	r2, [r3, #12]
  memp_free(MEMP_TCP_PCB, pcb);
 8009084:	6879      	ldr	r1, [r7, #4]
 8009086:	2002      	movs	r0, #2
 8009088:	f7ff f860 	bl	800814c <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 800908c:	68fb      	ldr	r3, [r7, #12]
 800908e:	4a09      	ldr	r2, [pc, #36]	; (80090b4 <tcp_listen_with_backlog+0x104>)
 8009090:	61da      	str	r2, [r3, #28]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
 8009092:	4b09      	ldr	r3, [pc, #36]	; (80090b8 <tcp_listen_with_backlog+0x108>)
 8009094:	681a      	ldr	r2, [r3, #0]
 8009096:	68fb      	ldr	r3, [r7, #12]
 8009098:	60da      	str	r2, [r3, #12]
 800909a:	4a07      	ldr	r2, [pc, #28]	; (80090b8 <tcp_listen_with_backlog+0x108>)
 800909c:	68fb      	ldr	r3, [r7, #12]
 800909e:	6013      	str	r3, [r2, #0]
  return (struct tcp_pcb *)lpcb;
 80090a0:	68fb      	ldr	r3, [r7, #12]
}
 80090a2:	4618      	mov	r0, r3
 80090a4:	3710      	adds	r7, #16
 80090a6:	46bd      	mov	sp, r7
 80090a8:	bd80      	pop	{r7, pc}
 80090aa:	bf00      	nop
 80090ac:	2000a334 	.word	0x2000a334
 80090b0:	2000a330 	.word	0x2000a330
 80090b4:	08008f91 	.word	0x08008f91
 80090b8:	2000a32c 	.word	0x2000a32c

080090bc <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 80090bc:	b480      	push	{r7}
 80090be:	b085      	sub	sp, #20
 80090c0:	af00      	add	r7, sp, #0
 80090c2:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 80090c4:	687b      	ldr	r3, [r7, #4]
 80090c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80090c8:	687a      	ldr	r2, [r7, #4]
 80090ca:	8d12      	ldrh	r2, [r2, #40]	; 0x28
 80090cc:	4413      	add	r3, r2
 80090ce:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 80090d0:	687b      	ldr	r3, [r7, #4]
 80090d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80090d4:	687a      	ldr	r2, [r7, #4]
 80090d6:	8f12      	ldrh	r2, [r2, #56]	; 0x38
 80090d8:	f240 51b4 	movw	r1, #1460	; 0x5b4
 80090dc:	428a      	cmp	r2, r1
 80090de:	d802      	bhi.n	80090e6 <tcp_update_rcv_ann_wnd+0x2a>
 80090e0:	687a      	ldr	r2, [r7, #4]
 80090e2:	8f12      	ldrh	r2, [r2, #56]	; 0x38
 80090e4:	e001      	b.n	80090ea <tcp_update_rcv_ann_wnd+0x2e>
 80090e6:	f240 52b4 	movw	r2, #1460	; 0x5b4
 80090ea:	4413      	add	r3, r2
 80090ec:	68fa      	ldr	r2, [r7, #12]
 80090ee:	1ad3      	subs	r3, r2, r3
 80090f0:	2b00      	cmp	r3, #0
 80090f2:	db08      	blt.n	8009106 <tcp_update_rcv_ann_wnd+0x4a>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 80090f4:	687b      	ldr	r3, [r7, #4]
 80090f6:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 80090f8:	687b      	ldr	r3, [r7, #4]
 80090fa:	855a      	strh	r2, [r3, #42]	; 0x2a
    return new_right_edge - pcb->rcv_ann_right_edge;
 80090fc:	687b      	ldr	r3, [r7, #4]
 80090fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009100:	68fa      	ldr	r2, [r7, #12]
 8009102:	1ad3      	subs	r3, r2, r3
 8009104:	e015      	b.n	8009132 <tcp_update_rcv_ann_wnd+0x76>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8009106:	687b      	ldr	r3, [r7, #4]
 8009108:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800910a:	687b      	ldr	r3, [r7, #4]
 800910c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800910e:	1ad3      	subs	r3, r2, r3
 8009110:	2b00      	cmp	r3, #0
 8009112:	dd03      	ble.n	800911c <tcp_update_rcv_ann_wnd+0x60>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 8009114:	687b      	ldr	r3, [r7, #4]
 8009116:	2200      	movs	r2, #0
 8009118:	855a      	strh	r2, [r3, #42]	; 0x2a
 800911a:	e009      	b.n	8009130 <tcp_update_rcv_ann_wnd+0x74>
    } else {
      /* keep the right edge of window constant */
      pcb->rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800911c:	687b      	ldr	r3, [r7, #4]
 800911e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009120:	b29a      	uxth	r2, r3
 8009122:	687b      	ldr	r3, [r7, #4]
 8009124:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009126:	b29b      	uxth	r3, r3
 8009128:	1ad3      	subs	r3, r2, r3
 800912a:	b29a      	uxth	r2, r3
 800912c:	687b      	ldr	r3, [r7, #4]
 800912e:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
    return 0;
 8009130:	2300      	movs	r3, #0
  }
}
 8009132:	4618      	mov	r0, r3
 8009134:	3714      	adds	r7, #20
 8009136:	46bd      	mov	sp, r7
 8009138:	f85d 7b04 	ldr.w	r7, [sp], #4
 800913c:	4770      	bx	lr

0800913e <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 800913e:	b580      	push	{r7, lr}
 8009140:	b084      	sub	sp, #16
 8009142:	af00      	add	r7, sp, #0
 8009144:	6078      	str	r0, [r7, #4]
 8009146:	460b      	mov	r3, r1
 8009148:	807b      	strh	r3, [r7, #2]
  int wnd_inflation;

  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 800914a:	687b      	ldr	r3, [r7, #4]
 800914c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 800914e:	887b      	ldrh	r3, [r7, #2]
 8009150:	4413      	add	r3, r2
 8009152:	b29a      	uxth	r2, r3
 8009154:	687b      	ldr	r3, [r7, #4]
 8009156:	851a      	strh	r2, [r3, #40]	; 0x28
  if (pcb->rcv_wnd > TCP_WND)
 8009158:	687b      	ldr	r3, [r7, #4]
 800915a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800915c:	f640 3268 	movw	r2, #2920	; 0xb68
 8009160:	4293      	cmp	r3, r2
 8009162:	d903      	bls.n	800916c <tcp_recved+0x2e>
    pcb->rcv_wnd = TCP_WND;
 8009164:	687b      	ldr	r3, [r7, #4]
 8009166:	f640 3268 	movw	r2, #2920	; 0xb68
 800916a:	851a      	strh	r2, [r3, #40]	; 0x28

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 800916c:	6878      	ldr	r0, [r7, #4]
 800916e:	f7ff ffa5 	bl	80090bc <tcp_update_rcv_ann_wnd>
 8009172:	4603      	mov	r3, r0
 8009174:	60fb      	str	r3, [r7, #12]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/2), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) 
 8009176:	68fb      	ldr	r3, [r7, #12]
 8009178:	f240 22d9 	movw	r2, #729	; 0x2d9
 800917c:	4293      	cmp	r3, r2
 800917e:	dd0b      	ble.n	8009198 <tcp_recved+0x5a>
    tcp_ack_now(pcb);
 8009180:	687b      	ldr	r3, [r7, #4]
 8009182:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8009186:	f043 0302 	orr.w	r3, r3, #2
 800918a:	b2da      	uxtb	r2, r3
 800918c:	687b      	ldr	r3, [r7, #4]
 800918e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8009192:	6878      	ldr	r0, [r7, #4]
 8009194:	f002 fdda 	bl	800bd4c <tcp_output>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8009198:	bf00      	nop
 800919a:	3710      	adds	r7, #16
 800919c:	46bd      	mov	sp, r7
 800919e:	bd80      	pop	{r7, pc}

080091a0 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 80091a0:	b480      	push	{r7}
 80091a2:	b083      	sub	sp, #12
 80091a4:	af00      	add	r7, sp, #0
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
 80091a6:	4b25      	ldr	r3, [pc, #148]	; (800923c <tcp_new_port+0x9c>)
 80091a8:	881b      	ldrh	r3, [r3, #0]
 80091aa:	3301      	adds	r3, #1
 80091ac:	b29a      	uxth	r2, r3
 80091ae:	4b23      	ldr	r3, [pc, #140]	; (800923c <tcp_new_port+0x9c>)
 80091b0:	801a      	strh	r2, [r3, #0]
 80091b2:	4b22      	ldr	r3, [pc, #136]	; (800923c <tcp_new_port+0x9c>)
 80091b4:	881b      	ldrh	r3, [r3, #0]
 80091b6:	b21b      	sxth	r3, r3
 80091b8:	2b00      	cmp	r3, #0
 80091ba:	da03      	bge.n	80091c4 <tcp_new_port+0x24>
    port = TCP_LOCAL_PORT_RANGE_START;
 80091bc:	4b1f      	ldr	r3, [pc, #124]	; (800923c <tcp_new_port+0x9c>)
 80091be:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80091c2:	801a      	strh	r2, [r3, #0]
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80091c4:	4b1e      	ldr	r3, [pc, #120]	; (8009240 <tcp_new_port+0xa0>)
 80091c6:	681b      	ldr	r3, [r3, #0]
 80091c8:	607b      	str	r3, [r7, #4]
 80091ca:	e009      	b.n	80091e0 <tcp_new_port+0x40>
    if (pcb->local_port == port) {
 80091cc:	687b      	ldr	r3, [r7, #4]
 80091ce:	8b1a      	ldrh	r2, [r3, #24]
 80091d0:	4b1a      	ldr	r3, [pc, #104]	; (800923c <tcp_new_port+0x9c>)
 80091d2:	881b      	ldrh	r3, [r3, #0]
 80091d4:	429a      	cmp	r2, r3
 80091d6:	d100      	bne.n	80091da <tcp_new_port+0x3a>
      goto again;
 80091d8:	e7e5      	b.n	80091a6 <tcp_new_port+0x6>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80091da:	687b      	ldr	r3, [r7, #4]
 80091dc:	68db      	ldr	r3, [r3, #12]
 80091de:	607b      	str	r3, [r7, #4]
 80091e0:	687b      	ldr	r3, [r7, #4]
 80091e2:	2b00      	cmp	r3, #0
 80091e4:	d1f2      	bne.n	80091cc <tcp_new_port+0x2c>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80091e6:	4b17      	ldr	r3, [pc, #92]	; (8009244 <tcp_new_port+0xa4>)
 80091e8:	681b      	ldr	r3, [r3, #0]
 80091ea:	607b      	str	r3, [r7, #4]
 80091ec:	e009      	b.n	8009202 <tcp_new_port+0x62>
    if (pcb->local_port == port) {
 80091ee:	687b      	ldr	r3, [r7, #4]
 80091f0:	8b1a      	ldrh	r2, [r3, #24]
 80091f2:	4b12      	ldr	r3, [pc, #72]	; (800923c <tcp_new_port+0x9c>)
 80091f4:	881b      	ldrh	r3, [r3, #0]
 80091f6:	429a      	cmp	r2, r3
 80091f8:	d100      	bne.n	80091fc <tcp_new_port+0x5c>
      goto again;
 80091fa:	e7d4      	b.n	80091a6 <tcp_new_port+0x6>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80091fc:	687b      	ldr	r3, [r7, #4]
 80091fe:	68db      	ldr	r3, [r3, #12]
 8009200:	607b      	str	r3, [r7, #4]
 8009202:	687b      	ldr	r3, [r7, #4]
 8009204:	2b00      	cmp	r3, #0
 8009206:	d1f2      	bne.n	80091ee <tcp_new_port+0x4e>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
 8009208:	4b0f      	ldr	r3, [pc, #60]	; (8009248 <tcp_new_port+0xa8>)
 800920a:	681b      	ldr	r3, [r3, #0]
 800920c:	607b      	str	r3, [r7, #4]
 800920e:	e009      	b.n	8009224 <tcp_new_port+0x84>
    if (pcb->local_port == port) {
 8009210:	687b      	ldr	r3, [r7, #4]
 8009212:	8b1a      	ldrh	r2, [r3, #24]
 8009214:	4b09      	ldr	r3, [pc, #36]	; (800923c <tcp_new_port+0x9c>)
 8009216:	881b      	ldrh	r3, [r3, #0]
 8009218:	429a      	cmp	r2, r3
 800921a:	d100      	bne.n	800921e <tcp_new_port+0x7e>
      goto again;
 800921c:	e7c3      	b.n	80091a6 <tcp_new_port+0x6>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
 800921e:	687b      	ldr	r3, [r7, #4]
 8009220:	68db      	ldr	r3, [r3, #12]
 8009222:	607b      	str	r3, [r7, #4]
 8009224:	687b      	ldr	r3, [r7, #4]
 8009226:	2b00      	cmp	r3, #0
 8009228:	d1f2      	bne.n	8009210 <tcp_new_port+0x70>
    }
  }
  return port;
 800922a:	4b04      	ldr	r3, [pc, #16]	; (800923c <tcp_new_port+0x9c>)
 800922c:	881b      	ldrh	r3, [r3, #0]
}
 800922e:	4618      	mov	r0, r3
 8009230:	370c      	adds	r7, #12
 8009232:	46bd      	mov	sp, r7
 8009234:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009238:	4770      	bx	lr
 800923a:	bf00      	nop
 800923c:	20000040 	.word	0x20000040
 8009240:	2000a324 	.word	0x2000a324
 8009244:	2000a338 	.word	0x2000a338
 8009248:	2000a32c 	.word	0x2000a32c

0800924c <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800924c:	b5b0      	push	{r4, r5, r7, lr}
 800924e:	b088      	sub	sp, #32
 8009250:	af02      	add	r7, sp, #8
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 8009252:	2300      	movs	r3, #0
 8009254:	737b      	strb	r3, [r7, #13]

  ++tcp_ticks;
 8009256:	4b96      	ldr	r3, [pc, #600]	; (80094b0 <tcp_slowtmr+0x264>)
 8009258:	681b      	ldr	r3, [r3, #0]
 800925a:	3301      	adds	r3, #1
 800925c:	4a94      	ldr	r2, [pc, #592]	; (80094b0 <tcp_slowtmr+0x264>)
 800925e:	6013      	str	r3, [r2, #0]

  /* Steps through all of the active PCBs. */
  prev = NULL;
 8009260:	2300      	movs	r3, #0
 8009262:	613b      	str	r3, [r7, #16]
  pcb = tcp_active_pcbs;
 8009264:	4b93      	ldr	r3, [pc, #588]	; (80094b4 <tcp_slowtmr+0x268>)
 8009266:	681b      	ldr	r3, [r3, #0]
 8009268:	617b      	str	r3, [r7, #20]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800926a:	e18f      	b.n	800958c <tcp_slowtmr+0x340>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
 800926c:	2300      	movs	r3, #0
 800926e:	73fb      	strb	r3, [r7, #15]
    pcb_reset = 0;
 8009270:	2300      	movs	r3, #0
 8009272:	73bb      	strb	r3, [r7, #14]

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8009274:	697b      	ldr	r3, [r7, #20]
 8009276:	7c1b      	ldrb	r3, [r3, #16]
 8009278:	2b02      	cmp	r3, #2
 800927a:	d108      	bne.n	800928e <tcp_slowtmr+0x42>
 800927c:	697b      	ldr	r3, [r7, #20]
 800927e:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 8009282:	2b06      	cmp	r3, #6
 8009284:	d103      	bne.n	800928e <tcp_slowtmr+0x42>
      ++pcb_remove;
 8009286:	7bfb      	ldrb	r3, [r7, #15]
 8009288:	3301      	adds	r3, #1
 800928a:	73fb      	strb	r3, [r7, #15]
 800928c:	e090      	b.n	80093b0 <tcp_slowtmr+0x164>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 800928e:	697b      	ldr	r3, [r7, #20]
 8009290:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 8009294:	2b0c      	cmp	r3, #12
 8009296:	d103      	bne.n	80092a0 <tcp_slowtmr+0x54>
      ++pcb_remove;
 8009298:	7bfb      	ldrb	r3, [r7, #15]
 800929a:	3301      	adds	r3, #1
 800929c:	73fb      	strb	r3, [r7, #15]
 800929e:	e087      	b.n	80093b0 <tcp_slowtmr+0x164>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 80092a0:	697b      	ldr	r3, [r7, #20]
 80092a2:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80092a6:	2b00      	cmp	r3, #0
 80092a8:	d026      	beq.n	80092f8 <tcp_slowtmr+0xac>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 80092aa:	697b      	ldr	r3, [r7, #20]
 80092ac:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80092b0:	1c5a      	adds	r2, r3, #1
 80092b2:	697b      	ldr	r3, [r7, #20]
 80092b4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 80092b8:	697b      	ldr	r3, [r7, #20]
 80092ba:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80092be:	697a      	ldr	r2, [r7, #20]
 80092c0:	f892 209c 	ldrb.w	r2, [r2, #156]	; 0x9c
 80092c4:	3a01      	subs	r2, #1
 80092c6:	497c      	ldr	r1, [pc, #496]	; (80094b8 <tcp_slowtmr+0x26c>)
 80092c8:	5c8a      	ldrb	r2, [r1, r2]
 80092ca:	4293      	cmp	r3, r2
 80092cc:	d370      	bcc.n	80093b0 <tcp_slowtmr+0x164>
          pcb->persist_cnt = 0;
 80092ce:	697b      	ldr	r3, [r7, #20]
 80092d0:	2200      	movs	r2, #0
 80092d2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 80092d6:	697b      	ldr	r3, [r7, #20]
 80092d8:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80092dc:	2b06      	cmp	r3, #6
 80092de:	d807      	bhi.n	80092f0 <tcp_slowtmr+0xa4>
            pcb->persist_backoff++;
 80092e0:	697b      	ldr	r3, [r7, #20]
 80092e2:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80092e6:	3301      	adds	r3, #1
 80092e8:	b2da      	uxtb	r2, r3
 80092ea:	697b      	ldr	r3, [r7, #20]
 80092ec:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
          }
          tcp_zero_window_probe(pcb);
 80092f0:	6978      	ldr	r0, [r7, #20]
 80092f2:	f003 f8b9 	bl	800c468 <tcp_zero_window_probe>
 80092f6:	e05b      	b.n	80093b0 <tcp_slowtmr+0x164>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
 80092f8:	697b      	ldr	r3, [r7, #20]
 80092fa:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 80092fe:	2b00      	cmp	r3, #0
 8009300:	db08      	blt.n	8009314 <tcp_slowtmr+0xc8>
          ++pcb->rtime;
 8009302:	697b      	ldr	r3, [r7, #20]
 8009304:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 8009308:	b29b      	uxth	r3, r3
 800930a:	3301      	adds	r3, #1
 800930c:	b29b      	uxth	r3, r3
 800930e:	b21a      	sxth	r2, r3
 8009310:	697b      	ldr	r3, [r7, #20]
 8009312:	86da      	strh	r2, [r3, #54]	; 0x36

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 8009314:	697b      	ldr	r3, [r7, #20]
 8009316:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009318:	2b00      	cmp	r3, #0
 800931a:	d049      	beq.n	80093b0 <tcp_slowtmr+0x164>
 800931c:	697b      	ldr	r3, [r7, #20]
 800931e:	f9b3 2036 	ldrsh.w	r2, [r3, #54]	; 0x36
 8009322:	697b      	ldr	r3, [r7, #20]
 8009324:	f9b3 3048 	ldrsh.w	r3, [r3, #72]	; 0x48
 8009328:	429a      	cmp	r2, r3
 800932a:	db41      	blt.n	80093b0 <tcp_slowtmr+0x164>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
 800932c:	697b      	ldr	r3, [r7, #20]
 800932e:	7c1b      	ldrb	r3, [r3, #16]
 8009330:	2b02      	cmp	r3, #2
 8009332:	d014      	beq.n	800935e <tcp_slowtmr+0x112>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 8009334:	697b      	ldr	r3, [r7, #20]
 8009336:	f9b3 3044 	ldrsh.w	r3, [r3, #68]	; 0x44
 800933a:	10db      	asrs	r3, r3, #3
 800933c:	b21b      	sxth	r3, r3
 800933e:	461a      	mov	r2, r3
 8009340:	697b      	ldr	r3, [r7, #20]
 8009342:	f9b3 3046 	ldrsh.w	r3, [r3, #70]	; 0x46
 8009346:	4413      	add	r3, r2
 8009348:	697a      	ldr	r2, [r7, #20]
 800934a:	f892 204a 	ldrb.w	r2, [r2, #74]	; 0x4a
 800934e:	4611      	mov	r1, r2
 8009350:	4a5a      	ldr	r2, [pc, #360]	; (80094bc <tcp_slowtmr+0x270>)
 8009352:	5c52      	ldrb	r2, [r2, r1]
 8009354:	4093      	lsls	r3, r2
 8009356:	b21a      	sxth	r2, r3
 8009358:	697b      	ldr	r3, [r7, #20]
 800935a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 800935e:	697b      	ldr	r3, [r7, #20]
 8009360:	2200      	movs	r2, #0
 8009362:	86da      	strh	r2, [r3, #54]	; 0x36

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 8009364:	697b      	ldr	r3, [r7, #20]
 8009366:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800936a:	697b      	ldr	r3, [r7, #20]
 800936c:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 8009370:	4293      	cmp	r3, r2
 8009372:	bf28      	it	cs
 8009374:	4613      	movcs	r3, r2
 8009376:	817b      	strh	r3, [r7, #10]
          pcb->ssthresh = eff_wnd >> 1;
 8009378:	897b      	ldrh	r3, [r7, #10]
 800937a:	085b      	lsrs	r3, r3, #1
 800937c:	b29a      	uxth	r2, r3
 800937e:	697b      	ldr	r3, [r7, #20]
 8009380:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
          if (pcb->ssthresh < pcb->mss) {
 8009384:	697b      	ldr	r3, [r7, #20]
 8009386:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 800938a:	697b      	ldr	r3, [r7, #20]
 800938c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800938e:	429a      	cmp	r2, r3
 8009390:	d206      	bcs.n	80093a0 <tcp_slowtmr+0x154>
            pcb->ssthresh = pcb->mss * 2;
 8009392:	697b      	ldr	r3, [r7, #20]
 8009394:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8009396:	005b      	lsls	r3, r3, #1
 8009398:	b29a      	uxth	r2, r3
 800939a:	697b      	ldr	r3, [r7, #20]
 800939c:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
          }
          pcb->cwnd = pcb->mss;
 80093a0:	697b      	ldr	r3, [r7, #20]
 80093a2:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 80093a4:	697b      	ldr	r3, [r7, #20]
 80093a6:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 80093aa:	6978      	ldr	r0, [r7, #20]
 80093ac:	f002 ff63 	bl	800c276 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 80093b0:	697b      	ldr	r3, [r7, #20]
 80093b2:	7c1b      	ldrb	r3, [r3, #16]
 80093b4:	2b06      	cmp	r3, #6
 80093b6:	d109      	bne.n	80093cc <tcp_slowtmr+0x180>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 80093b8:	4b3d      	ldr	r3, [pc, #244]	; (80094b0 <tcp_slowtmr+0x264>)
 80093ba:	681a      	ldr	r2, [r3, #0]
 80093bc:	697b      	ldr	r3, [r7, #20]
 80093be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093c0:	1ad3      	subs	r3, r2, r3
 80093c2:	2b28      	cmp	r3, #40	; 0x28
 80093c4:	d902      	bls.n	80093cc <tcp_slowtmr+0x180>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 80093c6:	7bfb      	ldrb	r3, [r7, #15]
 80093c8:	3301      	adds	r3, #1
 80093ca:	73fb      	strb	r3, [r7, #15]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
 80093cc:	697b      	ldr	r3, [r7, #20]
 80093ce:	891b      	ldrh	r3, [r3, #8]
 80093d0:	f003 0308 	and.w	r3, r3, #8
 80093d4:	2b00      	cmp	r3, #0
 80093d6:	d041      	beq.n	800945c <tcp_slowtmr+0x210>
       ((pcb->state == ESTABLISHED) || 
 80093d8:	697b      	ldr	r3, [r7, #20]
 80093da:	7c1b      	ldrb	r3, [r3, #16]
    if((pcb->so_options & SOF_KEEPALIVE) && 
 80093dc:	2b04      	cmp	r3, #4
 80093de:	d003      	beq.n	80093e8 <tcp_slowtmr+0x19c>
        (pcb->state == CLOSE_WAIT))) {
 80093e0:	697b      	ldr	r3, [r7, #20]
 80093e2:	7c1b      	ldrb	r3, [r3, #16]
       ((pcb->state == ESTABLISHED) || 
 80093e4:	2b07      	cmp	r3, #7
 80093e6:	d139      	bne.n	800945c <tcp_slowtmr+0x210>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
 80093e8:	4b31      	ldr	r3, [pc, #196]	; (80094b0 <tcp_slowtmr+0x264>)
 80093ea:	681a      	ldr	r2, [r3, #0]
 80093ec:	697b      	ldr	r3, [r7, #20]
 80093ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093f0:	1ad2      	subs	r2, r2, r3
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
 80093f2:	697b      	ldr	r3, [r7, #20]
 80093f4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80093f8:	f503 2324 	add.w	r3, r3, #671744	; 0xa4000
 80093fc:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 8009400:	492f      	ldr	r1, [pc, #188]	; (80094c0 <tcp_slowtmr+0x274>)
 8009402:	fba1 1303 	umull	r1, r3, r1, r3
 8009406:	095b      	lsrs	r3, r3, #5
      if((u32_t)(tcp_ticks - pcb->tmr) > 
 8009408:	429a      	cmp	r2, r3
 800940a:	d906      	bls.n	800941a <tcp_slowtmr+0x1ce>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        ++pcb_remove;
 800940c:	7bfb      	ldrb	r3, [r7, #15]
 800940e:	3301      	adds	r3, #1
 8009410:	73fb      	strb	r3, [r7, #15]
        ++pcb_reset;
 8009412:	7bbb      	ldrb	r3, [r7, #14]
 8009414:	3301      	adds	r3, #1
 8009416:	73bb      	strb	r3, [r7, #14]
 8009418:	e020      	b.n	800945c <tcp_slowtmr+0x210>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 800941a:	4b25      	ldr	r3, [pc, #148]	; (80094b0 <tcp_slowtmr+0x264>)
 800941c:	681a      	ldr	r2, [r3, #0]
 800941e:	697b      	ldr	r3, [r7, #20]
 8009420:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009422:	1ad2      	subs	r2, r2, r3
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
 8009424:	697b      	ldr	r3, [r7, #20]
 8009426:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 800942a:	697b      	ldr	r3, [r7, #20]
 800942c:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
 8009430:	4618      	mov	r0, r3
 8009432:	4b24      	ldr	r3, [pc, #144]	; (80094c4 <tcp_slowtmr+0x278>)
 8009434:	fb03 f300 	mul.w	r3, r3, r0
 8009438:	440b      	add	r3, r1
              / TCP_SLOW_INTERVAL)
 800943a:	4921      	ldr	r1, [pc, #132]	; (80094c0 <tcp_slowtmr+0x274>)
 800943c:	fba1 1303 	umull	r1, r3, r1, r3
 8009440:	095b      	lsrs	r3, r3, #5
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 8009442:	429a      	cmp	r2, r3
 8009444:	d90a      	bls.n	800945c <tcp_slowtmr+0x210>
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
 8009446:	6978      	ldr	r0, [r7, #20]
 8009448:	f002 ffdf 	bl	800c40a <tcp_keepalive>
        pcb->keep_cnt_sent++;
 800944c:	697b      	ldr	r3, [r7, #20]
 800944e:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
 8009452:	3301      	adds	r3, #1
 8009454:	b2da      	uxtb	r2, r3
 8009456:	697b      	ldr	r3, [r7, #20]
 8009458:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800945c:	697b      	ldr	r3, [r7, #20]
 800945e:	7c1b      	ldrb	r3, [r3, #16]
 8009460:	2b03      	cmp	r3, #3
 8009462:	d109      	bne.n	8009478 <tcp_slowtmr+0x22c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8009464:	4b12      	ldr	r3, [pc, #72]	; (80094b0 <tcp_slowtmr+0x264>)
 8009466:	681a      	ldr	r2, [r3, #0]
 8009468:	697b      	ldr	r3, [r7, #20]
 800946a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800946c:	1ad3      	subs	r3, r2, r3
 800946e:	2b28      	cmp	r3, #40	; 0x28
 8009470:	d902      	bls.n	8009478 <tcp_slowtmr+0x22c>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 8009472:	7bfb      	ldrb	r3, [r7, #15]
 8009474:	3301      	adds	r3, #1
 8009476:	73fb      	strb	r3, [r7, #15]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 8009478:	697b      	ldr	r3, [r7, #20]
 800947a:	7c1b      	ldrb	r3, [r3, #16]
 800947c:	2b09      	cmp	r3, #9
 800947e:	d109      	bne.n	8009494 <tcp_slowtmr+0x248>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8009480:	4b0b      	ldr	r3, [pc, #44]	; (80094b0 <tcp_slowtmr+0x264>)
 8009482:	681a      	ldr	r2, [r3, #0]
 8009484:	697b      	ldr	r3, [r7, #20]
 8009486:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009488:	1ad3      	subs	r3, r2, r3
 800948a:	2bf0      	cmp	r3, #240	; 0xf0
 800948c:	d902      	bls.n	8009494 <tcp_slowtmr+0x248>
        ++pcb_remove;
 800948e:	7bfb      	ldrb	r3, [r7, #15]
 8009490:	3301      	adds	r3, #1
 8009492:	73fb      	strb	r3, [r7, #15]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8009494:	7bfb      	ldrb	r3, [r7, #15]
 8009496:	2b00      	cmp	r3, #0
 8009498:	d046      	beq.n	8009528 <tcp_slowtmr+0x2dc>
      tcp_pcb_purge(pcb);      
 800949a:	6978      	ldr	r0, [r7, #20]
 800949c:	f000 fadc 	bl	8009a58 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 80094a0:	693b      	ldr	r3, [r7, #16]
 80094a2:	2b00      	cmp	r3, #0
 80094a4:	d010      	beq.n	80094c8 <tcp_slowtmr+0x27c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 80094a6:	697b      	ldr	r3, [r7, #20]
 80094a8:	68da      	ldr	r2, [r3, #12]
 80094aa:	693b      	ldr	r3, [r7, #16]
 80094ac:	60da      	str	r2, [r3, #12]
 80094ae:	e00f      	b.n	80094d0 <tcp_slowtmr+0x284>
 80094b0:	2000a328 	.word	0x2000a328
 80094b4:	2000a324 	.word	0x2000a324
 80094b8:	0801b5a8 	.word	0x0801b5a8
 80094bc:	0801b598 	.word	0x0801b598
 80094c0:	10624dd3 	.word	0x10624dd3
 80094c4:	000124f8 	.word	0x000124f8
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
 80094c8:	697b      	ldr	r3, [r7, #20]
 80094ca:	68db      	ldr	r3, [r3, #12]
 80094cc:	4a4e      	ldr	r2, [pc, #312]	; (8009608 <tcp_slowtmr+0x3bc>)
 80094ce:	6013      	str	r3, [r2, #0]
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
 80094d0:	697b      	ldr	r3, [r7, #20]
 80094d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80094d6:	2b00      	cmp	r3, #0
 80094d8:	d008      	beq.n	80094ec <tcp_slowtmr+0x2a0>
 80094da:	697b      	ldr	r3, [r7, #20]
 80094dc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80094e0:	697a      	ldr	r2, [r7, #20]
 80094e2:	6952      	ldr	r2, [r2, #20]
 80094e4:	f06f 0104 	mvn.w	r1, #4
 80094e8:	4610      	mov	r0, r2
 80094ea:	4798      	blx	r3
      if (pcb_reset) {
 80094ec:	7bbb      	ldrb	r3, [r7, #14]
 80094ee:	2b00      	cmp	r3, #0
 80094f0:	d010      	beq.n	8009514 <tcp_slowtmr+0x2c8>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 80094f2:	697b      	ldr	r3, [r7, #20]
 80094f4:	6d98      	ldr	r0, [r3, #88]	; 0x58
 80094f6:	697b      	ldr	r3, [r7, #20]
 80094f8:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80094fa:	697c      	ldr	r4, [r7, #20]
 80094fc:	697b      	ldr	r3, [r7, #20]
 80094fe:	1d1d      	adds	r5, r3, #4
 8009500:	697b      	ldr	r3, [r7, #20]
 8009502:	8b1b      	ldrh	r3, [r3, #24]
 8009504:	697a      	ldr	r2, [r7, #20]
 8009506:	8c12      	ldrh	r2, [r2, #32]
 8009508:	9201      	str	r2, [sp, #4]
 800950a:	9300      	str	r3, [sp, #0]
 800950c:	462b      	mov	r3, r5
 800950e:	4622      	mov	r2, r4
 8009510:	f002 fe38 	bl	800c184 <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      pcb2 = pcb->next;
 8009514:	697b      	ldr	r3, [r7, #20]
 8009516:	68db      	ldr	r3, [r3, #12]
 8009518:	607b      	str	r3, [r7, #4]
      memp_free(MEMP_TCP_PCB, pcb);
 800951a:	6979      	ldr	r1, [r7, #20]
 800951c:	2002      	movs	r0, #2
 800951e:	f7fe fe15 	bl	800814c <memp_free>
      pcb = pcb2;
 8009522:	687b      	ldr	r3, [r7, #4]
 8009524:	617b      	str	r3, [r7, #20]
 8009526:	e031      	b.n	800958c <tcp_slowtmr+0x340>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
 8009528:	697b      	ldr	r3, [r7, #20]
 800952a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800952e:	3301      	adds	r3, #1
 8009530:	b2da      	uxtb	r2, r3
 8009532:	697b      	ldr	r3, [r7, #20]
 8009534:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      if (pcb->polltmr >= pcb->pollinterval) {
 8009538:	697b      	ldr	r3, [r7, #20]
 800953a:	f893 2034 	ldrb.w	r2, [r3, #52]	; 0x34
 800953e:	697b      	ldr	r3, [r7, #20]
 8009540:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8009544:	429a      	cmp	r2, r3
 8009546:	d31c      	bcc.n	8009582 <tcp_slowtmr+0x336>
        pcb->polltmr = 0;
 8009548:	697b      	ldr	r3, [r7, #20]
 800954a:	2200      	movs	r2, #0
 800954c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
 8009550:	697b      	ldr	r3, [r7, #20]
 8009552:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8009556:	2b00      	cmp	r3, #0
 8009558:	d00a      	beq.n	8009570 <tcp_slowtmr+0x324>
 800955a:	697b      	ldr	r3, [r7, #20]
 800955c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8009560:	697a      	ldr	r2, [r7, #20]
 8009562:	6952      	ldr	r2, [r2, #20]
 8009564:	6979      	ldr	r1, [r7, #20]
 8009566:	4610      	mov	r0, r2
 8009568:	4798      	blx	r3
 800956a:	4603      	mov	r3, r0
 800956c:	737b      	strb	r3, [r7, #13]
 800956e:	e001      	b.n	8009574 <tcp_slowtmr+0x328>
 8009570:	2300      	movs	r3, #0
 8009572:	737b      	strb	r3, [r7, #13]
        if (err == ERR_OK) {
 8009574:	f997 300d 	ldrsb.w	r3, [r7, #13]
 8009578:	2b00      	cmp	r3, #0
 800957a:	d102      	bne.n	8009582 <tcp_slowtmr+0x336>
          tcp_output(pcb);
 800957c:	6978      	ldr	r0, [r7, #20]
 800957e:	f002 fbe5 	bl	800bd4c <tcp_output>
        }
      }
      
      prev = pcb;
 8009582:	697b      	ldr	r3, [r7, #20]
 8009584:	613b      	str	r3, [r7, #16]
      pcb = pcb->next;
 8009586:	697b      	ldr	r3, [r7, #20]
 8009588:	68db      	ldr	r3, [r3, #12]
 800958a:	617b      	str	r3, [r7, #20]
  while (pcb != NULL) {
 800958c:	697b      	ldr	r3, [r7, #20]
 800958e:	2b00      	cmp	r3, #0
 8009590:	f47f ae6c 	bne.w	800926c <tcp_slowtmr+0x20>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
 8009594:	2300      	movs	r3, #0
 8009596:	613b      	str	r3, [r7, #16]
  pcb = tcp_tw_pcbs;
 8009598:	4b1c      	ldr	r3, [pc, #112]	; (800960c <tcp_slowtmr+0x3c0>)
 800959a:	681b      	ldr	r3, [r3, #0]
 800959c:	617b      	str	r3, [r7, #20]
  while (pcb != NULL) {
 800959e:	e02c      	b.n	80095fa <tcp_slowtmr+0x3ae>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
 80095a0:	2300      	movs	r3, #0
 80095a2:	73fb      	strb	r3, [r7, #15]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 80095a4:	4b1a      	ldr	r3, [pc, #104]	; (8009610 <tcp_slowtmr+0x3c4>)
 80095a6:	681a      	ldr	r2, [r3, #0]
 80095a8:	697b      	ldr	r3, [r7, #20]
 80095aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80095ac:	1ad3      	subs	r3, r2, r3
 80095ae:	2bf0      	cmp	r3, #240	; 0xf0
 80095b0:	d902      	bls.n	80095b8 <tcp_slowtmr+0x36c>
      ++pcb_remove;
 80095b2:	7bfb      	ldrb	r3, [r7, #15]
 80095b4:	3301      	adds	r3, #1
 80095b6:	73fb      	strb	r3, [r7, #15]
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 80095b8:	7bfb      	ldrb	r3, [r7, #15]
 80095ba:	2b00      	cmp	r3, #0
 80095bc:	d018      	beq.n	80095f0 <tcp_slowtmr+0x3a4>
      tcp_pcb_purge(pcb);      
 80095be:	6978      	ldr	r0, [r7, #20]
 80095c0:	f000 fa4a 	bl	8009a58 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 80095c4:	693b      	ldr	r3, [r7, #16]
 80095c6:	2b00      	cmp	r3, #0
 80095c8:	d004      	beq.n	80095d4 <tcp_slowtmr+0x388>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
 80095ca:	697b      	ldr	r3, [r7, #20]
 80095cc:	68da      	ldr	r2, [r3, #12]
 80095ce:	693b      	ldr	r3, [r7, #16]
 80095d0:	60da      	str	r2, [r3, #12]
 80095d2:	e003      	b.n	80095dc <tcp_slowtmr+0x390>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
 80095d4:	697b      	ldr	r3, [r7, #20]
 80095d6:	68db      	ldr	r3, [r3, #12]
 80095d8:	4a0c      	ldr	r2, [pc, #48]	; (800960c <tcp_slowtmr+0x3c0>)
 80095da:	6013      	str	r3, [r2, #0]
      }
      pcb2 = pcb->next;
 80095dc:	697b      	ldr	r3, [r7, #20]
 80095de:	68db      	ldr	r3, [r3, #12]
 80095e0:	607b      	str	r3, [r7, #4]
      memp_free(MEMP_TCP_PCB, pcb);
 80095e2:	6979      	ldr	r1, [r7, #20]
 80095e4:	2002      	movs	r0, #2
 80095e6:	f7fe fdb1 	bl	800814c <memp_free>
      pcb = pcb2;
 80095ea:	687b      	ldr	r3, [r7, #4]
 80095ec:	617b      	str	r3, [r7, #20]
 80095ee:	e004      	b.n	80095fa <tcp_slowtmr+0x3ae>
    } else {
      prev = pcb;
 80095f0:	697b      	ldr	r3, [r7, #20]
 80095f2:	613b      	str	r3, [r7, #16]
      pcb = pcb->next;
 80095f4:	697b      	ldr	r3, [r7, #20]
 80095f6:	68db      	ldr	r3, [r3, #12]
 80095f8:	617b      	str	r3, [r7, #20]
  while (pcb != NULL) {
 80095fa:	697b      	ldr	r3, [r7, #20]
 80095fc:	2b00      	cmp	r3, #0
 80095fe:	d1cf      	bne.n	80095a0 <tcp_slowtmr+0x354>
    }
  }
}
 8009600:	bf00      	nop
 8009602:	3718      	adds	r7, #24
 8009604:	46bd      	mov	sp, r7
 8009606:	bdb0      	pop	{r4, r5, r7, pc}
 8009608:	2000a324 	.word	0x2000a324
 800960c:	2000a338 	.word	0x2000a338
 8009610:	2000a328 	.word	0x2000a328

08009614 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 8009614:	b590      	push	{r4, r7, lr}
 8009616:	b083      	sub	sp, #12
 8009618:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800961a:	4b28      	ldr	r3, [pc, #160]	; (80096bc <tcp_fasttmr+0xa8>)
 800961c:	681b      	ldr	r3, [r3, #0]
 800961e:	607b      	str	r3, [r7, #4]
 8009620:	e044      	b.n	80096ac <tcp_fasttmr+0x98>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 8009622:	687b      	ldr	r3, [r7, #4]
 8009624:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009626:	2b00      	cmp	r3, #0
 8009628:	d021      	beq.n	800966e <tcp_fasttmr+0x5a>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
 800962a:	687b      	ldr	r3, [r7, #4]
 800962c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8009630:	2b00      	cmp	r3, #0
 8009632:	d00c      	beq.n	800964e <tcp_fasttmr+0x3a>
 8009634:	687b      	ldr	r3, [r7, #4]
 8009636:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 800963a:	687b      	ldr	r3, [r7, #4]
 800963c:	6958      	ldr	r0, [r3, #20]
 800963e:	687b      	ldr	r3, [r7, #4]
 8009640:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8009642:	2300      	movs	r3, #0
 8009644:	6879      	ldr	r1, [r7, #4]
 8009646:	47a0      	blx	r4
 8009648:	4603      	mov	r3, r0
 800964a:	70fb      	strb	r3, [r7, #3]
 800964c:	e008      	b.n	8009660 <tcp_fasttmr+0x4c>
 800964e:	687b      	ldr	r3, [r7, #4]
 8009650:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8009652:	2300      	movs	r3, #0
 8009654:	6879      	ldr	r1, [r7, #4]
 8009656:	2000      	movs	r0, #0
 8009658:	f000 f87d 	bl	8009756 <tcp_recv_null>
 800965c:	4603      	mov	r3, r0
 800965e:	70fb      	strb	r3, [r7, #3]
      if (err == ERR_OK) {
 8009660:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8009664:	2b00      	cmp	r3, #0
 8009666:	d102      	bne.n	800966e <tcp_fasttmr+0x5a>
        pcb->refused_data = NULL;
 8009668:	687b      	ldr	r3, [r7, #4]
 800966a:	2200      	movs	r2, #0
 800966c:	67da      	str	r2, [r3, #124]	; 0x7c
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
 800966e:	687b      	ldr	r3, [r7, #4]
 8009670:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8009674:	f003 0301 	and.w	r3, r3, #1
 8009678:	2b00      	cmp	r3, #0
 800967a:	d014      	beq.n	80096a6 <tcp_fasttmr+0x92>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8009682:	f043 0302 	orr.w	r3, r3, #2
 8009686:	b2da      	uxtb	r2, r3
 8009688:	687b      	ldr	r3, [r7, #4]
 800968a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800968e:	6878      	ldr	r0, [r7, #4]
 8009690:	f002 fb5c 	bl	800bd4c <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8009694:	687b      	ldr	r3, [r7, #4]
 8009696:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800969a:	f023 0303 	bic.w	r3, r3, #3
 800969e:	b2da      	uxtb	r2, r3
 80096a0:	687b      	ldr	r3, [r7, #4]
 80096a2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80096a6:	687b      	ldr	r3, [r7, #4]
 80096a8:	68db      	ldr	r3, [r3, #12]
 80096aa:	607b      	str	r3, [r7, #4]
 80096ac:	687b      	ldr	r3, [r7, #4]
 80096ae:	2b00      	cmp	r3, #0
 80096b0:	d1b7      	bne.n	8009622 <tcp_fasttmr+0xe>
    }
  }
}
 80096b2:	bf00      	nop
 80096b4:	370c      	adds	r7, #12
 80096b6:	46bd      	mov	sp, r7
 80096b8:	bd90      	pop	{r4, r7, pc}
 80096ba:	bf00      	nop
 80096bc:	2000a324 	.word	0x2000a324

080096c0 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
 80096c0:	b580      	push	{r7, lr}
 80096c2:	b084      	sub	sp, #16
 80096c4:	af00      	add	r7, sp, #0
 80096c6:	6078      	str	r0, [r7, #4]
  u8_t count = 0;
 80096c8:	2300      	movs	r3, #0
 80096ca:	73fb      	strb	r3, [r7, #15]
  struct tcp_seg *next;
  while (seg != NULL) {
 80096cc:	e00c      	b.n	80096e8 <tcp_segs_free+0x28>
    next = seg->next;
 80096ce:	687b      	ldr	r3, [r7, #4]
 80096d0:	681b      	ldr	r3, [r3, #0]
 80096d2:	60bb      	str	r3, [r7, #8]
    count += tcp_seg_free(seg);
 80096d4:	6878      	ldr	r0, [r7, #4]
 80096d6:	f000 f80f 	bl	80096f8 <tcp_seg_free>
 80096da:	4603      	mov	r3, r0
 80096dc:	461a      	mov	r2, r3
 80096de:	7bfb      	ldrb	r3, [r7, #15]
 80096e0:	4413      	add	r3, r2
 80096e2:	73fb      	strb	r3, [r7, #15]
    seg = next;
 80096e4:	68bb      	ldr	r3, [r7, #8]
 80096e6:	607b      	str	r3, [r7, #4]
  while (seg != NULL) {
 80096e8:	687b      	ldr	r3, [r7, #4]
 80096ea:	2b00      	cmp	r3, #0
 80096ec:	d1ef      	bne.n	80096ce <tcp_segs_free+0xe>
  }
  return count;
 80096ee:	7bfb      	ldrb	r3, [r7, #15]
}
 80096f0:	4618      	mov	r0, r3
 80096f2:	3710      	adds	r7, #16
 80096f4:	46bd      	mov	sp, r7
 80096f6:	bd80      	pop	{r7, pc}

080096f8 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
 80096f8:	b580      	push	{r7, lr}
 80096fa:	b084      	sub	sp, #16
 80096fc:	af00      	add	r7, sp, #0
 80096fe:	6078      	str	r0, [r7, #4]
  u8_t count = 0;
 8009700:	2300      	movs	r3, #0
 8009702:	73fb      	strb	r3, [r7, #15]
  
  if (seg != NULL) {
 8009704:	687b      	ldr	r3, [r7, #4]
 8009706:	2b00      	cmp	r3, #0
 8009708:	d011      	beq.n	800972e <tcp_seg_free+0x36>
    if (seg->p != NULL) {
 800970a:	687b      	ldr	r3, [r7, #4]
 800970c:	685b      	ldr	r3, [r3, #4]
 800970e:	2b00      	cmp	r3, #0
 8009710:	d009      	beq.n	8009726 <tcp_seg_free+0x2e>
      count = pbuf_free(seg->p);
 8009712:	687b      	ldr	r3, [r7, #4]
 8009714:	685b      	ldr	r3, [r3, #4]
 8009716:	4618      	mov	r0, r3
 8009718:	f7ff f847 	bl	80087aa <pbuf_free>
 800971c:	4603      	mov	r3, r0
 800971e:	73fb      	strb	r3, [r7, #15]
#if TCP_DEBUG
      seg->p = NULL;
 8009720:	687b      	ldr	r3, [r7, #4]
 8009722:	2200      	movs	r2, #0
 8009724:	605a      	str	r2, [r3, #4]
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8009726:	6879      	ldr	r1, [r7, #4]
 8009728:	2004      	movs	r0, #4
 800972a:	f7fe fd0f 	bl	800814c <memp_free>
  }
  return count;
 800972e:	7bfb      	ldrb	r3, [r7, #15]
}
 8009730:	4618      	mov	r0, r3
 8009732:	3710      	adds	r7, #16
 8009734:	46bd      	mov	sp, r7
 8009736:	bd80      	pop	{r7, pc}

08009738 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
 8009738:	b480      	push	{r7}
 800973a:	b083      	sub	sp, #12
 800973c:	af00      	add	r7, sp, #0
 800973e:	6078      	str	r0, [r7, #4]
 8009740:	460b      	mov	r3, r1
 8009742:	70fb      	strb	r3, [r7, #3]
  pcb->prio = prio;
 8009744:	687b      	ldr	r3, [r7, #4]
 8009746:	78fa      	ldrb	r2, [r7, #3]
 8009748:	745a      	strb	r2, [r3, #17]
}
 800974a:	bf00      	nop
 800974c:	370c      	adds	r7, #12
 800974e:	46bd      	mov	sp, r7
 8009750:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009754:	4770      	bx	lr

08009756 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 8009756:	b580      	push	{r7, lr}
 8009758:	b084      	sub	sp, #16
 800975a:	af00      	add	r7, sp, #0
 800975c:	60f8      	str	r0, [r7, #12]
 800975e:	60b9      	str	r1, [r7, #8]
 8009760:	607a      	str	r2, [r7, #4]
 8009762:	70fb      	strb	r3, [r7, #3]
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
 8009764:	687b      	ldr	r3, [r7, #4]
 8009766:	2b00      	cmp	r3, #0
 8009768:	d009      	beq.n	800977e <tcp_recv_null+0x28>
    tcp_recved(pcb, p->tot_len);
 800976a:	687b      	ldr	r3, [r7, #4]
 800976c:	891b      	ldrh	r3, [r3, #8]
 800976e:	4619      	mov	r1, r3
 8009770:	68b8      	ldr	r0, [r7, #8]
 8009772:	f7ff fce4 	bl	800913e <tcp_recved>
    pbuf_free(p);
 8009776:	6878      	ldr	r0, [r7, #4]
 8009778:	f7ff f817 	bl	80087aa <pbuf_free>
 800977c:	e008      	b.n	8009790 <tcp_recv_null+0x3a>
  } else if (err == ERR_OK) {
 800977e:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8009782:	2b00      	cmp	r3, #0
 8009784:	d104      	bne.n	8009790 <tcp_recv_null+0x3a>
    return tcp_close(pcb);
 8009786:	68b8      	ldr	r0, [r7, #8]
 8009788:	f7ff fa16 	bl	8008bb8 <tcp_close>
 800978c:	4603      	mov	r3, r0
 800978e:	e000      	b.n	8009792 <tcp_recv_null+0x3c>
  }
  return ERR_OK;
 8009790:	2300      	movs	r3, #0
}
 8009792:	4618      	mov	r0, r3
 8009794:	3710      	adds	r7, #16
 8009796:	46bd      	mov	sp, r7
 8009798:	bd80      	pop	{r7, pc}
	...

0800979c <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 800979c:	b580      	push	{r7, lr}
 800979e:	b086      	sub	sp, #24
 80097a0:	af00      	add	r7, sp, #0
 80097a2:	4603      	mov	r3, r0
 80097a4:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
 80097a6:	237f      	movs	r3, #127	; 0x7f
 80097a8:	72fb      	strb	r3, [r7, #11]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
 80097aa:	2300      	movs	r3, #0
 80097ac:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 80097ae:	2300      	movs	r3, #0
 80097b0:	613b      	str	r3, [r7, #16]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80097b2:	4b19      	ldr	r3, [pc, #100]	; (8009818 <tcp_kill_prio+0x7c>)
 80097b4:	681b      	ldr	r3, [r3, #0]
 80097b6:	617b      	str	r3, [r7, #20]
 80097b8:	e01f      	b.n	80097fa <tcp_kill_prio+0x5e>
    if (pcb->prio <= prio &&
 80097ba:	697b      	ldr	r3, [r7, #20]
 80097bc:	7c5b      	ldrb	r3, [r3, #17]
 80097be:	79fa      	ldrb	r2, [r7, #7]
 80097c0:	429a      	cmp	r2, r3
 80097c2:	d317      	bcc.n	80097f4 <tcp_kill_prio+0x58>
       pcb->prio <= mprio &&
 80097c4:	697b      	ldr	r3, [r7, #20]
 80097c6:	7c5b      	ldrb	r3, [r3, #17]
    if (pcb->prio <= prio &&
 80097c8:	7afa      	ldrb	r2, [r7, #11]
 80097ca:	429a      	cmp	r2, r3
 80097cc:	d312      	bcc.n	80097f4 <tcp_kill_prio+0x58>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80097ce:	4b13      	ldr	r3, [pc, #76]	; (800981c <tcp_kill_prio+0x80>)
 80097d0:	681a      	ldr	r2, [r3, #0]
 80097d2:	697b      	ldr	r3, [r7, #20]
 80097d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80097d6:	1ad2      	subs	r2, r2, r3
       pcb->prio <= mprio &&
 80097d8:	68fb      	ldr	r3, [r7, #12]
 80097da:	429a      	cmp	r2, r3
 80097dc:	d30a      	bcc.n	80097f4 <tcp_kill_prio+0x58>
      inactivity = tcp_ticks - pcb->tmr;
 80097de:	4b0f      	ldr	r3, [pc, #60]	; (800981c <tcp_kill_prio+0x80>)
 80097e0:	681a      	ldr	r2, [r3, #0]
 80097e2:	697b      	ldr	r3, [r7, #20]
 80097e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80097e6:	1ad3      	subs	r3, r2, r3
 80097e8:	60fb      	str	r3, [r7, #12]
      inactive = pcb;
 80097ea:	697b      	ldr	r3, [r7, #20]
 80097ec:	613b      	str	r3, [r7, #16]
      mprio = pcb->prio;
 80097ee:	697b      	ldr	r3, [r7, #20]
 80097f0:	7c5b      	ldrb	r3, [r3, #17]
 80097f2:	72fb      	strb	r3, [r7, #11]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80097f4:	697b      	ldr	r3, [r7, #20]
 80097f6:	68db      	ldr	r3, [r3, #12]
 80097f8:	617b      	str	r3, [r7, #20]
 80097fa:	697b      	ldr	r3, [r7, #20]
 80097fc:	2b00      	cmp	r3, #0
 80097fe:	d1dc      	bne.n	80097ba <tcp_kill_prio+0x1e>
    }
  }
  if (inactive != NULL) {
 8009800:	693b      	ldr	r3, [r7, #16]
 8009802:	2b00      	cmp	r3, #0
 8009804:	d003      	beq.n	800980e <tcp_kill_prio+0x72>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 8009806:	2101      	movs	r1, #1
 8009808:	6938      	ldr	r0, [r7, #16]
 800980a:	f7ff fa8f 	bl	8008d2c <tcp_abandon>
  }      
}
 800980e:	bf00      	nop
 8009810:	3718      	adds	r7, #24
 8009812:	46bd      	mov	sp, r7
 8009814:	bd80      	pop	{r7, pc}
 8009816:	bf00      	nop
 8009818:	2000a324 	.word	0x2000a324
 800981c:	2000a328 	.word	0x2000a328

08009820 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 8009820:	b580      	push	{r7, lr}
 8009822:	b084      	sub	sp, #16
 8009824:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 8009826:	2300      	movs	r3, #0
 8009828:	607b      	str	r3, [r7, #4]
  inactive = NULL;
 800982a:	2300      	movs	r3, #0
 800982c:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800982e:	4b12      	ldr	r3, [pc, #72]	; (8009878 <tcp_kill_timewait+0x58>)
 8009830:	681b      	ldr	r3, [r3, #0]
 8009832:	60fb      	str	r3, [r7, #12]
 8009834:	e012      	b.n	800985c <tcp_kill_timewait+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8009836:	4b11      	ldr	r3, [pc, #68]	; (800987c <tcp_kill_timewait+0x5c>)
 8009838:	681a      	ldr	r2, [r3, #0]
 800983a:	68fb      	ldr	r3, [r7, #12]
 800983c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800983e:	1ad2      	subs	r2, r2, r3
 8009840:	687b      	ldr	r3, [r7, #4]
 8009842:	429a      	cmp	r2, r3
 8009844:	d307      	bcc.n	8009856 <tcp_kill_timewait+0x36>
      inactivity = tcp_ticks - pcb->tmr;
 8009846:	4b0d      	ldr	r3, [pc, #52]	; (800987c <tcp_kill_timewait+0x5c>)
 8009848:	681a      	ldr	r2, [r3, #0]
 800984a:	68fb      	ldr	r3, [r7, #12]
 800984c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800984e:	1ad3      	subs	r3, r2, r3
 8009850:	607b      	str	r3, [r7, #4]
      inactive = pcb;
 8009852:	68fb      	ldr	r3, [r7, #12]
 8009854:	60bb      	str	r3, [r7, #8]
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8009856:	68fb      	ldr	r3, [r7, #12]
 8009858:	68db      	ldr	r3, [r3, #12]
 800985a:	60fb      	str	r3, [r7, #12]
 800985c:	68fb      	ldr	r3, [r7, #12]
 800985e:	2b00      	cmp	r3, #0
 8009860:	d1e9      	bne.n	8009836 <tcp_kill_timewait+0x16>
    }
  }
  if (inactive != NULL) {
 8009862:	68bb      	ldr	r3, [r7, #8]
 8009864:	2b00      	cmp	r3, #0
 8009866:	d003      	beq.n	8009870 <tcp_kill_timewait+0x50>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 8009868:	2101      	movs	r1, #1
 800986a:	68b8      	ldr	r0, [r7, #8]
 800986c:	f7ff fa5e 	bl	8008d2c <tcp_abandon>
  }      
}
 8009870:	bf00      	nop
 8009872:	3710      	adds	r7, #16
 8009874:	46bd      	mov	sp, r7
 8009876:	bd80      	pop	{r7, pc}
 8009878:	2000a338 	.word	0x2000a338
 800987c:	2000a328 	.word	0x2000a328

08009880 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 8009880:	b580      	push	{r7, lr}
 8009882:	b084      	sub	sp, #16
 8009884:	af00      	add	r7, sp, #0
 8009886:	4603      	mov	r3, r0
 8009888:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
 800988a:	2002      	movs	r0, #2
 800988c:	f7fe fc3c 	bl	8008108 <memp_malloc>
 8009890:	60f8      	str	r0, [r7, #12]
  if (pcb == NULL) {
 8009892:	68fb      	ldr	r3, [r7, #12]
 8009894:	2b00      	cmp	r3, #0
 8009896:	d110      	bne.n	80098ba <tcp_alloc+0x3a>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 8009898:	f7ff ffc2 	bl	8009820 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
 800989c:	2002      	movs	r0, #2
 800989e:	f7fe fc33 	bl	8008108 <memp_malloc>
 80098a2:	60f8      	str	r0, [r7, #12]
    if (pcb == NULL) {
 80098a4:	68fb      	ldr	r3, [r7, #12]
 80098a6:	2b00      	cmp	r3, #0
 80098a8:	d107      	bne.n	80098ba <tcp_alloc+0x3a>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
 80098aa:	79fb      	ldrb	r3, [r7, #7]
 80098ac:	4618      	mov	r0, r3
 80098ae:	f7ff ff75 	bl	800979c <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
 80098b2:	2002      	movs	r0, #2
 80098b4:	f7fe fc28 	bl	8008108 <memp_malloc>
 80098b8:	60f8      	str	r0, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 80098ba:	68fb      	ldr	r3, [r7, #12]
 80098bc:	2b00      	cmp	r3, #0
 80098be:	d059      	beq.n	8009974 <tcp_alloc+0xf4>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 80098c0:	22a0      	movs	r2, #160	; 0xa0
 80098c2:	2100      	movs	r1, #0
 80098c4:	68f8      	ldr	r0, [r7, #12]
 80098c6:	f004 fed9 	bl	800e67c <memset>
    pcb->prio = TCP_PRIO_NORMAL;
 80098ca:	68fb      	ldr	r3, [r7, #12]
 80098cc:	2240      	movs	r2, #64	; 0x40
 80098ce:	745a      	strb	r2, [r3, #17]
    pcb->snd_buf = TCP_SND_BUF;
 80098d0:	68fb      	ldr	r3, [r7, #12]
 80098d2:	f241 62d0 	movw	r2, #5840	; 0x16d0
 80098d6:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
    pcb->snd_queuelen = 0;
 80098da:	68fb      	ldr	r3, [r7, #12]
 80098dc:	2200      	movs	r2, #0
 80098de:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
    pcb->rcv_wnd = TCP_WND;
 80098e2:	68fb      	ldr	r3, [r7, #12]
 80098e4:	f640 3268 	movw	r2, #2920	; 0xb68
 80098e8:	851a      	strh	r2, [r3, #40]	; 0x28
    pcb->rcv_ann_wnd = TCP_WND;
 80098ea:	68fb      	ldr	r3, [r7, #12]
 80098ec:	f640 3268 	movw	r2, #2920	; 0xb68
 80098f0:	855a      	strh	r2, [r3, #42]	; 0x2a
    pcb->tos = 0;
 80098f2:	68fb      	ldr	r3, [r7, #12]
 80098f4:	2200      	movs	r2, #0
 80098f6:	729a      	strb	r2, [r3, #10]
    pcb->ttl = TCP_TTL;
 80098f8:	68fb      	ldr	r3, [r7, #12]
 80098fa:	22ff      	movs	r2, #255	; 0xff
 80098fc:	72da      	strb	r2, [r3, #11]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 80098fe:	68fb      	ldr	r3, [r7, #12]
 8009900:	f44f 7206 	mov.w	r2, #536	; 0x218
 8009904:	871a      	strh	r2, [r3, #56]	; 0x38
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 8009906:	68fb      	ldr	r3, [r7, #12]
 8009908:	2206      	movs	r2, #6
 800990a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
    pcb->sa = 0;
 800990e:	68fb      	ldr	r3, [r7, #12]
 8009910:	2200      	movs	r2, #0
 8009912:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 8009916:	68fb      	ldr	r3, [r7, #12]
 8009918:	2206      	movs	r2, #6
 800991a:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
    pcb->rtime = -1;
 800991e:	68fb      	ldr	r3, [r7, #12]
 8009920:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009924:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->cwnd = 1;
 8009926:	68fb      	ldr	r3, [r7, #12]
 8009928:	2201      	movs	r2, #1
 800992a:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    iss = tcp_next_iss();
 800992e:	f000 f91f 	bl	8009b70 <tcp_next_iss>
 8009932:	60b8      	str	r0, [r7, #8]
    pcb->snd_wl2 = iss;
 8009934:	68fb      	ldr	r3, [r7, #12]
 8009936:	68ba      	ldr	r2, [r7, #8]
 8009938:	665a      	str	r2, [r3, #100]	; 0x64
    pcb->snd_nxt = iss;
 800993a:	68fb      	ldr	r3, [r7, #12]
 800993c:	68ba      	ldr	r2, [r7, #8]
 800993e:	659a      	str	r2, [r3, #88]	; 0x58
    pcb->lastack = iss;
 8009940:	68fb      	ldr	r3, [r7, #12]
 8009942:	68ba      	ldr	r2, [r7, #8]
 8009944:	64da      	str	r2, [r3, #76]	; 0x4c
    pcb->snd_lbb = iss;   
 8009946:	68fb      	ldr	r3, [r7, #12]
 8009948:	68ba      	ldr	r2, [r7, #8]
 800994a:	669a      	str	r2, [r3, #104]	; 0x68
    pcb->tmr = tcp_ticks;
 800994c:	4b0c      	ldr	r3, [pc, #48]	; (8009980 <tcp_alloc+0x100>)
 800994e:	681a      	ldr	r2, [r3, #0]
 8009950:	68fb      	ldr	r3, [r7, #12]
 8009952:	631a      	str	r2, [r3, #48]	; 0x30

    pcb->polltmr = 0;
 8009954:	68fb      	ldr	r3, [r7, #12]
 8009956:	2200      	movs	r2, #0
 8009958:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800995c:	68fb      	ldr	r3, [r7, #12]
 800995e:	4a09      	ldr	r2, [pc, #36]	; (8009984 <tcp_alloc+0x104>)
 8009960:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 8009964:	68fb      	ldr	r3, [r7, #12]
 8009966:	4a08      	ldr	r2, [pc, #32]	; (8009988 <tcp_alloc+0x108>)
 8009968:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 800996c:	68fb      	ldr	r3, [r7, #12]
 800996e:	2200      	movs	r2, #0
 8009970:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d
  }
  return pcb;
 8009974:	68fb      	ldr	r3, [r7, #12]
}
 8009976:	4618      	mov	r0, r3
 8009978:	3710      	adds	r7, #16
 800997a:	46bd      	mov	sp, r7
 800997c:	bd80      	pop	{r7, pc}
 800997e:	bf00      	nop
 8009980:	2000a328 	.word	0x2000a328
 8009984:	08009757 	.word	0x08009757
 8009988:	006ddd00 	.word	0x006ddd00

0800998c <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 800998c:	b580      	push	{r7, lr}
 800998e:	af00      	add	r7, sp, #0
  return tcp_alloc(TCP_PRIO_NORMAL);
 8009990:	2040      	movs	r0, #64	; 0x40
 8009992:	f7ff ff75 	bl	8009880 <tcp_alloc>
 8009996:	4603      	mov	r3, r0
}
 8009998:	4618      	mov	r0, r3
 800999a:	bd80      	pop	{r7, pc}

0800999c <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
 800999c:	b480      	push	{r7}
 800999e:	b083      	sub	sp, #12
 80099a0:	af00      	add	r7, sp, #0
 80099a2:	6078      	str	r0, [r7, #4]
 80099a4:	6039      	str	r1, [r7, #0]
  pcb->callback_arg = arg;
 80099a6:	687b      	ldr	r3, [r7, #4]
 80099a8:	683a      	ldr	r2, [r7, #0]
 80099aa:	615a      	str	r2, [r3, #20]
}
 80099ac:	bf00      	nop
 80099ae:	370c      	adds	r7, #12
 80099b0:	46bd      	mov	sp, r7
 80099b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099b6:	4770      	bx	lr

080099b8 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
 80099b8:	b480      	push	{r7}
 80099ba:	b083      	sub	sp, #12
 80099bc:	af00      	add	r7, sp, #0
 80099be:	6078      	str	r0, [r7, #4]
 80099c0:	6039      	str	r1, [r7, #0]
  pcb->recv = recv;
 80099c2:	687b      	ldr	r3, [r7, #4]
 80099c4:	683a      	ldr	r2, [r7, #0]
 80099c6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80099ca:	bf00      	nop
 80099cc:	370c      	adds	r7, #12
 80099ce:	46bd      	mov	sp, r7
 80099d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099d4:	4770      	bx	lr

080099d6 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
 80099d6:	b480      	push	{r7}
 80099d8:	b083      	sub	sp, #12
 80099da:	af00      	add	r7, sp, #0
 80099dc:	6078      	str	r0, [r7, #4]
 80099de:	6039      	str	r1, [r7, #0]
  pcb->sent = sent;
 80099e0:	687b      	ldr	r3, [r7, #4]
 80099e2:	683a      	ldr	r2, [r7, #0]
 80099e4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 80099e8:	bf00      	nop
 80099ea:	370c      	adds	r7, #12
 80099ec:	46bd      	mov	sp, r7
 80099ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099f2:	4770      	bx	lr

080099f4 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
 80099f4:	b480      	push	{r7}
 80099f6:	b083      	sub	sp, #12
 80099f8:	af00      	add	r7, sp, #0
 80099fa:	6078      	str	r0, [r7, #4]
 80099fc:	6039      	str	r1, [r7, #0]
  pcb->errf = errf;
 80099fe:	687b      	ldr	r3, [r7, #4]
 8009a00:	683a      	ldr	r2, [r7, #0]
 8009a02:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
 8009a06:	bf00      	nop
 8009a08:	370c      	adds	r7, #12
 8009a0a:	46bd      	mov	sp, r7
 8009a0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a10:	4770      	bx	lr

08009a12 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
 8009a12:	b480      	push	{r7}
 8009a14:	b083      	sub	sp, #12
 8009a16:	af00      	add	r7, sp, #0
 8009a18:	6078      	str	r0, [r7, #4]
 8009a1a:	6039      	str	r1, [r7, #0]
  pcb->accept = accept;
 8009a1c:	687b      	ldr	r3, [r7, #4]
 8009a1e:	683a      	ldr	r2, [r7, #0]
 8009a20:	61da      	str	r2, [r3, #28]
}
 8009a22:	bf00      	nop
 8009a24:	370c      	adds	r7, #12
 8009a26:	46bd      	mov	sp, r7
 8009a28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a2c:	4770      	bx	lr

08009a2e <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
 8009a2e:	b480      	push	{r7}
 8009a30:	b085      	sub	sp, #20
 8009a32:	af00      	add	r7, sp, #0
 8009a34:	60f8      	str	r0, [r7, #12]
 8009a36:	60b9      	str	r1, [r7, #8]
 8009a38:	4613      	mov	r3, r2
 8009a3a:	71fb      	strb	r3, [r7, #7]
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 8009a3c:	68fb      	ldr	r3, [r7, #12]
 8009a3e:	68ba      	ldr	r2, [r7, #8]
 8009a40:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 8009a44:	68fb      	ldr	r3, [r7, #12]
 8009a46:	79fa      	ldrb	r2, [r7, #7]
 8009a48:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
}
 8009a4c:	bf00      	nop
 8009a4e:	3714      	adds	r7, #20
 8009a50:	46bd      	mov	sp, r7
 8009a52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a56:	4770      	bx	lr

08009a58 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 8009a58:	b580      	push	{r7, lr}
 8009a5a:	b082      	sub	sp, #8
 8009a5c:	af00      	add	r7, sp, #0
 8009a5e:	6078      	str	r0, [r7, #4]
  if (pcb->state != CLOSED &&
 8009a60:	687b      	ldr	r3, [r7, #4]
 8009a62:	7c1b      	ldrb	r3, [r3, #16]
 8009a64:	2b00      	cmp	r3, #0
 8009a66:	d024      	beq.n	8009ab2 <tcp_pcb_purge+0x5a>
     pcb->state != TIME_WAIT &&
 8009a68:	687b      	ldr	r3, [r7, #4]
 8009a6a:	7c1b      	ldrb	r3, [r3, #16]
  if (pcb->state != CLOSED &&
 8009a6c:	2b0a      	cmp	r3, #10
 8009a6e:	d020      	beq.n	8009ab2 <tcp_pcb_purge+0x5a>
     pcb->state != LISTEN) {
 8009a70:	687b      	ldr	r3, [r7, #4]
 8009a72:	7c1b      	ldrb	r3, [r3, #16]
     pcb->state != TIME_WAIT &&
 8009a74:	2b01      	cmp	r3, #1
 8009a76:	d01c      	beq.n	8009ab2 <tcp_pcb_purge+0x5a>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8009a78:	687b      	ldr	r3, [r7, #4]
 8009a7a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009a7c:	2b00      	cmp	r3, #0
 8009a7e:	d007      	beq.n	8009a90 <tcp_pcb_purge+0x38>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8009a80:	687b      	ldr	r3, [r7, #4]
 8009a82:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009a84:	4618      	mov	r0, r3
 8009a86:	f7fe fe90 	bl	80087aa <pbuf_free>
      pcb->refused_data = NULL;
 8009a8a:	687b      	ldr	r3, [r7, #4]
 8009a8c:	2200      	movs	r2, #0
 8009a8e:	67da      	str	r2, [r3, #124]	; 0x7c
    pcb->rtime = -1;

    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
 8009a90:	687b      	ldr	r3, [r7, #4]
 8009a92:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009a94:	4618      	mov	r0, r3
 8009a96:	f7ff fe13 	bl	80096c0 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 8009a9a:	687b      	ldr	r3, [r7, #4]
 8009a9c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009a9e:	4618      	mov	r0, r3
 8009aa0:	f7ff fe0e 	bl	80096c0 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 8009aa4:	687b      	ldr	r3, [r7, #4]
 8009aa6:	2200      	movs	r2, #0
 8009aa8:	675a      	str	r2, [r3, #116]	; 0x74
 8009aaa:	687b      	ldr	r3, [r7, #4]
 8009aac:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8009aae:	687b      	ldr	r3, [r7, #4]
 8009ab0:	679a      	str	r2, [r3, #120]	; 0x78
  }
}
 8009ab2:	bf00      	nop
 8009ab4:	3708      	adds	r7, #8
 8009ab6:	46bd      	mov	sp, r7
 8009ab8:	bd80      	pop	{r7, pc}
	...

08009abc <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8009abc:	b580      	push	{r7, lr}
 8009abe:	b082      	sub	sp, #8
 8009ac0:	af00      	add	r7, sp, #0
 8009ac2:	6078      	str	r0, [r7, #4]
 8009ac4:	6039      	str	r1, [r7, #0]
  TCP_RMV(pcblist, pcb);
 8009ac6:	687b      	ldr	r3, [r7, #4]
 8009ac8:	681a      	ldr	r2, [r3, #0]
 8009aca:	683b      	ldr	r3, [r7, #0]
 8009acc:	429a      	cmp	r2, r3
 8009ace:	d105      	bne.n	8009adc <tcp_pcb_remove+0x20>
 8009ad0:	687b      	ldr	r3, [r7, #4]
 8009ad2:	681b      	ldr	r3, [r3, #0]
 8009ad4:	68da      	ldr	r2, [r3, #12]
 8009ad6:	687b      	ldr	r3, [r7, #4]
 8009ad8:	601a      	str	r2, [r3, #0]
 8009ada:	e019      	b.n	8009b10 <tcp_pcb_remove+0x54>
 8009adc:	687b      	ldr	r3, [r7, #4]
 8009ade:	681b      	ldr	r3, [r3, #0]
 8009ae0:	4a22      	ldr	r2, [pc, #136]	; (8009b6c <tcp_pcb_remove+0xb0>)
 8009ae2:	6013      	str	r3, [r2, #0]
 8009ae4:	e010      	b.n	8009b08 <tcp_pcb_remove+0x4c>
 8009ae6:	4b21      	ldr	r3, [pc, #132]	; (8009b6c <tcp_pcb_remove+0xb0>)
 8009ae8:	681b      	ldr	r3, [r3, #0]
 8009aea:	68da      	ldr	r2, [r3, #12]
 8009aec:	683b      	ldr	r3, [r7, #0]
 8009aee:	429a      	cmp	r2, r3
 8009af0:	d105      	bne.n	8009afe <tcp_pcb_remove+0x42>
 8009af2:	4b1e      	ldr	r3, [pc, #120]	; (8009b6c <tcp_pcb_remove+0xb0>)
 8009af4:	681b      	ldr	r3, [r3, #0]
 8009af6:	683a      	ldr	r2, [r7, #0]
 8009af8:	68d2      	ldr	r2, [r2, #12]
 8009afa:	60da      	str	r2, [r3, #12]
 8009afc:	e008      	b.n	8009b10 <tcp_pcb_remove+0x54>
 8009afe:	4b1b      	ldr	r3, [pc, #108]	; (8009b6c <tcp_pcb_remove+0xb0>)
 8009b00:	681b      	ldr	r3, [r3, #0]
 8009b02:	68db      	ldr	r3, [r3, #12]
 8009b04:	4a19      	ldr	r2, [pc, #100]	; (8009b6c <tcp_pcb_remove+0xb0>)
 8009b06:	6013      	str	r3, [r2, #0]
 8009b08:	4b18      	ldr	r3, [pc, #96]	; (8009b6c <tcp_pcb_remove+0xb0>)
 8009b0a:	681b      	ldr	r3, [r3, #0]
 8009b0c:	2b00      	cmp	r3, #0
 8009b0e:	d1ea      	bne.n	8009ae6 <tcp_pcb_remove+0x2a>
 8009b10:	683b      	ldr	r3, [r7, #0]
 8009b12:	2200      	movs	r2, #0
 8009b14:	60da      	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
 8009b16:	6838      	ldr	r0, [r7, #0]
 8009b18:	f7ff ff9e 	bl	8009a58 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8009b1c:	683b      	ldr	r3, [r7, #0]
 8009b1e:	7c1b      	ldrb	r3, [r3, #16]
 8009b20:	2b0a      	cmp	r3, #10
 8009b22:	d016      	beq.n	8009b52 <tcp_pcb_remove+0x96>
     pcb->state != LISTEN &&
 8009b24:	683b      	ldr	r3, [r7, #0]
 8009b26:	7c1b      	ldrb	r3, [r3, #16]
  if (pcb->state != TIME_WAIT &&
 8009b28:	2b01      	cmp	r3, #1
 8009b2a:	d012      	beq.n	8009b52 <tcp_pcb_remove+0x96>
     pcb->flags & TF_ACK_DELAY) {
 8009b2c:	683b      	ldr	r3, [r7, #0]
 8009b2e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8009b32:	f003 0301 	and.w	r3, r3, #1
     pcb->state != LISTEN &&
 8009b36:	2b00      	cmp	r3, #0
 8009b38:	d00b      	beq.n	8009b52 <tcp_pcb_remove+0x96>
    pcb->flags |= TF_ACK_NOW;
 8009b3a:	683b      	ldr	r3, [r7, #0]
 8009b3c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8009b40:	f043 0302 	orr.w	r3, r3, #2
 8009b44:	b2da      	uxtb	r2, r3
 8009b46:	683b      	ldr	r3, [r7, #0]
 8009b48:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    tcp_output(pcb);
 8009b4c:	6838      	ldr	r0, [r7, #0]
 8009b4e:	f002 f8fd 	bl	800bd4c <tcp_output>
  }

  if (pcb->state != LISTEN) {
 8009b52:	683b      	ldr	r3, [r7, #0]
 8009b54:	7c1b      	ldrb	r3, [r3, #16]
 8009b56:	2b01      	cmp	r3, #1
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8009b58:	683b      	ldr	r3, [r7, #0]
 8009b5a:	2200      	movs	r2, #0
 8009b5c:	741a      	strb	r2, [r3, #16]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
 8009b5e:	f000 f867 	bl	8009c30 <tcp_pcbs_sane>
}
 8009b62:	bf00      	nop
 8009b64:	3708      	adds	r7, #8
 8009b66:	46bd      	mov	sp, r7
 8009b68:	bd80      	pop	{r7, pc}
 8009b6a:	bf00      	nop
 8009b6c:	2000a330 	.word	0x2000a330

08009b70 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
 8009b70:	b480      	push	{r7}
 8009b72:	af00      	add	r7, sp, #0
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 8009b74:	4b06      	ldr	r3, [pc, #24]	; (8009b90 <tcp_next_iss+0x20>)
 8009b76:	681a      	ldr	r2, [r3, #0]
 8009b78:	4b06      	ldr	r3, [pc, #24]	; (8009b94 <tcp_next_iss+0x24>)
 8009b7a:	681b      	ldr	r3, [r3, #0]
 8009b7c:	4413      	add	r3, r2
 8009b7e:	4a04      	ldr	r2, [pc, #16]	; (8009b90 <tcp_next_iss+0x20>)
 8009b80:	6013      	str	r3, [r2, #0]
  return iss;
 8009b82:	4b03      	ldr	r3, [pc, #12]	; (8009b90 <tcp_next_iss+0x20>)
 8009b84:	681b      	ldr	r3, [r3, #0]
}
 8009b86:	4618      	mov	r0, r3
 8009b88:	46bd      	mov	sp, r7
 8009b8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b8e:	4770      	bx	lr
 8009b90:	20000044 	.word	0x20000044
 8009b94:	2000a328 	.word	0x2000a328

08009b98 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
 8009b98:	b580      	push	{r7, lr}
 8009b9a:	b084      	sub	sp, #16
 8009b9c:	af00      	add	r7, sp, #0
 8009b9e:	4603      	mov	r3, r0
 8009ba0:	6039      	str	r1, [r7, #0]
 8009ba2:	80fb      	strh	r3, [r7, #6]
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 8009ba4:	6838      	ldr	r0, [r7, #0]
 8009ba6:	f7fd f951 	bl	8006e4c <ip_route>
 8009baa:	60f8      	str	r0, [r7, #12]
  if ((outif != NULL) && (outif->mtu != 0)) {
 8009bac:	68fb      	ldr	r3, [r7, #12]
 8009bae:	2b00      	cmp	r3, #0
 8009bb0:	d00d      	beq.n	8009bce <tcp_eff_send_mss+0x36>
 8009bb2:	68fb      	ldr	r3, [r7, #12]
 8009bb4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8009bb6:	2b00      	cmp	r3, #0
 8009bb8:	d009      	beq.n	8009bce <tcp_eff_send_mss+0x36>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 8009bba:	68fb      	ldr	r3, [r7, #12]
 8009bbc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8009bbe:	3b28      	subs	r3, #40	; 0x28
 8009bc0:	817b      	strh	r3, [r7, #10]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_enqueue(), and don't support
     * IP options
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 8009bc2:	897a      	ldrh	r2, [r7, #10]
 8009bc4:	88fb      	ldrh	r3, [r7, #6]
 8009bc6:	4293      	cmp	r3, r2
 8009bc8:	bf28      	it	cs
 8009bca:	4613      	movcs	r3, r2
 8009bcc:	80fb      	strh	r3, [r7, #6]
  }
  return sendmss;
 8009bce:	88fb      	ldrh	r3, [r7, #6]
}
 8009bd0:	4618      	mov	r0, r3
 8009bd2:	3710      	adds	r7, #16
 8009bd4:	46bd      	mov	sp, r7
 8009bd6:	bd80      	pop	{r7, pc}

08009bd8 <tcp_debug_print>:
 *
 * @param tcphdr pointer to a struct tcp_hdr
 */
void
tcp_debug_print(struct tcp_hdr *tcphdr)
{
 8009bd8:	b580      	push	{r7, lr}
 8009bda:	b082      	sub	sp, #8
 8009bdc:	af00      	add	r7, sp, #0
 8009bde:	6078      	str	r0, [r7, #4]
         TCPH_FLAGS(tcphdr) >> 3 & 1,
         TCPH_FLAGS(tcphdr) >> 2 & 1,
         TCPH_FLAGS(tcphdr) >> 1 & 1,
         TCPH_FLAGS(tcphdr) & 1,
         ntohs(tcphdr->wnd)));
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
 8009be0:	687b      	ldr	r3, [r7, #4]
 8009be2:	899b      	ldrh	r3, [r3, #12]
 8009be4:	b29b      	uxth	r3, r3
 8009be6:	4618      	mov	r0, r3
 8009be8:	f7fd f853 	bl	8006c92 <ntohs>
 8009bec:	4603      	mov	r3, r0
 8009bee:	b2db      	uxtb	r3, r3
 8009bf0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009bf4:	b2db      	uxtb	r3, r3
 8009bf6:	4618      	mov	r0, r3
 8009bf8:	f000 f80f 	bl	8009c1a <tcp_debug_print_flags>
  LWIP_DEBUGF(TCP_DEBUG, ("), win)\n"));
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
  LWIP_DEBUGF(TCP_DEBUG, ("|    0x%04"X16_F"     |     %5"U16_F"     | (chksum, urgp)\n",
         ntohs(tcphdr->chksum), ntohs(tcphdr->urgp)));
  LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
}
 8009bfc:	bf00      	nop
 8009bfe:	3708      	adds	r7, #8
 8009c00:	46bd      	mov	sp, r7
 8009c02:	bd80      	pop	{r7, pc}

08009c04 <tcp_debug_print_state>:
 *
 * @param s enum tcp_state to print
 */
void
tcp_debug_print_state(enum tcp_state s)
{
 8009c04:	b480      	push	{r7}
 8009c06:	b083      	sub	sp, #12
 8009c08:	af00      	add	r7, sp, #0
 8009c0a:	4603      	mov	r3, r0
 8009c0c:	71fb      	strb	r3, [r7, #7]
  LWIP_DEBUGF(TCP_DEBUG, ("State: %s\n", tcp_state_str[s]));
}
 8009c0e:	bf00      	nop
 8009c10:	370c      	adds	r7, #12
 8009c12:	46bd      	mov	sp, r7
 8009c14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c18:	4770      	bx	lr

08009c1a <tcp_debug_print_flags>:
 *
 * @param flags tcp flags, all active flags are printed
 */
void
tcp_debug_print_flags(u8_t flags)
{
 8009c1a:	b480      	push	{r7}
 8009c1c:	b083      	sub	sp, #12
 8009c1e:	af00      	add	r7, sp, #0
 8009c20:	4603      	mov	r3, r0
 8009c22:	71fb      	strb	r3, [r7, #7]
  }
  if (flags & TCP_CWR) {
    LWIP_DEBUGF(TCP_DEBUG, ("CWR "));
  }
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));
}
 8009c24:	bf00      	nop
 8009c26:	370c      	adds	r7, #12
 8009c28:	46bd      	mov	sp, r7
 8009c2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c2e:	4770      	bx	lr

08009c30 <tcp_pcbs_sane>:
/**
 * Check state consistency of the tcp_pcb lists.
 */
s16_t
tcp_pcbs_sane(void)
{
 8009c30:	b480      	push	{r7}
 8009c32:	b083      	sub	sp, #12
 8009c34:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8009c36:	4b0d      	ldr	r3, [pc, #52]	; (8009c6c <tcp_pcbs_sane+0x3c>)
 8009c38:	681b      	ldr	r3, [r3, #0]
 8009c3a:	607b      	str	r3, [r7, #4]
 8009c3c:	e002      	b.n	8009c44 <tcp_pcbs_sane+0x14>
 8009c3e:	687b      	ldr	r3, [r7, #4]
 8009c40:	68db      	ldr	r3, [r3, #12]
 8009c42:	607b      	str	r3, [r7, #4]
 8009c44:	687b      	ldr	r3, [r7, #4]
 8009c46:	2b00      	cmp	r3, #0
 8009c48:	d1f9      	bne.n	8009c3e <tcp_pcbs_sane+0xe>
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != LISTEN", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8009c4a:	4b09      	ldr	r3, [pc, #36]	; (8009c70 <tcp_pcbs_sane+0x40>)
 8009c4c:	681b      	ldr	r3, [r3, #0]
 8009c4e:	607b      	str	r3, [r7, #4]
 8009c50:	e002      	b.n	8009c58 <tcp_pcbs_sane+0x28>
 8009c52:	687b      	ldr	r3, [r7, #4]
 8009c54:	68db      	ldr	r3, [r3, #12]
 8009c56:	607b      	str	r3, [r7, #4]
 8009c58:	687b      	ldr	r3, [r7, #4]
 8009c5a:	2b00      	cmp	r3, #0
 8009c5c:	d1f9      	bne.n	8009c52 <tcp_pcbs_sane+0x22>
    LWIP_ASSERT("tcp_pcbs_sane: tw pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  }
  return 1;
 8009c5e:	2301      	movs	r3, #1
}
 8009c60:	4618      	mov	r0, r3
 8009c62:	370c      	adds	r7, #12
 8009c64:	46bd      	mov	sp, r7
 8009c66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c6a:	4770      	bx	lr
 8009c6c:	2000a324 	.word	0x2000a324
 8009c70:	2000a338 	.word	0x2000a338

08009c74 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8009c74:	b5b0      	push	{r4, r5, r7, lr}
 8009c76:	b088      	sub	sp, #32
 8009c78:	af02      	add	r7, sp, #8
 8009c7a:	6078      	str	r0, [r7, #4]
 8009c7c:	6039      	str	r1, [r7, #0]
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
 8009c7e:	687b      	ldr	r3, [r7, #4]
 8009c80:	685b      	ldr	r3, [r3, #4]
 8009c82:	4aa2      	ldr	r2, [pc, #648]	; (8009f0c <tcp_input+0x298>)
 8009c84:	6013      	str	r3, [r2, #0]
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8009c86:	687b      	ldr	r3, [r7, #4]
 8009c88:	685c      	ldr	r4, [r3, #4]
 8009c8a:	4ba0      	ldr	r3, [pc, #640]	; (8009f0c <tcp_input+0x298>)
 8009c8c:	681b      	ldr	r3, [r3, #0]
 8009c8e:	881b      	ldrh	r3, [r3, #0]
 8009c90:	b29b      	uxth	r3, r3
 8009c92:	4618      	mov	r0, r3
 8009c94:	f7fc fffd 	bl	8006c92 <ntohs>
 8009c98:	4603      	mov	r3, r0
 8009c9a:	0a1b      	lsrs	r3, r3, #8
 8009c9c:	b29b      	uxth	r3, r3
 8009c9e:	f003 030f 	and.w	r3, r3, #15
 8009ca2:	009b      	lsls	r3, r3, #2
 8009ca4:	4423      	add	r3, r4
 8009ca6:	4a9a      	ldr	r2, [pc, #616]	; (8009f10 <tcp_input+0x29c>)
 8009ca8:	6013      	str	r3, [r2, #0]

#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
 8009caa:	4b99      	ldr	r3, [pc, #612]	; (8009f10 <tcp_input+0x29c>)
 8009cac:	681b      	ldr	r3, [r3, #0]
 8009cae:	4618      	mov	r0, r3
 8009cb0:	f7ff ff92 	bl	8009bd8 <tcp_debug_print>
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8009cb4:	4b95      	ldr	r3, [pc, #596]	; (8009f0c <tcp_input+0x298>)
 8009cb6:	681b      	ldr	r3, [r3, #0]
 8009cb8:	881b      	ldrh	r3, [r3, #0]
 8009cba:	b29b      	uxth	r3, r3
 8009cbc:	4618      	mov	r0, r3
 8009cbe:	f7fc ffe8 	bl	8006c92 <ntohs>
 8009cc2:	4603      	mov	r3, r0
 8009cc4:	0a1b      	lsrs	r3, r3, #8
 8009cc6:	b29b      	uxth	r3, r3
 8009cc8:	f003 030f 	and.w	r3, r3, #15
 8009ccc:	b29b      	uxth	r3, r3
 8009cce:	009b      	lsls	r3, r3, #2
 8009cd0:	b29b      	uxth	r3, r3
 8009cd2:	425b      	negs	r3, r3
 8009cd4:	b29b      	uxth	r3, r3
 8009cd6:	b21b      	sxth	r3, r3
 8009cd8:	4619      	mov	r1, r3
 8009cda:	6878      	ldr	r0, [r7, #4]
 8009cdc:	f7fe fcf6 	bl	80086cc <pbuf_header>
 8009ce0:	4603      	mov	r3, r0
 8009ce2:	2b00      	cmp	r3, #0
 8009ce4:	d103      	bne.n	8009cee <tcp_input+0x7a>
 8009ce6:	687b      	ldr	r3, [r7, #4]
 8009ce8:	891b      	ldrh	r3, [r3, #8]
 8009cea:	2b13      	cmp	r3, #19
 8009cec:	d803      	bhi.n	8009cf6 <tcp_input+0x82>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
 8009cee:	6878      	ldr	r0, [r7, #4]
 8009cf0:	f7fe fd5b 	bl	80087aa <pbuf_free>
    return;
 8009cf4:	e2b1      	b.n	800a25a <tcp_input+0x5e6>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
 8009cf6:	4b85      	ldr	r3, [pc, #532]	; (8009f0c <tcp_input+0x298>)
 8009cf8:	681b      	ldr	r3, [r3, #0]
 8009cfa:	3310      	adds	r3, #16
 8009cfc:	6839      	ldr	r1, [r7, #0]
 8009cfe:	4618      	mov	r0, r3
 8009d00:	f7fd fb1d 	bl	800733e <ip_addr_isbroadcast>
 8009d04:	4603      	mov	r3, r0
 8009d06:	2b00      	cmp	r3, #0
 8009d08:	d10f      	bne.n	8009d2a <tcp_input+0xb6>
      ip_addr_ismulticast(&(iphdr->dest))) {
 8009d0a:	4b80      	ldr	r3, [pc, #512]	; (8009f0c <tcp_input+0x298>)
 8009d0c:	681b      	ldr	r3, [r3, #0]
 8009d0e:	691c      	ldr	r4, [r3, #16]
 8009d10:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8009d14:	f7fc ffe4 	bl	8006ce0 <ntohl>
 8009d18:	4603      	mov	r3, r0
 8009d1a:	401c      	ands	r4, r3
 8009d1c:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8009d20:	f7fc ffde 	bl	8006ce0 <ntohl>
 8009d24:	4603      	mov	r3, r0
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
 8009d26:	429c      	cmp	r4, r3
 8009d28:	d103      	bne.n	8009d32 <tcp_input+0xbe>
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
 8009d2a:	6878      	ldr	r0, [r7, #4]
 8009d2c:	f7fe fd3d 	bl	80087aa <pbuf_free>
    return;
 8009d30:	e293      	b.n	800a25a <tcp_input+0x5e6>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
 8009d32:	4b77      	ldr	r3, [pc, #476]	; (8009f10 <tcp_input+0x29c>)
 8009d34:	681b      	ldr	r3, [r3, #0]
 8009d36:	899b      	ldrh	r3, [r3, #12]
 8009d38:	b29b      	uxth	r3, r3
 8009d3a:	4618      	mov	r0, r3
 8009d3c:	f7fc ffa9 	bl	8006c92 <ntohs>
 8009d40:	4603      	mov	r3, r0
 8009d42:	0b1b      	lsrs	r3, r3, #12
 8009d44:	b29b      	uxth	r3, r3
 8009d46:	72bb      	strb	r3, [r7, #10]
  if(pbuf_header(p, -(hdrlen * 4))){
 8009d48:	7abb      	ldrb	r3, [r7, #10]
 8009d4a:	b29b      	uxth	r3, r3
 8009d4c:	461a      	mov	r2, r3
 8009d4e:	0392      	lsls	r2, r2, #14
 8009d50:	1ad3      	subs	r3, r2, r3
 8009d52:	009b      	lsls	r3, r3, #2
 8009d54:	b29b      	uxth	r3, r3
 8009d56:	b21b      	sxth	r3, r3
 8009d58:	4619      	mov	r1, r3
 8009d5a:	6878      	ldr	r0, [r7, #4]
 8009d5c:	f7fe fcb6 	bl	80086cc <pbuf_header>
 8009d60:	4603      	mov	r3, r0
 8009d62:	2b00      	cmp	r3, #0
 8009d64:	d003      	beq.n	8009d6e <tcp_input+0xfa>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
 8009d66:	6878      	ldr	r0, [r7, #4]
 8009d68:	f7fe fd1f 	bl	80087aa <pbuf_free>
    return;
 8009d6c:	e275      	b.n	800a25a <tcp_input+0x5e6>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 8009d6e:	4b68      	ldr	r3, [pc, #416]	; (8009f10 <tcp_input+0x29c>)
 8009d70:	681c      	ldr	r4, [r3, #0]
 8009d72:	4b67      	ldr	r3, [pc, #412]	; (8009f10 <tcp_input+0x29c>)
 8009d74:	681b      	ldr	r3, [r3, #0]
 8009d76:	881b      	ldrh	r3, [r3, #0]
 8009d78:	b29b      	uxth	r3, r3
 8009d7a:	4618      	mov	r0, r3
 8009d7c:	f7fc ff89 	bl	8006c92 <ntohs>
 8009d80:	4603      	mov	r3, r0
 8009d82:	8023      	strh	r3, [r4, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 8009d84:	4b62      	ldr	r3, [pc, #392]	; (8009f10 <tcp_input+0x29c>)
 8009d86:	681c      	ldr	r4, [r3, #0]
 8009d88:	4b61      	ldr	r3, [pc, #388]	; (8009f10 <tcp_input+0x29c>)
 8009d8a:	681b      	ldr	r3, [r3, #0]
 8009d8c:	885b      	ldrh	r3, [r3, #2]
 8009d8e:	b29b      	uxth	r3, r3
 8009d90:	4618      	mov	r0, r3
 8009d92:	f7fc ff7e 	bl	8006c92 <ntohs>
 8009d96:	4603      	mov	r3, r0
 8009d98:	8063      	strh	r3, [r4, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8009d9a:	4b5d      	ldr	r3, [pc, #372]	; (8009f10 <tcp_input+0x29c>)
 8009d9c:	681c      	ldr	r4, [r3, #0]
 8009d9e:	4b5c      	ldr	r3, [pc, #368]	; (8009f10 <tcp_input+0x29c>)
 8009da0:	681b      	ldr	r3, [r3, #0]
 8009da2:	685b      	ldr	r3, [r3, #4]
 8009da4:	4618      	mov	r0, r3
 8009da6:	f7fc ff9b 	bl	8006ce0 <ntohl>
 8009daa:	4603      	mov	r3, r0
 8009dac:	6063      	str	r3, [r4, #4]
 8009dae:	6863      	ldr	r3, [r4, #4]
 8009db0:	4a58      	ldr	r2, [pc, #352]	; (8009f14 <tcp_input+0x2a0>)
 8009db2:	6013      	str	r3, [r2, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8009db4:	4b56      	ldr	r3, [pc, #344]	; (8009f10 <tcp_input+0x29c>)
 8009db6:	681c      	ldr	r4, [r3, #0]
 8009db8:	4b55      	ldr	r3, [pc, #340]	; (8009f10 <tcp_input+0x29c>)
 8009dba:	681b      	ldr	r3, [r3, #0]
 8009dbc:	689b      	ldr	r3, [r3, #8]
 8009dbe:	4618      	mov	r0, r3
 8009dc0:	f7fc ff8e 	bl	8006ce0 <ntohl>
 8009dc4:	4603      	mov	r3, r0
 8009dc6:	60a3      	str	r3, [r4, #8]
 8009dc8:	68a3      	ldr	r3, [r4, #8]
 8009dca:	4a53      	ldr	r2, [pc, #332]	; (8009f18 <tcp_input+0x2a4>)
 8009dcc:	6013      	str	r3, [r2, #0]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8009dce:	4b50      	ldr	r3, [pc, #320]	; (8009f10 <tcp_input+0x29c>)
 8009dd0:	681c      	ldr	r4, [r3, #0]
 8009dd2:	4b4f      	ldr	r3, [pc, #316]	; (8009f10 <tcp_input+0x29c>)
 8009dd4:	681b      	ldr	r3, [r3, #0]
 8009dd6:	89db      	ldrh	r3, [r3, #14]
 8009dd8:	b29b      	uxth	r3, r3
 8009dda:	4618      	mov	r0, r3
 8009ddc:	f7fc ff59 	bl	8006c92 <ntohs>
 8009de0:	4603      	mov	r3, r0
 8009de2:	81e3      	strh	r3, [r4, #14]

  flags = TCPH_FLAGS(tcphdr);
 8009de4:	4b4a      	ldr	r3, [pc, #296]	; (8009f10 <tcp_input+0x29c>)
 8009de6:	681b      	ldr	r3, [r3, #0]
 8009de8:	899b      	ldrh	r3, [r3, #12]
 8009dea:	b29b      	uxth	r3, r3
 8009dec:	4618      	mov	r0, r3
 8009dee:	f7fc ff50 	bl	8006c92 <ntohs>
 8009df2:	4603      	mov	r3, r0
 8009df4:	b2db      	uxtb	r3, r3
 8009df6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009dfa:	b2da      	uxtb	r2, r3
 8009dfc:	4b47      	ldr	r3, [pc, #284]	; (8009f1c <tcp_input+0x2a8>)
 8009dfe:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8009e00:	687b      	ldr	r3, [r7, #4]
 8009e02:	891a      	ldrh	r2, [r3, #8]
 8009e04:	4b45      	ldr	r3, [pc, #276]	; (8009f1c <tcp_input+0x2a8>)
 8009e06:	781b      	ldrb	r3, [r3, #0]
 8009e08:	f003 0303 	and.w	r3, r3, #3
 8009e0c:	2b00      	cmp	r3, #0
 8009e0e:	bf14      	ite	ne
 8009e10:	2301      	movne	r3, #1
 8009e12:	2300      	moveq	r3, #0
 8009e14:	b2db      	uxtb	r3, r3
 8009e16:	b29b      	uxth	r3, r3
 8009e18:	4413      	add	r3, r2
 8009e1a:	b29a      	uxth	r2, r3
 8009e1c:	4b40      	ldr	r3, [pc, #256]	; (8009f20 <tcp_input+0x2ac>)
 8009e1e:	801a      	strh	r2, [r3, #0]

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 8009e20:	2300      	movs	r3, #0
 8009e22:	613b      	str	r3, [r7, #16]

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8009e24:	4b3f      	ldr	r3, [pc, #252]	; (8009f24 <tcp_input+0x2b0>)
 8009e26:	681b      	ldr	r3, [r3, #0]
 8009e28:	617b      	str	r3, [r7, #20]
 8009e2a:	e031      	b.n	8009e90 <tcp_input+0x21c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 8009e2c:	697b      	ldr	r3, [r7, #20]
 8009e2e:	8c1a      	ldrh	r2, [r3, #32]
 8009e30:	4b37      	ldr	r3, [pc, #220]	; (8009f10 <tcp_input+0x29c>)
 8009e32:	681b      	ldr	r3, [r3, #0]
 8009e34:	881b      	ldrh	r3, [r3, #0]
 8009e36:	b29b      	uxth	r3, r3
 8009e38:	429a      	cmp	r2, r3
 8009e3a:	d124      	bne.n	8009e86 <tcp_input+0x212>
       pcb->local_port == tcphdr->dest &&
 8009e3c:	697b      	ldr	r3, [r7, #20]
 8009e3e:	8b1a      	ldrh	r2, [r3, #24]
 8009e40:	4b33      	ldr	r3, [pc, #204]	; (8009f10 <tcp_input+0x29c>)
 8009e42:	681b      	ldr	r3, [r3, #0]
 8009e44:	885b      	ldrh	r3, [r3, #2]
 8009e46:	b29b      	uxth	r3, r3
    if (pcb->remote_port == tcphdr->src &&
 8009e48:	429a      	cmp	r2, r3
 8009e4a:	d11c      	bne.n	8009e86 <tcp_input+0x212>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8009e4c:	697b      	ldr	r3, [r7, #20]
 8009e4e:	685a      	ldr	r2, [r3, #4]
 8009e50:	4b2e      	ldr	r3, [pc, #184]	; (8009f0c <tcp_input+0x298>)
 8009e52:	681b      	ldr	r3, [r3, #0]
 8009e54:	68db      	ldr	r3, [r3, #12]
       pcb->local_port == tcphdr->dest &&
 8009e56:	429a      	cmp	r2, r3
 8009e58:	d115      	bne.n	8009e86 <tcp_input+0x212>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
 8009e5a:	697b      	ldr	r3, [r7, #20]
 8009e5c:	681a      	ldr	r2, [r3, #0]
 8009e5e:	4b2b      	ldr	r3, [pc, #172]	; (8009f0c <tcp_input+0x298>)
 8009e60:	681b      	ldr	r3, [r3, #0]
 8009e62:	691b      	ldr	r3, [r3, #16]
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8009e64:	429a      	cmp	r2, r3
 8009e66:	d10e      	bne.n	8009e86 <tcp_input+0x212>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
 8009e68:	693b      	ldr	r3, [r7, #16]
 8009e6a:	2b00      	cmp	r3, #0
 8009e6c:	d014      	beq.n	8009e98 <tcp_input+0x224>
        prev->next = pcb->next;
 8009e6e:	697b      	ldr	r3, [r7, #20]
 8009e70:	68da      	ldr	r2, [r3, #12]
 8009e72:	693b      	ldr	r3, [r7, #16]
 8009e74:	60da      	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
 8009e76:	4b2b      	ldr	r3, [pc, #172]	; (8009f24 <tcp_input+0x2b0>)
 8009e78:	681a      	ldr	r2, [r3, #0]
 8009e7a:	697b      	ldr	r3, [r7, #20]
 8009e7c:	60da      	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
 8009e7e:	4a29      	ldr	r2, [pc, #164]	; (8009f24 <tcp_input+0x2b0>)
 8009e80:	697b      	ldr	r3, [r7, #20]
 8009e82:	6013      	str	r3, [r2, #0]
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 8009e84:	e008      	b.n	8009e98 <tcp_input+0x224>
    }
    prev = pcb;
 8009e86:	697b      	ldr	r3, [r7, #20]
 8009e88:	613b      	str	r3, [r7, #16]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8009e8a:	697b      	ldr	r3, [r7, #20]
 8009e8c:	68db      	ldr	r3, [r3, #12]
 8009e8e:	617b      	str	r3, [r7, #20]
 8009e90:	697b      	ldr	r3, [r7, #20]
 8009e92:	2b00      	cmp	r3, #0
 8009e94:	d1ca      	bne.n	8009e2c <tcp_input+0x1b8>
 8009e96:	e000      	b.n	8009e9a <tcp_input+0x226>
      break;
 8009e98:	bf00      	nop
  }

  if (pcb == NULL) {
 8009e9a:	697b      	ldr	r3, [r7, #20]
 8009e9c:	2b00      	cmp	r3, #0
 8009e9e:	d17a      	bne.n	8009f96 <tcp_input+0x322>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8009ea0:	4b21      	ldr	r3, [pc, #132]	; (8009f28 <tcp_input+0x2b4>)
 8009ea2:	681b      	ldr	r3, [r3, #0]
 8009ea4:	617b      	str	r3, [r7, #20]
 8009ea6:	e027      	b.n	8009ef8 <tcp_input+0x284>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 8009ea8:	697b      	ldr	r3, [r7, #20]
 8009eaa:	8c1a      	ldrh	r2, [r3, #32]
 8009eac:	4b18      	ldr	r3, [pc, #96]	; (8009f10 <tcp_input+0x29c>)
 8009eae:	681b      	ldr	r3, [r3, #0]
 8009eb0:	881b      	ldrh	r3, [r3, #0]
 8009eb2:	b29b      	uxth	r3, r3
 8009eb4:	429a      	cmp	r2, r3
 8009eb6:	d11c      	bne.n	8009ef2 <tcp_input+0x27e>
         pcb->local_port == tcphdr->dest &&
 8009eb8:	697b      	ldr	r3, [r7, #20]
 8009eba:	8b1a      	ldrh	r2, [r3, #24]
 8009ebc:	4b14      	ldr	r3, [pc, #80]	; (8009f10 <tcp_input+0x29c>)
 8009ebe:	681b      	ldr	r3, [r3, #0]
 8009ec0:	885b      	ldrh	r3, [r3, #2]
 8009ec2:	b29b      	uxth	r3, r3
      if (pcb->remote_port == tcphdr->src &&
 8009ec4:	429a      	cmp	r2, r3
 8009ec6:	d114      	bne.n	8009ef2 <tcp_input+0x27e>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8009ec8:	697b      	ldr	r3, [r7, #20]
 8009eca:	685a      	ldr	r2, [r3, #4]
 8009ecc:	4b0f      	ldr	r3, [pc, #60]	; (8009f0c <tcp_input+0x298>)
 8009ece:	681b      	ldr	r3, [r3, #0]
 8009ed0:	68db      	ldr	r3, [r3, #12]
         pcb->local_port == tcphdr->dest &&
 8009ed2:	429a      	cmp	r2, r3
 8009ed4:	d10d      	bne.n	8009ef2 <tcp_input+0x27e>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
 8009ed6:	697b      	ldr	r3, [r7, #20]
 8009ed8:	681a      	ldr	r2, [r3, #0]
 8009eda:	4b0c      	ldr	r3, [pc, #48]	; (8009f0c <tcp_input+0x298>)
 8009edc:	681b      	ldr	r3, [r3, #0]
 8009ede:	691b      	ldr	r3, [r3, #16]
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8009ee0:	429a      	cmp	r2, r3
 8009ee2:	d106      	bne.n	8009ef2 <tcp_input+0x27e>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
 8009ee4:	6978      	ldr	r0, [r7, #20]
 8009ee6:	f000 fa89 	bl	800a3fc <tcp_timewait_input>
        pbuf_free(p);
 8009eea:	6878      	ldr	r0, [r7, #4]
 8009eec:	f7fe fc5d 	bl	80087aa <pbuf_free>
        return;
 8009ef0:	e1b3      	b.n	800a25a <tcp_input+0x5e6>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8009ef2:	697b      	ldr	r3, [r7, #20]
 8009ef4:	68db      	ldr	r3, [r3, #12]
 8009ef6:	617b      	str	r3, [r7, #20]
 8009ef8:	697b      	ldr	r3, [r7, #20]
 8009efa:	2b00      	cmp	r3, #0
 8009efc:	d1d4      	bne.n	8009ea8 <tcp_input+0x234>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
 8009efe:	2300      	movs	r3, #0
 8009f00:	613b      	str	r3, [r7, #16]
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8009f02:	4b0a      	ldr	r3, [pc, #40]	; (8009f2c <tcp_input+0x2b8>)
 8009f04:	681b      	ldr	r3, [r3, #0]
 8009f06:	60fb      	str	r3, [r7, #12]
 8009f08:	e042      	b.n	8009f90 <tcp_input+0x31c>
 8009f0a:	bf00      	nop
 8009f0c:	20007c50 	.word	0x20007c50
 8009f10:	20007c4c 	.word	0x20007c4c
 8009f14:	20007c54 	.word	0x20007c54
 8009f18:	20007c58 	.word	0x20007c58
 8009f1c:	20007c5c 	.word	0x20007c5c
 8009f20:	20007c5e 	.word	0x20007c5e
 8009f24:	2000a324 	.word	0x2000a324
 8009f28:	2000a338 	.word	0x2000a338
 8009f2c:	2000a32c 	.word	0x2000a32c
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
 8009f30:	68fb      	ldr	r3, [r7, #12]
 8009f32:	2b00      	cmp	r3, #0
 8009f34:	d00a      	beq.n	8009f4c <tcp_input+0x2d8>
 8009f36:	68fb      	ldr	r3, [r7, #12]
 8009f38:	681b      	ldr	r3, [r3, #0]
 8009f3a:	2b00      	cmp	r3, #0
 8009f3c:	d006      	beq.n	8009f4c <tcp_input+0x2d8>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
 8009f3e:	68fb      	ldr	r3, [r7, #12]
 8009f40:	681a      	ldr	r2, [r3, #0]
 8009f42:	4ba5      	ldr	r3, [pc, #660]	; (800a1d8 <tcp_input+0x564>)
 8009f44:	681b      	ldr	r3, [r3, #0]
 8009f46:	691b      	ldr	r3, [r3, #16]
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
 8009f48:	429a      	cmp	r2, r3
 8009f4a:	d11c      	bne.n	8009f86 <tcp_input+0x312>
        lpcb->local_port == tcphdr->dest) {
 8009f4c:	68fb      	ldr	r3, [r7, #12]
 8009f4e:	8b1a      	ldrh	r2, [r3, #24]
 8009f50:	4ba2      	ldr	r3, [pc, #648]	; (800a1dc <tcp_input+0x568>)
 8009f52:	681b      	ldr	r3, [r3, #0]
 8009f54:	885b      	ldrh	r3, [r3, #2]
 8009f56:	b29b      	uxth	r3, r3
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
 8009f58:	429a      	cmp	r2, r3
 8009f5a:	d114      	bne.n	8009f86 <tcp_input+0x312>
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
 8009f5c:	693b      	ldr	r3, [r7, #16]
 8009f5e:	2b00      	cmp	r3, #0
 8009f60:	d00a      	beq.n	8009f78 <tcp_input+0x304>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8009f62:	68fb      	ldr	r3, [r7, #12]
 8009f64:	68da      	ldr	r2, [r3, #12]
 8009f66:	693b      	ldr	r3, [r7, #16]
 8009f68:	60da      	str	r2, [r3, #12]
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
 8009f6a:	4b9d      	ldr	r3, [pc, #628]	; (800a1e0 <tcp_input+0x56c>)
 8009f6c:	681a      	ldr	r2, [r3, #0]
 8009f6e:	68fb      	ldr	r3, [r7, #12]
 8009f70:	60da      	str	r2, [r3, #12]
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
 8009f72:	4a9b      	ldr	r2, [pc, #620]	; (800a1e0 <tcp_input+0x56c>)
 8009f74:	68fb      	ldr	r3, [r7, #12]
 8009f76:	6013      	str	r3, [r2, #0]
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
 8009f78:	68f8      	ldr	r0, [r7, #12]
 8009f7a:	f000 f97b 	bl	800a274 <tcp_listen_input>
        pbuf_free(p);
 8009f7e:	6878      	ldr	r0, [r7, #4]
 8009f80:	f7fe fc13 	bl	80087aa <pbuf_free>
        return;
 8009f84:	e169      	b.n	800a25a <tcp_input+0x5e6>
      }
      prev = (struct tcp_pcb *)lpcb;
 8009f86:	68fb      	ldr	r3, [r7, #12]
 8009f88:	613b      	str	r3, [r7, #16]
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8009f8a:	68fb      	ldr	r3, [r7, #12]
 8009f8c:	68db      	ldr	r3, [r3, #12]
 8009f8e:	60fb      	str	r3, [r7, #12]
 8009f90:	68fb      	ldr	r3, [r7, #12]
 8009f92:	2b00      	cmp	r3, #0
 8009f94:	d1cc      	bne.n	8009f30 <tcp_input+0x2bc>
    }
  }

#if TCP_INPUT_DEBUG
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
 8009f96:	4b91      	ldr	r3, [pc, #580]	; (800a1dc <tcp_input+0x568>)
 8009f98:	681b      	ldr	r3, [r3, #0]
 8009f9a:	899b      	ldrh	r3, [r3, #12]
 8009f9c:	b29b      	uxth	r3, r3
 8009f9e:	4618      	mov	r0, r3
 8009fa0:	f7fc fe77 	bl	8006c92 <ntohs>
 8009fa4:	4603      	mov	r3, r0
 8009fa6:	b2db      	uxtb	r3, r3
 8009fa8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009fac:	b2db      	uxtb	r3, r3
 8009fae:	4618      	mov	r0, r3
 8009fb0:	f7ff fe33 	bl	8009c1a <tcp_debug_print_flags>
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
 8009fb4:	697b      	ldr	r3, [r7, #20]
 8009fb6:	2b00      	cmp	r3, #0
 8009fb8:	f000 8120 	beq.w	800a1fc <tcp_input+0x588>
    /* The incoming segment belongs to a connection. */
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
    tcp_debug_print_state(pcb->state);
 8009fbc:	697b      	ldr	r3, [r7, #20]
 8009fbe:	7c1b      	ldrb	r3, [r3, #16]
 8009fc0:	4618      	mov	r0, r3
 8009fc2:	f7ff fe1f 	bl	8009c04 <tcp_debug_print_state>
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8009fc6:	4b87      	ldr	r3, [pc, #540]	; (800a1e4 <tcp_input+0x570>)
 8009fc8:	2200      	movs	r2, #0
 8009fca:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 8009fcc:	687b      	ldr	r3, [r7, #4]
 8009fce:	891a      	ldrh	r2, [r3, #8]
 8009fd0:	4b84      	ldr	r3, [pc, #528]	; (800a1e4 <tcp_input+0x570>)
 8009fd2:	819a      	strh	r2, [r3, #12]
    inseg.dataptr = p->payload;
 8009fd4:	687b      	ldr	r3, [r7, #4]
 8009fd6:	685b      	ldr	r3, [r3, #4]
 8009fd8:	4a82      	ldr	r2, [pc, #520]	; (800a1e4 <tcp_input+0x570>)
 8009fda:	6093      	str	r3, [r2, #8]
    inseg.p = p;
 8009fdc:	4a81      	ldr	r2, [pc, #516]	; (800a1e4 <tcp_input+0x570>)
 8009fde:	687b      	ldr	r3, [r7, #4]
 8009fe0:	6053      	str	r3, [r2, #4]
    inseg.tcphdr = tcphdr;
 8009fe2:	4b7e      	ldr	r3, [pc, #504]	; (800a1dc <tcp_input+0x568>)
 8009fe4:	681b      	ldr	r3, [r3, #0]
 8009fe6:	4a7f      	ldr	r2, [pc, #508]	; (800a1e4 <tcp_input+0x570>)
 8009fe8:	6113      	str	r3, [r2, #16]

    recv_data = NULL;
 8009fea:	4b7f      	ldr	r3, [pc, #508]	; (800a1e8 <tcp_input+0x574>)
 8009fec:	2200      	movs	r2, #0
 8009fee:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 8009ff0:	4b7e      	ldr	r3, [pc, #504]	; (800a1ec <tcp_input+0x578>)
 8009ff2:	2200      	movs	r2, #0
 8009ff4:	701a      	strb	r2, [r3, #0]

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 8009ff6:	697b      	ldr	r3, [r7, #20]
 8009ff8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009ffa:	2b00      	cmp	r3, #0
 8009ffc:	d026      	beq.n	800a04c <tcp_input+0x3d8>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
 8009ffe:	697b      	ldr	r3, [r7, #20]
 800a000:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800a004:	2b00      	cmp	r3, #0
 800a006:	d00c      	beq.n	800a022 <tcp_input+0x3ae>
 800a008:	697b      	ldr	r3, [r7, #20]
 800a00a:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 800a00e:	697b      	ldr	r3, [r7, #20]
 800a010:	6958      	ldr	r0, [r3, #20]
 800a012:	697b      	ldr	r3, [r7, #20]
 800a014:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800a016:	2300      	movs	r3, #0
 800a018:	6979      	ldr	r1, [r7, #20]
 800a01a:	47a0      	blx	r4
 800a01c:	4603      	mov	r3, r0
 800a01e:	72fb      	strb	r3, [r7, #11]
 800a020:	e008      	b.n	800a034 <tcp_input+0x3c0>
 800a022:	697b      	ldr	r3, [r7, #20]
 800a024:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800a026:	2300      	movs	r3, #0
 800a028:	6979      	ldr	r1, [r7, #20]
 800a02a:	2000      	movs	r0, #0
 800a02c:	f7ff fb93 	bl	8009756 <tcp_recv_null>
 800a030:	4603      	mov	r3, r0
 800a032:	72fb      	strb	r3, [r7, #11]
      if (err == ERR_OK) {
 800a034:	f997 300b 	ldrsb.w	r3, [r7, #11]
 800a038:	2b00      	cmp	r3, #0
 800a03a:	d103      	bne.n	800a044 <tcp_input+0x3d0>
        pcb->refused_data = NULL;
 800a03c:	697b      	ldr	r3, [r7, #20]
 800a03e:	2200      	movs	r2, #0
 800a040:	67da      	str	r2, [r3, #124]	; 0x7c
 800a042:	e003      	b.n	800a04c <tcp_input+0x3d8>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
 800a044:	6878      	ldr	r0, [r7, #4]
 800a046:	f7fe fbb0 	bl	80087aa <pbuf_free>
        return;
 800a04a:	e106      	b.n	800a25a <tcp_input+0x5e6>
      }
    }
    tcp_input_pcb = pcb;
 800a04c:	4a68      	ldr	r2, [pc, #416]	; (800a1f0 <tcp_input+0x57c>)
 800a04e:	697b      	ldr	r3, [r7, #20]
 800a050:	6013      	str	r3, [r2, #0]
    err = tcp_process(pcb);
 800a052:	6978      	ldr	r0, [r7, #20]
 800a054:	f000 fa44 	bl	800a4e0 <tcp_process>
 800a058:	4603      	mov	r3, r0
 800a05a:	72fb      	strb	r3, [r7, #11]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 800a05c:	f997 300b 	ldrsb.w	r3, [r7, #11]
 800a060:	f113 0f05 	cmn.w	r3, #5
 800a064:	f000 80a7 	beq.w	800a1b6 <tcp_input+0x542>
      if (recv_flags & TF_RESET) {
 800a068:	4b60      	ldr	r3, [pc, #384]	; (800a1ec <tcp_input+0x578>)
 800a06a:	781b      	ldrb	r3, [r3, #0]
 800a06c:	f003 0308 	and.w	r3, r3, #8
 800a070:	2b00      	cmp	r3, #0
 800a072:	d016      	beq.n	800a0a2 <tcp_input+0x42e>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 800a074:	697b      	ldr	r3, [r7, #20]
 800a076:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a07a:	2b00      	cmp	r3, #0
 800a07c:	d008      	beq.n	800a090 <tcp_input+0x41c>
 800a07e:	697b      	ldr	r3, [r7, #20]
 800a080:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a084:	697a      	ldr	r2, [r7, #20]
 800a086:	6952      	ldr	r2, [r2, #20]
 800a088:	f06f 0105 	mvn.w	r1, #5
 800a08c:	4610      	mov	r0, r2
 800a08e:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800a090:	6979      	ldr	r1, [r7, #20]
 800a092:	4858      	ldr	r0, [pc, #352]	; (800a1f4 <tcp_input+0x580>)
 800a094:	f7ff fd12 	bl	8009abc <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 800a098:	6979      	ldr	r1, [r7, #20]
 800a09a:	2002      	movs	r0, #2
 800a09c:	f7fe f856 	bl	800814c <memp_free>
 800a0a0:	e089      	b.n	800a1b6 <tcp_input+0x542>
      } else if (recv_flags & TF_CLOSED) {
 800a0a2:	4b52      	ldr	r3, [pc, #328]	; (800a1ec <tcp_input+0x578>)
 800a0a4:	781b      	ldrb	r3, [r3, #0]
 800a0a6:	f003 0310 	and.w	r3, r3, #16
 800a0aa:	2b00      	cmp	r3, #0
 800a0ac:	d008      	beq.n	800a0c0 <tcp_input+0x44c>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800a0ae:	6979      	ldr	r1, [r7, #20]
 800a0b0:	4850      	ldr	r0, [pc, #320]	; (800a1f4 <tcp_input+0x580>)
 800a0b2:	f7ff fd03 	bl	8009abc <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 800a0b6:	6979      	ldr	r1, [r7, #20]
 800a0b8:	2002      	movs	r0, #2
 800a0ba:	f7fe f847 	bl	800814c <memp_free>
 800a0be:	e07a      	b.n	800a1b6 <tcp_input+0x542>
      } else {
        err = ERR_OK;
 800a0c0:	2300      	movs	r3, #0
 800a0c2:	72fb      	strb	r3, [r7, #11]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 800a0c4:	697b      	ldr	r3, [r7, #20]
 800a0c6:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800a0ca:	2b00      	cmp	r3, #0
 800a0cc:	d013      	beq.n	800a0f6 <tcp_input+0x482>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 800a0ce:	697b      	ldr	r3, [r7, #20]
 800a0d0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800a0d4:	2b00      	cmp	r3, #0
 800a0d6:	d00c      	beq.n	800a0f2 <tcp_input+0x47e>
 800a0d8:	697b      	ldr	r3, [r7, #20]
 800a0da:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800a0de:	697a      	ldr	r2, [r7, #20]
 800a0e0:	6950      	ldr	r0, [r2, #20]
 800a0e2:	697a      	ldr	r2, [r7, #20]
 800a0e4:	f8b2 206c 	ldrh.w	r2, [r2, #108]	; 0x6c
 800a0e8:	6979      	ldr	r1, [r7, #20]
 800a0ea:	4798      	blx	r3
 800a0ec:	4603      	mov	r3, r0
 800a0ee:	72fb      	strb	r3, [r7, #11]
 800a0f0:	e001      	b.n	800a0f6 <tcp_input+0x482>
 800a0f2:	2300      	movs	r3, #0
 800a0f4:	72fb      	strb	r3, [r7, #11]
        }
      
        if (recv_data != NULL) {
 800a0f6:	4b3c      	ldr	r3, [pc, #240]	; (800a1e8 <tcp_input+0x574>)
 800a0f8:	681b      	ldr	r3, [r3, #0]
 800a0fa:	2b00      	cmp	r3, #0
 800a0fc:	d031      	beq.n	800a162 <tcp_input+0x4ee>
          if(flags & TCP_PSH) {
 800a0fe:	4b3e      	ldr	r3, [pc, #248]	; (800a1f8 <tcp_input+0x584>)
 800a100:	781b      	ldrb	r3, [r3, #0]
 800a102:	f003 0308 	and.w	r3, r3, #8
 800a106:	2b00      	cmp	r3, #0
 800a108:	d008      	beq.n	800a11c <tcp_input+0x4a8>
            recv_data->flags |= PBUF_FLAG_PUSH;
 800a10a:	4b37      	ldr	r3, [pc, #220]	; (800a1e8 <tcp_input+0x574>)
 800a10c:	681b      	ldr	r3, [r3, #0]
 800a10e:	4a36      	ldr	r2, [pc, #216]	; (800a1e8 <tcp_input+0x574>)
 800a110:	6812      	ldr	r2, [r2, #0]
 800a112:	7b52      	ldrb	r2, [r2, #13]
 800a114:	f042 0201 	orr.w	r2, r2, #1
 800a118:	b2d2      	uxtb	r2, r2
 800a11a:	735a      	strb	r2, [r3, #13]
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800a11c:	697b      	ldr	r3, [r7, #20]
 800a11e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800a122:	2b00      	cmp	r3, #0
 800a124:	d00c      	beq.n	800a140 <tcp_input+0x4cc>
 800a126:	697b      	ldr	r3, [r7, #20]
 800a128:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 800a12c:	697b      	ldr	r3, [r7, #20]
 800a12e:	6958      	ldr	r0, [r3, #20]
 800a130:	4b2d      	ldr	r3, [pc, #180]	; (800a1e8 <tcp_input+0x574>)
 800a132:	681a      	ldr	r2, [r3, #0]
 800a134:	2300      	movs	r3, #0
 800a136:	6979      	ldr	r1, [r7, #20]
 800a138:	47a0      	blx	r4
 800a13a:	4603      	mov	r3, r0
 800a13c:	72fb      	strb	r3, [r7, #11]
 800a13e:	e008      	b.n	800a152 <tcp_input+0x4de>
 800a140:	4b29      	ldr	r3, [pc, #164]	; (800a1e8 <tcp_input+0x574>)
 800a142:	681a      	ldr	r2, [r3, #0]
 800a144:	2300      	movs	r3, #0
 800a146:	6979      	ldr	r1, [r7, #20]
 800a148:	2000      	movs	r0, #0
 800a14a:	f7ff fb04 	bl	8009756 <tcp_recv_null>
 800a14e:	4603      	mov	r3, r0
 800a150:	72fb      	strb	r3, [r7, #11]

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 800a152:	f997 300b 	ldrsb.w	r3, [r7, #11]
 800a156:	2b00      	cmp	r3, #0
 800a158:	d003      	beq.n	800a162 <tcp_input+0x4ee>
            pcb->refused_data = recv_data;
 800a15a:	4b23      	ldr	r3, [pc, #140]	; (800a1e8 <tcp_input+0x574>)
 800a15c:	681a      	ldr	r2, [r3, #0]
 800a15e:	697b      	ldr	r3, [r7, #20]
 800a160:	67da      	str	r2, [r3, #124]	; 0x7c
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 800a162:	4b22      	ldr	r3, [pc, #136]	; (800a1ec <tcp_input+0x578>)
 800a164:	781b      	ldrb	r3, [r3, #0]
 800a166:	f003 0320 	and.w	r3, r3, #32
 800a16a:	2b00      	cmp	r3, #0
 800a16c:	d018      	beq.n	800a1a0 <tcp_input+0x52c>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
 800a16e:	697b      	ldr	r3, [r7, #20]
 800a170:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800a174:	2b00      	cmp	r3, #0
 800a176:	d00b      	beq.n	800a190 <tcp_input+0x51c>
 800a178:	697b      	ldr	r3, [r7, #20]
 800a17a:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 800a17e:	697b      	ldr	r3, [r7, #20]
 800a180:	6958      	ldr	r0, [r3, #20]
 800a182:	2300      	movs	r3, #0
 800a184:	2200      	movs	r2, #0
 800a186:	6979      	ldr	r1, [r7, #20]
 800a188:	47a0      	blx	r4
 800a18a:	4603      	mov	r3, r0
 800a18c:	72fb      	strb	r3, [r7, #11]
 800a18e:	e007      	b.n	800a1a0 <tcp_input+0x52c>
 800a190:	2300      	movs	r3, #0
 800a192:	2200      	movs	r2, #0
 800a194:	6979      	ldr	r1, [r7, #20]
 800a196:	2000      	movs	r0, #0
 800a198:	f7ff fadd 	bl	8009756 <tcp_recv_null>
 800a19c:	4603      	mov	r3, r0
 800a19e:	72fb      	strb	r3, [r7, #11]
        }

        tcp_input_pcb = NULL;
 800a1a0:	4b13      	ldr	r3, [pc, #76]	; (800a1f0 <tcp_input+0x57c>)
 800a1a2:	2200      	movs	r2, #0
 800a1a4:	601a      	str	r2, [r3, #0]
        /* Try to send something out. */
        tcp_output(pcb);
 800a1a6:	6978      	ldr	r0, [r7, #20]
 800a1a8:	f001 fdd0 	bl	800bd4c <tcp_output>
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
        tcp_debug_print_state(pcb->state);
 800a1ac:	697b      	ldr	r3, [r7, #20]
 800a1ae:	7c1b      	ldrb	r3, [r3, #16]
 800a1b0:	4618      	mov	r0, r3
 800a1b2:	f7ff fd27 	bl	8009c04 <tcp_debug_print_state>
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */
      }
    }
    tcp_input_pcb = NULL;
 800a1b6:	4b0e      	ldr	r3, [pc, #56]	; (800a1f0 <tcp_input+0x57c>)
 800a1b8:	2200      	movs	r2, #0
 800a1ba:	601a      	str	r2, [r3, #0]


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 800a1bc:	4b09      	ldr	r3, [pc, #36]	; (800a1e4 <tcp_input+0x570>)
 800a1be:	685b      	ldr	r3, [r3, #4]
 800a1c0:	2b00      	cmp	r3, #0
 800a1c2:	d048      	beq.n	800a256 <tcp_input+0x5e2>
    {
      pbuf_free(inseg.p);
 800a1c4:	4b07      	ldr	r3, [pc, #28]	; (800a1e4 <tcp_input+0x570>)
 800a1c6:	685b      	ldr	r3, [r3, #4]
 800a1c8:	4618      	mov	r0, r3
 800a1ca:	f7fe faee 	bl	80087aa <pbuf_free>
      inseg.p = NULL;
 800a1ce:	4b05      	ldr	r3, [pc, #20]	; (800a1e4 <tcp_input+0x570>)
 800a1d0:	2200      	movs	r2, #0
 800a1d2:	605a      	str	r2, [r3, #4]
 800a1d4:	e03f      	b.n	800a256 <tcp_input+0x5e2>
 800a1d6:	bf00      	nop
 800a1d8:	20007c50 	.word	0x20007c50
 800a1dc:	20007c4c 	.word	0x20007c4c
 800a1e0:	2000a32c 	.word	0x2000a32c
 800a1e4:	20007c38 	.word	0x20007c38
 800a1e8:	20007c64 	.word	0x20007c64
 800a1ec:	20007c60 	.word	0x20007c60
 800a1f0:	2000a33c 	.word	0x2000a33c
 800a1f4:	2000a324 	.word	0x2000a324
 800a1f8:	20007c5c 	.word	0x20007c5c
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800a1fc:	4b18      	ldr	r3, [pc, #96]	; (800a260 <tcp_input+0x5ec>)
 800a1fe:	681b      	ldr	r3, [r3, #0]
 800a200:	899b      	ldrh	r3, [r3, #12]
 800a202:	b29b      	uxth	r3, r3
 800a204:	4618      	mov	r0, r3
 800a206:	f7fc fd44 	bl	8006c92 <ntohs>
 800a20a:	4603      	mov	r3, r0
 800a20c:	f003 0304 	and.w	r3, r3, #4
 800a210:	2b00      	cmp	r3, #0
 800a212:	d11d      	bne.n	800a250 <tcp_input+0x5dc>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 800a214:	4b13      	ldr	r3, [pc, #76]	; (800a264 <tcp_input+0x5f0>)
 800a216:	6818      	ldr	r0, [r3, #0]
 800a218:	4b13      	ldr	r3, [pc, #76]	; (800a268 <tcp_input+0x5f4>)
 800a21a:	881b      	ldrh	r3, [r3, #0]
 800a21c:	461a      	mov	r2, r3
 800a21e:	4b13      	ldr	r3, [pc, #76]	; (800a26c <tcp_input+0x5f8>)
 800a220:	681b      	ldr	r3, [r3, #0]
 800a222:	18d1      	adds	r1, r2, r3
        &(iphdr->dest), &(iphdr->src),
 800a224:	4b12      	ldr	r3, [pc, #72]	; (800a270 <tcp_input+0x5fc>)
 800a226:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen,
 800a228:	f103 0410 	add.w	r4, r3, #16
        &(iphdr->dest), &(iphdr->src),
 800a22c:	4b10      	ldr	r3, [pc, #64]	; (800a270 <tcp_input+0x5fc>)
 800a22e:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen,
 800a230:	f103 050c 	add.w	r5, r3, #12
        tcphdr->dest, tcphdr->src);
 800a234:	4b0a      	ldr	r3, [pc, #40]	; (800a260 <tcp_input+0x5ec>)
 800a236:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen,
 800a238:	885b      	ldrh	r3, [r3, #2]
 800a23a:	b29b      	uxth	r3, r3
        tcphdr->dest, tcphdr->src);
 800a23c:	4a08      	ldr	r2, [pc, #32]	; (800a260 <tcp_input+0x5ec>)
 800a23e:	6812      	ldr	r2, [r2, #0]
      tcp_rst(ackno, seqno + tcplen,
 800a240:	8812      	ldrh	r2, [r2, #0]
 800a242:	b292      	uxth	r2, r2
 800a244:	9201      	str	r2, [sp, #4]
 800a246:	9300      	str	r3, [sp, #0]
 800a248:	462b      	mov	r3, r5
 800a24a:	4622      	mov	r2, r4
 800a24c:	f001 ff9a 	bl	800c184 <tcp_rst>
    }
    pbuf_free(p);
 800a250:	6878      	ldr	r0, [r7, #4]
 800a252:	f7fe faaa 	bl	80087aa <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
 800a256:	f7ff fceb 	bl	8009c30 <tcp_pcbs_sane>
  PERF_STOP("tcp_input");
}
 800a25a:	3718      	adds	r7, #24
 800a25c:	46bd      	mov	sp, r7
 800a25e:	bdb0      	pop	{r4, r5, r7, pc}
 800a260:	20007c4c 	.word	0x20007c4c
 800a264:	20007c58 	.word	0x20007c58
 800a268:	20007c5e 	.word	0x20007c5e
 800a26c:	20007c54 	.word	0x20007c54
 800a270:	20007c50 	.word	0x20007c50

0800a274 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 800a274:	b5b0      	push	{r4, r5, r7, lr}
 800a276:	b086      	sub	sp, #24
 800a278:	af02      	add	r7, sp, #8
 800a27a:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  err_t rc;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 800a27c:	4b58      	ldr	r3, [pc, #352]	; (800a3e0 <tcp_listen_input+0x16c>)
 800a27e:	781b      	ldrb	r3, [r3, #0]
 800a280:	f003 0310 	and.w	r3, r3, #16
 800a284:	2b00      	cmp	r3, #0
 800a286:	d01f      	beq.n	800a2c8 <tcp_listen_input+0x54>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
 800a288:	4b56      	ldr	r3, [pc, #344]	; (800a3e4 <tcp_listen_input+0x170>)
 800a28a:	681b      	ldr	r3, [r3, #0]
 800a28c:	1c58      	adds	r0, r3, #1
 800a28e:	4b56      	ldr	r3, [pc, #344]	; (800a3e8 <tcp_listen_input+0x174>)
 800a290:	881b      	ldrh	r3, [r3, #0]
 800a292:	461a      	mov	r2, r3
 800a294:	4b55      	ldr	r3, [pc, #340]	; (800a3ec <tcp_listen_input+0x178>)
 800a296:	681b      	ldr	r3, [r3, #0]
 800a298:	18d1      	adds	r1, r2, r3
      &(iphdr->dest), &(iphdr->src),
 800a29a:	4b55      	ldr	r3, [pc, #340]	; (800a3f0 <tcp_listen_input+0x17c>)
 800a29c:	681b      	ldr	r3, [r3, #0]
    tcp_rst(ackno + 1, seqno + tcplen,
 800a29e:	f103 0410 	add.w	r4, r3, #16
      &(iphdr->dest), &(iphdr->src),
 800a2a2:	4b53      	ldr	r3, [pc, #332]	; (800a3f0 <tcp_listen_input+0x17c>)
 800a2a4:	681b      	ldr	r3, [r3, #0]
    tcp_rst(ackno + 1, seqno + tcplen,
 800a2a6:	f103 050c 	add.w	r5, r3, #12
      tcphdr->dest, tcphdr->src);
 800a2aa:	4b52      	ldr	r3, [pc, #328]	; (800a3f4 <tcp_listen_input+0x180>)
 800a2ac:	681b      	ldr	r3, [r3, #0]
    tcp_rst(ackno + 1, seqno + tcplen,
 800a2ae:	885b      	ldrh	r3, [r3, #2]
 800a2b0:	b29b      	uxth	r3, r3
      tcphdr->dest, tcphdr->src);
 800a2b2:	4a50      	ldr	r2, [pc, #320]	; (800a3f4 <tcp_listen_input+0x180>)
 800a2b4:	6812      	ldr	r2, [r2, #0]
    tcp_rst(ackno + 1, seqno + tcplen,
 800a2b6:	8812      	ldrh	r2, [r2, #0]
 800a2b8:	b292      	uxth	r2, r2
 800a2ba:	9201      	str	r2, [sp, #4]
 800a2bc:	9300      	str	r3, [sp, #0]
 800a2be:	462b      	mov	r3, r5
 800a2c0:	4622      	mov	r2, r4
 800a2c2:	f001 ff5f 	bl	800c184 <tcp_rst>
 800a2c6:	e085      	b.n	800a3d4 <tcp_listen_input+0x160>
  } else if (flags & TCP_SYN) {
 800a2c8:	4b45      	ldr	r3, [pc, #276]	; (800a3e0 <tcp_listen_input+0x16c>)
 800a2ca:	781b      	ldrb	r3, [r3, #0]
 800a2cc:	f003 0302 	and.w	r3, r3, #2
 800a2d0:	2b00      	cmp	r3, #0
 800a2d2:	d07f      	beq.n	800a3d4 <tcp_listen_input+0x160>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 800a2d4:	687b      	ldr	r3, [r7, #4]
 800a2d6:	7c5b      	ldrb	r3, [r3, #17]
 800a2d8:	4618      	mov	r0, r3
 800a2da:	f7ff fad1 	bl	8009880 <tcp_alloc>
 800a2de:	60f8      	str	r0, [r7, #12]
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 800a2e0:	68fb      	ldr	r3, [r7, #12]
 800a2e2:	2b00      	cmp	r3, #0
 800a2e4:	d102      	bne.n	800a2ec <tcp_listen_input+0x78>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
 800a2e6:	f04f 33ff 	mov.w	r3, #4294967295
 800a2ea:	e074      	b.n	800a3d6 <tcp_listen_input+0x162>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
 800a2ec:	4b40      	ldr	r3, [pc, #256]	; (800a3f0 <tcp_listen_input+0x17c>)
 800a2ee:	681b      	ldr	r3, [r3, #0]
 800a2f0:	691a      	ldr	r2, [r3, #16]
 800a2f2:	68fb      	ldr	r3, [r7, #12]
 800a2f4:	601a      	str	r2, [r3, #0]
    npcb->local_port = pcb->local_port;
 800a2f6:	687b      	ldr	r3, [r7, #4]
 800a2f8:	8b1a      	ldrh	r2, [r3, #24]
 800a2fa:	68fb      	ldr	r3, [r7, #12]
 800a2fc:	831a      	strh	r2, [r3, #24]
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
 800a2fe:	4b3c      	ldr	r3, [pc, #240]	; (800a3f0 <tcp_listen_input+0x17c>)
 800a300:	681b      	ldr	r3, [r3, #0]
 800a302:	68da      	ldr	r2, [r3, #12]
 800a304:	68fb      	ldr	r3, [r7, #12]
 800a306:	605a      	str	r2, [r3, #4]
    npcb->remote_port = tcphdr->src;
 800a308:	4b3a      	ldr	r3, [pc, #232]	; (800a3f4 <tcp_listen_input+0x180>)
 800a30a:	681b      	ldr	r3, [r3, #0]
 800a30c:	881b      	ldrh	r3, [r3, #0]
 800a30e:	b29a      	uxth	r2, r3
 800a310:	68fb      	ldr	r3, [r7, #12]
 800a312:	841a      	strh	r2, [r3, #32]
    npcb->state = SYN_RCVD;
 800a314:	68fb      	ldr	r3, [r7, #12]
 800a316:	2203      	movs	r2, #3
 800a318:	741a      	strb	r2, [r3, #16]
    npcb->rcv_nxt = seqno + 1;
 800a31a:	4b34      	ldr	r3, [pc, #208]	; (800a3ec <tcp_listen_input+0x178>)
 800a31c:	681b      	ldr	r3, [r3, #0]
 800a31e:	1c5a      	adds	r2, r3, #1
 800a320:	68fb      	ldr	r3, [r7, #12]
 800a322:	625a      	str	r2, [r3, #36]	; 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800a324:	68fb      	ldr	r3, [r7, #12]
 800a326:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a328:	68fb      	ldr	r3, [r7, #12]
 800a32a:	62da      	str	r2, [r3, #44]	; 0x2c
    npcb->snd_wnd = tcphdr->wnd;
 800a32c:	4b31      	ldr	r3, [pc, #196]	; (800a3f4 <tcp_listen_input+0x180>)
 800a32e:	681b      	ldr	r3, [r3, #0]
 800a330:	89db      	ldrh	r3, [r3, #14]
 800a332:	b29a      	uxth	r2, r3
 800a334:	68fb      	ldr	r3, [r7, #12]
 800a336:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    npcb->ssthresh = npcb->snd_wnd;
 800a33a:	68fb      	ldr	r3, [r7, #12]
 800a33c:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800a340:	68fb      	ldr	r3, [r7, #12]
 800a342:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800a346:	4b29      	ldr	r3, [pc, #164]	; (800a3ec <tcp_listen_input+0x178>)
 800a348:	681b      	ldr	r3, [r3, #0]
 800a34a:	1e5a      	subs	r2, r3, #1
 800a34c:	68fb      	ldr	r3, [r7, #12]
 800a34e:	661a      	str	r2, [r3, #96]	; 0x60
    npcb->callback_arg = pcb->callback_arg;
 800a350:	687b      	ldr	r3, [r7, #4]
 800a352:	695a      	ldr	r2, [r3, #20]
 800a354:	68fb      	ldr	r3, [r7, #12]
 800a356:	615a      	str	r2, [r3, #20]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 800a358:	687b      	ldr	r3, [r7, #4]
 800a35a:	69da      	ldr	r2, [r3, #28]
 800a35c:	68fb      	ldr	r3, [r7, #12]
 800a35e:	61da      	str	r2, [r3, #28]
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
 800a360:	687b      	ldr	r3, [r7, #4]
 800a362:	891a      	ldrh	r2, [r3, #8]
 800a364:	f240 1399 	movw	r3, #409	; 0x199
 800a368:	4013      	ands	r3, r2
 800a36a:	b29a      	uxth	r2, r3
 800a36c:	68fb      	ldr	r3, [r7, #12]
 800a36e:	811a      	strh	r2, [r3, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
 800a370:	4b21      	ldr	r3, [pc, #132]	; (800a3f8 <tcp_listen_input+0x184>)
 800a372:	681a      	ldr	r2, [r3, #0]
 800a374:	68fb      	ldr	r3, [r7, #12]
 800a376:	60da      	str	r2, [r3, #12]
 800a378:	4a1f      	ldr	r2, [pc, #124]	; (800a3f8 <tcp_listen_input+0x184>)
 800a37a:	68fb      	ldr	r3, [r7, #12]
 800a37c:	6013      	str	r3, [r2, #0]

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 800a37e:	68f8      	ldr	r0, [r7, #12]
 800a380:	f001 f87c 	bl	800b47c <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 800a384:	68fb      	ldr	r3, [r7, #12]
 800a386:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 800a388:	68fb      	ldr	r3, [r7, #12]
 800a38a:	3304      	adds	r3, #4
 800a38c:	4619      	mov	r1, r3
 800a38e:	4610      	mov	r0, r2
 800a390:	f7ff fc02 	bl	8009b98 <tcp_eff_send_mss>
 800a394:	4603      	mov	r3, r0
 800a396:	461a      	mov	r2, r3
 800a398:	68fb      	ldr	r3, [r7, #12]
 800a39a:	871a      	strh	r2, [r3, #56]	; 0x38
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, TF_SEG_OPTS_MSS
 800a39c:	2301      	movs	r3, #1
 800a39e:	9301      	str	r3, [sp, #4]
 800a3a0:	2300      	movs	r3, #0
 800a3a2:	9300      	str	r3, [sp, #0]
 800a3a4:	2312      	movs	r3, #18
 800a3a6:	2200      	movs	r2, #0
 800a3a8:	2100      	movs	r1, #0
 800a3aa:	68f8      	ldr	r0, [r7, #12]
 800a3ac:	f001 f9a7 	bl	800b6fe <tcp_enqueue>
 800a3b0:	4603      	mov	r3, r0
 800a3b2:	72fb      	strb	r3, [r7, #11]
#if LWIP_TCP_TIMESTAMPS
      /* and maybe include the TIMESTAMP option */
     | (npcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0)
#endif
      );
    if (rc != ERR_OK) {
 800a3b4:	f997 300b 	ldrsb.w	r3, [r7, #11]
 800a3b8:	2b00      	cmp	r3, #0
 800a3ba:	d006      	beq.n	800a3ca <tcp_listen_input+0x156>
      tcp_abandon(npcb, 0);
 800a3bc:	2100      	movs	r1, #0
 800a3be:	68f8      	ldr	r0, [r7, #12]
 800a3c0:	f7fe fcb4 	bl	8008d2c <tcp_abandon>
      return rc;
 800a3c4:	f997 300b 	ldrsb.w	r3, [r7, #11]
 800a3c8:	e005      	b.n	800a3d6 <tcp_listen_input+0x162>
    }
    return tcp_output(npcb);
 800a3ca:	68f8      	ldr	r0, [r7, #12]
 800a3cc:	f001 fcbe 	bl	800bd4c <tcp_output>
 800a3d0:	4603      	mov	r3, r0
 800a3d2:	e000      	b.n	800a3d6 <tcp_listen_input+0x162>
  }
  return ERR_OK;
 800a3d4:	2300      	movs	r3, #0
}
 800a3d6:	4618      	mov	r0, r3
 800a3d8:	3710      	adds	r7, #16
 800a3da:	46bd      	mov	sp, r7
 800a3dc:	bdb0      	pop	{r4, r5, r7, pc}
 800a3de:	bf00      	nop
 800a3e0:	20007c5c 	.word	0x20007c5c
 800a3e4:	20007c58 	.word	0x20007c58
 800a3e8:	20007c5e 	.word	0x20007c5e
 800a3ec:	20007c54 	.word	0x20007c54
 800a3f0:	20007c50 	.word	0x20007c50
 800a3f4:	20007c4c 	.word	0x20007c4c
 800a3f8:	2000a324 	.word	0x2000a324

0800a3fc <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
 800a3fc:	b5b0      	push	{r4, r5, r7, lr}
 800a3fe:	b084      	sub	sp, #16
 800a400:	af02      	add	r7, sp, #8
 800a402:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
 800a404:	4b2f      	ldr	r3, [pc, #188]	; (800a4c4 <tcp_timewait_input+0xc8>)
 800a406:	781b      	ldrb	r3, [r3, #0]
 800a408:	f003 0304 	and.w	r3, r3, #4
 800a40c:	2b00      	cmp	r3, #0
 800a40e:	d001      	beq.n	800a414 <tcp_timewait_input+0x18>
    return ERR_OK;
 800a410:	2300      	movs	r3, #0
 800a412:	e053      	b.n	800a4bc <tcp_timewait_input+0xc0>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 800a414:	4b2b      	ldr	r3, [pc, #172]	; (800a4c4 <tcp_timewait_input+0xc8>)
 800a416:	781b      	ldrb	r3, [r3, #0]
 800a418:	f003 0302 	and.w	r3, r3, #2
 800a41c:	2b00      	cmp	r3, #0
 800a41e:	d030      	beq.n	800a482 <tcp_timewait_input+0x86>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 800a420:	4b29      	ldr	r3, [pc, #164]	; (800a4c8 <tcp_timewait_input+0xcc>)
 800a422:	681a      	ldr	r2, [r3, #0]
 800a424:	687b      	ldr	r3, [r7, #4]
 800a426:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a428:	1ad3      	subs	r3, r2, r3
 800a42a:	2b00      	cmp	r3, #0
 800a42c:	db33      	blt.n	800a496 <tcp_timewait_input+0x9a>
 800a42e:	4b26      	ldr	r3, [pc, #152]	; (800a4c8 <tcp_timewait_input+0xcc>)
 800a430:	681a      	ldr	r2, [r3, #0]
 800a432:	687b      	ldr	r3, [r7, #4]
 800a434:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a436:	6879      	ldr	r1, [r7, #4]
 800a438:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 800a43a:	440b      	add	r3, r1
 800a43c:	1ad3      	subs	r3, r2, r3
 800a43e:	2b00      	cmp	r3, #0
 800a440:	dc29      	bgt.n	800a496 <tcp_timewait_input+0x9a>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a442:	4b22      	ldr	r3, [pc, #136]	; (800a4cc <tcp_timewait_input+0xd0>)
 800a444:	6818      	ldr	r0, [r3, #0]
 800a446:	4b22      	ldr	r3, [pc, #136]	; (800a4d0 <tcp_timewait_input+0xd4>)
 800a448:	881b      	ldrh	r3, [r3, #0]
 800a44a:	461a      	mov	r2, r3
 800a44c:	4b1e      	ldr	r3, [pc, #120]	; (800a4c8 <tcp_timewait_input+0xcc>)
 800a44e:	681b      	ldr	r3, [r3, #0]
 800a450:	18d1      	adds	r1, r2, r3
 800a452:	4b20      	ldr	r3, [pc, #128]	; (800a4d4 <tcp_timewait_input+0xd8>)
 800a454:	681b      	ldr	r3, [r3, #0]
 800a456:	f103 0410 	add.w	r4, r3, #16
 800a45a:	4b1e      	ldr	r3, [pc, #120]	; (800a4d4 <tcp_timewait_input+0xd8>)
 800a45c:	681b      	ldr	r3, [r3, #0]
 800a45e:	f103 050c 	add.w	r5, r3, #12
        tcphdr->dest, tcphdr->src);
 800a462:	4b1d      	ldr	r3, [pc, #116]	; (800a4d8 <tcp_timewait_input+0xdc>)
 800a464:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a466:	885b      	ldrh	r3, [r3, #2]
 800a468:	b29b      	uxth	r3, r3
        tcphdr->dest, tcphdr->src);
 800a46a:	4a1b      	ldr	r2, [pc, #108]	; (800a4d8 <tcp_timewait_input+0xdc>)
 800a46c:	6812      	ldr	r2, [r2, #0]
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a46e:	8812      	ldrh	r2, [r2, #0]
 800a470:	b292      	uxth	r2, r2
 800a472:	9201      	str	r2, [sp, #4]
 800a474:	9300      	str	r3, [sp, #0]
 800a476:	462b      	mov	r3, r5
 800a478:	4622      	mov	r2, r4
 800a47a:	f001 fe83 	bl	800c184 <tcp_rst>
      return ERR_OK;
 800a47e:	2300      	movs	r3, #0
 800a480:	e01c      	b.n	800a4bc <tcp_timewait_input+0xc0>
    }
  } else if (flags & TCP_FIN) {
 800a482:	4b10      	ldr	r3, [pc, #64]	; (800a4c4 <tcp_timewait_input+0xc8>)
 800a484:	781b      	ldrb	r3, [r3, #0]
 800a486:	f003 0301 	and.w	r3, r3, #1
 800a48a:	2b00      	cmp	r3, #0
 800a48c:	d003      	beq.n	800a496 <tcp_timewait_input+0x9a>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 800a48e:	4b13      	ldr	r3, [pc, #76]	; (800a4dc <tcp_timewait_input+0xe0>)
 800a490:	681a      	ldr	r2, [r3, #0]
 800a492:	687b      	ldr	r3, [r7, #4]
 800a494:	631a      	str	r2, [r3, #48]	; 0x30
  }

  if ((tcplen > 0))  {
 800a496:	4b0e      	ldr	r3, [pc, #56]	; (800a4d0 <tcp_timewait_input+0xd4>)
 800a498:	881b      	ldrh	r3, [r3, #0]
 800a49a:	2b00      	cmp	r3, #0
 800a49c:	d00d      	beq.n	800a4ba <tcp_timewait_input+0xbe>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 800a49e:	687b      	ldr	r3, [r7, #4]
 800a4a0:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a4a4:	f043 0302 	orr.w	r3, r3, #2
 800a4a8:	b2da      	uxtb	r2, r3
 800a4aa:	687b      	ldr	r3, [r7, #4]
 800a4ac:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    return tcp_output(pcb);
 800a4b0:	6878      	ldr	r0, [r7, #4]
 800a4b2:	f001 fc4b 	bl	800bd4c <tcp_output>
 800a4b6:	4603      	mov	r3, r0
 800a4b8:	e000      	b.n	800a4bc <tcp_timewait_input+0xc0>
  }
  return ERR_OK;
 800a4ba:	2300      	movs	r3, #0
}
 800a4bc:	4618      	mov	r0, r3
 800a4be:	3708      	adds	r7, #8
 800a4c0:	46bd      	mov	sp, r7
 800a4c2:	bdb0      	pop	{r4, r5, r7, pc}
 800a4c4:	20007c5c 	.word	0x20007c5c
 800a4c8:	20007c54 	.word	0x20007c54
 800a4cc:	20007c58 	.word	0x20007c58
 800a4d0:	20007c5e 	.word	0x20007c5e
 800a4d4:	20007c50 	.word	0x20007c50
 800a4d8:	20007c4c 	.word	0x20007c4c
 800a4dc:	2000a328 	.word	0x2000a328

0800a4e0 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 800a4e0:	b5b0      	push	{r4, r5, r7, lr}
 800a4e2:	b086      	sub	sp, #24
 800a4e4:	af02      	add	r7, sp, #8
 800a4e6:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 800a4e8:	2300      	movs	r3, #0
 800a4ea:	73fb      	strb	r3, [r7, #15]
  err_t err;

  err = ERR_OK;
 800a4ec:	2300      	movs	r3, #0
 800a4ee:	73bb      	strb	r3, [r7, #14]

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800a4f0:	4ba4      	ldr	r3, [pc, #656]	; (800a784 <tcp_process+0x2a4>)
 800a4f2:	781b      	ldrb	r3, [r3, #0]
 800a4f4:	f003 0304 	and.w	r3, r3, #4
 800a4f8:	2b00      	cmp	r3, #0
 800a4fa:	d037      	beq.n	800a56c <tcp_process+0x8c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 800a4fc:	687b      	ldr	r3, [r7, #4]
 800a4fe:	7c1b      	ldrb	r3, [r3, #16]
 800a500:	2b02      	cmp	r3, #2
 800a502:	d108      	bne.n	800a516 <tcp_process+0x36>
      if (ackno == pcb->snd_nxt) {
 800a504:	687b      	ldr	r3, [r7, #4]
 800a506:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a508:	4b9f      	ldr	r3, [pc, #636]	; (800a788 <tcp_process+0x2a8>)
 800a50a:	681b      	ldr	r3, [r3, #0]
 800a50c:	429a      	cmp	r2, r3
 800a50e:	d115      	bne.n	800a53c <tcp_process+0x5c>
        acceptable = 1;
 800a510:	2301      	movs	r3, #1
 800a512:	73fb      	strb	r3, [r7, #15]
 800a514:	e012      	b.n	800a53c <tcp_process+0x5c>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800a516:	4b9d      	ldr	r3, [pc, #628]	; (800a78c <tcp_process+0x2ac>)
 800a518:	681a      	ldr	r2, [r3, #0]
 800a51a:	687b      	ldr	r3, [r7, #4]
 800a51c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a51e:	1ad3      	subs	r3, r2, r3
 800a520:	2b00      	cmp	r3, #0
 800a522:	db0b      	blt.n	800a53c <tcp_process+0x5c>
 800a524:	4b99      	ldr	r3, [pc, #612]	; (800a78c <tcp_process+0x2ac>)
 800a526:	681a      	ldr	r2, [r3, #0]
 800a528:	687b      	ldr	r3, [r7, #4]
 800a52a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a52c:	6879      	ldr	r1, [r7, #4]
 800a52e:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 800a530:	440b      	add	r3, r1
 800a532:	1ad3      	subs	r3, r2, r3
 800a534:	2b00      	cmp	r3, #0
 800a536:	dc01      	bgt.n	800a53c <tcp_process+0x5c>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
 800a538:	2301      	movs	r3, #1
 800a53a:	73fb      	strb	r3, [r7, #15]
      }
    }

    if (acceptable) {
 800a53c:	7bfb      	ldrb	r3, [r7, #15]
 800a53e:	2b00      	cmp	r3, #0
 800a540:	d012      	beq.n	800a568 <tcp_process+0x88>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 800a542:	4b93      	ldr	r3, [pc, #588]	; (800a790 <tcp_process+0x2b0>)
 800a544:	781b      	ldrb	r3, [r3, #0]
 800a546:	f043 0308 	orr.w	r3, r3, #8
 800a54a:	b2da      	uxtb	r2, r3
 800a54c:	4b90      	ldr	r3, [pc, #576]	; (800a790 <tcp_process+0x2b0>)
 800a54e:	701a      	strb	r2, [r3, #0]
      pcb->flags &= ~TF_ACK_DELAY;
 800a550:	687b      	ldr	r3, [r7, #4]
 800a552:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a556:	f023 0301 	bic.w	r3, r3, #1
 800a55a:	b2da      	uxtb	r2, r3
 800a55c:	687b      	ldr	r3, [r7, #4]
 800a55e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
      return ERR_RST;
 800a562:	f06f 0305 	mvn.w	r3, #5
 800a566:	e31b      	b.n	800aba0 <tcp_process+0x6c0>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
 800a568:	2300      	movs	r3, #0
 800a56a:	e319      	b.n	800aba0 <tcp_process+0x6c0>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 800a56c:	4b85      	ldr	r3, [pc, #532]	; (800a784 <tcp_process+0x2a4>)
 800a56e:	781b      	ldrb	r3, [r3, #0]
 800a570:	f003 0302 	and.w	r3, r3, #2
 800a574:	2b00      	cmp	r3, #0
 800a576:	d015      	beq.n	800a5a4 <tcp_process+0xc4>
 800a578:	687b      	ldr	r3, [r7, #4]
 800a57a:	7c1b      	ldrb	r3, [r3, #16]
 800a57c:	2b02      	cmp	r3, #2
 800a57e:	d011      	beq.n	800a5a4 <tcp_process+0xc4>
 800a580:	687b      	ldr	r3, [r7, #4]
 800a582:	7c1b      	ldrb	r3, [r3, #16]
 800a584:	2b03      	cmp	r3, #3
 800a586:	d00d      	beq.n	800a5a4 <tcp_process+0xc4>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 800a588:	687b      	ldr	r3, [r7, #4]
 800a58a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a58e:	f043 0302 	orr.w	r3, r3, #2
 800a592:	b2da      	uxtb	r2, r3
 800a594:	687b      	ldr	r3, [r7, #4]
 800a596:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800a59a:	6878      	ldr	r0, [r7, #4]
 800a59c:	f001 fbd6 	bl	800bd4c <tcp_output>
    return ERR_OK;
 800a5a0:	2300      	movs	r3, #0
 800a5a2:	e2fd      	b.n	800aba0 <tcp_process+0x6c0>
  }
  
  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
 800a5a4:	4b7b      	ldr	r3, [pc, #492]	; (800a794 <tcp_process+0x2b4>)
 800a5a6:	681a      	ldr	r2, [r3, #0]
 800a5a8:	687b      	ldr	r3, [r7, #4]
 800a5aa:	631a      	str	r2, [r3, #48]	; 0x30
  pcb->keep_cnt_sent = 0;
 800a5ac:	687b      	ldr	r3, [r7, #4]
 800a5ae:	2200      	movs	r2, #0
 800a5b0:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d

  tcp_parseopt(pcb);
 800a5b4:	6878      	ldr	r0, [r7, #4]
 800a5b6:	f000 ff61 	bl	800b47c <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 800a5ba:	687b      	ldr	r3, [r7, #4]
 800a5bc:	7c1b      	ldrb	r3, [r3, #16]
 800a5be:	3b02      	subs	r3, #2
 800a5c0:	2b07      	cmp	r3, #7
 800a5c2:	f200 82dd 	bhi.w	800ab80 <tcp_process+0x6a0>
 800a5c6:	a201      	add	r2, pc, #4	; (adr r2, 800a5cc <tcp_process+0xec>)
 800a5c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a5cc:	0800a5ed 	.word	0x0800a5ed
 800a5d0:	0800a7a5 	.word	0x0800a7a5
 800a5d4:	0800a8e3 	.word	0x0800a8e3
 800a5d8:	0800a917 	.word	0x0800a917
 800a5dc:	0800aa31 	.word	0x0800aa31
 800a5e0:	0800a8e3 	.word	0x0800a8e3
 800a5e4:	0800aac9 	.word	0x0800aac9
 800a5e8:	0800ab53 	.word	0x0800ab53
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800a5ec:	4b65      	ldr	r3, [pc, #404]	; (800a784 <tcp_process+0x2a4>)
 800a5ee:	781b      	ldrb	r3, [r3, #0]
 800a5f0:	f003 0310 	and.w	r3, r3, #16
 800a5f4:	2b00      	cmp	r3, #0
 800a5f6:	f000 809f 	beq.w	800a738 <tcp_process+0x258>
 800a5fa:	4b62      	ldr	r3, [pc, #392]	; (800a784 <tcp_process+0x2a4>)
 800a5fc:	781b      	ldrb	r3, [r3, #0]
 800a5fe:	f003 0302 	and.w	r3, r3, #2
 800a602:	2b00      	cmp	r3, #0
 800a604:	f000 8098 	beq.w	800a738 <tcp_process+0x258>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 800a608:	687b      	ldr	r3, [r7, #4]
 800a60a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a60c:	691b      	ldr	r3, [r3, #16]
 800a60e:	685b      	ldr	r3, [r3, #4]
 800a610:	4618      	mov	r0, r3
 800a612:	f7fc fb65 	bl	8006ce0 <ntohl>
 800a616:	4603      	mov	r3, r0
 800a618:	1c5a      	adds	r2, r3, #1
 800a61a:	4b5b      	ldr	r3, [pc, #364]	; (800a788 <tcp_process+0x2a8>)
 800a61c:	681b      	ldr	r3, [r3, #0]
 800a61e:	429a      	cmp	r2, r3
 800a620:	f040 808a 	bne.w	800a738 <tcp_process+0x258>
      pcb->snd_buf++;
 800a624:	687b      	ldr	r3, [r7, #4]
 800a626:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 800a62a:	3301      	adds	r3, #1
 800a62c:	b29a      	uxth	r2, r3
 800a62e:	687b      	ldr	r3, [r7, #4]
 800a630:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
      pcb->rcv_nxt = seqno + 1;
 800a634:	4b55      	ldr	r3, [pc, #340]	; (800a78c <tcp_process+0x2ac>)
 800a636:	681b      	ldr	r3, [r3, #0]
 800a638:	1c5a      	adds	r2, r3, #1
 800a63a:	687b      	ldr	r3, [r7, #4]
 800a63c:	625a      	str	r2, [r3, #36]	; 0x24
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800a63e:	687b      	ldr	r3, [r7, #4]
 800a640:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a642:	687b      	ldr	r3, [r7, #4]
 800a644:	62da      	str	r2, [r3, #44]	; 0x2c
      pcb->lastack = ackno;
 800a646:	4b50      	ldr	r3, [pc, #320]	; (800a788 <tcp_process+0x2a8>)
 800a648:	681a      	ldr	r2, [r3, #0]
 800a64a:	687b      	ldr	r3, [r7, #4]
 800a64c:	64da      	str	r2, [r3, #76]	; 0x4c
      pcb->snd_wnd = tcphdr->wnd;
 800a64e:	4b52      	ldr	r3, [pc, #328]	; (800a798 <tcp_process+0x2b8>)
 800a650:	681b      	ldr	r3, [r3, #0]
 800a652:	89db      	ldrh	r3, [r3, #14]
 800a654:	b29a      	uxth	r2, r3
 800a656:	687b      	ldr	r3, [r7, #4]
 800a658:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800a65c:	4b4b      	ldr	r3, [pc, #300]	; (800a78c <tcp_process+0x2ac>)
 800a65e:	681b      	ldr	r3, [r3, #0]
 800a660:	1e5a      	subs	r2, r3, #1
 800a662:	687b      	ldr	r3, [r7, #4]
 800a664:	661a      	str	r2, [r3, #96]	; 0x60
      pcb->state = ESTABLISHED;
 800a666:	687b      	ldr	r3, [r7, #4]
 800a668:	2204      	movs	r2, #4
 800a66a:	741a      	strb	r2, [r3, #16]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 800a66c:	687b      	ldr	r3, [r7, #4]
 800a66e:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 800a670:	687b      	ldr	r3, [r7, #4]
 800a672:	3304      	adds	r3, #4
 800a674:	4619      	mov	r1, r3
 800a676:	4610      	mov	r0, r2
 800a678:	f7ff fa8e 	bl	8009b98 <tcp_eff_send_mss>
 800a67c:	4603      	mov	r3, r0
 800a67e:	461a      	mov	r2, r3
 800a680:	687b      	ldr	r3, [r7, #4]
 800a682:	871a      	strh	r2, [r3, #56]	; 0x38
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 800a684:	687b      	ldr	r3, [r7, #4]
 800a686:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800a688:	461a      	mov	r2, r3
 800a68a:	0092      	lsls	r2, r2, #2
 800a68c:	4413      	add	r3, r2
 800a68e:	005b      	lsls	r3, r3, #1
 800a690:	b29a      	uxth	r2, r3
 800a692:	687b      	ldr	r3, [r7, #4]
 800a694:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800a69e:	2b01      	cmp	r3, #1
 800a6a0:	d104      	bne.n	800a6ac <tcp_process+0x1cc>
 800a6a2:	687b      	ldr	r3, [r7, #4]
 800a6a4:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800a6a6:	005b      	lsls	r3, r3, #1
 800a6a8:	b29b      	uxth	r3, r3
 800a6aa:	e001      	b.n	800a6b0 <tcp_process+0x1d0>
 800a6ac:	687b      	ldr	r3, [r7, #4]
 800a6ae:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800a6b0:	687a      	ldr	r2, [r7, #4]
 800a6b2:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 800a6b6:	687b      	ldr	r3, [r7, #4]
 800a6b8:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 800a6bc:	3b01      	subs	r3, #1
 800a6be:	b29a      	uxth	r2, r3
 800a6c0:	687b      	ldr	r3, [r7, #4]
 800a6c2:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 800a6c6:	687b      	ldr	r3, [r7, #4]
 800a6c8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a6ca:	60bb      	str	r3, [r7, #8]
      pcb->unacked = rseg->next;
 800a6cc:	68bb      	ldr	r3, [r7, #8]
 800a6ce:	681a      	ldr	r2, [r3, #0]
 800a6d0:	687b      	ldr	r3, [r7, #4]
 800a6d2:	679a      	str	r2, [r3, #120]	; 0x78

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 800a6d4:	687b      	ldr	r3, [r7, #4]
 800a6d6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a6d8:	2b00      	cmp	r3, #0
 800a6da:	d104      	bne.n	800a6e6 <tcp_process+0x206>
        pcb->rtime = -1;
 800a6dc:	687b      	ldr	r3, [r7, #4]
 800a6de:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a6e2:	86da      	strh	r2, [r3, #54]	; 0x36
 800a6e4:	e006      	b.n	800a6f4 <tcp_process+0x214>
      else {
        pcb->rtime = 0;
 800a6e6:	687b      	ldr	r3, [r7, #4]
 800a6e8:	2200      	movs	r2, #0
 800a6ea:	86da      	strh	r2, [r3, #54]	; 0x36
        pcb->nrtx = 0;
 800a6ec:	687b      	ldr	r3, [r7, #4]
 800a6ee:	2200      	movs	r2, #0
 800a6f0:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
      }

      tcp_seg_free(rseg);
 800a6f4:	68b8      	ldr	r0, [r7, #8]
 800a6f6:	f7fe ffff 	bl	80096f8 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800a6fa:	687b      	ldr	r3, [r7, #4]
 800a6fc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a700:	2b00      	cmp	r3, #0
 800a702:	d00a      	beq.n	800a71a <tcp_process+0x23a>
 800a704:	687b      	ldr	r3, [r7, #4]
 800a706:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a70a:	687a      	ldr	r2, [r7, #4]
 800a70c:	6950      	ldr	r0, [r2, #20]
 800a70e:	2200      	movs	r2, #0
 800a710:	6879      	ldr	r1, [r7, #4]
 800a712:	4798      	blx	r3
 800a714:	4603      	mov	r3, r0
 800a716:	73bb      	strb	r3, [r7, #14]
 800a718:	e001      	b.n	800a71e <tcp_process+0x23e>
 800a71a:	2300      	movs	r3, #0
 800a71c:	73bb      	strb	r3, [r7, #14]
      tcp_ack_now(pcb);
 800a71e:	687b      	ldr	r3, [r7, #4]
 800a720:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a724:	f043 0302 	orr.w	r3, r3, #2
 800a728:	b2da      	uxtb	r2, r3
 800a72a:	687b      	ldr	r3, [r7, #4]
 800a72c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800a730:	6878      	ldr	r0, [r7, #4]
 800a732:	f001 fb0b 	bl	800bd4c <tcp_output>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
 800a736:	e225      	b.n	800ab84 <tcp_process+0x6a4>
    else if (flags & TCP_ACK) {
 800a738:	4b12      	ldr	r3, [pc, #72]	; (800a784 <tcp_process+0x2a4>)
 800a73a:	781b      	ldrb	r3, [r3, #0]
 800a73c:	f003 0310 	and.w	r3, r3, #16
 800a740:	2b00      	cmp	r3, #0
 800a742:	f000 821f 	beq.w	800ab84 <tcp_process+0x6a4>
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a746:	4b10      	ldr	r3, [pc, #64]	; (800a788 <tcp_process+0x2a8>)
 800a748:	6818      	ldr	r0, [r3, #0]
 800a74a:	4b14      	ldr	r3, [pc, #80]	; (800a79c <tcp_process+0x2bc>)
 800a74c:	881b      	ldrh	r3, [r3, #0]
 800a74e:	461a      	mov	r2, r3
 800a750:	4b0e      	ldr	r3, [pc, #56]	; (800a78c <tcp_process+0x2ac>)
 800a752:	681b      	ldr	r3, [r3, #0]
 800a754:	18d1      	adds	r1, r2, r3
 800a756:	4b12      	ldr	r3, [pc, #72]	; (800a7a0 <tcp_process+0x2c0>)
 800a758:	681b      	ldr	r3, [r3, #0]
 800a75a:	f103 0410 	add.w	r4, r3, #16
 800a75e:	4b10      	ldr	r3, [pc, #64]	; (800a7a0 <tcp_process+0x2c0>)
 800a760:	681b      	ldr	r3, [r3, #0]
 800a762:	f103 050c 	add.w	r5, r3, #12
        tcphdr->dest, tcphdr->src);
 800a766:	4b0c      	ldr	r3, [pc, #48]	; (800a798 <tcp_process+0x2b8>)
 800a768:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a76a:	885b      	ldrh	r3, [r3, #2]
 800a76c:	b29b      	uxth	r3, r3
        tcphdr->dest, tcphdr->src);
 800a76e:	4a0a      	ldr	r2, [pc, #40]	; (800a798 <tcp_process+0x2b8>)
 800a770:	6812      	ldr	r2, [r2, #0]
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a772:	8812      	ldrh	r2, [r2, #0]
 800a774:	b292      	uxth	r2, r2
 800a776:	9201      	str	r2, [sp, #4]
 800a778:	9300      	str	r3, [sp, #0]
 800a77a:	462b      	mov	r3, r5
 800a77c:	4622      	mov	r2, r4
 800a77e:	f001 fd01 	bl	800c184 <tcp_rst>
    break;
 800a782:	e1ff      	b.n	800ab84 <tcp_process+0x6a4>
 800a784:	20007c5c 	.word	0x20007c5c
 800a788:	20007c58 	.word	0x20007c58
 800a78c:	20007c54 	.word	0x20007c54
 800a790:	20007c60 	.word	0x20007c60
 800a794:	2000a328 	.word	0x2000a328
 800a798:	20007c4c 	.word	0x20007c4c
 800a79c:	20007c5e 	.word	0x20007c5e
 800a7a0:	20007c50 	.word	0x20007c50
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 800a7a4:	4b98      	ldr	r3, [pc, #608]	; (800aa08 <tcp_process+0x528>)
 800a7a6:	781b      	ldrb	r3, [r3, #0]
 800a7a8:	f003 0310 	and.w	r3, r3, #16
 800a7ac:	2b00      	cmp	r3, #0
 800a7ae:	f000 8083 	beq.w	800a8b8 <tcp_process+0x3d8>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 800a7b2:	4b96      	ldr	r3, [pc, #600]	; (800aa0c <tcp_process+0x52c>)
 800a7b4:	681a      	ldr	r2, [r3, #0]
 800a7b6:	687b      	ldr	r3, [r7, #4]
 800a7b8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a7ba:	1ad3      	subs	r3, r2, r3
 800a7bc:	3b01      	subs	r3, #1
 800a7be:	2b00      	cmp	r3, #0
 800a7c0:	db5b      	blt.n	800a87a <tcp_process+0x39a>
 800a7c2:	4b92      	ldr	r3, [pc, #584]	; (800aa0c <tcp_process+0x52c>)
 800a7c4:	681a      	ldr	r2, [r3, #0]
 800a7c6:	687b      	ldr	r3, [r7, #4]
 800a7c8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a7ca:	1ad3      	subs	r3, r2, r3
 800a7cc:	2b00      	cmp	r3, #0
 800a7ce:	dc54      	bgt.n	800a87a <tcp_process+0x39a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 800a7d0:	687b      	ldr	r3, [r7, #4]
 800a7d2:	2204      	movs	r2, #4
 800a7d4:	741a      	strb	r2, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 800a7d6:	687b      	ldr	r3, [r7, #4]
 800a7d8:	69db      	ldr	r3, [r3, #28]
 800a7da:	2b00      	cmp	r3, #0
 800a7dc:	d009      	beq.n	800a7f2 <tcp_process+0x312>
 800a7de:	687b      	ldr	r3, [r7, #4]
 800a7e0:	69db      	ldr	r3, [r3, #28]
 800a7e2:	687a      	ldr	r2, [r7, #4]
 800a7e4:	6950      	ldr	r0, [r2, #20]
 800a7e6:	2200      	movs	r2, #0
 800a7e8:	6879      	ldr	r1, [r7, #4]
 800a7ea:	4798      	blx	r3
 800a7ec:	4603      	mov	r3, r0
 800a7ee:	73bb      	strb	r3, [r7, #14]
 800a7f0:	e001      	b.n	800a7f6 <tcp_process+0x316>
 800a7f2:	2300      	movs	r3, #0
 800a7f4:	73bb      	strb	r3, [r7, #14]
        if (err != ERR_OK) {
 800a7f6:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800a7fa:	2b00      	cmp	r3, #0
 800a7fc:	d006      	beq.n	800a80c <tcp_process+0x32c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
 800a7fe:	2101      	movs	r1, #1
 800a800:	6878      	ldr	r0, [r7, #4]
 800a802:	f7fe fa93 	bl	8008d2c <tcp_abandon>
          return ERR_ABRT;
 800a806:	f06f 0304 	mvn.w	r3, #4
 800a80a:	e1c9      	b.n	800aba0 <tcp_process+0x6c0>
        }
        old_cwnd = pcb->cwnd;
 800a80c:	687b      	ldr	r3, [r7, #4]
 800a80e:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800a812:	81bb      	strh	r3, [r7, #12]
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 800a814:	6878      	ldr	r0, [r7, #4]
 800a816:	f000 f9d3 	bl	800abc0 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
 800a81a:	687b      	ldr	r3, [r7, #4]
 800a81c:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800a820:	2b00      	cmp	r3, #0
 800a822:	d007      	beq.n	800a834 <tcp_process+0x354>
          pcb->acked--;
 800a824:	687b      	ldr	r3, [r7, #4]
 800a826:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800a82a:	3b01      	subs	r3, #1
 800a82c:	b29a      	uxth	r2, r3
 800a82e:	687b      	ldr	r3, [r7, #4]
 800a830:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800a834:	89bb      	ldrh	r3, [r7, #12]
 800a836:	2b01      	cmp	r3, #1
 800a838:	d104      	bne.n	800a844 <tcp_process+0x364>
 800a83a:	687b      	ldr	r3, [r7, #4]
 800a83c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800a83e:	005b      	lsls	r3, r3, #1
 800a840:	b29b      	uxth	r3, r3
 800a842:	e001      	b.n	800a848 <tcp_process+0x368>
 800a844:	687b      	ldr	r3, [r7, #4]
 800a846:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800a848:	687a      	ldr	r2, [r7, #4]
 800a84a:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52

        if (recv_flags & TF_GOT_FIN) {
 800a84e:	4b70      	ldr	r3, [pc, #448]	; (800aa10 <tcp_process+0x530>)
 800a850:	781b      	ldrb	r3, [r3, #0]
 800a852:	f003 0320 	and.w	r3, r3, #32
 800a856:	2b00      	cmp	r3, #0
 800a858:	d041      	beq.n	800a8de <tcp_process+0x3fe>
          tcp_ack_now(pcb);
 800a85a:	687b      	ldr	r3, [r7, #4]
 800a85c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a860:	f043 0302 	orr.w	r3, r3, #2
 800a864:	b2da      	uxtb	r2, r3
 800a866:	687b      	ldr	r3, [r7, #4]
 800a868:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800a86c:	6878      	ldr	r0, [r7, #4]
 800a86e:	f001 fa6d 	bl	800bd4c <tcp_output>
          pcb->state = CLOSE_WAIT;
 800a872:	687b      	ldr	r3, [r7, #4]
 800a874:	2207      	movs	r2, #7
 800a876:	741a      	strb	r2, [r3, #16]
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 800a878:	e031      	b.n	800a8de <tcp_process+0x3fe>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a87a:	4b64      	ldr	r3, [pc, #400]	; (800aa0c <tcp_process+0x52c>)
 800a87c:	6818      	ldr	r0, [r3, #0]
 800a87e:	4b65      	ldr	r3, [pc, #404]	; (800aa14 <tcp_process+0x534>)
 800a880:	881b      	ldrh	r3, [r3, #0]
 800a882:	461a      	mov	r2, r3
 800a884:	4b64      	ldr	r3, [pc, #400]	; (800aa18 <tcp_process+0x538>)
 800a886:	681b      	ldr	r3, [r3, #0]
 800a888:	18d1      	adds	r1, r2, r3
 800a88a:	4b64      	ldr	r3, [pc, #400]	; (800aa1c <tcp_process+0x53c>)
 800a88c:	681b      	ldr	r3, [r3, #0]
 800a88e:	f103 0410 	add.w	r4, r3, #16
 800a892:	4b62      	ldr	r3, [pc, #392]	; (800aa1c <tcp_process+0x53c>)
 800a894:	681b      	ldr	r3, [r3, #0]
 800a896:	f103 050c 	add.w	r5, r3, #12
                tcphdr->dest, tcphdr->src);
 800a89a:	4b61      	ldr	r3, [pc, #388]	; (800aa20 <tcp_process+0x540>)
 800a89c:	681b      	ldr	r3, [r3, #0]
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a89e:	885b      	ldrh	r3, [r3, #2]
 800a8a0:	b29b      	uxth	r3, r3
                tcphdr->dest, tcphdr->src);
 800a8a2:	4a5f      	ldr	r2, [pc, #380]	; (800aa20 <tcp_process+0x540>)
 800a8a4:	6812      	ldr	r2, [r2, #0]
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 800a8a6:	8812      	ldrh	r2, [r2, #0]
 800a8a8:	b292      	uxth	r2, r2
 800a8aa:	9201      	str	r2, [sp, #4]
 800a8ac:	9300      	str	r3, [sp, #0]
 800a8ae:	462b      	mov	r3, r5
 800a8b0:	4622      	mov	r2, r4
 800a8b2:	f001 fc67 	bl	800c184 <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 800a8b6:	e167      	b.n	800ab88 <tcp_process+0x6a8>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800a8b8:	4b53      	ldr	r3, [pc, #332]	; (800aa08 <tcp_process+0x528>)
 800a8ba:	781b      	ldrb	r3, [r3, #0]
 800a8bc:	f003 0302 	and.w	r3, r3, #2
 800a8c0:	2b00      	cmp	r3, #0
 800a8c2:	f000 8161 	beq.w	800ab88 <tcp_process+0x6a8>
 800a8c6:	687b      	ldr	r3, [r7, #4]
 800a8c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a8ca:	1e5a      	subs	r2, r3, #1
 800a8cc:	4b52      	ldr	r3, [pc, #328]	; (800aa18 <tcp_process+0x538>)
 800a8ce:	681b      	ldr	r3, [r3, #0]
 800a8d0:	429a      	cmp	r2, r3
 800a8d2:	f040 8159 	bne.w	800ab88 <tcp_process+0x6a8>
      tcp_rexmit(pcb);
 800a8d6:	6878      	ldr	r0, [r7, #4]
 800a8d8:	f001 fcfe 	bl	800c2d8 <tcp_rexmit>
    break;
 800a8dc:	e154      	b.n	800ab88 <tcp_process+0x6a8>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 800a8de:	bf00      	nop
    break;
 800a8e0:	e152      	b.n	800ab88 <tcp_process+0x6a8>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 800a8e2:	6878      	ldr	r0, [r7, #4]
 800a8e4:	f000 f96c 	bl	800abc0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 800a8e8:	4b49      	ldr	r3, [pc, #292]	; (800aa10 <tcp_process+0x530>)
 800a8ea:	781b      	ldrb	r3, [r3, #0]
 800a8ec:	f003 0320 	and.w	r3, r3, #32
 800a8f0:	2b00      	cmp	r3, #0
 800a8f2:	f000 814b 	beq.w	800ab8c <tcp_process+0x6ac>
      tcp_ack_now(pcb);
 800a8f6:	687b      	ldr	r3, [r7, #4]
 800a8f8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a8fc:	f043 0302 	orr.w	r3, r3, #2
 800a900:	b2da      	uxtb	r2, r3
 800a902:	687b      	ldr	r3, [r7, #4]
 800a904:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800a908:	6878      	ldr	r0, [r7, #4]
 800a90a:	f001 fa1f 	bl	800bd4c <tcp_output>
      pcb->state = CLOSE_WAIT;
 800a90e:	687b      	ldr	r3, [r7, #4]
 800a910:	2207      	movs	r2, #7
 800a912:	741a      	strb	r2, [r3, #16]
    }
    break;
 800a914:	e13a      	b.n	800ab8c <tcp_process+0x6ac>
  case FIN_WAIT_1:
    tcp_receive(pcb);
 800a916:	6878      	ldr	r0, [r7, #4]
 800a918:	f000 f952 	bl	800abc0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800a91c:	4b3c      	ldr	r3, [pc, #240]	; (800aa10 <tcp_process+0x530>)
 800a91e:	781b      	ldrb	r3, [r3, #0]
 800a920:	f003 0320 	and.w	r3, r3, #32
 800a924:	2b00      	cmp	r3, #0
 800a926:	d05d      	beq.n	800a9e4 <tcp_process+0x504>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 800a928:	4b37      	ldr	r3, [pc, #220]	; (800aa08 <tcp_process+0x528>)
 800a92a:	781b      	ldrb	r3, [r3, #0]
 800a92c:	f003 0310 	and.w	r3, r3, #16
 800a930:	2b00      	cmp	r3, #0
 800a932:	d047      	beq.n	800a9c4 <tcp_process+0x4e4>
 800a934:	687b      	ldr	r3, [r7, #4]
 800a936:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a938:	4b34      	ldr	r3, [pc, #208]	; (800aa0c <tcp_process+0x52c>)
 800a93a:	681b      	ldr	r3, [r3, #0]
 800a93c:	429a      	cmp	r2, r3
 800a93e:	d141      	bne.n	800a9c4 <tcp_process+0x4e4>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 800a940:	687b      	ldr	r3, [r7, #4]
 800a942:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a946:	f043 0302 	orr.w	r3, r3, #2
 800a94a:	b2da      	uxtb	r2, r3
 800a94c:	687b      	ldr	r3, [r7, #4]
 800a94e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800a952:	6878      	ldr	r0, [r7, #4]
 800a954:	f001 f9fa 	bl	800bd4c <tcp_output>
        tcp_pcb_purge(pcb);
 800a958:	6878      	ldr	r0, [r7, #4]
 800a95a:	f7ff f87d 	bl	8009a58 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
 800a95e:	4b31      	ldr	r3, [pc, #196]	; (800aa24 <tcp_process+0x544>)
 800a960:	681a      	ldr	r2, [r3, #0]
 800a962:	687b      	ldr	r3, [r7, #4]
 800a964:	429a      	cmp	r2, r3
 800a966:	d105      	bne.n	800a974 <tcp_process+0x494>
 800a968:	4b2e      	ldr	r3, [pc, #184]	; (800aa24 <tcp_process+0x544>)
 800a96a:	681b      	ldr	r3, [r3, #0]
 800a96c:	68db      	ldr	r3, [r3, #12]
 800a96e:	4a2d      	ldr	r2, [pc, #180]	; (800aa24 <tcp_process+0x544>)
 800a970:	6013      	str	r3, [r2, #0]
 800a972:	e019      	b.n	800a9a8 <tcp_process+0x4c8>
 800a974:	4b2b      	ldr	r3, [pc, #172]	; (800aa24 <tcp_process+0x544>)
 800a976:	681b      	ldr	r3, [r3, #0]
 800a978:	4a2b      	ldr	r2, [pc, #172]	; (800aa28 <tcp_process+0x548>)
 800a97a:	6013      	str	r3, [r2, #0]
 800a97c:	e010      	b.n	800a9a0 <tcp_process+0x4c0>
 800a97e:	4b2a      	ldr	r3, [pc, #168]	; (800aa28 <tcp_process+0x548>)
 800a980:	681b      	ldr	r3, [r3, #0]
 800a982:	68da      	ldr	r2, [r3, #12]
 800a984:	687b      	ldr	r3, [r7, #4]
 800a986:	429a      	cmp	r2, r3
 800a988:	d105      	bne.n	800a996 <tcp_process+0x4b6>
 800a98a:	4b27      	ldr	r3, [pc, #156]	; (800aa28 <tcp_process+0x548>)
 800a98c:	681b      	ldr	r3, [r3, #0]
 800a98e:	687a      	ldr	r2, [r7, #4]
 800a990:	68d2      	ldr	r2, [r2, #12]
 800a992:	60da      	str	r2, [r3, #12]
 800a994:	e008      	b.n	800a9a8 <tcp_process+0x4c8>
 800a996:	4b24      	ldr	r3, [pc, #144]	; (800aa28 <tcp_process+0x548>)
 800a998:	681b      	ldr	r3, [r3, #0]
 800a99a:	68db      	ldr	r3, [r3, #12]
 800a99c:	4a22      	ldr	r2, [pc, #136]	; (800aa28 <tcp_process+0x548>)
 800a99e:	6013      	str	r3, [r2, #0]
 800a9a0:	4b21      	ldr	r3, [pc, #132]	; (800aa28 <tcp_process+0x548>)
 800a9a2:	681b      	ldr	r3, [r3, #0]
 800a9a4:	2b00      	cmp	r3, #0
 800a9a6:	d1ea      	bne.n	800a97e <tcp_process+0x49e>
 800a9a8:	687b      	ldr	r3, [r7, #4]
 800a9aa:	2200      	movs	r2, #0
 800a9ac:	60da      	str	r2, [r3, #12]
        pcb->state = TIME_WAIT;
 800a9ae:	687b      	ldr	r3, [r7, #4]
 800a9b0:	220a      	movs	r2, #10
 800a9b2:	741a      	strb	r2, [r3, #16]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800a9b4:	4b1d      	ldr	r3, [pc, #116]	; (800aa2c <tcp_process+0x54c>)
 800a9b6:	681a      	ldr	r2, [r3, #0]
 800a9b8:	687b      	ldr	r3, [r7, #4]
 800a9ba:	60da      	str	r2, [r3, #12]
 800a9bc:	4a1b      	ldr	r2, [pc, #108]	; (800aa2c <tcp_process+0x54c>)
 800a9be:	687b      	ldr	r3, [r7, #4]
 800a9c0:	6013      	str	r3, [r2, #0]
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 800a9c2:	e0e5      	b.n	800ab90 <tcp_process+0x6b0>
        tcp_ack_now(pcb);
 800a9c4:	687b      	ldr	r3, [r7, #4]
 800a9c6:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a9ca:	f043 0302 	orr.w	r3, r3, #2
 800a9ce:	b2da      	uxtb	r2, r3
 800a9d0:	687b      	ldr	r3, [r7, #4]
 800a9d2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800a9d6:	6878      	ldr	r0, [r7, #4]
 800a9d8:	f001 f9b8 	bl	800bd4c <tcp_output>
        pcb->state = CLOSING;
 800a9dc:	687b      	ldr	r3, [r7, #4]
 800a9de:	2208      	movs	r2, #8
 800a9e0:	741a      	strb	r2, [r3, #16]
    break;
 800a9e2:	e0d5      	b.n	800ab90 <tcp_process+0x6b0>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 800a9e4:	4b08      	ldr	r3, [pc, #32]	; (800aa08 <tcp_process+0x528>)
 800a9e6:	781b      	ldrb	r3, [r3, #0]
 800a9e8:	f003 0310 	and.w	r3, r3, #16
 800a9ec:	2b00      	cmp	r3, #0
 800a9ee:	f000 80cf 	beq.w	800ab90 <tcp_process+0x6b0>
 800a9f2:	687b      	ldr	r3, [r7, #4]
 800a9f4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a9f6:	4b05      	ldr	r3, [pc, #20]	; (800aa0c <tcp_process+0x52c>)
 800a9f8:	681b      	ldr	r3, [r3, #0]
 800a9fa:	429a      	cmp	r2, r3
 800a9fc:	f040 80c8 	bne.w	800ab90 <tcp_process+0x6b0>
      pcb->state = FIN_WAIT_2;
 800aa00:	687b      	ldr	r3, [r7, #4]
 800aa02:	2206      	movs	r2, #6
 800aa04:	741a      	strb	r2, [r3, #16]
    break;
 800aa06:	e0c3      	b.n	800ab90 <tcp_process+0x6b0>
 800aa08:	20007c5c 	.word	0x20007c5c
 800aa0c:	20007c58 	.word	0x20007c58
 800aa10:	20007c60 	.word	0x20007c60
 800aa14:	20007c5e 	.word	0x20007c5e
 800aa18:	20007c54 	.word	0x20007c54
 800aa1c:	20007c50 	.word	0x20007c50
 800aa20:	20007c4c 	.word	0x20007c4c
 800aa24:	2000a324 	.word	0x2000a324
 800aa28:	2000a330 	.word	0x2000a330
 800aa2c:	2000a338 	.word	0x2000a338
  case FIN_WAIT_2:
    tcp_receive(pcb);
 800aa30:	6878      	ldr	r0, [r7, #4]
 800aa32:	f000 f8c5 	bl	800abc0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800aa36:	4b5c      	ldr	r3, [pc, #368]	; (800aba8 <tcp_process+0x6c8>)
 800aa38:	781b      	ldrb	r3, [r3, #0]
 800aa3a:	f003 0320 	and.w	r3, r3, #32
 800aa3e:	2b00      	cmp	r3, #0
 800aa40:	f000 80a8 	beq.w	800ab94 <tcp_process+0x6b4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 800aa44:	687b      	ldr	r3, [r7, #4]
 800aa46:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800aa4a:	f043 0302 	orr.w	r3, r3, #2
 800aa4e:	b2da      	uxtb	r2, r3
 800aa50:	687b      	ldr	r3, [r7, #4]
 800aa52:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800aa56:	6878      	ldr	r0, [r7, #4]
 800aa58:	f001 f978 	bl	800bd4c <tcp_output>
      tcp_pcb_purge(pcb);
 800aa5c:	6878      	ldr	r0, [r7, #4]
 800aa5e:	f7fe fffb 	bl	8009a58 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
 800aa62:	4b52      	ldr	r3, [pc, #328]	; (800abac <tcp_process+0x6cc>)
 800aa64:	681a      	ldr	r2, [r3, #0]
 800aa66:	687b      	ldr	r3, [r7, #4]
 800aa68:	429a      	cmp	r2, r3
 800aa6a:	d105      	bne.n	800aa78 <tcp_process+0x598>
 800aa6c:	4b4f      	ldr	r3, [pc, #316]	; (800abac <tcp_process+0x6cc>)
 800aa6e:	681b      	ldr	r3, [r3, #0]
 800aa70:	68db      	ldr	r3, [r3, #12]
 800aa72:	4a4e      	ldr	r2, [pc, #312]	; (800abac <tcp_process+0x6cc>)
 800aa74:	6013      	str	r3, [r2, #0]
 800aa76:	e019      	b.n	800aaac <tcp_process+0x5cc>
 800aa78:	4b4c      	ldr	r3, [pc, #304]	; (800abac <tcp_process+0x6cc>)
 800aa7a:	681b      	ldr	r3, [r3, #0]
 800aa7c:	4a4c      	ldr	r2, [pc, #304]	; (800abb0 <tcp_process+0x6d0>)
 800aa7e:	6013      	str	r3, [r2, #0]
 800aa80:	e010      	b.n	800aaa4 <tcp_process+0x5c4>
 800aa82:	4b4b      	ldr	r3, [pc, #300]	; (800abb0 <tcp_process+0x6d0>)
 800aa84:	681b      	ldr	r3, [r3, #0]
 800aa86:	68da      	ldr	r2, [r3, #12]
 800aa88:	687b      	ldr	r3, [r7, #4]
 800aa8a:	429a      	cmp	r2, r3
 800aa8c:	d105      	bne.n	800aa9a <tcp_process+0x5ba>
 800aa8e:	4b48      	ldr	r3, [pc, #288]	; (800abb0 <tcp_process+0x6d0>)
 800aa90:	681b      	ldr	r3, [r3, #0]
 800aa92:	687a      	ldr	r2, [r7, #4]
 800aa94:	68d2      	ldr	r2, [r2, #12]
 800aa96:	60da      	str	r2, [r3, #12]
 800aa98:	e008      	b.n	800aaac <tcp_process+0x5cc>
 800aa9a:	4b45      	ldr	r3, [pc, #276]	; (800abb0 <tcp_process+0x6d0>)
 800aa9c:	681b      	ldr	r3, [r3, #0]
 800aa9e:	68db      	ldr	r3, [r3, #12]
 800aaa0:	4a43      	ldr	r2, [pc, #268]	; (800abb0 <tcp_process+0x6d0>)
 800aaa2:	6013      	str	r3, [r2, #0]
 800aaa4:	4b42      	ldr	r3, [pc, #264]	; (800abb0 <tcp_process+0x6d0>)
 800aaa6:	681b      	ldr	r3, [r3, #0]
 800aaa8:	2b00      	cmp	r3, #0
 800aaaa:	d1ea      	bne.n	800aa82 <tcp_process+0x5a2>
 800aaac:	687b      	ldr	r3, [r7, #4]
 800aaae:	2200      	movs	r2, #0
 800aab0:	60da      	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
 800aab2:	687b      	ldr	r3, [r7, #4]
 800aab4:	220a      	movs	r2, #10
 800aab6:	741a      	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
 800aab8:	4b3e      	ldr	r3, [pc, #248]	; (800abb4 <tcp_process+0x6d4>)
 800aaba:	681a      	ldr	r2, [r3, #0]
 800aabc:	687b      	ldr	r3, [r7, #4]
 800aabe:	60da      	str	r2, [r3, #12]
 800aac0:	4a3c      	ldr	r2, [pc, #240]	; (800abb4 <tcp_process+0x6d4>)
 800aac2:	687b      	ldr	r3, [r7, #4]
 800aac4:	6013      	str	r3, [r2, #0]
    }
    break;
 800aac6:	e065      	b.n	800ab94 <tcp_process+0x6b4>
  case CLOSING:
    tcp_receive(pcb);
 800aac8:	6878      	ldr	r0, [r7, #4]
 800aaca:	f000 f879 	bl	800abc0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 800aace:	4b3a      	ldr	r3, [pc, #232]	; (800abb8 <tcp_process+0x6d8>)
 800aad0:	781b      	ldrb	r3, [r3, #0]
 800aad2:	f003 0310 	and.w	r3, r3, #16
 800aad6:	2b00      	cmp	r3, #0
 800aad8:	d05e      	beq.n	800ab98 <tcp_process+0x6b8>
 800aada:	687b      	ldr	r3, [r7, #4]
 800aadc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800aade:	4b37      	ldr	r3, [pc, #220]	; (800abbc <tcp_process+0x6dc>)
 800aae0:	681b      	ldr	r3, [r3, #0]
 800aae2:	429a      	cmp	r2, r3
 800aae4:	d158      	bne.n	800ab98 <tcp_process+0x6b8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 800aae6:	6878      	ldr	r0, [r7, #4]
 800aae8:	f7fe ffb6 	bl	8009a58 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
 800aaec:	4b2f      	ldr	r3, [pc, #188]	; (800abac <tcp_process+0x6cc>)
 800aaee:	681a      	ldr	r2, [r3, #0]
 800aaf0:	687b      	ldr	r3, [r7, #4]
 800aaf2:	429a      	cmp	r2, r3
 800aaf4:	d105      	bne.n	800ab02 <tcp_process+0x622>
 800aaf6:	4b2d      	ldr	r3, [pc, #180]	; (800abac <tcp_process+0x6cc>)
 800aaf8:	681b      	ldr	r3, [r3, #0]
 800aafa:	68db      	ldr	r3, [r3, #12]
 800aafc:	4a2b      	ldr	r2, [pc, #172]	; (800abac <tcp_process+0x6cc>)
 800aafe:	6013      	str	r3, [r2, #0]
 800ab00:	e019      	b.n	800ab36 <tcp_process+0x656>
 800ab02:	4b2a      	ldr	r3, [pc, #168]	; (800abac <tcp_process+0x6cc>)
 800ab04:	681b      	ldr	r3, [r3, #0]
 800ab06:	4a2a      	ldr	r2, [pc, #168]	; (800abb0 <tcp_process+0x6d0>)
 800ab08:	6013      	str	r3, [r2, #0]
 800ab0a:	e010      	b.n	800ab2e <tcp_process+0x64e>
 800ab0c:	4b28      	ldr	r3, [pc, #160]	; (800abb0 <tcp_process+0x6d0>)
 800ab0e:	681b      	ldr	r3, [r3, #0]
 800ab10:	68da      	ldr	r2, [r3, #12]
 800ab12:	687b      	ldr	r3, [r7, #4]
 800ab14:	429a      	cmp	r2, r3
 800ab16:	d105      	bne.n	800ab24 <tcp_process+0x644>
 800ab18:	4b25      	ldr	r3, [pc, #148]	; (800abb0 <tcp_process+0x6d0>)
 800ab1a:	681b      	ldr	r3, [r3, #0]
 800ab1c:	687a      	ldr	r2, [r7, #4]
 800ab1e:	68d2      	ldr	r2, [r2, #12]
 800ab20:	60da      	str	r2, [r3, #12]
 800ab22:	e008      	b.n	800ab36 <tcp_process+0x656>
 800ab24:	4b22      	ldr	r3, [pc, #136]	; (800abb0 <tcp_process+0x6d0>)
 800ab26:	681b      	ldr	r3, [r3, #0]
 800ab28:	68db      	ldr	r3, [r3, #12]
 800ab2a:	4a21      	ldr	r2, [pc, #132]	; (800abb0 <tcp_process+0x6d0>)
 800ab2c:	6013      	str	r3, [r2, #0]
 800ab2e:	4b20      	ldr	r3, [pc, #128]	; (800abb0 <tcp_process+0x6d0>)
 800ab30:	681b      	ldr	r3, [r3, #0]
 800ab32:	2b00      	cmp	r3, #0
 800ab34:	d1ea      	bne.n	800ab0c <tcp_process+0x62c>
 800ab36:	687b      	ldr	r3, [r7, #4]
 800ab38:	2200      	movs	r2, #0
 800ab3a:	60da      	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
 800ab3c:	687b      	ldr	r3, [r7, #4]
 800ab3e:	220a      	movs	r2, #10
 800ab40:	741a      	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
 800ab42:	4b1c      	ldr	r3, [pc, #112]	; (800abb4 <tcp_process+0x6d4>)
 800ab44:	681a      	ldr	r2, [r3, #0]
 800ab46:	687b      	ldr	r3, [r7, #4]
 800ab48:	60da      	str	r2, [r3, #12]
 800ab4a:	4a1a      	ldr	r2, [pc, #104]	; (800abb4 <tcp_process+0x6d4>)
 800ab4c:	687b      	ldr	r3, [r7, #4]
 800ab4e:	6013      	str	r3, [r2, #0]
    }
    break;
 800ab50:	e022      	b.n	800ab98 <tcp_process+0x6b8>
  case LAST_ACK:
    tcp_receive(pcb);
 800ab52:	6878      	ldr	r0, [r7, #4]
 800ab54:	f000 f834 	bl	800abc0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 800ab58:	4b17      	ldr	r3, [pc, #92]	; (800abb8 <tcp_process+0x6d8>)
 800ab5a:	781b      	ldrb	r3, [r3, #0]
 800ab5c:	f003 0310 	and.w	r3, r3, #16
 800ab60:	2b00      	cmp	r3, #0
 800ab62:	d01b      	beq.n	800ab9c <tcp_process+0x6bc>
 800ab64:	687b      	ldr	r3, [r7, #4]
 800ab66:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800ab68:	4b14      	ldr	r3, [pc, #80]	; (800abbc <tcp_process+0x6dc>)
 800ab6a:	681b      	ldr	r3, [r3, #0]
 800ab6c:	429a      	cmp	r2, r3
 800ab6e:	d115      	bne.n	800ab9c <tcp_process+0x6bc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 800ab70:	4b0d      	ldr	r3, [pc, #52]	; (800aba8 <tcp_process+0x6c8>)
 800ab72:	781b      	ldrb	r3, [r3, #0]
 800ab74:	f043 0310 	orr.w	r3, r3, #16
 800ab78:	b2da      	uxtb	r2, r3
 800ab7a:	4b0b      	ldr	r3, [pc, #44]	; (800aba8 <tcp_process+0x6c8>)
 800ab7c:	701a      	strb	r2, [r3, #0]
    }
    break;
 800ab7e:	e00d      	b.n	800ab9c <tcp_process+0x6bc>
  default:
    break;
 800ab80:	bf00      	nop
 800ab82:	e00c      	b.n	800ab9e <tcp_process+0x6be>
    break;
 800ab84:	bf00      	nop
 800ab86:	e00a      	b.n	800ab9e <tcp_process+0x6be>
    break;
 800ab88:	bf00      	nop
 800ab8a:	e008      	b.n	800ab9e <tcp_process+0x6be>
    break;
 800ab8c:	bf00      	nop
 800ab8e:	e006      	b.n	800ab9e <tcp_process+0x6be>
    break;
 800ab90:	bf00      	nop
 800ab92:	e004      	b.n	800ab9e <tcp_process+0x6be>
    break;
 800ab94:	bf00      	nop
 800ab96:	e002      	b.n	800ab9e <tcp_process+0x6be>
    break;
 800ab98:	bf00      	nop
 800ab9a:	e000      	b.n	800ab9e <tcp_process+0x6be>
    break;
 800ab9c:	bf00      	nop
  }
  return ERR_OK;
 800ab9e:	2300      	movs	r3, #0
}
 800aba0:	4618      	mov	r0, r3
 800aba2:	3710      	adds	r7, #16
 800aba4:	46bd      	mov	sp, r7
 800aba6:	bdb0      	pop	{r4, r5, r7, pc}
 800aba8:	20007c60 	.word	0x20007c60
 800abac:	2000a324 	.word	0x2000a324
 800abb0:	2000a330 	.word	0x2000a330
 800abb4:	2000a338 	.word	0x2000a338
 800abb8:	20007c5c 	.word	0x20007c5c
 800abbc:	20007c58 	.word	0x20007c58

0800abc0 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 800abc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800abc2:	b08b      	sub	sp, #44	; 0x2c
 800abc4:	af00      	add	r7, sp, #0
 800abc6:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
 800abc8:	2300      	movs	r3, #0
 800abca:	61bb      	str	r3, [r7, #24]

  if (flags & TCP_ACK) {
 800abcc:	4ba5      	ldr	r3, [pc, #660]	; (800ae64 <tcp_receive+0x2a4>)
 800abce:	781b      	ldrb	r3, [r3, #0]
 800abd0:	f003 0310 	and.w	r3, r3, #16
 800abd4:	2b00      	cmp	r3, #0
 800abd6:	f000 8295 	beq.w	800b104 <tcp_receive+0x544>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800abda:	687b      	ldr	r3, [r7, #4]
 800abdc:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800abe0:	461a      	mov	r2, r3
 800abe2:	687b      	ldr	r3, [r7, #4]
 800abe4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800abe6:	4413      	add	r3, r2
 800abe8:	617b      	str	r3, [r7, #20]

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800abea:	687b      	ldr	r3, [r7, #4]
 800abec:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800abee:	4b9e      	ldr	r3, [pc, #632]	; (800ae68 <tcp_receive+0x2a8>)
 800abf0:	681b      	ldr	r3, [r3, #0]
 800abf2:	1ad3      	subs	r3, r2, r3
 800abf4:	2b00      	cmp	r3, #0
 800abf6:	db1b      	blt.n	800ac30 <tcp_receive+0x70>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800abf8:	687b      	ldr	r3, [r7, #4]
 800abfa:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800abfc:	4b9a      	ldr	r3, [pc, #616]	; (800ae68 <tcp_receive+0x2a8>)
 800abfe:	681b      	ldr	r3, [r3, #0]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800ac00:	429a      	cmp	r2, r3
 800ac02:	d106      	bne.n	800ac12 <tcp_receive+0x52>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800ac04:	687b      	ldr	r3, [r7, #4]
 800ac06:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800ac08:	4b98      	ldr	r3, [pc, #608]	; (800ae6c <tcp_receive+0x2ac>)
 800ac0a:	681b      	ldr	r3, [r3, #0]
 800ac0c:	1ad3      	subs	r3, r2, r3
 800ac0e:	2b00      	cmp	r3, #0
 800ac10:	db0e      	blt.n	800ac30 <tcp_receive+0x70>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 800ac12:	687b      	ldr	r3, [r7, #4]
 800ac14:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800ac16:	4b95      	ldr	r3, [pc, #596]	; (800ae6c <tcp_receive+0x2ac>)
 800ac18:	681b      	ldr	r3, [r3, #0]
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800ac1a:	429a      	cmp	r2, r3
 800ac1c:	d125      	bne.n	800ac6a <tcp_receive+0xaa>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 800ac1e:	4b94      	ldr	r3, [pc, #592]	; (800ae70 <tcp_receive+0x2b0>)
 800ac20:	681b      	ldr	r3, [r3, #0]
 800ac22:	89db      	ldrh	r3, [r3, #14]
 800ac24:	b29a      	uxth	r2, r3
 800ac26:	687b      	ldr	r3, [r7, #4]
 800ac28:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800ac2c:	429a      	cmp	r2, r3
 800ac2e:	d91c      	bls.n	800ac6a <tcp_receive+0xaa>
      pcb->snd_wnd = tcphdr->wnd;
 800ac30:	4b8f      	ldr	r3, [pc, #572]	; (800ae70 <tcp_receive+0x2b0>)
 800ac32:	681b      	ldr	r3, [r3, #0]
 800ac34:	89db      	ldrh	r3, [r3, #14]
 800ac36:	b29a      	uxth	r2, r3
 800ac38:	687b      	ldr	r3, [r7, #4]
 800ac3a:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
      pcb->snd_wl1 = seqno;
 800ac3e:	4b8a      	ldr	r3, [pc, #552]	; (800ae68 <tcp_receive+0x2a8>)
 800ac40:	681a      	ldr	r2, [r3, #0]
 800ac42:	687b      	ldr	r3, [r7, #4]
 800ac44:	661a      	str	r2, [r3, #96]	; 0x60
      pcb->snd_wl2 = ackno;
 800ac46:	4b89      	ldr	r3, [pc, #548]	; (800ae6c <tcp_receive+0x2ac>)
 800ac48:	681a      	ldr	r2, [r3, #0]
 800ac4a:	687b      	ldr	r3, [r7, #4]
 800ac4c:	665a      	str	r2, [r3, #100]	; 0x64
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
 800ac4e:	687b      	ldr	r3, [r7, #4]
 800ac50:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800ac54:	2b00      	cmp	r3, #0
 800ac56:	d008      	beq.n	800ac6a <tcp_receive+0xaa>
 800ac58:	687b      	ldr	r3, [r7, #4]
 800ac5a:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 800ac5e:	2b00      	cmp	r3, #0
 800ac60:	d003      	beq.n	800ac6a <tcp_receive+0xaa>
          pcb->persist_backoff = 0;
 800ac62:	687b      	ldr	r3, [r7, #4]
 800ac64:	2200      	movs	r2, #0
 800ac66:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800ac6a:	4b80      	ldr	r3, [pc, #512]	; (800ae6c <tcp_receive+0x2ac>)
 800ac6c:	681a      	ldr	r2, [r3, #0]
 800ac6e:	687b      	ldr	r3, [r7, #4]
 800ac70:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ac72:	1ad3      	subs	r3, r2, r3
 800ac74:	2b00      	cmp	r3, #0
 800ac76:	dc5b      	bgt.n	800ad30 <tcp_receive+0x170>
      pcb->acked = 0;
 800ac78:	687b      	ldr	r3, [r7, #4]
 800ac7a:	2200      	movs	r2, #0
 800ac7c:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
      /* Clause 2 */
      if (tcplen == 0) {
 800ac80:	4b7c      	ldr	r3, [pc, #496]	; (800ae74 <tcp_receive+0x2b4>)
 800ac82:	881b      	ldrh	r3, [r3, #0]
 800ac84:	2b00      	cmp	r3, #0
 800ac86:	d14a      	bne.n	800ad1e <tcp_receive+0x15e>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 800ac88:	687b      	ldr	r3, [r7, #4]
 800ac8a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800ac8c:	687a      	ldr	r2, [r7, #4]
 800ac8e:	f8b2 205c 	ldrh.w	r2, [r2, #92]	; 0x5c
 800ac92:	441a      	add	r2, r3
 800ac94:	697b      	ldr	r3, [r7, #20]
 800ac96:	429a      	cmp	r2, r3
 800ac98:	d141      	bne.n	800ad1e <tcp_receive+0x15e>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 800ac9a:	687b      	ldr	r3, [r7, #4]
 800ac9c:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 800aca0:	2b00      	cmp	r3, #0
 800aca2:	db3c      	blt.n	800ad1e <tcp_receive+0x15e>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 800aca4:	687b      	ldr	r3, [r7, #4]
 800aca6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800aca8:	4b70      	ldr	r3, [pc, #448]	; (800ae6c <tcp_receive+0x2ac>)
 800acaa:	681b      	ldr	r3, [r3, #0]
 800acac:	429a      	cmp	r2, r3
 800acae:	d136      	bne.n	800ad1e <tcp_receive+0x15e>
              found_dupack = 1;
 800acb0:	2301      	movs	r3, #1
 800acb2:	61bb      	str	r3, [r7, #24]
              if (pcb->dupacks + 1 > pcb->dupacks)
 800acb4:	687b      	ldr	r3, [r7, #4]
 800acb6:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800acba:	3301      	adds	r3, #1
 800acbc:	687a      	ldr	r2, [r7, #4]
 800acbe:	f892 2050 	ldrb.w	r2, [r2, #80]	; 0x50
 800acc2:	4293      	cmp	r3, r2
 800acc4:	dd07      	ble.n	800acd6 <tcp_receive+0x116>
                ++pcb->dupacks;
 800acc6:	687b      	ldr	r3, [r7, #4]
 800acc8:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800accc:	3301      	adds	r3, #1
 800acce:	b2da      	uxtb	r2, r3
 800acd0:	687b      	ldr	r3, [r7, #4]
 800acd2:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
              if (pcb->dupacks > 3) {
 800acd6:	687b      	ldr	r3, [r7, #4]
 800acd8:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800acdc:	2b03      	cmp	r3, #3
 800acde:	d916      	bls.n	800ad0e <tcp_receive+0x14e>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800ace0:	687b      	ldr	r3, [r7, #4]
 800ace2:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800ace6:	687b      	ldr	r3, [r7, #4]
 800ace8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800acea:	4413      	add	r3, r2
 800acec:	b29a      	uxth	r2, r3
 800acee:	687b      	ldr	r3, [r7, #4]
 800acf0:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800acf4:	429a      	cmp	r2, r3
 800acf6:	d912      	bls.n	800ad1e <tcp_receive+0x15e>
                  pcb->cwnd += pcb->mss;
 800acf8:	687b      	ldr	r3, [r7, #4]
 800acfa:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800acfe:	687b      	ldr	r3, [r7, #4]
 800ad00:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800ad02:	4413      	add	r3, r2
 800ad04:	b29a      	uxth	r2, r3
 800ad06:	687b      	ldr	r3, [r7, #4]
 800ad08:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
 800ad0c:	e007      	b.n	800ad1e <tcp_receive+0x15e>
                }
              } else if (pcb->dupacks == 3) {
 800ad0e:	687b      	ldr	r3, [r7, #4]
 800ad10:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800ad14:	2b03      	cmp	r3, #3
 800ad16:	d102      	bne.n	800ad1e <tcp_receive+0x15e>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
 800ad18:	6878      	ldr	r0, [r7, #4]
 800ad1a:	f001 fb20 	bl	800c35e <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 800ad1e:	69bb      	ldr	r3, [r7, #24]
 800ad20:	2b00      	cmp	r3, #0
 800ad22:	f040 8168 	bne.w	800aff6 <tcp_receive+0x436>
        pcb->dupacks = 0;
 800ad26:	687b      	ldr	r3, [r7, #4]
 800ad28:	2200      	movs	r2, #0
 800ad2a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
 800ad2e:	e162      	b.n	800aff6 <tcp_receive+0x436>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 800ad30:	4b4e      	ldr	r3, [pc, #312]	; (800ae6c <tcp_receive+0x2ac>)
 800ad32:	681a      	ldr	r2, [r3, #0]
 800ad34:	687b      	ldr	r3, [r7, #4]
 800ad36:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ad38:	1ad3      	subs	r3, r2, r3
 800ad3a:	3b01      	subs	r3, #1
 800ad3c:	2b00      	cmp	r3, #0
 800ad3e:	f2c0 8114 	blt.w	800af6a <tcp_receive+0x3aa>
 800ad42:	4b4a      	ldr	r3, [pc, #296]	; (800ae6c <tcp_receive+0x2ac>)
 800ad44:	681a      	ldr	r2, [r3, #0]
 800ad46:	687b      	ldr	r3, [r7, #4]
 800ad48:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ad4a:	1ad3      	subs	r3, r2, r3
 800ad4c:	2b00      	cmp	r3, #0
 800ad4e:	f300 810c 	bgt.w	800af6a <tcp_receive+0x3aa>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 800ad52:	687b      	ldr	r3, [r7, #4]
 800ad54:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800ad58:	f003 0304 	and.w	r3, r3, #4
 800ad5c:	2b00      	cmp	r3, #0
 800ad5e:	d00e      	beq.n	800ad7e <tcp_receive+0x1be>
        pcb->flags &= ~TF_INFR;
 800ad60:	687b      	ldr	r3, [r7, #4]
 800ad62:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800ad66:	f023 0304 	bic.w	r3, r3, #4
 800ad6a:	b2da      	uxtb	r2, r3
 800ad6c:	687b      	ldr	r3, [r7, #4]
 800ad6e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
        pcb->cwnd = pcb->ssthresh;
 800ad72:	687b      	ldr	r3, [r7, #4]
 800ad74:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 800ad78:	687b      	ldr	r3, [r7, #4]
 800ad7a:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 800ad7e:	687b      	ldr	r3, [r7, #4]
 800ad80:	2200      	movs	r2, #0
 800ad82:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800ad86:	687b      	ldr	r3, [r7, #4]
 800ad88:	f9b3 3044 	ldrsh.w	r3, [r3, #68]	; 0x44
 800ad8c:	10db      	asrs	r3, r3, #3
 800ad8e:	b21b      	sxth	r3, r3
 800ad90:	b29a      	uxth	r2, r3
 800ad92:	687b      	ldr	r3, [r7, #4]
 800ad94:	f9b3 3046 	ldrsh.w	r3, [r3, #70]	; 0x46
 800ad98:	b29b      	uxth	r3, r3
 800ad9a:	4413      	add	r3, r2
 800ad9c:	b29b      	uxth	r3, r3
 800ad9e:	b21a      	sxth	r2, r3
 800ada0:	687b      	ldr	r3, [r7, #4]
 800ada2:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 800ada6:	4b31      	ldr	r3, [pc, #196]	; (800ae6c <tcp_receive+0x2ac>)
 800ada8:	681b      	ldr	r3, [r3, #0]
 800adaa:	b29a      	uxth	r2, r3
 800adac:	687b      	ldr	r3, [r7, #4]
 800adae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800adb0:	b29b      	uxth	r3, r3
 800adb2:	1ad3      	subs	r3, r2, r3
 800adb4:	b29a      	uxth	r2, r3
 800adb6:	687b      	ldr	r3, [r7, #4]
 800adb8:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c

      pcb->snd_buf += pcb->acked;
 800adbc:	687b      	ldr	r3, [r7, #4]
 800adbe:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 800adc2:	687b      	ldr	r3, [r7, #4]
 800adc4:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800adc8:	4413      	add	r3, r2
 800adca:	b29a      	uxth	r2, r3
 800adcc:	687b      	ldr	r3, [r7, #4]
 800adce:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 800add2:	687b      	ldr	r3, [r7, #4]
 800add4:	2200      	movs	r2, #0
 800add6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      pcb->lastack = ackno;
 800adda:	4b24      	ldr	r3, [pc, #144]	; (800ae6c <tcp_receive+0x2ac>)
 800addc:	681a      	ldr	r2, [r3, #0]
 800adde:	687b      	ldr	r3, [r7, #4]
 800ade0:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800ade2:	687b      	ldr	r3, [r7, #4]
 800ade4:	7c1b      	ldrb	r3, [r3, #16]
 800ade6:	2b03      	cmp	r3, #3
 800ade8:	f240 8087 	bls.w	800aefa <tcp_receive+0x33a>
        if (pcb->cwnd < pcb->ssthresh) {
 800adec:	687b      	ldr	r3, [r7, #4]
 800adee:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800adf2:	687b      	ldr	r3, [r7, #4]
 800adf4:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 800adf8:	429a      	cmp	r2, r3
 800adfa:	d216      	bcs.n	800ae2a <tcp_receive+0x26a>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800adfc:	687b      	ldr	r3, [r7, #4]
 800adfe:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800ae02:	687b      	ldr	r3, [r7, #4]
 800ae04:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800ae06:	4413      	add	r3, r2
 800ae08:	b29a      	uxth	r2, r3
 800ae0a:	687b      	ldr	r3, [r7, #4]
 800ae0c:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800ae10:	429a      	cmp	r2, r3
 800ae12:	d972      	bls.n	800aefa <tcp_receive+0x33a>
            pcb->cwnd += pcb->mss;
 800ae14:	687b      	ldr	r3, [r7, #4]
 800ae16:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800ae1a:	687b      	ldr	r3, [r7, #4]
 800ae1c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800ae1e:	4413      	add	r3, r2
 800ae20:	b29a      	uxth	r2, r3
 800ae22:	687b      	ldr	r3, [r7, #4]
 800ae24:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
 800ae28:	e067      	b.n	800aefa <tcp_receive+0x33a>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 800ae2a:	687b      	ldr	r3, [r7, #4]
 800ae2c:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800ae30:	687b      	ldr	r3, [r7, #4]
 800ae32:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800ae34:	4619      	mov	r1, r3
 800ae36:	687b      	ldr	r3, [r7, #4]
 800ae38:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800ae3a:	fb03 f301 	mul.w	r3, r3, r1
 800ae3e:	6879      	ldr	r1, [r7, #4]
 800ae40:	f8b1 1052 	ldrh.w	r1, [r1, #82]	; 0x52
 800ae44:	fb93 f3f1 	sdiv	r3, r3, r1
 800ae48:	b29b      	uxth	r3, r3
 800ae4a:	4413      	add	r3, r2
 800ae4c:	827b      	strh	r3, [r7, #18]
          if (new_cwnd > pcb->cwnd) {
 800ae4e:	687b      	ldr	r3, [r7, #4]
 800ae50:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800ae54:	8a7a      	ldrh	r2, [r7, #18]
 800ae56:	429a      	cmp	r2, r3
 800ae58:	d94f      	bls.n	800aefa <tcp_receive+0x33a>
            pcb->cwnd = new_cwnd;
 800ae5a:	687b      	ldr	r3, [r7, #4]
 800ae5c:	8a7a      	ldrh	r2, [r7, #18]
 800ae5e:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 800ae62:	e04a      	b.n	800aefa <tcp_receive+0x33a>
 800ae64:	20007c5c 	.word	0x20007c5c
 800ae68:	20007c54 	.word	0x20007c54
 800ae6c:	20007c58 	.word	0x20007c58
 800ae70:	20007c4c 	.word	0x20007c4c
 800ae74:	20007c5e 	.word	0x20007c5e
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 800ae78:	687b      	ldr	r3, [r7, #4]
 800ae7a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ae7c:	60fb      	str	r3, [r7, #12]
        pcb->unacked = pcb->unacked->next;
 800ae7e:	687b      	ldr	r3, [r7, #4]
 800ae80:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ae82:	681a      	ldr	r2, [r3, #0]
 800ae84:	687b      	ldr	r3, [r7, #4]
 800ae86:	679a      	str	r2, [r3, #120]	; 0x78

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800ae88:	68fb      	ldr	r3, [r7, #12]
 800ae8a:	685b      	ldr	r3, [r3, #4]
 800ae8c:	4618      	mov	r0, r3
 800ae8e:	f7fd fcdb 	bl	8008848 <pbuf_clen>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800ae92:	687b      	ldr	r3, [r7, #4]
 800ae94:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800ae98:	2b00      	cmp	r3, #0
 800ae9a:	d013      	beq.n	800aec4 <tcp_receive+0x304>
 800ae9c:	68fb      	ldr	r3, [r7, #12]
 800ae9e:	691b      	ldr	r3, [r3, #16]
 800aea0:	899b      	ldrh	r3, [r3, #12]
 800aea2:	b29b      	uxth	r3, r3
 800aea4:	4618      	mov	r0, r3
 800aea6:	f7fb fef4 	bl	8006c92 <ntohs>
 800aeaa:	4603      	mov	r3, r0
 800aeac:	f003 0301 	and.w	r3, r3, #1
 800aeb0:	2b00      	cmp	r3, #0
 800aeb2:	d007      	beq.n	800aec4 <tcp_receive+0x304>
          pcb->acked--;
 800aeb4:	687b      	ldr	r3, [r7, #4]
 800aeb6:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800aeba:	3b01      	subs	r3, #1
 800aebc:	b29a      	uxth	r2, r3
 800aebe:	687b      	ldr	r3, [r7, #4]
 800aec0:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
 800aec4:	68fb      	ldr	r3, [r7, #12]
 800aec6:	685b      	ldr	r3, [r3, #4]
 800aec8:	4618      	mov	r0, r3
 800aeca:	f7fd fcbd 	bl	8008848 <pbuf_clen>
 800aece:	4603      	mov	r3, r0
 800aed0:	4619      	mov	r1, r3
 800aed2:	687b      	ldr	r3, [r7, #4]
 800aed4:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 800aed8:	b28b      	uxth	r3, r1
 800aeda:	1ad3      	subs	r3, r2, r3
 800aedc:	b29a      	uxth	r2, r3
 800aede:	687b      	ldr	r3, [r7, #4]
 800aee0:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
        tcp_seg_free(next);
 800aee4:	68f8      	ldr	r0, [r7, #12]
 800aee6:	f7fe fc07 	bl	80096f8 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
 800aeea:	687b      	ldr	r3, [r7, #4]
 800aeec:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 800aef0:	2b00      	cmp	r3, #0
 800aef2:	d002      	beq.n	800aefa <tcp_receive+0x33a>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 800aef4:	687b      	ldr	r3, [r7, #4]
 800aef6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800aef8:	2b00      	cmp	r3, #0
      while (pcb->unacked != NULL &&
 800aefa:	687b      	ldr	r3, [r7, #4]
 800aefc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800aefe:	2b00      	cmp	r3, #0
 800af00:	d022      	beq.n	800af48 <tcp_receive+0x388>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 800af02:	687b      	ldr	r3, [r7, #4]
 800af04:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800af06:	691b      	ldr	r3, [r3, #16]
 800af08:	685b      	ldr	r3, [r3, #4]
 800af0a:	4618      	mov	r0, r3
 800af0c:	f7fb fee8 	bl	8006ce0 <ntohl>
 800af10:	4604      	mov	r4, r0
 800af12:	687b      	ldr	r3, [r7, #4]
 800af14:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800af16:	899b      	ldrh	r3, [r3, #12]
 800af18:	461d      	mov	r5, r3
 800af1a:	687b      	ldr	r3, [r7, #4]
 800af1c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800af1e:	691b      	ldr	r3, [r3, #16]
 800af20:	899b      	ldrh	r3, [r3, #12]
 800af22:	b29b      	uxth	r3, r3
 800af24:	4618      	mov	r0, r3
 800af26:	f7fb feb4 	bl	8006c92 <ntohs>
 800af2a:	4603      	mov	r3, r0
 800af2c:	f003 0303 	and.w	r3, r3, #3
 800af30:	2b00      	cmp	r3, #0
 800af32:	bf14      	ite	ne
 800af34:	2301      	movne	r3, #1
 800af36:	2300      	moveq	r3, #0
 800af38:	b2db      	uxtb	r3, r3
 800af3a:	442b      	add	r3, r5
 800af3c:	18e2      	adds	r2, r4, r3
 800af3e:	4b99      	ldr	r3, [pc, #612]	; (800b1a4 <tcp_receive+0x5e4>)
 800af40:	681b      	ldr	r3, [r3, #0]
 800af42:	1ad3      	subs	r3, r2, r3
      while (pcb->unacked != NULL &&
 800af44:	2b00      	cmp	r3, #0
 800af46:	dd97      	ble.n	800ae78 <tcp_receive+0x2b8>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 800af48:	687b      	ldr	r3, [r7, #4]
 800af4a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800af4c:	2b00      	cmp	r3, #0
 800af4e:	d104      	bne.n	800af5a <tcp_receive+0x39a>
        pcb->rtime = -1;
 800af50:	687b      	ldr	r3, [r7, #4]
 800af52:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800af56:	86da      	strh	r2, [r3, #54]	; 0x36
 800af58:	e002      	b.n	800af60 <tcp_receive+0x3a0>
      else
        pcb->rtime = 0;
 800af5a:	687b      	ldr	r3, [r7, #4]
 800af5c:	2200      	movs	r2, #0
 800af5e:	86da      	strh	r2, [r3, #54]	; 0x36

      pcb->polltmr = 0;
 800af60:	687b      	ldr	r3, [r7, #4]
 800af62:	2200      	movs	r2, #0
 800af64:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 800af68:	e003      	b.n	800af72 <tcp_receive+0x3b2>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 800af6a:	687b      	ldr	r3, [r7, #4]
 800af6c:	2200      	movs	r2, #0
 800af6e:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 800af72:	e040      	b.n	800aff6 <tcp_receive+0x436>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 800af74:	687b      	ldr	r3, [r7, #4]
 800af76:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800af78:	60fb      	str	r3, [r7, #12]
      pcb->unsent = pcb->unsent->next;
 800af7a:	687b      	ldr	r3, [r7, #4]
 800af7c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800af7e:	681a      	ldr	r2, [r3, #0]
 800af80:	687b      	ldr	r3, [r7, #4]
 800af82:	675a      	str	r2, [r3, #116]	; 0x74
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800af84:	68fb      	ldr	r3, [r7, #12]
 800af86:	685b      	ldr	r3, [r3, #4]
 800af88:	4618      	mov	r0, r3
 800af8a:	f7fd fc5d 	bl	8008848 <pbuf_clen>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800af8e:	687b      	ldr	r3, [r7, #4]
 800af90:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800af94:	2b00      	cmp	r3, #0
 800af96:	d013      	beq.n	800afc0 <tcp_receive+0x400>
 800af98:	68fb      	ldr	r3, [r7, #12]
 800af9a:	691b      	ldr	r3, [r3, #16]
 800af9c:	899b      	ldrh	r3, [r3, #12]
 800af9e:	b29b      	uxth	r3, r3
 800afa0:	4618      	mov	r0, r3
 800afa2:	f7fb fe76 	bl	8006c92 <ntohs>
 800afa6:	4603      	mov	r3, r0
 800afa8:	f003 0301 	and.w	r3, r3, #1
 800afac:	2b00      	cmp	r3, #0
 800afae:	d007      	beq.n	800afc0 <tcp_receive+0x400>
        pcb->acked--;
 800afb0:	687b      	ldr	r3, [r7, #4]
 800afb2:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 800afb6:	3b01      	subs	r3, #1
 800afb8:	b29a      	uxth	r2, r3
 800afba:	687b      	ldr	r3, [r7, #4]
 800afbc:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
 800afc0:	68fb      	ldr	r3, [r7, #12]
 800afc2:	685b      	ldr	r3, [r3, #4]
 800afc4:	4618      	mov	r0, r3
 800afc6:	f7fd fc3f 	bl	8008848 <pbuf_clen>
 800afca:	4603      	mov	r3, r0
 800afcc:	4619      	mov	r1, r3
 800afce:	687b      	ldr	r3, [r7, #4]
 800afd0:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 800afd4:	b28b      	uxth	r3, r1
 800afd6:	1ad3      	subs	r3, r2, r3
 800afd8:	b29a      	uxth	r2, r3
 800afda:	687b      	ldr	r3, [r7, #4]
 800afdc:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
      tcp_seg_free(next);
 800afe0:	68f8      	ldr	r0, [r7, #12]
 800afe2:	f7fe fb89 	bl	80096f8 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
 800afe6:	687b      	ldr	r3, [r7, #4]
 800afe8:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 800afec:	2b00      	cmp	r3, #0
 800afee:	d002      	beq.n	800aff6 <tcp_receive+0x436>
        LWIP_ASSERT("tcp_receive: valid queue length",
 800aff0:	687b      	ldr	r3, [r7, #4]
 800aff2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800aff4:	2b00      	cmp	r3, #0
    while (pcb->unsent != NULL &&
 800aff6:	687b      	ldr	r3, [r7, #4]
 800aff8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800affa:	2b00      	cmp	r3, #0
 800affc:	d029      	beq.n	800b052 <tcp_receive+0x492>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800affe:	4b69      	ldr	r3, [pc, #420]	; (800b1a4 <tcp_receive+0x5e4>)
 800b000:	681c      	ldr	r4, [r3, #0]
 800b002:	687b      	ldr	r3, [r7, #4]
 800b004:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b006:	691b      	ldr	r3, [r3, #16]
 800b008:	685b      	ldr	r3, [r3, #4]
 800b00a:	4618      	mov	r0, r3
 800b00c:	f7fb fe68 	bl	8006ce0 <ntohl>
 800b010:	4605      	mov	r5, r0
 800b012:	687b      	ldr	r3, [r7, #4]
 800b014:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b016:	899b      	ldrh	r3, [r3, #12]
 800b018:	461e      	mov	r6, r3
 800b01a:	687b      	ldr	r3, [r7, #4]
 800b01c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b01e:	691b      	ldr	r3, [r3, #16]
 800b020:	899b      	ldrh	r3, [r3, #12]
 800b022:	b29b      	uxth	r3, r3
 800b024:	4618      	mov	r0, r3
 800b026:	f7fb fe34 	bl	8006c92 <ntohs>
 800b02a:	4603      	mov	r3, r0
 800b02c:	f003 0303 	and.w	r3, r3, #3
 800b030:	2b00      	cmp	r3, #0
 800b032:	bf14      	ite	ne
 800b034:	2301      	movne	r3, #1
 800b036:	2300      	moveq	r3, #0
 800b038:	b2db      	uxtb	r3, r3
 800b03a:	4433      	add	r3, r6
 800b03c:	442b      	add	r3, r5
 800b03e:	1ae3      	subs	r3, r4, r3
    while (pcb->unsent != NULL &&
 800b040:	2b00      	cmp	r3, #0
 800b042:	db06      	blt.n	800b052 <tcp_receive+0x492>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800b044:	4b57      	ldr	r3, [pc, #348]	; (800b1a4 <tcp_receive+0x5e4>)
 800b046:	681a      	ldr	r2, [r3, #0]
 800b048:	687b      	ldr	r3, [r7, #4]
 800b04a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800b04c:	1ad3      	subs	r3, r2, r3
 800b04e:	2b00      	cmp	r3, #0
 800b050:	dd90      	ble.n	800af74 <tcp_receive+0x3b4>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800b052:	687b      	ldr	r3, [r7, #4]
 800b054:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b056:	2b00      	cmp	r3, #0
 800b058:	d054      	beq.n	800b104 <tcp_receive+0x544>
 800b05a:	687b      	ldr	r3, [r7, #4]
 800b05c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800b05e:	4b51      	ldr	r3, [pc, #324]	; (800b1a4 <tcp_receive+0x5e4>)
 800b060:	681b      	ldr	r3, [r3, #0]
 800b062:	1ad3      	subs	r3, r2, r3
 800b064:	2b00      	cmp	r3, #0
 800b066:	da4d      	bge.n	800b104 <tcp_receive+0x544>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800b068:	4b4f      	ldr	r3, [pc, #316]	; (800b1a8 <tcp_receive+0x5e8>)
 800b06a:	681b      	ldr	r3, [r3, #0]
 800b06c:	b29a      	uxth	r2, r3
 800b06e:	687b      	ldr	r3, [r7, #4]
 800b070:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b072:	b29b      	uxth	r3, r3
 800b074:	1ad3      	subs	r3, r2, r3
 800b076:	b29b      	uxth	r3, r3
 800b078:	83fb      	strh	r3, [r7, #30]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 800b07a:	8bfa      	ldrh	r2, [r7, #30]
 800b07c:	687b      	ldr	r3, [r7, #4]
 800b07e:	f9b3 3044 	ldrsh.w	r3, [r3, #68]	; 0x44
 800b082:	10db      	asrs	r3, r3, #3
 800b084:	b21b      	sxth	r3, r3
 800b086:	b29b      	uxth	r3, r3
 800b088:	1ad3      	subs	r3, r2, r3
 800b08a:	b29b      	uxth	r3, r3
 800b08c:	83fb      	strh	r3, [r7, #30]
      pcb->sa += m;
 800b08e:	687b      	ldr	r3, [r7, #4]
 800b090:	f9b3 3044 	ldrsh.w	r3, [r3, #68]	; 0x44
 800b094:	b29a      	uxth	r2, r3
 800b096:	8bfb      	ldrh	r3, [r7, #30]
 800b098:	4413      	add	r3, r2
 800b09a:	b29b      	uxth	r3, r3
 800b09c:	b21a      	sxth	r2, r3
 800b09e:	687b      	ldr	r3, [r7, #4]
 800b0a0:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
      if (m < 0) {
 800b0a4:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b0a8:	2b00      	cmp	r3, #0
 800b0aa:	da03      	bge.n	800b0b4 <tcp_receive+0x4f4>
        m = -m;
 800b0ac:	8bfb      	ldrh	r3, [r7, #30]
 800b0ae:	425b      	negs	r3, r3
 800b0b0:	b29b      	uxth	r3, r3
 800b0b2:	83fb      	strh	r3, [r7, #30]
      }
      m = m - (pcb->sv >> 2);
 800b0b4:	8bfa      	ldrh	r2, [r7, #30]
 800b0b6:	687b      	ldr	r3, [r7, #4]
 800b0b8:	f9b3 3046 	ldrsh.w	r3, [r3, #70]	; 0x46
 800b0bc:	109b      	asrs	r3, r3, #2
 800b0be:	b21b      	sxth	r3, r3
 800b0c0:	b29b      	uxth	r3, r3
 800b0c2:	1ad3      	subs	r3, r2, r3
 800b0c4:	b29b      	uxth	r3, r3
 800b0c6:	83fb      	strh	r3, [r7, #30]
      pcb->sv += m;
 800b0c8:	687b      	ldr	r3, [r7, #4]
 800b0ca:	f9b3 3046 	ldrsh.w	r3, [r3, #70]	; 0x46
 800b0ce:	b29a      	uxth	r2, r3
 800b0d0:	8bfb      	ldrh	r3, [r7, #30]
 800b0d2:	4413      	add	r3, r2
 800b0d4:	b29b      	uxth	r3, r3
 800b0d6:	b21a      	sxth	r2, r3
 800b0d8:	687b      	ldr	r3, [r7, #4]
 800b0da:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800b0de:	687b      	ldr	r3, [r7, #4]
 800b0e0:	f9b3 3044 	ldrsh.w	r3, [r3, #68]	; 0x44
 800b0e4:	10db      	asrs	r3, r3, #3
 800b0e6:	b21b      	sxth	r3, r3
 800b0e8:	b29a      	uxth	r2, r3
 800b0ea:	687b      	ldr	r3, [r7, #4]
 800b0ec:	f9b3 3046 	ldrsh.w	r3, [r3, #70]	; 0x46
 800b0f0:	b29b      	uxth	r3, r3
 800b0f2:	4413      	add	r3, r2
 800b0f4:	b29b      	uxth	r3, r3
 800b0f6:	b21a      	sxth	r2, r3
 800b0f8:	687b      	ldr	r3, [r7, #4]
 800b0fa:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 800b0fe:	687b      	ldr	r3, [r7, #4]
 800b100:	2200      	movs	r2, #0
 800b102:	63da      	str	r2, [r3, #60]	; 0x3c
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
 800b104:	4b29      	ldr	r3, [pc, #164]	; (800b1ac <tcp_receive+0x5ec>)
 800b106:	881b      	ldrh	r3, [r3, #0]
 800b108:	2b00      	cmp	r3, #0
 800b10a:	f000 8191 	beq.w	800b430 <tcp_receive+0x870>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 800b10e:	687b      	ldr	r3, [r7, #4]
 800b110:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b112:	4b27      	ldr	r3, [pc, #156]	; (800b1b0 <tcp_receive+0x5f0>)
 800b114:	681b      	ldr	r3, [r3, #0]
 800b116:	1ad3      	subs	r3, r2, r3
 800b118:	3b01      	subs	r3, #1
 800b11a:	2b00      	cmp	r3, #0
 800b11c:	db73      	blt.n	800b206 <tcp_receive+0x646>
 800b11e:	687b      	ldr	r3, [r7, #4]
 800b120:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b122:	4b22      	ldr	r3, [pc, #136]	; (800b1ac <tcp_receive+0x5ec>)
 800b124:	881b      	ldrh	r3, [r3, #0]
 800b126:	4619      	mov	r1, r3
 800b128:	4b21      	ldr	r3, [pc, #132]	; (800b1b0 <tcp_receive+0x5f0>)
 800b12a:	681b      	ldr	r3, [r3, #0]
 800b12c:	440b      	add	r3, r1
 800b12e:	1ad3      	subs	r3, r2, r3
 800b130:	3301      	adds	r3, #1
 800b132:	2b00      	cmp	r3, #0
 800b134:	dc67      	bgt.n	800b206 <tcp_receive+0x646>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 800b136:	687b      	ldr	r3, [r7, #4]
 800b138:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b13a:	4b1d      	ldr	r3, [pc, #116]	; (800b1b0 <tcp_receive+0x5f0>)
 800b13c:	681b      	ldr	r3, [r3, #0]
 800b13e:	1ad3      	subs	r3, r2, r3
 800b140:	623b      	str	r3, [r7, #32]
      p = inseg.p;
 800b142:	4b1c      	ldr	r3, [pc, #112]	; (800b1b4 <tcp_receive+0x5f4>)
 800b144:	685b      	ldr	r3, [r3, #4]
 800b146:	627b      	str	r3, [r7, #36]	; 0x24
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 800b148:	4b1a      	ldr	r3, [pc, #104]	; (800b1b4 <tcp_receive+0x5f4>)
 800b14a:	685b      	ldr	r3, [r3, #4]
 800b14c:	895b      	ldrh	r3, [r3, #10]
 800b14e:	461a      	mov	r2, r3
 800b150:	6a3b      	ldr	r3, [r7, #32]
 800b152:	429a      	cmp	r2, r3
 800b154:	da30      	bge.n	800b1b8 <tcp_receive+0x5f8>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800b156:	4b17      	ldr	r3, [pc, #92]	; (800b1b4 <tcp_receive+0x5f4>)
 800b158:	685b      	ldr	r3, [r3, #4]
 800b15a:	891a      	ldrh	r2, [r3, #8]
 800b15c:	6a3b      	ldr	r3, [r7, #32]
 800b15e:	b29b      	uxth	r3, r3
 800b160:	1ad3      	subs	r3, r2, r3
 800b162:	817b      	strh	r3, [r7, #10]
        while (p->len < off) {
 800b164:	e00e      	b.n	800b184 <tcp_receive+0x5c4>
          off -= p->len;
 800b166:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b168:	895b      	ldrh	r3, [r3, #10]
 800b16a:	461a      	mov	r2, r3
 800b16c:	6a3b      	ldr	r3, [r7, #32]
 800b16e:	1a9b      	subs	r3, r3, r2
 800b170:	623b      	str	r3, [r7, #32]
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 800b172:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b174:	897a      	ldrh	r2, [r7, #10]
 800b176:	811a      	strh	r2, [r3, #8]
          p->len = 0;
 800b178:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b17a:	2200      	movs	r2, #0
 800b17c:	815a      	strh	r2, [r3, #10]
          p = p->next;
 800b17e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b180:	681b      	ldr	r3, [r3, #0]
 800b182:	627b      	str	r3, [r7, #36]	; 0x24
        while (p->len < off) {
 800b184:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b186:	895b      	ldrh	r3, [r3, #10]
 800b188:	461a      	mov	r2, r3
 800b18a:	6a3b      	ldr	r3, [r7, #32]
 800b18c:	429a      	cmp	r2, r3
 800b18e:	dbea      	blt.n	800b166 <tcp_receive+0x5a6>
        }
        if(pbuf_header(p, (s16_t)-off)) {
 800b190:	6a3b      	ldr	r3, [r7, #32]
 800b192:	b29b      	uxth	r3, r3
 800b194:	425b      	negs	r3, r3
 800b196:	b29b      	uxth	r3, r3
 800b198:	b21b      	sxth	r3, r3
 800b19a:	4619      	mov	r1, r3
 800b19c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800b19e:	f7fd fa95 	bl	80086cc <pbuf_header>
 800b1a2:	e014      	b.n	800b1ce <tcp_receive+0x60e>
 800b1a4:	20007c58 	.word	0x20007c58
 800b1a8:	2000a328 	.word	0x2000a328
 800b1ac:	20007c5e 	.word	0x20007c5e
 800b1b0:	20007c54 	.word	0x20007c54
 800b1b4:	20007c38 	.word	0x20007c38
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 800b1b8:	4b98      	ldr	r3, [pc, #608]	; (800b41c <tcp_receive+0x85c>)
 800b1ba:	685b      	ldr	r3, [r3, #4]
 800b1bc:	6a3a      	ldr	r2, [r7, #32]
 800b1be:	b292      	uxth	r2, r2
 800b1c0:	4252      	negs	r2, r2
 800b1c2:	b292      	uxth	r2, r2
 800b1c4:	b212      	sxth	r2, r2
 800b1c6:	4611      	mov	r1, r2
 800b1c8:	4618      	mov	r0, r3
 800b1ca:	f7fd fa7f 	bl	80086cc <pbuf_header>
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
 800b1ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b1d0:	685b      	ldr	r3, [r3, #4]
 800b1d2:	4a92      	ldr	r2, [pc, #584]	; (800b41c <tcp_receive+0x85c>)
 800b1d4:	6093      	str	r3, [r2, #8]
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800b1d6:	4b91      	ldr	r3, [pc, #580]	; (800b41c <tcp_receive+0x85c>)
 800b1d8:	899a      	ldrh	r2, [r3, #12]
 800b1da:	4b91      	ldr	r3, [pc, #580]	; (800b420 <tcp_receive+0x860>)
 800b1dc:	681b      	ldr	r3, [r3, #0]
 800b1de:	b299      	uxth	r1, r3
 800b1e0:	687b      	ldr	r3, [r7, #4]
 800b1e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b1e4:	b29b      	uxth	r3, r3
 800b1e6:	1acb      	subs	r3, r1, r3
 800b1e8:	b29b      	uxth	r3, r3
 800b1ea:	4413      	add	r3, r2
 800b1ec:	b29a      	uxth	r2, r3
 800b1ee:	4b8b      	ldr	r3, [pc, #556]	; (800b41c <tcp_receive+0x85c>)
 800b1f0:	819a      	strh	r2, [r3, #12]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800b1f2:	4b8a      	ldr	r3, [pc, #552]	; (800b41c <tcp_receive+0x85c>)
 800b1f4:	691b      	ldr	r3, [r3, #16]
 800b1f6:	687a      	ldr	r2, [r7, #4]
 800b1f8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b1fa:	4989      	ldr	r1, [pc, #548]	; (800b420 <tcp_receive+0x860>)
 800b1fc:	600a      	str	r2, [r1, #0]
 800b1fe:	4a88      	ldr	r2, [pc, #544]	; (800b420 <tcp_receive+0x860>)
 800b200:	6812      	ldr	r2, [r2, #0]
 800b202:	605a      	str	r2, [r3, #4]
 800b204:	e012      	b.n	800b22c <tcp_receive+0x66c>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 800b206:	4b86      	ldr	r3, [pc, #536]	; (800b420 <tcp_receive+0x860>)
 800b208:	681a      	ldr	r2, [r3, #0]
 800b20a:	687b      	ldr	r3, [r7, #4]
 800b20c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b20e:	1ad3      	subs	r3, r2, r3
 800b210:	2b00      	cmp	r3, #0
 800b212:	da0b      	bge.n	800b22c <tcp_receive+0x66c>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 800b214:	687b      	ldr	r3, [r7, #4]
 800b216:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b21a:	f043 0302 	orr.w	r3, r3, #2
 800b21e:	b2da      	uxtb	r2, r3
 800b220:	687b      	ldr	r3, [r7, #4]
 800b222:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800b226:	6878      	ldr	r0, [r7, #4]
 800b228:	f000 fd90 	bl	800bd4c <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800b22c:	4b7c      	ldr	r3, [pc, #496]	; (800b420 <tcp_receive+0x860>)
 800b22e:	681a      	ldr	r2, [r3, #0]
 800b230:	687b      	ldr	r3, [r7, #4]
 800b232:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b234:	1ad3      	subs	r3, r2, r3
 800b236:	2b00      	cmp	r3, #0
 800b238:	f2c0 80eb 	blt.w	800b412 <tcp_receive+0x852>
 800b23c:	4b78      	ldr	r3, [pc, #480]	; (800b420 <tcp_receive+0x860>)
 800b23e:	681a      	ldr	r2, [r3, #0]
 800b240:	687b      	ldr	r3, [r7, #4]
 800b242:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b244:	6879      	ldr	r1, [r7, #4]
 800b246:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 800b248:	440b      	add	r3, r1
 800b24a:	1ad3      	subs	r3, r2, r3
 800b24c:	3301      	adds	r3, #1
 800b24e:	2b00      	cmp	r3, #0
 800b250:	f300 80df 	bgt.w	800b412 <tcp_receive+0x852>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 800b254:	687b      	ldr	r3, [r7, #4]
 800b256:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b258:	4b71      	ldr	r3, [pc, #452]	; (800b420 <tcp_receive+0x860>)
 800b25a:	681b      	ldr	r3, [r3, #0]
 800b25c:	429a      	cmp	r2, r3
 800b25e:	f040 80d4 	bne.w	800b40a <tcp_receive+0x84a>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800b262:	4b6e      	ldr	r3, [pc, #440]	; (800b41c <tcp_receive+0x85c>)
 800b264:	899c      	ldrh	r4, [r3, #12]
 800b266:	4b6d      	ldr	r3, [pc, #436]	; (800b41c <tcp_receive+0x85c>)
 800b268:	691b      	ldr	r3, [r3, #16]
 800b26a:	899b      	ldrh	r3, [r3, #12]
 800b26c:	b29b      	uxth	r3, r3
 800b26e:	4618      	mov	r0, r3
 800b270:	f7fb fd0f 	bl	8006c92 <ntohs>
 800b274:	4603      	mov	r3, r0
 800b276:	f003 0303 	and.w	r3, r3, #3
 800b27a:	2b00      	cmp	r3, #0
 800b27c:	bf14      	ite	ne
 800b27e:	2301      	movne	r3, #1
 800b280:	2300      	moveq	r3, #0
 800b282:	b2db      	uxtb	r3, r3
 800b284:	b29b      	uxth	r3, r3
 800b286:	4423      	add	r3, r4
 800b288:	b29a      	uxth	r2, r3
 800b28a:	4b66      	ldr	r3, [pc, #408]	; (800b424 <tcp_receive+0x864>)
 800b28c:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
 800b28e:	687b      	ldr	r3, [r7, #4]
 800b290:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 800b292:	4b64      	ldr	r3, [pc, #400]	; (800b424 <tcp_receive+0x864>)
 800b294:	881b      	ldrh	r3, [r3, #0]
 800b296:	429a      	cmp	r2, r3
 800b298:	d25e      	bcs.n	800b358 <tcp_receive+0x798>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U32_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800b29a:	4b60      	ldr	r3, [pc, #384]	; (800b41c <tcp_receive+0x85c>)
 800b29c:	691b      	ldr	r3, [r3, #16]
 800b29e:	899b      	ldrh	r3, [r3, #12]
 800b2a0:	b29b      	uxth	r3, r3
 800b2a2:	4618      	mov	r0, r3
 800b2a4:	f7fb fcf5 	bl	8006c92 <ntohs>
 800b2a8:	4603      	mov	r3, r0
 800b2aa:	f003 0301 	and.w	r3, r3, #1
 800b2ae:	2b00      	cmp	r3, #0
 800b2b0:	d01e      	beq.n	800b2f0 <tcp_receive+0x730>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 800b2b2:	4b5a      	ldr	r3, [pc, #360]	; (800b41c <tcp_receive+0x85c>)
 800b2b4:	691c      	ldr	r4, [r3, #16]
 800b2b6:	4b59      	ldr	r3, [pc, #356]	; (800b41c <tcp_receive+0x85c>)
 800b2b8:	691b      	ldr	r3, [r3, #16]
 800b2ba:	899b      	ldrh	r3, [r3, #12]
 800b2bc:	b29d      	uxth	r5, r3
 800b2be:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 800b2c2:	f7fb fcd1 	bl	8006c68 <htons>
 800b2c6:	4603      	mov	r3, r0
 800b2c8:	402b      	ands	r3, r5
 800b2ca:	b29d      	uxth	r5, r3
 800b2cc:	4b53      	ldr	r3, [pc, #332]	; (800b41c <tcp_receive+0x85c>)
 800b2ce:	691b      	ldr	r3, [r3, #16]
 800b2d0:	899b      	ldrh	r3, [r3, #12]
 800b2d2:	b29b      	uxth	r3, r3
 800b2d4:	4618      	mov	r0, r3
 800b2d6:	f7fb fcdc 	bl	8006c92 <ntohs>
 800b2da:	4603      	mov	r3, r0
 800b2dc:	f003 033e 	and.w	r3, r3, #62	; 0x3e
 800b2e0:	b29b      	uxth	r3, r3
 800b2e2:	4618      	mov	r0, r3
 800b2e4:	f7fb fcc0 	bl	8006c68 <htons>
 800b2e8:	4603      	mov	r3, r0
 800b2ea:	432b      	orrs	r3, r5
 800b2ec:	b29b      	uxth	r3, r3
 800b2ee:	81a3      	strh	r3, [r4, #12]
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 800b2f0:	687b      	ldr	r3, [r7, #4]
 800b2f2:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 800b2f4:	4b49      	ldr	r3, [pc, #292]	; (800b41c <tcp_receive+0x85c>)
 800b2f6:	819a      	strh	r2, [r3, #12]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b2f8:	4b48      	ldr	r3, [pc, #288]	; (800b41c <tcp_receive+0x85c>)
 800b2fa:	691b      	ldr	r3, [r3, #16]
 800b2fc:	899b      	ldrh	r3, [r3, #12]
 800b2fe:	b29b      	uxth	r3, r3
 800b300:	4618      	mov	r0, r3
 800b302:	f7fb fcc6 	bl	8006c92 <ntohs>
 800b306:	4603      	mov	r3, r0
 800b308:	f003 0302 	and.w	r3, r3, #2
 800b30c:	2b00      	cmp	r3, #0
 800b30e:	d005      	beq.n	800b31c <tcp_receive+0x75c>
            inseg.len -= 1;
 800b310:	4b42      	ldr	r3, [pc, #264]	; (800b41c <tcp_receive+0x85c>)
 800b312:	899b      	ldrh	r3, [r3, #12]
 800b314:	3b01      	subs	r3, #1
 800b316:	b29a      	uxth	r2, r3
 800b318:	4b40      	ldr	r3, [pc, #256]	; (800b41c <tcp_receive+0x85c>)
 800b31a:	819a      	strh	r2, [r3, #12]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800b31c:	4b3f      	ldr	r3, [pc, #252]	; (800b41c <tcp_receive+0x85c>)
 800b31e:	685a      	ldr	r2, [r3, #4]
 800b320:	4b3e      	ldr	r3, [pc, #248]	; (800b41c <tcp_receive+0x85c>)
 800b322:	899b      	ldrh	r3, [r3, #12]
 800b324:	4619      	mov	r1, r3
 800b326:	4610      	mov	r0, r2
 800b328:	f7fd f96c 	bl	8008604 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800b32c:	4b3b      	ldr	r3, [pc, #236]	; (800b41c <tcp_receive+0x85c>)
 800b32e:	899c      	ldrh	r4, [r3, #12]
 800b330:	4b3a      	ldr	r3, [pc, #232]	; (800b41c <tcp_receive+0x85c>)
 800b332:	691b      	ldr	r3, [r3, #16]
 800b334:	899b      	ldrh	r3, [r3, #12]
 800b336:	b29b      	uxth	r3, r3
 800b338:	4618      	mov	r0, r3
 800b33a:	f7fb fcaa 	bl	8006c92 <ntohs>
 800b33e:	4603      	mov	r3, r0
 800b340:	f003 0303 	and.w	r3, r3, #3
 800b344:	2b00      	cmp	r3, #0
 800b346:	bf14      	ite	ne
 800b348:	2301      	movne	r3, #1
 800b34a:	2300      	moveq	r3, #0
 800b34c:	b2db      	uxtb	r3, r3
 800b34e:	b29b      	uxth	r3, r3
 800b350:	4423      	add	r3, r4
 800b352:	b29a      	uxth	r2, r3
 800b354:	4b33      	ldr	r3, [pc, #204]	; (800b424 <tcp_receive+0x864>)
 800b356:	801a      	strh	r2, [r3, #0]
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800b358:	4b32      	ldr	r3, [pc, #200]	; (800b424 <tcp_receive+0x864>)
 800b35a:	881b      	ldrh	r3, [r3, #0]
 800b35c:	461a      	mov	r2, r3
 800b35e:	4b30      	ldr	r3, [pc, #192]	; (800b420 <tcp_receive+0x860>)
 800b360:	681b      	ldr	r3, [r3, #0]
 800b362:	441a      	add	r2, r3
 800b364:	687b      	ldr	r3, [r7, #4]
 800b366:	625a      	str	r2, [r3, #36]	; 0x24

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 800b368:	687b      	ldr	r3, [r7, #4]
 800b36a:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 800b36c:	4b2d      	ldr	r3, [pc, #180]	; (800b424 <tcp_receive+0x864>)
 800b36e:	881b      	ldrh	r3, [r3, #0]
 800b370:	1ad3      	subs	r3, r2, r3
 800b372:	b29a      	uxth	r2, r3
 800b374:	687b      	ldr	r3, [r7, #4]
 800b376:	851a      	strh	r2, [r3, #40]	; 0x28

        tcp_update_rcv_ann_wnd(pcb);
 800b378:	6878      	ldr	r0, [r7, #4]
 800b37a:	f7fd fe9f 	bl	80090bc <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800b37e:	4b27      	ldr	r3, [pc, #156]	; (800b41c <tcp_receive+0x85c>)
 800b380:	685b      	ldr	r3, [r3, #4]
 800b382:	891b      	ldrh	r3, [r3, #8]
 800b384:	2b00      	cmp	r3, #0
 800b386:	d006      	beq.n	800b396 <tcp_receive+0x7d6>
          recv_data = inseg.p;
 800b388:	4b24      	ldr	r3, [pc, #144]	; (800b41c <tcp_receive+0x85c>)
 800b38a:	685b      	ldr	r3, [r3, #4]
 800b38c:	4a26      	ldr	r2, [pc, #152]	; (800b428 <tcp_receive+0x868>)
 800b38e:	6013      	str	r3, [r2, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800b390:	4b22      	ldr	r3, [pc, #136]	; (800b41c <tcp_receive+0x85c>)
 800b392:	2200      	movs	r2, #0
 800b394:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800b396:	4b21      	ldr	r3, [pc, #132]	; (800b41c <tcp_receive+0x85c>)
 800b398:	691b      	ldr	r3, [r3, #16]
 800b39a:	899b      	ldrh	r3, [r3, #12]
 800b39c:	b29b      	uxth	r3, r3
 800b39e:	4618      	mov	r0, r3
 800b3a0:	f7fb fc77 	bl	8006c92 <ntohs>
 800b3a4:	4603      	mov	r3, r0
 800b3a6:	f003 0301 	and.w	r3, r3, #1
 800b3aa:	2b00      	cmp	r3, #0
 800b3ac:	d006      	beq.n	800b3bc <tcp_receive+0x7fc>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 800b3ae:	4b1f      	ldr	r3, [pc, #124]	; (800b42c <tcp_receive+0x86c>)
 800b3b0:	781b      	ldrb	r3, [r3, #0]
 800b3b2:	f043 0320 	orr.w	r3, r3, #32
 800b3b6:	b2da      	uxtb	r2, r3
 800b3b8:	4b1c      	ldr	r3, [pc, #112]	; (800b42c <tcp_receive+0x86c>)
 800b3ba:	701a      	strb	r2, [r3, #0]
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800b3bc:	687b      	ldr	r3, [r7, #4]
 800b3be:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b3c2:	f003 0301 	and.w	r3, r3, #1
 800b3c6:	2b00      	cmp	r3, #0
 800b3c8:	d015      	beq.n	800b3f6 <tcp_receive+0x836>
 800b3ca:	687b      	ldr	r3, [r7, #4]
 800b3cc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b3d0:	f023 0301 	bic.w	r3, r3, #1
 800b3d4:	b2da      	uxtb	r2, r3
 800b3d6:	687b      	ldr	r3, [r7, #4]
 800b3d8:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800b3dc:	687b      	ldr	r3, [r7, #4]
 800b3de:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b3e2:	f043 0302 	orr.w	r3, r3, #2
 800b3e6:	b2da      	uxtb	r2, r3
 800b3e8:	687b      	ldr	r3, [r7, #4]
 800b3ea:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800b3ee:	6878      	ldr	r0, [r7, #4]
 800b3f0:	f000 fcac 	bl	800bd4c <tcp_output>
      if (pcb->rcv_nxt == seqno) {
 800b3f4:	e03b      	b.n	800b46e <tcp_receive+0x8ae>
        tcp_ack(pcb);
 800b3f6:	687b      	ldr	r3, [r7, #4]
 800b3f8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b3fc:	f043 0301 	orr.w	r3, r3, #1
 800b400:	b2da      	uxtb	r2, r3
 800b402:	687b      	ldr	r3, [r7, #4]
 800b404:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
      if (pcb->rcv_nxt == seqno) {
 800b408:	e031      	b.n	800b46e <tcp_receive+0x8ae>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 800b40a:	6878      	ldr	r0, [r7, #4]
 800b40c:	f000 fc5a 	bl	800bcc4 <tcp_send_empty_ack>
      if (pcb->rcv_nxt == seqno) {
 800b410:	e02d      	b.n	800b46e <tcp_receive+0x8ae>
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
 800b412:	6878      	ldr	r0, [r7, #4]
 800b414:	f000 fc56 	bl	800bcc4 <tcp_send_empty_ack>
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
 800b418:	e029      	b.n	800b46e <tcp_receive+0x8ae>
 800b41a:	bf00      	nop
 800b41c:	20007c38 	.word	0x20007c38
 800b420:	20007c54 	.word	0x20007c54
 800b424:	20007c5e 	.word	0x20007c5e
 800b428:	20007c64 	.word	0x20007c64
 800b42c:	20007c60 	.word	0x20007c60
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 800b430:	4b11      	ldr	r3, [pc, #68]	; (800b478 <tcp_receive+0x8b8>)
 800b432:	681a      	ldr	r2, [r3, #0]
 800b434:	687b      	ldr	r3, [r7, #4]
 800b436:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b438:	1ad3      	subs	r3, r2, r3
 800b43a:	2b00      	cmp	r3, #0
 800b43c:	db0a      	blt.n	800b454 <tcp_receive+0x894>
 800b43e:	4b0e      	ldr	r3, [pc, #56]	; (800b478 <tcp_receive+0x8b8>)
 800b440:	681a      	ldr	r2, [r3, #0]
 800b442:	687b      	ldr	r3, [r7, #4]
 800b444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b446:	6879      	ldr	r1, [r7, #4]
 800b448:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 800b44a:	440b      	add	r3, r1
 800b44c:	1ad3      	subs	r3, r2, r3
 800b44e:	3301      	adds	r3, #1
 800b450:	2b00      	cmp	r3, #0
 800b452:	dd0c      	ble.n	800b46e <tcp_receive+0x8ae>
      tcp_ack_now(pcb);
 800b454:	687b      	ldr	r3, [r7, #4]
 800b456:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b45a:	f043 0302 	orr.w	r3, r3, #2
 800b45e:	b2da      	uxtb	r2, r3
 800b460:	687b      	ldr	r3, [r7, #4]
 800b462:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800b466:	6878      	ldr	r0, [r7, #4]
 800b468:	f000 fc70 	bl	800bd4c <tcp_output>
}
 800b46c:	e7ff      	b.n	800b46e <tcp_receive+0x8ae>
 800b46e:	bf00      	nop
 800b470:	372c      	adds	r7, #44	; 0x2c
 800b472:	46bd      	mov	sp, r7
 800b474:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b476:	bf00      	nop
 800b478:	20007c54 	.word	0x20007c54

0800b47c <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 800b47c:	b580      	push	{r7, lr}
 800b47e:	b086      	sub	sp, #24
 800b480:	af00      	add	r7, sp, #0
 800b482:	6078      	str	r0, [r7, #4]
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 800b484:	4b3e      	ldr	r3, [pc, #248]	; (800b580 <tcp_parseopt+0x104>)
 800b486:	681b      	ldr	r3, [r3, #0]
 800b488:	3314      	adds	r3, #20
 800b48a:	613b      	str	r3, [r7, #16]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 800b48c:	4b3c      	ldr	r3, [pc, #240]	; (800b580 <tcp_parseopt+0x104>)
 800b48e:	681b      	ldr	r3, [r3, #0]
 800b490:	899b      	ldrh	r3, [r3, #12]
 800b492:	b29b      	uxth	r3, r3
 800b494:	4618      	mov	r0, r3
 800b496:	f7fb fbfc 	bl	8006c92 <ntohs>
 800b49a:	4603      	mov	r3, r0
 800b49c:	0b1b      	lsrs	r3, r3, #12
 800b49e:	b29b      	uxth	r3, r3
 800b4a0:	2b05      	cmp	r3, #5
 800b4a2:	d969      	bls.n	800b578 <tcp_parseopt+0xfc>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 800b4a4:	4b36      	ldr	r3, [pc, #216]	; (800b580 <tcp_parseopt+0x104>)
 800b4a6:	681b      	ldr	r3, [r3, #0]
 800b4a8:	899b      	ldrh	r3, [r3, #12]
 800b4aa:	b29b      	uxth	r3, r3
 800b4ac:	4618      	mov	r0, r3
 800b4ae:	f7fb fbf0 	bl	8006c92 <ntohs>
 800b4b2:	4603      	mov	r3, r0
 800b4b4:	0b1b      	lsrs	r3, r3, #12
 800b4b6:	b29b      	uxth	r3, r3
 800b4b8:	3b05      	subs	r3, #5
 800b4ba:	b29b      	uxth	r3, r3
 800b4bc:	009b      	lsls	r3, r3, #2
 800b4be:	81fb      	strh	r3, [r7, #14]
    for (c = 0; c < max_c; ) {
 800b4c0:	2300      	movs	r3, #0
 800b4c2:	82fb      	strh	r3, [r7, #22]
 800b4c4:	e04e      	b.n	800b564 <tcp_parseopt+0xe8>
      opt = opts[c];
 800b4c6:	8afb      	ldrh	r3, [r7, #22]
 800b4c8:	693a      	ldr	r2, [r7, #16]
 800b4ca:	4413      	add	r3, r2
 800b4cc:	781b      	ldrb	r3, [r3, #0]
 800b4ce:	737b      	strb	r3, [r7, #13]
      switch (opt) {
 800b4d0:	7b7b      	ldrb	r3, [r7, #13]
 800b4d2:	2b01      	cmp	r3, #1
 800b4d4:	d004      	beq.n	800b4e0 <tcp_parseopt+0x64>
 800b4d6:	2b02      	cmp	r3, #2
 800b4d8:	d006      	beq.n	800b4e8 <tcp_parseopt+0x6c>
 800b4da:	2b00      	cmp	r3, #0
 800b4dc:	d047      	beq.n	800b56e <tcp_parseopt+0xf2>
 800b4de:	e031      	b.n	800b544 <tcp_parseopt+0xc8>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
 800b4e0:	8afb      	ldrh	r3, [r7, #22]
 800b4e2:	3301      	adds	r3, #1
 800b4e4:	82fb      	strh	r3, [r7, #22]
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
 800b4e6:	e03d      	b.n	800b564 <tcp_parseopt+0xe8>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 800b4e8:	8afb      	ldrh	r3, [r7, #22]
 800b4ea:	3301      	adds	r3, #1
 800b4ec:	693a      	ldr	r2, [r7, #16]
 800b4ee:	4413      	add	r3, r2
 800b4f0:	781b      	ldrb	r3, [r3, #0]
 800b4f2:	2b04      	cmp	r3, #4
 800b4f4:	d13d      	bne.n	800b572 <tcp_parseopt+0xf6>
 800b4f6:	8afb      	ldrh	r3, [r7, #22]
 800b4f8:	1d1a      	adds	r2, r3, #4
 800b4fa:	89fb      	ldrh	r3, [r7, #14]
 800b4fc:	429a      	cmp	r2, r3
 800b4fe:	dc38      	bgt.n	800b572 <tcp_parseopt+0xf6>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 800b500:	8afb      	ldrh	r3, [r7, #22]
 800b502:	3302      	adds	r3, #2
 800b504:	693a      	ldr	r2, [r7, #16]
 800b506:	4413      	add	r3, r2
 800b508:	781b      	ldrb	r3, [r3, #0]
 800b50a:	021b      	lsls	r3, r3, #8
 800b50c:	b21a      	sxth	r2, r3
 800b50e:	8afb      	ldrh	r3, [r7, #22]
 800b510:	3303      	adds	r3, #3
 800b512:	6939      	ldr	r1, [r7, #16]
 800b514:	440b      	add	r3, r1
 800b516:	781b      	ldrb	r3, [r3, #0]
 800b518:	b21b      	sxth	r3, r3
 800b51a:	4313      	orrs	r3, r2
 800b51c:	b21b      	sxth	r3, r3
 800b51e:	817b      	strh	r3, [r7, #10]
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800b520:	897b      	ldrh	r3, [r7, #10]
 800b522:	f240 52b4 	movw	r2, #1460	; 0x5b4
 800b526:	4293      	cmp	r3, r2
 800b528:	d804      	bhi.n	800b534 <tcp_parseopt+0xb8>
 800b52a:	897b      	ldrh	r3, [r7, #10]
 800b52c:	2b00      	cmp	r3, #0
 800b52e:	d001      	beq.n	800b534 <tcp_parseopt+0xb8>
 800b530:	897a      	ldrh	r2, [r7, #10]
 800b532:	e001      	b.n	800b538 <tcp_parseopt+0xbc>
 800b534:	f240 52b4 	movw	r2, #1460	; 0x5b4
 800b538:	687b      	ldr	r3, [r7, #4]
 800b53a:	871a      	strh	r2, [r3, #56]	; 0x38
        /* Advance to next option */
        c += 0x04;
 800b53c:	8afb      	ldrh	r3, [r7, #22]
 800b53e:	3304      	adds	r3, #4
 800b540:	82fb      	strh	r3, [r7, #22]
        break;
 800b542:	e00f      	b.n	800b564 <tcp_parseopt+0xe8>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 800b544:	8afb      	ldrh	r3, [r7, #22]
 800b546:	3301      	adds	r3, #1
 800b548:	693a      	ldr	r2, [r7, #16]
 800b54a:	4413      	add	r3, r2
 800b54c:	781b      	ldrb	r3, [r3, #0]
 800b54e:	2b00      	cmp	r3, #0
 800b550:	d011      	beq.n	800b576 <tcp_parseopt+0xfa>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 800b552:	8afb      	ldrh	r3, [r7, #22]
 800b554:	3301      	adds	r3, #1
 800b556:	693a      	ldr	r2, [r7, #16]
 800b558:	4413      	add	r3, r2
 800b55a:	781b      	ldrb	r3, [r3, #0]
 800b55c:	b29a      	uxth	r2, r3
 800b55e:	8afb      	ldrh	r3, [r7, #22]
 800b560:	4413      	add	r3, r2
 800b562:	82fb      	strh	r3, [r7, #22]
    for (c = 0; c < max_c; ) {
 800b564:	8afa      	ldrh	r2, [r7, #22]
 800b566:	89fb      	ldrh	r3, [r7, #14]
 800b568:	429a      	cmp	r2, r3
 800b56a:	d3ac      	bcc.n	800b4c6 <tcp_parseopt+0x4a>
 800b56c:	e004      	b.n	800b578 <tcp_parseopt+0xfc>
        return;
 800b56e:	bf00      	nop
 800b570:	e002      	b.n	800b578 <tcp_parseopt+0xfc>
          return;
 800b572:	bf00      	nop
 800b574:	e000      	b.n	800b578 <tcp_parseopt+0xfc>
          return;
 800b576:	bf00      	nop
      }
    }
  }
}
 800b578:	3718      	adds	r7, #24
 800b57a:	46bd      	mov	sp, r7
 800b57c:	bd80      	pop	{r7, pc}
 800b57e:	bf00      	nop
 800b580:	20007c4c 	.word	0x20007c4c

0800b584 <tcp_output_set_header>:
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);

static struct tcp_hdr *
tcp_output_set_header(struct tcp_pcb *pcb, struct pbuf *p, int optlen,
                      u32_t seqno_be /* already in network byte order */)
{
 800b584:	b590      	push	{r4, r7, lr}
 800b586:	b087      	sub	sp, #28
 800b588:	af00      	add	r7, sp, #0
 800b58a:	60f8      	str	r0, [r7, #12]
 800b58c:	60b9      	str	r1, [r7, #8]
 800b58e:	607a      	str	r2, [r7, #4]
 800b590:	603b      	str	r3, [r7, #0]
  struct tcp_hdr *tcphdr = p->payload;
 800b592:	68bb      	ldr	r3, [r7, #8]
 800b594:	685b      	ldr	r3, [r3, #4]
 800b596:	617b      	str	r3, [r7, #20]
  tcphdr->src = htons(pcb->local_port);
 800b598:	68fb      	ldr	r3, [r7, #12]
 800b59a:	8b1b      	ldrh	r3, [r3, #24]
 800b59c:	4618      	mov	r0, r3
 800b59e:	f7fb fb63 	bl	8006c68 <htons>
 800b5a2:	4603      	mov	r3, r0
 800b5a4:	461a      	mov	r2, r3
 800b5a6:	697b      	ldr	r3, [r7, #20]
 800b5a8:	801a      	strh	r2, [r3, #0]
  tcphdr->dest = htons(pcb->remote_port);
 800b5aa:	68fb      	ldr	r3, [r7, #12]
 800b5ac:	8c1b      	ldrh	r3, [r3, #32]
 800b5ae:	4618      	mov	r0, r3
 800b5b0:	f7fb fb5a 	bl	8006c68 <htons>
 800b5b4:	4603      	mov	r3, r0
 800b5b6:	461a      	mov	r2, r3
 800b5b8:	697b      	ldr	r3, [r7, #20]
 800b5ba:	805a      	strh	r2, [r3, #2]
  tcphdr->seqno = seqno_be;
 800b5bc:	697b      	ldr	r3, [r7, #20]
 800b5be:	683a      	ldr	r2, [r7, #0]
 800b5c0:	605a      	str	r2, [r3, #4]
  tcphdr->ackno = htonl(pcb->rcv_nxt);
 800b5c2:	68fb      	ldr	r3, [r7, #12]
 800b5c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b5c6:	4618      	mov	r0, r3
 800b5c8:	f7fb fb71 	bl	8006cae <htonl>
 800b5cc:	4602      	mov	r2, r0
 800b5ce:	697b      	ldr	r3, [r7, #20]
 800b5d0:	609a      	str	r2, [r3, #8]
  TCPH_FLAGS_SET(tcphdr, TCP_ACK);
 800b5d2:	697b      	ldr	r3, [r7, #20]
 800b5d4:	899b      	ldrh	r3, [r3, #12]
 800b5d6:	b29c      	uxth	r4, r3
 800b5d8:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 800b5dc:	f7fb fb44 	bl	8006c68 <htons>
 800b5e0:	4603      	mov	r3, r0
 800b5e2:	4023      	ands	r3, r4
 800b5e4:	b29c      	uxth	r4, r3
 800b5e6:	2010      	movs	r0, #16
 800b5e8:	f7fb fb3e 	bl	8006c68 <htons>
 800b5ec:	4603      	mov	r3, r0
 800b5ee:	4323      	orrs	r3, r4
 800b5f0:	b29a      	uxth	r2, r3
 800b5f2:	697b      	ldr	r3, [r7, #20]
 800b5f4:	819a      	strh	r2, [r3, #12]
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800b5f6:	68fb      	ldr	r3, [r7, #12]
 800b5f8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800b5fa:	4618      	mov	r0, r3
 800b5fc:	f7fb fb34 	bl	8006c68 <htons>
 800b600:	4603      	mov	r3, r0
 800b602:	461a      	mov	r2, r3
 800b604:	697b      	ldr	r3, [r7, #20]
 800b606:	81da      	strh	r2, [r3, #14]
  tcphdr->urgp = 0;
 800b608:	697b      	ldr	r3, [r7, #20]
 800b60a:	2200      	movs	r2, #0
 800b60c:	749a      	strb	r2, [r3, #18]
 800b60e:	2200      	movs	r2, #0
 800b610:	74da      	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, (5 + optlen / 4));
 800b612:	687b      	ldr	r3, [r7, #4]
 800b614:	2b00      	cmp	r3, #0
 800b616:	da00      	bge.n	800b61a <tcp_output_set_header+0x96>
 800b618:	3303      	adds	r3, #3
 800b61a:	109b      	asrs	r3, r3, #2
 800b61c:	b29b      	uxth	r3, r3
 800b61e:	3305      	adds	r3, #5
 800b620:	b29b      	uxth	r3, r3
 800b622:	031b      	lsls	r3, r3, #12
 800b624:	b29c      	uxth	r4, r3
 800b626:	697b      	ldr	r3, [r7, #20]
 800b628:	899b      	ldrh	r3, [r3, #12]
 800b62a:	b29b      	uxth	r3, r3
 800b62c:	4618      	mov	r0, r3
 800b62e:	f7fb fb30 	bl	8006c92 <ntohs>
 800b632:	4603      	mov	r3, r0
 800b634:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b638:	b29b      	uxth	r3, r3
 800b63a:	4323      	orrs	r3, r4
 800b63c:	b29b      	uxth	r3, r3
 800b63e:	4618      	mov	r0, r3
 800b640:	f7fb fb12 	bl	8006c68 <htons>
 800b644:	4603      	mov	r3, r0
 800b646:	461a      	mov	r2, r3
 800b648:	697b      	ldr	r3, [r7, #20]
 800b64a:	819a      	strh	r2, [r3, #12]
  tcphdr->chksum = 0;
 800b64c:	697b      	ldr	r3, [r7, #20]
 800b64e:	2200      	movs	r2, #0
 800b650:	741a      	strb	r2, [r3, #16]
 800b652:	2200      	movs	r2, #0
 800b654:	745a      	strb	r2, [r3, #17]

  /* If we're sending a packet, update the announced right window edge */
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800b656:	68fb      	ldr	r3, [r7, #12]
 800b658:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b65a:	68fa      	ldr	r2, [r7, #12]
 800b65c:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
 800b65e:	441a      	add	r2, r3
 800b660:	68fb      	ldr	r3, [r7, #12]
 800b662:	62da      	str	r2, [r3, #44]	; 0x2c

  return tcphdr;
 800b664:	697b      	ldr	r3, [r7, #20]
}
 800b666:	4618      	mov	r0, r3
 800b668:	371c      	adds	r7, #28
 800b66a:	46bd      	mov	sp, r7
 800b66c:	bd90      	pop	{r4, r7, pc}

0800b66e <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
 800b66e:	b580      	push	{r7, lr}
 800b670:	b084      	sub	sp, #16
 800b672:	af02      	add	r7, sp, #8
 800b674:	6078      	str	r0, [r7, #4]
 800b676:	460b      	mov	r3, r1
 800b678:	70fb      	strb	r3, [r7, #3]
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, 0);
 800b67a:	78fa      	ldrb	r2, [r7, #3]
 800b67c:	2300      	movs	r3, #0
 800b67e:	9301      	str	r3, [sp, #4]
 800b680:	2301      	movs	r3, #1
 800b682:	9300      	str	r3, [sp, #0]
 800b684:	4613      	mov	r3, r2
 800b686:	2200      	movs	r2, #0
 800b688:	2100      	movs	r1, #0
 800b68a:	6878      	ldr	r0, [r7, #4]
 800b68c:	f000 f837 	bl	800b6fe <tcp_enqueue>
 800b690:	4603      	mov	r3, r0
}
 800b692:	4618      	mov	r0, r3
 800b694:	3708      	adds	r7, #8
 800b696:	46bd      	mov	sp, r7
 800b698:	bd80      	pop	{r7, pc}

0800b69a <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
 800b69a:	b580      	push	{r7, lr}
 800b69c:	b086      	sub	sp, #24
 800b69e:	af02      	add	r7, sp, #8
 800b6a0:	60f8      	str	r0, [r7, #12]
 800b6a2:	60b9      	str	r1, [r7, #8]
 800b6a4:	4611      	mov	r1, r2
 800b6a6:	461a      	mov	r2, r3
 800b6a8:	460b      	mov	r3, r1
 800b6aa:	80fb      	strh	r3, [r7, #6]
 800b6ac:	4613      	mov	r3, r2
 800b6ae:	717b      	strb	r3, [r7, #5]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
 800b6b0:	68fb      	ldr	r3, [r7, #12]
 800b6b2:	7c1b      	ldrb	r3, [r3, #16]
 800b6b4:	2b04      	cmp	r3, #4
 800b6b6:	d00b      	beq.n	800b6d0 <tcp_write+0x36>
     pcb->state == CLOSE_WAIT ||
 800b6b8:	68fb      	ldr	r3, [r7, #12]
 800b6ba:	7c1b      	ldrb	r3, [r3, #16]
  if (pcb->state == ESTABLISHED ||
 800b6bc:	2b07      	cmp	r3, #7
 800b6be:	d007      	beq.n	800b6d0 <tcp_write+0x36>
     pcb->state == SYN_SENT ||
 800b6c0:	68fb      	ldr	r3, [r7, #12]
 800b6c2:	7c1b      	ldrb	r3, [r3, #16]
     pcb->state == CLOSE_WAIT ||
 800b6c4:	2b02      	cmp	r3, #2
 800b6c6:	d003      	beq.n	800b6d0 <tcp_write+0x36>
     pcb->state == SYN_RCVD) {
 800b6c8:	68fb      	ldr	r3, [r7, #12]
 800b6ca:	7c1b      	ldrb	r3, [r3, #16]
     pcb->state == SYN_SENT ||
 800b6cc:	2b03      	cmp	r3, #3
 800b6ce:	d110      	bne.n	800b6f2 <tcp_write+0x58>
    if (len > 0) {
 800b6d0:	88fb      	ldrh	r3, [r7, #6]
 800b6d2:	2b00      	cmp	r3, #0
 800b6d4:	d00b      	beq.n	800b6ee <tcp_write+0x54>
#if LWIP_TCP_TIMESTAMPS
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 
                         pcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0);
#else
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 0);
 800b6d6:	88fa      	ldrh	r2, [r7, #6]
 800b6d8:	2300      	movs	r3, #0
 800b6da:	9301      	str	r3, [sp, #4]
 800b6dc:	797b      	ldrb	r3, [r7, #5]
 800b6de:	9300      	str	r3, [sp, #0]
 800b6e0:	2300      	movs	r3, #0
 800b6e2:	68b9      	ldr	r1, [r7, #8]
 800b6e4:	68f8      	ldr	r0, [r7, #12]
 800b6e6:	f000 f80a 	bl	800b6fe <tcp_enqueue>
 800b6ea:	4603      	mov	r3, r0
 800b6ec:	e003      	b.n	800b6f6 <tcp_write+0x5c>
#endif
    }
    return ERR_OK;
 800b6ee:	2300      	movs	r3, #0
 800b6f0:	e001      	b.n	800b6f6 <tcp_write+0x5c>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 800b6f2:	f06f 0307 	mvn.w	r3, #7
  }
}
 800b6f6:	4618      	mov	r0, r3
 800b6f8:	3710      	adds	r7, #16
 800b6fa:	46bd      	mov	sp, r7
 800b6fc:	bd80      	pop	{r7, pc}

0800b6fe <tcp_enqueue>:
 * @param optflags options to include in segment later on (see definition of struct tcp_seg)
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
            u8_t flags, u8_t apiflags, u8_t optflags)
{
 800b6fe:	b5b0      	push	{r4, r5, r7, lr}
 800b700:	b08e      	sub	sp, #56	; 0x38
 800b702:	af00      	add	r7, sp, #0
 800b704:	60f8      	str	r0, [r7, #12]
 800b706:	60b9      	str	r1, [r7, #8]
 800b708:	4611      	mov	r1, r2
 800b70a:	461a      	mov	r2, r3
 800b70c:	460b      	mov	r3, r1
 800b70e:	80fb      	strh	r3, [r7, #6]
 800b710:	4613      	mov	r3, r2
 800b712:	717b      	strb	r3, [r7, #5]
  u8_t optlen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
               (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: packet needs payload, options, or SYN/FIN (programmer violates API)",
 800b714:	88fb      	ldrh	r3, [r7, #6]
 800b716:	2b00      	cmp	r3, #0
 800b718:	d10b      	bne.n	800b732 <tcp_enqueue+0x34>
 800b71a:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800b71e:	2b00      	cmp	r3, #0
 800b720:	d107      	bne.n	800b732 <tcp_enqueue+0x34>
 800b722:	797b      	ldrb	r3, [r7, #5]
 800b724:	f003 0303 	and.w	r3, r3, #3
 800b728:	2b00      	cmp	r3, #0
 800b72a:	d102      	bne.n	800b732 <tcp_enqueue+0x34>
 800b72c:	f06f 0309 	mvn.w	r3, #9
 800b730:	e2c4      	b.n	800bcbc <tcp_enqueue+0x5be>
             ((len != 0) || (optflags != 0) || ((flags & (TCP_SYN | TCP_FIN)) != 0)),
             return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: len != 0 || arg == NULL (programmer violates API)", 
 800b732:	88fb      	ldrh	r3, [r7, #6]
 800b734:	2b00      	cmp	r3, #0
 800b736:	d105      	bne.n	800b744 <tcp_enqueue+0x46>
 800b738:	68bb      	ldr	r3, [r7, #8]
 800b73a:	2b00      	cmp	r3, #0
 800b73c:	d002      	beq.n	800b744 <tcp_enqueue+0x46>
 800b73e:	f06f 0309 	mvn.w	r3, #9
 800b742:	e2bb      	b.n	800bcbc <tcp_enqueue+0x5be>
             ((len != 0) || (arg == NULL)), return ERR_ARG;);

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 800b744:	68fb      	ldr	r3, [r7, #12]
 800b746:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 800b74a:	88fa      	ldrh	r2, [r7, #6]
 800b74c:	429a      	cmp	r2, r3
 800b74e:	d90b      	bls.n	800b768 <tcp_enqueue+0x6a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
 800b750:	68fb      	ldr	r3, [r7, #12]
 800b752:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b756:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800b75a:	b2da      	uxtb	r2, r3
 800b75c:	68fb      	ldr	r3, [r7, #12]
 800b75e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    return ERR_MEM;
 800b762:	f04f 33ff 	mov.w	r3, #4294967295
 800b766:	e2a9      	b.n	800bcbc <tcp_enqueue+0x5be>
  }
  left = len;
 800b768:	88fb      	ldrh	r3, [r7, #6]
 800b76a:	84fb      	strh	r3, [r7, #38]	; 0x26
  ptr = arg;
 800b76c:	68bb      	ldr	r3, [r7, #8]
 800b76e:	623b      	str	r3, [r7, #32]

  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800b770:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800b774:	f003 0301 	and.w	r3, r3, #1
 800b778:	2b00      	cmp	r3, #0
 800b77a:	d001      	beq.n	800b780 <tcp_enqueue+0x82>
 800b77c:	2204      	movs	r2, #4
 800b77e:	e000      	b.n	800b782 <tcp_enqueue+0x84>
 800b780:	2200      	movs	r2, #0
 800b782:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800b786:	f003 0302 	and.w	r3, r3, #2
 800b78a:	2b00      	cmp	r3, #0
 800b78c:	d001      	beq.n	800b792 <tcp_enqueue+0x94>
 800b78e:	230c      	movs	r3, #12
 800b790:	e000      	b.n	800b794 <tcp_enqueue+0x96>
 800b792:	2300      	movs	r3, #0
 800b794:	4413      	add	r3, r2
 800b796:	777b      	strb	r3, [r7, #29]

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
 800b798:	68fb      	ldr	r3, [r7, #12]
 800b79a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800b79c:	62bb      	str	r3, [r7, #40]	; 0x28

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
 800b79e:	68fb      	ldr	r3, [r7, #12]
 800b7a0:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 800b7a4:	83fb      	strh	r3, [r7, #30]
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800b7a6:	8bfb      	ldrh	r3, [r7, #30]
 800b7a8:	2b07      	cmp	r3, #7
 800b7aa:	d804      	bhi.n	800b7b6 <tcp_enqueue+0xb8>
 800b7ac:	8bfb      	ldrh	r3, [r7, #30]
 800b7ae:	f64f 72fc 	movw	r2, #65532	; 0xfffc
 800b7b2:	4293      	cmp	r3, r2
 800b7b4:	d90b      	bls.n	800b7ce <tcp_enqueue+0xd0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
 800b7b6:	68fb      	ldr	r3, [r7, #12]
 800b7b8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800b7bc:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800b7c0:	b2da      	uxtb	r2, r3
 800b7c2:	68fb      	ldr	r3, [r7, #12]
 800b7c4:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    return ERR_MEM;
 800b7c8:	f04f 33ff 	mov.w	r3, #4294967295
 800b7cc:	e276      	b.n	800bcbc <tcp_enqueue+0x5be>
  }
  if (queuelen != 0) {
 800b7ce:	8bfb      	ldrh	r3, [r7, #30]
 800b7d0:	2b00      	cmp	r3, #0
 800b7d2:	d003      	beq.n	800b7dc <tcp_enqueue+0xde>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
 800b7d4:	68fb      	ldr	r3, [r7, #12]
 800b7d6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b7d8:	2b00      	cmp	r3, #0
 800b7da:	e002      	b.n	800b7e2 <tcp_enqueue+0xe4>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
 800b7dc:	68fb      	ldr	r3, [r7, #12]
 800b7de:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b7e0:	2b00      	cmp	r3, #0
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
 800b7e2:	2300      	movs	r3, #0
 800b7e4:	637b      	str	r3, [r7, #52]	; 0x34
 800b7e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b7e8:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b7ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7ec:	633b      	str	r3, [r7, #48]	; 0x30
  seglen = 0;
 800b7ee:	2300      	movs	r3, #0
 800b7f0:	84bb      	strh	r3, [r7, #36]	; 0x24
  while (queue == NULL || left > 0) {
 800b7f2:	e114      	b.n	800ba1e <tcp_enqueue+0x320>
    /* The segment length (including options) should be at most the MSS */
    seglen = left > (pcb->mss - optlen) ? (pcb->mss - optlen) : left;
 800b7f4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800b7f6:	68fb      	ldr	r3, [r7, #12]
 800b7f8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800b7fa:	4619      	mov	r1, r3
 800b7fc:	7f7b      	ldrb	r3, [r7, #29]
 800b7fe:	1acb      	subs	r3, r1, r3
 800b800:	4293      	cmp	r3, r2
 800b802:	bfa8      	it	ge
 800b804:	4613      	movge	r3, r2
 800b806:	84bb      	strh	r3, [r7, #36]	; 0x24

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
 800b808:	2004      	movs	r0, #4
 800b80a:	f7fc fc7d 	bl	8008108 <memp_malloc>
 800b80e:	6378      	str	r0, [r7, #52]	; 0x34
    if (seg == NULL) {
 800b810:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b812:	2b00      	cmp	r3, #0
 800b814:	f000 8230 	beq.w	800bc78 <tcp_enqueue+0x57a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                  ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
 800b818:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b81a:	2200      	movs	r2, #0
 800b81c:	601a      	str	r2, [r3, #0]
    seg->p = NULL;
 800b81e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b820:	2200      	movs	r2, #0
 800b822:	605a      	str	r2, [r3, #4]

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 800b824:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b826:	2b00      	cmp	r3, #0
 800b828:	d102      	bne.n	800b830 <tcp_enqueue+0x132>
      queue = seg;
 800b82a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b82c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b82e:	e002      	b.n	800b836 <tcp_enqueue+0x138>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
      useg->next = seg;
 800b830:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b832:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b834:	601a      	str	r2, [r3, #0]
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
 800b836:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b838:	633b      	str	r3, [r7, #48]	; 0x30

    /* If copy is set, memory should be allocated
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied.  */
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800b83a:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 800b83e:	f003 0301 	and.w	r3, r3, #1
 800b842:	2b00      	cmp	r3, #0
 800b844:	d02e      	beq.n	800b8a4 <tcp_enqueue+0x1a6>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
 800b846:	7f7b      	ldrb	r3, [r7, #29]
 800b848:	b29a      	uxth	r2, r3
 800b84a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b84c:	4413      	add	r3, r2
 800b84e:	b29b      	uxth	r3, r3
 800b850:	2200      	movs	r2, #0
 800b852:	4619      	mov	r1, r3
 800b854:	2000      	movs	r0, #0
 800b856:	f7fc fddb 	bl	8008410 <pbuf_alloc>
 800b85a:	4602      	mov	r2, r0
 800b85c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b85e:	605a      	str	r2, [r3, #4]
 800b860:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b862:	685b      	ldr	r3, [r3, #4]
 800b864:	2b00      	cmp	r3, #0
 800b866:	f000 8209 	beq.w	800bc7c <tcp_enqueue+0x57e>
                    ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen + optlen));
      queuelen += pbuf_clen(seg->p);
 800b86a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b86c:	685b      	ldr	r3, [r3, #4]
 800b86e:	4618      	mov	r0, r3
 800b870:	f7fc ffea 	bl	8008848 <pbuf_clen>
 800b874:	4603      	mov	r3, r0
 800b876:	b29a      	uxth	r2, r3
 800b878:	8bfb      	ldrh	r3, [r7, #30]
 800b87a:	4413      	add	r3, r2
 800b87c:	83fb      	strh	r3, [r7, #30]
      if (arg != NULL) {
 800b87e:	68bb      	ldr	r3, [r7, #8]
 800b880:	2b00      	cmp	r3, #0
 800b882:	d009      	beq.n	800b898 <tcp_enqueue+0x19a>
        MEMCPY((char *)seg->p->payload + optlen, ptr, seglen);
 800b884:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b886:	685b      	ldr	r3, [r3, #4]
 800b888:	685a      	ldr	r2, [r3, #4]
 800b88a:	7f7b      	ldrb	r3, [r7, #29]
 800b88c:	4413      	add	r3, r2
 800b88e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800b890:	6a39      	ldr	r1, [r7, #32]
 800b892:	4618      	mov	r0, r3
 800b894:	f002 fee7 	bl	800e666 <memcpy>
      }
      seg->dataptr = seg->p->payload;
 800b898:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b89a:	685b      	ldr	r3, [r3, #4]
 800b89c:	685a      	ldr	r2, [r3, #4]
 800b89e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8a0:	609a      	str	r2, [r3, #8]
 800b8a2:	e03f      	b.n	800b924 <tcp_enqueue+0x226>
    }
    /* do not copy data */
    else {
      /* First, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800b8a4:	7f7b      	ldrb	r3, [r7, #29]
 800b8a6:	b29b      	uxth	r3, r3
 800b8a8:	2200      	movs	r2, #0
 800b8aa:	4619      	mov	r1, r3
 800b8ac:	2000      	movs	r0, #0
 800b8ae:	f7fc fdaf 	bl	8008410 <pbuf_alloc>
 800b8b2:	4602      	mov	r2, r0
 800b8b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8b6:	605a      	str	r2, [r3, #4]
 800b8b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8ba:	685b      	ldr	r3, [r3, #4]
 800b8bc:	2b00      	cmp	r3, #0
 800b8be:	f000 81df 	beq.w	800bc80 <tcp_enqueue+0x582>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      queuelen += pbuf_clen(seg->p);
 800b8c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8c4:	685b      	ldr	r3, [r3, #4]
 800b8c6:	4618      	mov	r0, r3
 800b8c8:	f7fc ffbe 	bl	8008848 <pbuf_clen>
 800b8cc:	4603      	mov	r3, r0
 800b8ce:	b29a      	uxth	r2, r3
 800b8d0:	8bfb      	ldrh	r3, [r7, #30]
 800b8d2:	4413      	add	r3, r2
 800b8d4:	83fb      	strh	r3, [r7, #30]
      /* Second, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if (left > 0) {
 800b8d6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800b8d8:	2b00      	cmp	r3, #0
 800b8da:	d023      	beq.n	800b924 <tcp_enqueue+0x226>
        if ((p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800b8dc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b8de:	2201      	movs	r2, #1
 800b8e0:	4619      	mov	r1, r3
 800b8e2:	2003      	movs	r0, #3
 800b8e4:	f7fc fd94 	bl	8008410 <pbuf_alloc>
 800b8e8:	61b8      	str	r0, [r7, #24]
 800b8ea:	69bb      	ldr	r3, [r7, #24]
 800b8ec:	2b00      	cmp	r3, #0
 800b8ee:	d108      	bne.n	800b902 <tcp_enqueue+0x204>
          /* If allocation fails, we have to deallocate the header pbuf as well. */
          pbuf_free(seg->p);
 800b8f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8f2:	685b      	ldr	r3, [r3, #4]
 800b8f4:	4618      	mov	r0, r3
 800b8f6:	f7fc ff58 	bl	80087aa <pbuf_free>
          seg->p = NULL;
 800b8fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8fc:	2200      	movs	r2, #0
 800b8fe:	605a      	str	r2, [r3, #4]
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                      ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
 800b900:	e1c3      	b.n	800bc8a <tcp_enqueue+0x58c>
        }
        ++queuelen;
 800b902:	8bfb      	ldrh	r3, [r7, #30]
 800b904:	3301      	adds	r3, #1
 800b906:	83fb      	strh	r3, [r7, #30]
        /* reference the non-volatile payload data */
        p->payload = ptr;
 800b908:	69bb      	ldr	r3, [r7, #24]
 800b90a:	6a3a      	ldr	r2, [r7, #32]
 800b90c:	605a      	str	r2, [r3, #4]
        seg->dataptr = ptr;
 800b90e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b910:	6a3a      	ldr	r2, [r7, #32]
 800b912:	609a      	str	r2, [r3, #8]

        /* Concatenate the headers and data pbufs together. */
        pbuf_cat(seg->p/*header*/, p/*data*/);
 800b914:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b916:	685b      	ldr	r3, [r3, #4]
 800b918:	69b9      	ldr	r1, [r7, #24]
 800b91a:	4618      	mov	r0, r3
 800b91c:	f7fc ffbe 	bl	800889c <pbuf_cat>
        p = NULL;
 800b920:	2300      	movs	r3, #0
 800b922:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800b924:	8bfb      	ldrh	r3, [r7, #30]
 800b926:	2b08      	cmp	r3, #8
 800b928:	f200 81af 	bhi.w	800bc8a <tcp_enqueue+0x58c>
 800b92c:	8bfb      	ldrh	r3, [r7, #30]
 800b92e:	f64f 72fc 	movw	r2, #65532	; 0xfffc
 800b932:	4293      	cmp	r3, r2
 800b934:	f200 81a9 	bhi.w	800bc8a <tcp_enqueue+0x58c>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
 800b938:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b93a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800b93c:	819a      	strh	r2, [r3, #12]

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
 800b93e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b940:	685b      	ldr	r3, [r3, #4]
 800b942:	2114      	movs	r1, #20
 800b944:	4618      	mov	r0, r3
 800b946:	f7fc fec1 	bl	80086cc <pbuf_header>
 800b94a:	4603      	mov	r3, r0
 800b94c:	2b00      	cmp	r3, #0
 800b94e:	f040 8199 	bne.w	800bc84 <tcp_enqueue+0x586>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
 800b952:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b954:	685b      	ldr	r3, [r3, #4]
 800b956:	685a      	ldr	r2, [r3, #4]
 800b958:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b95a:	611a      	str	r2, [r3, #16]
    seg->tcphdr->src = htons(pcb->local_port);
 800b95c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b95e:	691c      	ldr	r4, [r3, #16]
 800b960:	68fb      	ldr	r3, [r7, #12]
 800b962:	8b1b      	ldrh	r3, [r3, #24]
 800b964:	4618      	mov	r0, r3
 800b966:	f7fb f97f 	bl	8006c68 <htons>
 800b96a:	4603      	mov	r3, r0
 800b96c:	8023      	strh	r3, [r4, #0]
    seg->tcphdr->dest = htons(pcb->remote_port);
 800b96e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b970:	691c      	ldr	r4, [r3, #16]
 800b972:	68fb      	ldr	r3, [r7, #12]
 800b974:	8c1b      	ldrh	r3, [r3, #32]
 800b976:	4618      	mov	r0, r3
 800b978:	f7fb f976 	bl	8006c68 <htons>
 800b97c:	4603      	mov	r3, r0
 800b97e:	8063      	strh	r3, [r4, #2]
    seg->tcphdr->seqno = htonl(seqno);
 800b980:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b982:	691c      	ldr	r4, [r3, #16]
 800b984:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800b986:	f7fb f992 	bl	8006cae <htonl>
 800b98a:	4603      	mov	r3, r0
 800b98c:	6063      	str	r3, [r4, #4]
    seg->tcphdr->urgp = 0;
 800b98e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b990:	691b      	ldr	r3, [r3, #16]
 800b992:	2200      	movs	r2, #0
 800b994:	749a      	strb	r2, [r3, #18]
 800b996:	2200      	movs	r2, #0
 800b998:	74da      	strb	r2, [r3, #19]
    TCPH_FLAGS_SET(seg->tcphdr, flags);
 800b99a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b99c:	691c      	ldr	r4, [r3, #16]
 800b99e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b9a0:	691b      	ldr	r3, [r3, #16]
 800b9a2:	899b      	ldrh	r3, [r3, #12]
 800b9a4:	b29d      	uxth	r5, r3
 800b9a6:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 800b9aa:	f7fb f95d 	bl	8006c68 <htons>
 800b9ae:	4603      	mov	r3, r0
 800b9b0:	402b      	ands	r3, r5
 800b9b2:	b29d      	uxth	r5, r3
 800b9b4:	797b      	ldrb	r3, [r7, #5]
 800b9b6:	b29b      	uxth	r3, r3
 800b9b8:	4618      	mov	r0, r3
 800b9ba:	f7fb f955 	bl	8006c68 <htons>
 800b9be:	4603      	mov	r3, r0
 800b9c0:	432b      	orrs	r3, r5
 800b9c2:	b29b      	uxth	r3, r3
 800b9c4:	81a3      	strh	r3, [r4, #12]
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    seg->flags = optflags;
 800b9c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b9c8:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 800b9cc:	739a      	strb	r2, [r3, #14]

    /* Set the length of the header */
    TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
 800b9ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b9d0:	691c      	ldr	r4, [r3, #16]
 800b9d2:	7f7b      	ldrb	r3, [r7, #29]
 800b9d4:	089b      	lsrs	r3, r3, #2
 800b9d6:	b2db      	uxtb	r3, r3
 800b9d8:	b29b      	uxth	r3, r3
 800b9da:	3305      	adds	r3, #5
 800b9dc:	b29b      	uxth	r3, r3
 800b9de:	031b      	lsls	r3, r3, #12
 800b9e0:	b29d      	uxth	r5, r3
 800b9e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b9e4:	691b      	ldr	r3, [r3, #16]
 800b9e6:	899b      	ldrh	r3, [r3, #12]
 800b9e8:	b29b      	uxth	r3, r3
 800b9ea:	4618      	mov	r0, r3
 800b9ec:	f7fb f951 	bl	8006c92 <ntohs>
 800b9f0:	4603      	mov	r3, r0
 800b9f2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b9f6:	b29b      	uxth	r3, r3
 800b9f8:	432b      	orrs	r3, r5
 800b9fa:	b29b      	uxth	r3, r3
 800b9fc:	4618      	mov	r0, r3
 800b9fe:	f7fb f933 	bl	8006c68 <htons>
 800ba02:	4603      	mov	r3, r0
 800ba04:	81a3      	strh	r3, [r4, #12]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
 800ba06:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800ba08:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ba0a:	1ad3      	subs	r3, r2, r3
 800ba0c:	84fb      	strh	r3, [r7, #38]	; 0x26
    seqno += seglen;
 800ba0e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ba10:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800ba12:	4413      	add	r3, r2
 800ba14:	62bb      	str	r3, [r7, #40]	; 0x28
    ptr = (void *)((u8_t *)ptr + seglen);
 800ba16:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ba18:	6a3a      	ldr	r2, [r7, #32]
 800ba1a:	4413      	add	r3, r2
 800ba1c:	623b      	str	r3, [r7, #32]
  while (queue == NULL || left > 0) {
 800ba1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba20:	2b00      	cmp	r3, #0
 800ba22:	f43f aee7 	beq.w	800b7f4 <tcp_enqueue+0xf6>
 800ba26:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800ba28:	2b00      	cmp	r3, #0
 800ba2a:	f47f aee3 	bne.w	800b7f4 <tcp_enqueue+0xf6>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
 800ba2e:	68fb      	ldr	r3, [r7, #12]
 800ba30:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ba32:	2b00      	cmp	r3, #0
 800ba34:	d102      	bne.n	800ba3c <tcp_enqueue+0x33e>
    useg = NULL;
 800ba36:	2300      	movs	r3, #0
 800ba38:	633b      	str	r3, [r7, #48]	; 0x30
 800ba3a:	e00a      	b.n	800ba52 <tcp_enqueue+0x354>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 800ba3c:	68fb      	ldr	r3, [r7, #12]
 800ba3e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ba40:	633b      	str	r3, [r7, #48]	; 0x30
 800ba42:	e002      	b.n	800ba4a <tcp_enqueue+0x34c>
 800ba44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba46:	681b      	ldr	r3, [r3, #0]
 800ba48:	633b      	str	r3, [r7, #48]	; 0x30
 800ba4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba4c:	681b      	ldr	r3, [r3, #0]
 800ba4e:	2b00      	cmp	r3, #0
 800ba50:	d1f8      	bne.n	800ba44 <tcp_enqueue+0x346>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
 800ba52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba54:	2b00      	cmp	r3, #0
 800ba56:	f000 80b0 	beq.w	800bbba <tcp_enqueue+0x4bc>
    TCP_TCPLEN(useg) != 0 &&
 800ba5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba5c:	899b      	ldrh	r3, [r3, #12]
 800ba5e:	461c      	mov	r4, r3
 800ba60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba62:	691b      	ldr	r3, [r3, #16]
 800ba64:	899b      	ldrh	r3, [r3, #12]
 800ba66:	b29b      	uxth	r3, r3
 800ba68:	4618      	mov	r0, r3
 800ba6a:	f7fb f912 	bl	8006c92 <ntohs>
 800ba6e:	4603      	mov	r3, r0
 800ba70:	f003 0303 	and.w	r3, r3, #3
 800ba74:	2b00      	cmp	r3, #0
 800ba76:	bf14      	ite	ne
 800ba78:	2301      	movne	r3, #1
 800ba7a:	2300      	moveq	r3, #0
 800ba7c:	b2db      	uxtb	r3, r3
 800ba7e:	4423      	add	r3, r4
  if (useg != NULL &&
 800ba80:	2b00      	cmp	r3, #0
 800ba82:	f000 809a 	beq.w	800bbba <tcp_enqueue+0x4bc>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
 800ba86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba88:	691b      	ldr	r3, [r3, #16]
 800ba8a:	899b      	ldrh	r3, [r3, #12]
 800ba8c:	b29b      	uxth	r3, r3
 800ba8e:	4618      	mov	r0, r3
 800ba90:	f7fb f8ff 	bl	8006c92 <ntohs>
 800ba94:	4603      	mov	r3, r0
 800ba96:	f003 0303 	and.w	r3, r3, #3
    TCP_TCPLEN(useg) != 0 &&
 800ba9a:	2b00      	cmp	r3, #0
 800ba9c:	f040 808d 	bne.w	800bbba <tcp_enqueue+0x4bc>
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
 800baa0:	797b      	ldrb	r3, [r7, #5]
 800baa2:	f003 0303 	and.w	r3, r3, #3
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
 800baa6:	2b00      	cmp	r3, #0
 800baa8:	d003      	beq.n	800bab2 <tcp_enqueue+0x3b4>
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
 800baaa:	797b      	ldrb	r3, [r7, #5]
 800baac:	2b01      	cmp	r3, #1
 800baae:	f040 8084 	bne.w	800bbba <tcp_enqueue+0x4bc>
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
 800bab2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bab4:	899b      	ldrh	r3, [r3, #12]
 800bab6:	461a      	mov	r2, r3
 800bab8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800baba:	899b      	ldrh	r3, [r3, #12]
 800babc:	4413      	add	r3, r2
 800babe:	68fa      	ldr	r2, [r7, #12]
 800bac0:	8f12      	ldrh	r2, [r2, #56]	; 0x38
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
 800bac2:	4293      	cmp	r3, r2
 800bac4:	dc79      	bgt.n	800bbba <tcp_enqueue+0x4bc>
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
 800bac6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bac8:	7b9a      	ldrb	r2, [r3, #14]
 800baca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bacc:	7b9b      	ldrb	r3, [r3, #14]
    (useg->len + queue->len <= pcb->mss) &&
 800bace:	429a      	cmp	r2, r3
 800bad0:	d173      	bne.n	800bbba <tcp_enqueue+0x4bc>
    /* segments are consecutive */
    (ntohl(useg->tcphdr->seqno) + useg->len == ntohl(queue->tcphdr->seqno)) ) {
 800bad2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bad4:	691b      	ldr	r3, [r3, #16]
 800bad6:	685b      	ldr	r3, [r3, #4]
 800bad8:	4618      	mov	r0, r3
 800bada:	f7fb f901 	bl	8006ce0 <ntohl>
 800bade:	4602      	mov	r2, r0
 800bae0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bae2:	899b      	ldrh	r3, [r3, #12]
 800bae4:	18d4      	adds	r4, r2, r3
 800bae6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bae8:	691b      	ldr	r3, [r3, #16]
 800baea:	685b      	ldr	r3, [r3, #4]
 800baec:	4618      	mov	r0, r3
 800baee:	f7fb f8f7 	bl	8006ce0 <ntohl>
 800baf2:	4603      	mov	r3, r0
    (useg->flags == queue->flags) &&
 800baf4:	429c      	cmp	r4, r3
 800baf6:	d160      	bne.n	800bbba <tcp_enqueue+0x4bc>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -(TCP_HLEN + optlen))) {
 800baf8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bafa:	6858      	ldr	r0, [r3, #4]
 800bafc:	7f7b      	ldrb	r3, [r7, #29]
 800bafe:	b29a      	uxth	r2, r3
 800bb00:	f06f 0313 	mvn.w	r3, #19
 800bb04:	1a9b      	subs	r3, r3, r2
 800bb06:	b29b      	uxth	r3, r3
 800bb08:	b21b      	sxth	r3, r3
 800bb0a:	4619      	mov	r1, r3
 800bb0c:	f7fc fdde 	bl	80086cc <pbuf_header>
 800bb10:	4603      	mov	r3, r0
 800bb12:	2b00      	cmp	r3, #0
 800bb14:	f040 80b8 	bne.w	800bc88 <tcp_enqueue+0x58a>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    if (queue->p->len == 0) {
 800bb18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb1a:	685b      	ldr	r3, [r3, #4]
 800bb1c:	895b      	ldrh	r3, [r3, #10]
 800bb1e:	2b00      	cmp	r3, #0
 800bb20:	d110      	bne.n	800bb44 <tcp_enqueue+0x446>
      /* free the first (header-only) pbuf if it is now empty (contained only headers) */
      struct pbuf *old_q = queue->p;
 800bb22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb24:	685b      	ldr	r3, [r3, #4]
 800bb26:	617b      	str	r3, [r7, #20]
      queue->p = queue->p->next;
 800bb28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb2a:	685b      	ldr	r3, [r3, #4]
 800bb2c:	681a      	ldr	r2, [r3, #0]
 800bb2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb30:	605a      	str	r2, [r3, #4]
      old_q->next = NULL;
 800bb32:	697b      	ldr	r3, [r7, #20]
 800bb34:	2200      	movs	r2, #0
 800bb36:	601a      	str	r2, [r3, #0]
      queuelen--;
 800bb38:	8bfb      	ldrh	r3, [r7, #30]
 800bb3a:	3b01      	subs	r3, #1
 800bb3c:	83fb      	strh	r3, [r7, #30]
      pbuf_free(old_q);
 800bb3e:	6978      	ldr	r0, [r7, #20]
 800bb40:	f7fc fe33 	bl	80087aa <pbuf_free>
    }
    if (flags & TCP_FIN) {
 800bb44:	797b      	ldrb	r3, [r7, #5]
 800bb46:	f003 0301 	and.w	r3, r3, #1
 800bb4a:	2b00      	cmp	r3, #0
 800bb4c:	d010      	beq.n	800bb70 <tcp_enqueue+0x472>
      /* the new segment contains only FIN, no data -> put the FIN into the last segment */
      LWIP_ASSERT("FIN enqueued together with data", queue->p == NULL && queue->len == 0);
 800bb4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb50:	685b      	ldr	r3, [r3, #4]
 800bb52:	2b00      	cmp	r3, #0
      TCPH_SET_FLAG(useg->tcphdr, TCP_FIN);
 800bb54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb56:	691c      	ldr	r4, [r3, #16]
 800bb58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb5a:	691b      	ldr	r3, [r3, #16]
 800bb5c:	899b      	ldrh	r3, [r3, #12]
 800bb5e:	b29d      	uxth	r5, r3
 800bb60:	2001      	movs	r0, #1
 800bb62:	f7fb f881 	bl	8006c68 <htons>
 800bb66:	4603      	mov	r3, r0
 800bb68:	432b      	orrs	r3, r5
 800bb6a:	b29b      	uxth	r3, r3
 800bb6c:	81a3      	strh	r3, [r4, #12]
 800bb6e:	e016      	b.n	800bb9e <tcp_enqueue+0x4a0>
    } else {
      LWIP_ASSERT("zero-length pbuf", (queue->p != NULL) && (queue->p->len > 0));
 800bb70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb72:	685b      	ldr	r3, [r3, #4]
 800bb74:	2b00      	cmp	r3, #0
      pbuf_cat(useg->p, queue->p);
 800bb76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb78:	685a      	ldr	r2, [r3, #4]
 800bb7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb7c:	685b      	ldr	r3, [r3, #4]
 800bb7e:	4619      	mov	r1, r3
 800bb80:	4610      	mov	r0, r2
 800bb82:	f7fc fe8b 	bl	800889c <pbuf_cat>
      useg->len += queue->len;
 800bb86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb88:	899a      	ldrh	r2, [r3, #12]
 800bb8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb8c:	899b      	ldrh	r3, [r3, #12]
 800bb8e:	4413      	add	r3, r2
 800bb90:	b29a      	uxth	r2, r3
 800bb92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb94:	819a      	strh	r2, [r3, #12]
      useg->next = queue->next;
 800bb96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb98:	681a      	ldr	r2, [r3, #0]
 800bb9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb9c:	601a      	str	r2, [r3, #0]
    }

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
 800bb9e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800bba0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bba2:	429a      	cmp	r2, r3
 800bba4:	d104      	bne.n	800bbb0 <tcp_enqueue+0x4b2>
      seg = useg;
 800bba6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bba8:	637b      	str	r3, [r7, #52]	; 0x34
      seglen = useg->len;
 800bbaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bbac:	899b      	ldrh	r3, [r3, #12]
 800bbae:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    memp_free(MEMP_TCP_SEG, queue);
 800bbb0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800bbb2:	2004      	movs	r0, #4
 800bbb4:	f7fc faca 	bl	800814c <memp_free>
 800bbb8:	e009      	b.n	800bbce <tcp_enqueue+0x4d0>
  }
  else {
    /* empty list */
    if (useg == NULL) {
 800bbba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bbbc:	2b00      	cmp	r3, #0
 800bbbe:	d103      	bne.n	800bbc8 <tcp_enqueue+0x4ca>
      /* initialize list with this segment */
      pcb->unsent = queue;
 800bbc0:	68fb      	ldr	r3, [r7, #12]
 800bbc2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bbc4:	675a      	str	r2, [r3, #116]	; 0x74
 800bbc6:	e002      	b.n	800bbce <tcp_enqueue+0x4d0>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
 800bbc8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bbca:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bbcc:	601a      	str	r2, [r3, #0]
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 800bbce:	797b      	ldrb	r3, [r7, #5]
 800bbd0:	f003 0302 	and.w	r3, r3, #2
 800bbd4:	2b00      	cmp	r3, #0
 800bbd6:	d104      	bne.n	800bbe2 <tcp_enqueue+0x4e4>
 800bbd8:	797b      	ldrb	r3, [r7, #5]
 800bbda:	f003 0301 	and.w	r3, r3, #1
 800bbde:	2b00      	cmp	r3, #0
 800bbe0:	d002      	beq.n	800bbe8 <tcp_enqueue+0x4ea>
    ++len;
 800bbe2:	88fb      	ldrh	r3, [r7, #6]
 800bbe4:	3301      	adds	r3, #1
 800bbe6:	80fb      	strh	r3, [r7, #6]
  }
  if (flags & TCP_FIN) {
 800bbe8:	797b      	ldrb	r3, [r7, #5]
 800bbea:	f003 0301 	and.w	r3, r3, #1
 800bbee:	2b00      	cmp	r3, #0
 800bbf0:	d008      	beq.n	800bc04 <tcp_enqueue+0x506>
    pcb->flags |= TF_FIN;
 800bbf2:	68fb      	ldr	r3, [r7, #12]
 800bbf4:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800bbf8:	f043 0320 	orr.w	r3, r3, #32
 800bbfc:	b2da      	uxtb	r2, r3
 800bbfe:	68fb      	ldr	r3, [r7, #12]
 800bc00:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
  pcb->snd_lbb += len;
 800bc04:	68fb      	ldr	r3, [r7, #12]
 800bc06:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800bc08:	88fb      	ldrh	r3, [r7, #6]
 800bc0a:	441a      	add	r2, r3
 800bc0c:	68fb      	ldr	r3, [r7, #12]
 800bc0e:	669a      	str	r2, [r3, #104]	; 0x68

  pcb->snd_buf -= len;
 800bc10:	68fb      	ldr	r3, [r7, #12]
 800bc12:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 800bc16:	88fb      	ldrh	r3, [r7, #6]
 800bc18:	1ad3      	subs	r3, r2, r3
 800bc1a:	b29a      	uxth	r2, r3
 800bc1c:	68fb      	ldr	r3, [r7, #12]
 800bc1e:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
 800bc22:	68fb      	ldr	r3, [r7, #12]
 800bc24:	8bfa      	ldrh	r2, [r7, #30]
 800bc26:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 800bc2a:	68fb      	ldr	r3, [r7, #12]
 800bc2c:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 800bc30:	2b00      	cmp	r3, #0
 800bc32:	d002      	beq.n	800bc3a <tcp_enqueue+0x53c>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
 800bc34:	68fb      	ldr	r3, [r7, #12]
 800bc36:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bc38:	2b00      	cmp	r3, #0
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 800bc3a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bc3c:	2b00      	cmp	r3, #0
 800bc3e:	d019      	beq.n	800bc74 <tcp_enqueue+0x576>
 800bc40:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800bc42:	2b00      	cmp	r3, #0
 800bc44:	d016      	beq.n	800bc74 <tcp_enqueue+0x576>
 800bc46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bc48:	691b      	ldr	r3, [r3, #16]
 800bc4a:	2b00      	cmp	r3, #0
 800bc4c:	d012      	beq.n	800bc74 <tcp_enqueue+0x576>
 800bc4e:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 800bc52:	f003 0302 	and.w	r3, r3, #2
 800bc56:	2b00      	cmp	r3, #0
 800bc58:	d10c      	bne.n	800bc74 <tcp_enqueue+0x576>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 800bc5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bc5c:	691c      	ldr	r4, [r3, #16]
 800bc5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bc60:	691b      	ldr	r3, [r3, #16]
 800bc62:	899b      	ldrh	r3, [r3, #12]
 800bc64:	b29d      	uxth	r5, r3
 800bc66:	2008      	movs	r0, #8
 800bc68:	f7fa fffe 	bl	8006c68 <htons>
 800bc6c:	4603      	mov	r3, r0
 800bc6e:	432b      	orrs	r3, r5
 800bc70:	b29b      	uxth	r3, r3
 800bc72:	81a3      	strh	r3, [r4, #12]
  }

  return ERR_OK;
 800bc74:	2300      	movs	r3, #0
 800bc76:	e021      	b.n	800bcbc <tcp_enqueue+0x5be>
      goto memerr;
 800bc78:	bf00      	nop
 800bc7a:	e006      	b.n	800bc8a <tcp_enqueue+0x58c>
        goto memerr;
 800bc7c:	bf00      	nop
 800bc7e:	e004      	b.n	800bc8a <tcp_enqueue+0x58c>
        goto memerr;
 800bc80:	bf00      	nop
 800bc82:	e002      	b.n	800bc8a <tcp_enqueue+0x58c>
      goto memerr;
 800bc84:	bf00      	nop
 800bc86:	e000      	b.n	800bc8a <tcp_enqueue+0x58c>
      goto memerr;
 800bc88:	bf00      	nop
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800bc8a:	68fb      	ldr	r3, [r7, #12]
 800bc8c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800bc90:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800bc94:	b2da      	uxtb	r2, r3
 800bc96:	68fb      	ldr	r3, [r7, #12]
 800bc98:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
 800bc9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bc9e:	2b00      	cmp	r3, #0
 800bca0:	d002      	beq.n	800bca8 <tcp_enqueue+0x5aa>
    tcp_segs_free(queue);
 800bca2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800bca4:	f7fd fd0c 	bl	80096c0 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 800bca8:	68fb      	ldr	r3, [r7, #12]
 800bcaa:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 800bcae:	2b00      	cmp	r3, #0
 800bcb0:	d002      	beq.n	800bcb8 <tcp_enqueue+0x5ba>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
 800bcb2:	68fb      	ldr	r3, [r7, #12]
 800bcb4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bcb6:	2b00      	cmp	r3, #0
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 800bcb8:	f04f 33ff 	mov.w	r3, #4294967295
}
 800bcbc:	4618      	mov	r0, r3
 800bcbe:	3738      	adds	r7, #56	; 0x38
 800bcc0:	46bd      	mov	sp, r7
 800bcc2:	bdb0      	pop	{r4, r5, r7, pc}

0800bcc4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 800bcc4:	b590      	push	{r4, r7, lr}
 800bcc6:	b089      	sub	sp, #36	; 0x24
 800bcc8:	af02      	add	r7, sp, #8
 800bcca:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
 800bccc:	2300      	movs	r3, #0
 800bcce:	75fb      	strb	r3, [r7, #23]
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen, PBUF_RAM);
 800bcd0:	7dfb      	ldrb	r3, [r7, #23]
 800bcd2:	b29b      	uxth	r3, r3
 800bcd4:	3314      	adds	r3, #20
 800bcd6:	b29b      	uxth	r3, r3
 800bcd8:	2200      	movs	r2, #0
 800bcda:	4619      	mov	r1, r3
 800bcdc:	2001      	movs	r0, #1
 800bcde:	f7fc fb97 	bl	8008410 <pbuf_alloc>
 800bce2:	6138      	str	r0, [r7, #16]
  if (p == NULL) {
 800bce4:	693b      	ldr	r3, [r7, #16]
 800bce6:	2b00      	cmp	r3, #0
 800bce8:	d102      	bne.n	800bcf0 <tcp_send_empty_ack+0x2c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 800bcea:	f06f 0301 	mvn.w	r3, #1
 800bcee:	e028      	b.n	800bd42 <tcp_send_empty_ack+0x7e>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800bcf0:	687b      	ldr	r3, [r7, #4]
 800bcf2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800bcf6:	f023 0303 	bic.w	r3, r3, #3
 800bcfa:	b2da      	uxtb	r2, r3
 800bcfc:	687b      	ldr	r3, [r7, #4]
 800bcfe:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  tcphdr = tcp_output_set_header(pcb, p, optlen, htonl(pcb->snd_nxt));
 800bd02:	7dfc      	ldrb	r4, [r7, #23]
 800bd04:	687b      	ldr	r3, [r7, #4]
 800bd06:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800bd08:	4618      	mov	r0, r3
 800bd0a:	f7fa ffd0 	bl	8006cae <htonl>
 800bd0e:	4603      	mov	r3, r0
 800bd10:	4622      	mov	r2, r4
 800bd12:	6939      	ldr	r1, [r7, #16]
 800bd14:	6878      	ldr	r0, [r7, #4]
 800bd16:	f7ff fc35 	bl	800b584 <tcp_output_set_header>
 800bd1a:	60f8      	str	r0, [r7, #12]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 800bd1c:	6879      	ldr	r1, [r7, #4]
 800bd1e:	687b      	ldr	r3, [r7, #4]
 800bd20:	1d18      	adds	r0, r3, #4
 800bd22:	687b      	ldr	r3, [r7, #4]
 800bd24:	7adc      	ldrb	r4, [r3, #11]
 800bd26:	687b      	ldr	r3, [r7, #4]
 800bd28:	7a9b      	ldrb	r3, [r3, #10]
 800bd2a:	2206      	movs	r2, #6
 800bd2c:	9201      	str	r2, [sp, #4]
 800bd2e:	9300      	str	r3, [sp, #0]
 800bd30:	4623      	mov	r3, r4
 800bd32:	4602      	mov	r2, r0
 800bd34:	6938      	ldr	r0, [r7, #16]
 800bd36:	f7fb facd 	bl	80072d4 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 800bd3a:	6938      	ldr	r0, [r7, #16]
 800bd3c:	f7fc fd35 	bl	80087aa <pbuf_free>

  return ERR_OK;
 800bd40:	2300      	movs	r3, #0
}
 800bd42:	4618      	mov	r0, r3
 800bd44:	371c      	adds	r7, #28
 800bd46:	46bd      	mov	sp, r7
 800bd48:	bd90      	pop	{r4, r7, pc}
	...

0800bd4c <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 800bd4c:	b5b0      	push	{r4, r5, r7, lr}
 800bd4e:	b088      	sub	sp, #32
 800bd50:	af00      	add	r7, sp, #0
 800bd52:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg, *useg;
  u32_t wnd, snd_nxt;
#if TCP_CWND_DEBUG
  s16_t i = 0;
 800bd54:	2300      	movs	r3, #0
 800bd56:	82fb      	strh	r3, [r7, #22]

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 800bd58:	4b9e      	ldr	r3, [pc, #632]	; (800bfd4 <tcp_output+0x288>)
 800bd5a:	681a      	ldr	r2, [r3, #0]
 800bd5c:	687b      	ldr	r3, [r7, #4]
 800bd5e:	429a      	cmp	r2, r3
 800bd60:	d101      	bne.n	800bd66 <tcp_output+0x1a>
    return ERR_OK;
 800bd62:	2300      	movs	r3, #0
 800bd64:	e165      	b.n	800c032 <tcp_output+0x2e6>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800bd66:	687b      	ldr	r3, [r7, #4]
 800bd68:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800bd6c:	687b      	ldr	r3, [r7, #4]
 800bd6e:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800bd72:	429a      	cmp	r2, r3
 800bd74:	d203      	bcs.n	800bd7e <tcp_output+0x32>
 800bd76:	687b      	ldr	r3, [r7, #4]
 800bd78:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800bd7c:	e002      	b.n	800bd84 <tcp_output+0x38>
 800bd7e:	687b      	ldr	r3, [r7, #4]
 800bd80:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800bd84:	60fb      	str	r3, [r7, #12]

  seg = pcb->unsent;
 800bd86:	687b      	ldr	r3, [r7, #4]
 800bd88:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bd8a:	61fb      	str	r3, [r7, #28]
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 800bd8c:	687b      	ldr	r3, [r7, #4]
 800bd8e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800bd92:	f003 0302 	and.w	r3, r3, #2
 800bd96:	2b00      	cmp	r3, #0
 800bd98:	d017      	beq.n	800bdca <tcp_output+0x7e>
 800bd9a:	69fb      	ldr	r3, [r7, #28]
 800bd9c:	2b00      	cmp	r3, #0
 800bd9e:	d00f      	beq.n	800bdc0 <tcp_output+0x74>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 800bda0:	69fb      	ldr	r3, [r7, #28]
 800bda2:	691b      	ldr	r3, [r3, #16]
 800bda4:	685b      	ldr	r3, [r3, #4]
 800bda6:	4618      	mov	r0, r3
 800bda8:	f7fa ff9a 	bl	8006ce0 <ntohl>
 800bdac:	4602      	mov	r2, r0
 800bdae:	687b      	ldr	r3, [r7, #4]
 800bdb0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bdb2:	1ad3      	subs	r3, r2, r3
 800bdb4:	69fa      	ldr	r2, [r7, #28]
 800bdb6:	8992      	ldrh	r2, [r2, #12]
 800bdb8:	441a      	add	r2, r3
     (seg == NULL ||
 800bdba:	68fb      	ldr	r3, [r7, #12]
 800bdbc:	429a      	cmp	r2, r3
 800bdbe:	d904      	bls.n	800bdca <tcp_output+0x7e>
     return tcp_send_empty_ack(pcb);
 800bdc0:	6878      	ldr	r0, [r7, #4]
 800bdc2:	f7ff ff7f 	bl	800bcc4 <tcp_send_empty_ack>
 800bdc6:	4603      	mov	r3, r0
 800bdc8:	e133      	b.n	800c032 <tcp_output+0x2e6>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 800bdca:	687b      	ldr	r3, [r7, #4]
 800bdcc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bdce:	61bb      	str	r3, [r7, #24]
  if (useg != NULL) {
 800bdd0:	69bb      	ldr	r3, [r7, #24]
 800bdd2:	2b00      	cmp	r3, #0
 800bdd4:	f000 80e8 	beq.w	800bfa8 <tcp_output+0x25c>
    for (; useg->next != NULL; useg = useg->next);
 800bdd8:	e002      	b.n	800bde0 <tcp_output+0x94>
 800bdda:	69bb      	ldr	r3, [r7, #24]
 800bddc:	681b      	ldr	r3, [r3, #0]
 800bdde:	61bb      	str	r3, [r7, #24]
 800bde0:	69bb      	ldr	r3, [r7, #24]
 800bde2:	681b      	ldr	r3, [r3, #0]
 800bde4:	2b00      	cmp	r3, #0
 800bde6:	d1f8      	bne.n	800bdda <tcp_output+0x8e>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800bde8:	e0de      	b.n	800bfa8 <tcp_output+0x25c>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
 800bdea:	69fb      	ldr	r3, [r7, #28]
 800bdec:	691b      	ldr	r3, [r3, #16]
 800bdee:	899b      	ldrh	r3, [r3, #12]
 800bdf0:	b29b      	uxth	r3, r3
 800bdf2:	4618      	mov	r0, r3
 800bdf4:	f7fa ff4d 	bl	8006c92 <ntohs>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 800bdf8:	687b      	ldr	r3, [r7, #4]
 800bdfa:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bdfc:	2b00      	cmp	r3, #0
 800bdfe:	d016      	beq.n	800be2e <tcp_output+0xe2>
 800be00:	687b      	ldr	r3, [r7, #4]
 800be02:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800be06:	f003 0344 	and.w	r3, r3, #68	; 0x44
 800be0a:	2b00      	cmp	r3, #0
 800be0c:	d10f      	bne.n	800be2e <tcp_output+0xe2>
 800be0e:	687b      	ldr	r3, [r7, #4]
 800be10:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800be12:	2b00      	cmp	r3, #0
 800be14:	d00d      	beq.n	800be32 <tcp_output+0xe6>
 800be16:	687b      	ldr	r3, [r7, #4]
 800be18:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800be1a:	681b      	ldr	r3, [r3, #0]
 800be1c:	2b00      	cmp	r3, #0
 800be1e:	d106      	bne.n	800be2e <tcp_output+0xe2>
 800be20:	687b      	ldr	r3, [r7, #4]
 800be22:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800be24:	899a      	ldrh	r2, [r3, #12]
 800be26:	687b      	ldr	r3, [r7, #4]
 800be28:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800be2a:	429a      	cmp	r2, r3
 800be2c:	d301      	bcc.n	800be32 <tcp_output+0xe6>
 800be2e:	2301      	movs	r3, #1
 800be30:	e000      	b.n	800be34 <tcp_output+0xe8>
 800be32:	2300      	movs	r3, #0
 800be34:	2b00      	cmp	r3, #0
 800be36:	d107      	bne.n	800be48 <tcp_output+0xfc>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
 800be38:	687b      	ldr	r3, [r7, #4]
 800be3a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800be3e:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    if((tcp_do_output_nagle(pcb) == 0) &&
 800be42:	2b00      	cmp	r3, #0
 800be44:	f000 80c8 	beq.w	800bfd8 <tcp_output+0x28c>
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            ntohl(seg->tcphdr->seqno) + seg->len -
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
 800be48:	8afb      	ldrh	r3, [r7, #22]
 800be4a:	3301      	adds	r3, #1
 800be4c:	b29b      	uxth	r3, r3
 800be4e:	82fb      	strh	r3, [r7, #22]
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 800be50:	69fb      	ldr	r3, [r7, #28]
 800be52:	681a      	ldr	r2, [r3, #0]
 800be54:	687b      	ldr	r3, [r7, #4]
 800be56:	675a      	str	r2, [r3, #116]	; 0x74

    if (pcb->state != SYN_SENT) {
 800be58:	687b      	ldr	r3, [r7, #4]
 800be5a:	7c1b      	ldrb	r3, [r3, #16]
 800be5c:	2b02      	cmp	r3, #2
 800be5e:	d015      	beq.n	800be8c <tcp_output+0x140>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 800be60:	69fb      	ldr	r3, [r7, #28]
 800be62:	691c      	ldr	r4, [r3, #16]
 800be64:	69fb      	ldr	r3, [r7, #28]
 800be66:	691b      	ldr	r3, [r3, #16]
 800be68:	899b      	ldrh	r3, [r3, #12]
 800be6a:	b29d      	uxth	r5, r3
 800be6c:	2010      	movs	r0, #16
 800be6e:	f7fa fefb 	bl	8006c68 <htons>
 800be72:	4603      	mov	r3, r0
 800be74:	432b      	orrs	r3, r5
 800be76:	b29b      	uxth	r3, r3
 800be78:	81a3      	strh	r3, [r4, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800be7a:	687b      	ldr	r3, [r7, #4]
 800be7c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800be80:	f023 0303 	bic.w	r3, r3, #3
 800be84:	b2da      	uxtb	r2, r3
 800be86:	687b      	ldr	r3, [r7, #4]
 800be88:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    }

    tcp_output_segment(seg, pcb);
 800be8c:	6879      	ldr	r1, [r7, #4]
 800be8e:	69f8      	ldr	r0, [r7, #28]
 800be90:	f000 f8d4 	bl	800c03c <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800be94:	69fb      	ldr	r3, [r7, #28]
 800be96:	691b      	ldr	r3, [r3, #16]
 800be98:	685b      	ldr	r3, [r3, #4]
 800be9a:	4618      	mov	r0, r3
 800be9c:	f7fa ff20 	bl	8006ce0 <ntohl>
 800bea0:	4604      	mov	r4, r0
 800bea2:	69fb      	ldr	r3, [r7, #28]
 800bea4:	899b      	ldrh	r3, [r3, #12]
 800bea6:	461d      	mov	r5, r3
 800bea8:	69fb      	ldr	r3, [r7, #28]
 800beaa:	691b      	ldr	r3, [r3, #16]
 800beac:	899b      	ldrh	r3, [r3, #12]
 800beae:	b29b      	uxth	r3, r3
 800beb0:	4618      	mov	r0, r3
 800beb2:	f7fa feee 	bl	8006c92 <ntohs>
 800beb6:	4603      	mov	r3, r0
 800beb8:	f003 0303 	and.w	r3, r3, #3
 800bebc:	2b00      	cmp	r3, #0
 800bebe:	bf14      	ite	ne
 800bec0:	2301      	movne	r3, #1
 800bec2:	2300      	moveq	r3, #0
 800bec4:	b2db      	uxtb	r3, r3
 800bec6:	442b      	add	r3, r5
 800bec8:	4423      	add	r3, r4
 800beca:	60bb      	str	r3, [r7, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800becc:	687b      	ldr	r3, [r7, #4]
 800bece:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800bed0:	68bb      	ldr	r3, [r7, #8]
 800bed2:	1ad3      	subs	r3, r2, r3
 800bed4:	2b00      	cmp	r3, #0
 800bed6:	da02      	bge.n	800bede <tcp_output+0x192>
      pcb->snd_nxt = snd_nxt;
 800bed8:	687b      	ldr	r3, [r7, #4]
 800beda:	68ba      	ldr	r2, [r7, #8]
 800bedc:	659a      	str	r2, [r3, #88]	; 0x58
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 800bede:	69fb      	ldr	r3, [r7, #28]
 800bee0:	899b      	ldrh	r3, [r3, #12]
 800bee2:	461c      	mov	r4, r3
 800bee4:	69fb      	ldr	r3, [r7, #28]
 800bee6:	691b      	ldr	r3, [r3, #16]
 800bee8:	899b      	ldrh	r3, [r3, #12]
 800beea:	b29b      	uxth	r3, r3
 800beec:	4618      	mov	r0, r3
 800beee:	f7fa fed0 	bl	8006c92 <ntohs>
 800bef2:	4603      	mov	r3, r0
 800bef4:	f003 0303 	and.w	r3, r3, #3
 800bef8:	2b00      	cmp	r3, #0
 800befa:	bf14      	ite	ne
 800befc:	2301      	movne	r3, #1
 800befe:	2300      	moveq	r3, #0
 800bf00:	b2db      	uxtb	r3, r3
 800bf02:	4423      	add	r3, r4
 800bf04:	2b00      	cmp	r3, #0
 800bf06:	dd49      	ble.n	800bf9c <tcp_output+0x250>
      seg->next = NULL;
 800bf08:	69fb      	ldr	r3, [r7, #28]
 800bf0a:	2200      	movs	r2, #0
 800bf0c:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 800bf0e:	687b      	ldr	r3, [r7, #4]
 800bf10:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bf12:	2b00      	cmp	r3, #0
 800bf14:	d105      	bne.n	800bf22 <tcp_output+0x1d6>
        pcb->unacked = seg;
 800bf16:	687b      	ldr	r3, [r7, #4]
 800bf18:	69fa      	ldr	r2, [r7, #28]
 800bf1a:	679a      	str	r2, [r3, #120]	; 0x78
        useg = seg;
 800bf1c:	69fb      	ldr	r3, [r7, #28]
 800bf1e:	61bb      	str	r3, [r7, #24]
 800bf20:	e03f      	b.n	800bfa2 <tcp_output+0x256>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
 800bf22:	69fb      	ldr	r3, [r7, #28]
 800bf24:	691b      	ldr	r3, [r3, #16]
 800bf26:	685b      	ldr	r3, [r3, #4]
 800bf28:	4618      	mov	r0, r3
 800bf2a:	f7fa fed9 	bl	8006ce0 <ntohl>
 800bf2e:	4604      	mov	r4, r0
 800bf30:	69bb      	ldr	r3, [r7, #24]
 800bf32:	691b      	ldr	r3, [r3, #16]
 800bf34:	685b      	ldr	r3, [r3, #4]
 800bf36:	4618      	mov	r0, r3
 800bf38:	f7fa fed2 	bl	8006ce0 <ntohl>
 800bf3c:	4603      	mov	r3, r0
 800bf3e:	1ae3      	subs	r3, r4, r3
 800bf40:	2b00      	cmp	r3, #0
 800bf42:	da24      	bge.n	800bf8e <tcp_output+0x242>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 800bf44:	687b      	ldr	r3, [r7, #4]
 800bf46:	3378      	adds	r3, #120	; 0x78
 800bf48:	613b      	str	r3, [r7, #16]
          while (*cur_seg &&
 800bf4a:	e002      	b.n	800bf52 <tcp_output+0x206>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 800bf4c:	693b      	ldr	r3, [r7, #16]
 800bf4e:	681b      	ldr	r3, [r3, #0]
 800bf50:	613b      	str	r3, [r7, #16]
          while (*cur_seg &&
 800bf52:	693b      	ldr	r3, [r7, #16]
 800bf54:	681b      	ldr	r3, [r3, #0]
 800bf56:	2b00      	cmp	r3, #0
 800bf58:	d011      	beq.n	800bf7e <tcp_output+0x232>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 800bf5a:	693b      	ldr	r3, [r7, #16]
 800bf5c:	681b      	ldr	r3, [r3, #0]
 800bf5e:	691b      	ldr	r3, [r3, #16]
 800bf60:	685b      	ldr	r3, [r3, #4]
 800bf62:	4618      	mov	r0, r3
 800bf64:	f7fa febc 	bl	8006ce0 <ntohl>
 800bf68:	4604      	mov	r4, r0
 800bf6a:	69fb      	ldr	r3, [r7, #28]
 800bf6c:	691b      	ldr	r3, [r3, #16]
 800bf6e:	685b      	ldr	r3, [r3, #4]
 800bf70:	4618      	mov	r0, r3
 800bf72:	f7fa feb5 	bl	8006ce0 <ntohl>
 800bf76:	4603      	mov	r3, r0
 800bf78:	1ae3      	subs	r3, r4, r3
          while (*cur_seg &&
 800bf7a:	2b00      	cmp	r3, #0
 800bf7c:	dbe6      	blt.n	800bf4c <tcp_output+0x200>
          }
          seg->next = (*cur_seg);
 800bf7e:	693b      	ldr	r3, [r7, #16]
 800bf80:	681a      	ldr	r2, [r3, #0]
 800bf82:	69fb      	ldr	r3, [r7, #28]
 800bf84:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
 800bf86:	693b      	ldr	r3, [r7, #16]
 800bf88:	69fa      	ldr	r2, [r7, #28]
 800bf8a:	601a      	str	r2, [r3, #0]
 800bf8c:	e009      	b.n	800bfa2 <tcp_output+0x256>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 800bf8e:	69bb      	ldr	r3, [r7, #24]
 800bf90:	69fa      	ldr	r2, [r7, #28]
 800bf92:	601a      	str	r2, [r3, #0]
          useg = useg->next;
 800bf94:	69bb      	ldr	r3, [r7, #24]
 800bf96:	681b      	ldr	r3, [r3, #0]
 800bf98:	61bb      	str	r3, [r7, #24]
 800bf9a:	e002      	b.n	800bfa2 <tcp_output+0x256>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 800bf9c:	69f8      	ldr	r0, [r7, #28]
 800bf9e:	f7fd fbab 	bl	80096f8 <tcp_seg_free>
    }
    seg = pcb->unsent;
 800bfa2:	687b      	ldr	r3, [r7, #4]
 800bfa4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bfa6:	61fb      	str	r3, [r7, #28]
  while (seg != NULL &&
 800bfa8:	69fb      	ldr	r3, [r7, #28]
 800bfaa:	2b00      	cmp	r3, #0
 800bfac:	d015      	beq.n	800bfda <tcp_output+0x28e>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 800bfae:	69fb      	ldr	r3, [r7, #28]
 800bfb0:	691b      	ldr	r3, [r3, #16]
 800bfb2:	685b      	ldr	r3, [r3, #4]
 800bfb4:	4618      	mov	r0, r3
 800bfb6:	f7fa fe93 	bl	8006ce0 <ntohl>
 800bfba:	4602      	mov	r2, r0
 800bfbc:	687b      	ldr	r3, [r7, #4]
 800bfbe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bfc0:	1ad3      	subs	r3, r2, r3
 800bfc2:	69fa      	ldr	r2, [r7, #28]
 800bfc4:	8992      	ldrh	r2, [r2, #12]
 800bfc6:	441a      	add	r2, r3
  while (seg != NULL &&
 800bfc8:	68fb      	ldr	r3, [r7, #12]
 800bfca:	429a      	cmp	r2, r3
 800bfcc:	f67f af0d 	bls.w	800bdea <tcp_output+0x9e>
 800bfd0:	e003      	b.n	800bfda <tcp_output+0x28e>
 800bfd2:	bf00      	nop
 800bfd4:	2000a33c 	.word	0x2000a33c
      break;
 800bfd8:	bf00      	nop
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
 800bfda:	69fb      	ldr	r3, [r7, #28]
 800bfdc:	2b00      	cmp	r3, #0
 800bfde:	d01e      	beq.n	800c01e <tcp_output+0x2d2>
 800bfe0:	687b      	ldr	r3, [r7, #4]
 800bfe2:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 800bfe6:	2b00      	cmp	r3, #0
 800bfe8:	d119      	bne.n	800c01e <tcp_output+0x2d2>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
 800bfea:	69fb      	ldr	r3, [r7, #28]
 800bfec:	691b      	ldr	r3, [r3, #16]
 800bfee:	685b      	ldr	r3, [r3, #4]
 800bff0:	4618      	mov	r0, r3
 800bff2:	f7fa fe75 	bl	8006ce0 <ntohl>
 800bff6:	4602      	mov	r2, r0
 800bff8:	687b      	ldr	r3, [r7, #4]
 800bffa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bffc:	1ad3      	subs	r3, r2, r3
 800bffe:	69fa      	ldr	r2, [r7, #28]
 800c000:	8992      	ldrh	r2, [r2, #12]
 800c002:	4413      	add	r3, r2
 800c004:	687a      	ldr	r2, [r7, #4]
 800c006:	f8b2 205c 	ldrh.w	r2, [r2, #92]	; 0x5c
  if (seg != NULL && pcb->persist_backoff == 0 && 
 800c00a:	4293      	cmp	r3, r2
 800c00c:	d907      	bls.n	800c01e <tcp_output+0x2d2>
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
 800c00e:	687b      	ldr	r3, [r7, #4]
 800c010:	2200      	movs	r2, #0
 800c012:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    pcb->persist_backoff = 1;
 800c016:	687b      	ldr	r3, [r7, #4]
 800c018:	2201      	movs	r2, #1
 800c01a:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
 800c01e:	687b      	ldr	r3, [r7, #4]
 800c020:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800c024:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800c028:	b2da      	uxtb	r2, r3
 800c02a:	687b      	ldr	r3, [r7, #4]
 800c02c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  return ERR_OK;
 800c030:	2300      	movs	r3, #0
}
 800c032:	4618      	mov	r0, r3
 800c034:	3720      	adds	r7, #32
 800c036:	46bd      	mov	sp, r7
 800c038:	bdb0      	pop	{r4, r5, r7, pc}
 800c03a:	bf00      	nop

0800c03c <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
 800c03c:	b5b0      	push	{r4, r5, r7, lr}
 800c03e:	b088      	sub	sp, #32
 800c040:	af02      	add	r7, sp, #8
 800c042:	6078      	str	r0, [r7, #4]
 800c044:	6039      	str	r1, [r7, #0]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 800c046:	687b      	ldr	r3, [r7, #4]
 800c048:	691c      	ldr	r4, [r3, #16]
 800c04a:	683b      	ldr	r3, [r7, #0]
 800c04c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c04e:	4618      	mov	r0, r3
 800c050:	f7fa fe2d 	bl	8006cae <htonl>
 800c054:	4603      	mov	r3, r0
 800c056:	60a3      	str	r3, [r4, #8]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800c058:	687b      	ldr	r3, [r7, #4]
 800c05a:	691c      	ldr	r4, [r3, #16]
 800c05c:	683b      	ldr	r3, [r7, #0]
 800c05e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800c060:	4618      	mov	r0, r3
 800c062:	f7fa fe01 	bl	8006c68 <htons>
 800c066:	4603      	mov	r3, r0
 800c068:	81e3      	strh	r3, [r4, #14]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800c06a:	683b      	ldr	r3, [r7, #0]
 800c06c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c06e:	683a      	ldr	r2, [r7, #0]
 800c070:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
 800c072:	441a      	add	r2, r3
 800c074:	683b      	ldr	r3, [r7, #0]
 800c076:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(seg->tcphdr + 1);
 800c078:	687b      	ldr	r3, [r7, #4]
 800c07a:	691b      	ldr	r3, [r3, #16]
 800c07c:	3314      	adds	r3, #20
 800c07e:	617b      	str	r3, [r7, #20]
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800c080:	687b      	ldr	r3, [r7, #4]
 800c082:	7b9b      	ldrb	r3, [r3, #14]
 800c084:	f003 0301 	and.w	r3, r3, #1
 800c088:	2b00      	cmp	r3, #0
 800c08a:	d008      	beq.n	800c09e <tcp_output_segment+0x62>
    TCP_BUILD_MSS_OPTION(*opts);
 800c08c:	483b      	ldr	r0, [pc, #236]	; (800c17c <tcp_output_segment+0x140>)
 800c08e:	f7fa fe0e 	bl	8006cae <htonl>
 800c092:	4602      	mov	r2, r0
 800c094:	697b      	ldr	r3, [r7, #20]
 800c096:	601a      	str	r2, [r3, #0]
    opts += 1;
 800c098:	697b      	ldr	r3, [r7, #20]
 800c09a:	3304      	adds	r3, #4
 800c09c:	617b      	str	r3, [r7, #20]
  }
#endif

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 800c09e:	683b      	ldr	r3, [r7, #0]
 800c0a0:	2b00      	cmp	r3, #0
 800c0a2:	d003      	beq.n	800c0ac <tcp_output_segment+0x70>
 800c0a4:	683b      	ldr	r3, [r7, #0]
 800c0a6:	681b      	ldr	r3, [r3, #0]
 800c0a8:	2b00      	cmp	r3, #0
 800c0aa:	d112      	bne.n	800c0d2 <tcp_output_segment+0x96>
    netif = ip_route(&(pcb->remote_ip));
 800c0ac:	683b      	ldr	r3, [r7, #0]
 800c0ae:	3304      	adds	r3, #4
 800c0b0:	4618      	mov	r0, r3
 800c0b2:	f7fa fecb 	bl	8006e4c <ip_route>
 800c0b6:	6138      	str	r0, [r7, #16]
    if (netif == NULL) {
 800c0b8:	693b      	ldr	r3, [r7, #16]
 800c0ba:	2b00      	cmp	r3, #0
 800c0bc:	d059      	beq.n	800c172 <tcp_output_segment+0x136>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
 800c0be:	693b      	ldr	r3, [r7, #16]
 800c0c0:	3304      	adds	r3, #4
 800c0c2:	2b00      	cmp	r3, #0
 800c0c4:	d002      	beq.n	800c0cc <tcp_output_segment+0x90>
 800c0c6:	693b      	ldr	r3, [r7, #16]
 800c0c8:	685b      	ldr	r3, [r3, #4]
 800c0ca:	e000      	b.n	800c0ce <tcp_output_segment+0x92>
 800c0cc:	2300      	movs	r3, #0
 800c0ce:	683a      	ldr	r2, [r7, #0]
 800c0d0:	6013      	str	r3, [r2, #0]
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
 800c0d2:	683b      	ldr	r3, [r7, #0]
 800c0d4:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 800c0d8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c0dc:	d102      	bne.n	800c0e4 <tcp_output_segment+0xa8>
    pcb->rtime = 0;
 800c0de:	683b      	ldr	r3, [r7, #0]
 800c0e0:	2200      	movs	r2, #0
 800c0e2:	86da      	strh	r2, [r3, #54]	; 0x36

  if (pcb->rttest == 0) {
 800c0e4:	683b      	ldr	r3, [r7, #0]
 800c0e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c0e8:	2b00      	cmp	r3, #0
 800c0ea:	d10c      	bne.n	800c106 <tcp_output_segment+0xca>
    pcb->rttest = tcp_ticks;
 800c0ec:	4b24      	ldr	r3, [pc, #144]	; (800c180 <tcp_output_segment+0x144>)
 800c0ee:	681a      	ldr	r2, [r3, #0]
 800c0f0:	683b      	ldr	r3, [r7, #0]
 800c0f2:	63da      	str	r2, [r3, #60]	; 0x3c
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 800c0f4:	687b      	ldr	r3, [r7, #4]
 800c0f6:	691b      	ldr	r3, [r3, #16]
 800c0f8:	685b      	ldr	r3, [r3, #4]
 800c0fa:	4618      	mov	r0, r3
 800c0fc:	f7fa fdf0 	bl	8006ce0 <ntohl>
 800c100:	4602      	mov	r2, r0
 800c102:	683b      	ldr	r3, [r7, #0]
 800c104:	641a      	str	r2, [r3, #64]	; 0x40
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800c106:	687b      	ldr	r3, [r7, #4]
 800c108:	691b      	ldr	r3, [r3, #16]
 800c10a:	461a      	mov	r2, r3
 800c10c:	687b      	ldr	r3, [r7, #4]
 800c10e:	685b      	ldr	r3, [r3, #4]
 800c110:	685b      	ldr	r3, [r3, #4]
 800c112:	1ad3      	subs	r3, r2, r3
 800c114:	81fb      	strh	r3, [r7, #14]

  seg->p->len -= len;
 800c116:	687b      	ldr	r3, [r7, #4]
 800c118:	685b      	ldr	r3, [r3, #4]
 800c11a:	687a      	ldr	r2, [r7, #4]
 800c11c:	6852      	ldr	r2, [r2, #4]
 800c11e:	8951      	ldrh	r1, [r2, #10]
 800c120:	89fa      	ldrh	r2, [r7, #14]
 800c122:	1a8a      	subs	r2, r1, r2
 800c124:	b292      	uxth	r2, r2
 800c126:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
 800c128:	687b      	ldr	r3, [r7, #4]
 800c12a:	685b      	ldr	r3, [r3, #4]
 800c12c:	687a      	ldr	r2, [r7, #4]
 800c12e:	6852      	ldr	r2, [r2, #4]
 800c130:	8911      	ldrh	r1, [r2, #8]
 800c132:	89fa      	ldrh	r2, [r7, #14]
 800c134:	1a8a      	subs	r2, r1, r2
 800c136:	b292      	uxth	r2, r2
 800c138:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
 800c13a:	687b      	ldr	r3, [r7, #4]
 800c13c:	685b      	ldr	r3, [r3, #4]
 800c13e:	687a      	ldr	r2, [r7, #4]
 800c140:	6912      	ldr	r2, [r2, #16]
 800c142:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
 800c144:	687b      	ldr	r3, [r7, #4]
 800c146:	691b      	ldr	r3, [r3, #16]
 800c148:	2200      	movs	r2, #0
 800c14a:	741a      	strb	r2, [r3, #16]
 800c14c:	2200      	movs	r2, #0
 800c14e:	745a      	strb	r2, [r3, #17]

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 800c150:	687b      	ldr	r3, [r7, #4]
 800c152:	6858      	ldr	r0, [r3, #4]
 800c154:	6839      	ldr	r1, [r7, #0]
 800c156:	683b      	ldr	r3, [r7, #0]
 800c158:	1d1c      	adds	r4, r3, #4
 800c15a:	683b      	ldr	r3, [r7, #0]
 800c15c:	7add      	ldrb	r5, [r3, #11]
 800c15e:	683b      	ldr	r3, [r7, #0]
 800c160:	7a9b      	ldrb	r3, [r3, #10]
 800c162:	2206      	movs	r2, #6
 800c164:	9201      	str	r2, [sp, #4]
 800c166:	9300      	str	r3, [sp, #0]
 800c168:	462b      	mov	r3, r5
 800c16a:	4622      	mov	r2, r4
 800c16c:	f7fb f8b2 	bl	80072d4 <ip_output>
 800c170:	e000      	b.n	800c174 <tcp_output_segment+0x138>
      return;
 800c172:	bf00      	nop
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
 800c174:	3718      	adds	r7, #24
 800c176:	46bd      	mov	sp, r7
 800c178:	bdb0      	pop	{r4, r5, r7, pc}
 800c17a:	bf00      	nop
 800c17c:	020405b4 	.word	0x020405b4
 800c180:	2000a328 	.word	0x2000a328

0800c184 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 800c184:	b590      	push	{r4, r7, lr}
 800c186:	b089      	sub	sp, #36	; 0x24
 800c188:	af02      	add	r7, sp, #8
 800c18a:	60f8      	str	r0, [r7, #12]
 800c18c:	60b9      	str	r1, [r7, #8]
 800c18e:	607a      	str	r2, [r7, #4]
 800c190:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800c192:	2200      	movs	r2, #0
 800c194:	2114      	movs	r1, #20
 800c196:	2001      	movs	r0, #1
 800c198:	f7fc f93a 	bl	8008410 <pbuf_alloc>
 800c19c:	6178      	str	r0, [r7, #20]
  if (p == NULL) {
 800c19e:	697b      	ldr	r3, [r7, #20]
 800c1a0:	2b00      	cmp	r3, #0
 800c1a2:	d064      	beq.n	800c26e <tcp_rst+0xea>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
 800c1a4:	697b      	ldr	r3, [r7, #20]
 800c1a6:	685b      	ldr	r3, [r3, #4]
 800c1a8:	613b      	str	r3, [r7, #16]
  tcphdr->src = htons(local_port);
 800c1aa:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800c1ac:	4618      	mov	r0, r3
 800c1ae:	f7fa fd5b 	bl	8006c68 <htons>
 800c1b2:	4603      	mov	r3, r0
 800c1b4:	461a      	mov	r2, r3
 800c1b6:	693b      	ldr	r3, [r7, #16]
 800c1b8:	801a      	strh	r2, [r3, #0]
  tcphdr->dest = htons(remote_port);
 800c1ba:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800c1bc:	4618      	mov	r0, r3
 800c1be:	f7fa fd53 	bl	8006c68 <htons>
 800c1c2:	4603      	mov	r3, r0
 800c1c4:	461a      	mov	r2, r3
 800c1c6:	693b      	ldr	r3, [r7, #16]
 800c1c8:	805a      	strh	r2, [r3, #2]
  tcphdr->seqno = htonl(seqno);
 800c1ca:	68f8      	ldr	r0, [r7, #12]
 800c1cc:	f7fa fd6f 	bl	8006cae <htonl>
 800c1d0:	4602      	mov	r2, r0
 800c1d2:	693b      	ldr	r3, [r7, #16]
 800c1d4:	605a      	str	r2, [r3, #4]
  tcphdr->ackno = htonl(ackno);
 800c1d6:	68b8      	ldr	r0, [r7, #8]
 800c1d8:	f7fa fd69 	bl	8006cae <htonl>
 800c1dc:	4602      	mov	r2, r0
 800c1de:	693b      	ldr	r3, [r7, #16]
 800c1e0:	609a      	str	r2, [r3, #8]
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
 800c1e2:	693b      	ldr	r3, [r7, #16]
 800c1e4:	899b      	ldrh	r3, [r3, #12]
 800c1e6:	b29c      	uxth	r4, r3
 800c1e8:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 800c1ec:	f7fa fd3c 	bl	8006c68 <htons>
 800c1f0:	4603      	mov	r3, r0
 800c1f2:	4023      	ands	r3, r4
 800c1f4:	b29c      	uxth	r4, r3
 800c1f6:	2014      	movs	r0, #20
 800c1f8:	f7fa fd36 	bl	8006c68 <htons>
 800c1fc:	4603      	mov	r3, r0
 800c1fe:	4323      	orrs	r3, r4
 800c200:	b29a      	uxth	r2, r3
 800c202:	693b      	ldr	r3, [r7, #16]
 800c204:	819a      	strh	r2, [r3, #12]
  tcphdr->wnd = htons(TCP_WND);
 800c206:	f640 3068 	movw	r0, #2920	; 0xb68
 800c20a:	f7fa fd2d 	bl	8006c68 <htons>
 800c20e:	4603      	mov	r3, r0
 800c210:	461a      	mov	r2, r3
 800c212:	693b      	ldr	r3, [r7, #16]
 800c214:	81da      	strh	r2, [r3, #14]
  tcphdr->urgp = 0;
 800c216:	693b      	ldr	r3, [r7, #16]
 800c218:	2200      	movs	r2, #0
 800c21a:	749a      	strb	r2, [r3, #18]
 800c21c:	2200      	movs	r2, #0
 800c21e:	74da      	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
 800c220:	693b      	ldr	r3, [r7, #16]
 800c222:	899b      	ldrh	r3, [r3, #12]
 800c224:	b29b      	uxth	r3, r3
 800c226:	4618      	mov	r0, r3
 800c228:	f7fa fd33 	bl	8006c92 <ntohs>
 800c22c:	4603      	mov	r3, r0
 800c22e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800c232:	b29b      	uxth	r3, r3
 800c234:	f443 43a0 	orr.w	r3, r3, #20480	; 0x5000
 800c238:	b29b      	uxth	r3, r3
 800c23a:	4618      	mov	r0, r3
 800c23c:	f7fa fd14 	bl	8006c68 <htons>
 800c240:	4603      	mov	r3, r0
 800c242:	461a      	mov	r2, r3
 800c244:	693b      	ldr	r3, [r7, #16]
 800c246:	819a      	strh	r2, [r3, #12]

  tcphdr->chksum = 0;
 800c248:	693b      	ldr	r3, [r7, #16]
 800c24a:	2200      	movs	r2, #0
 800c24c:	741a      	strb	r2, [r3, #16]
 800c24e:	2200      	movs	r2, #0
 800c250:	745a      	strb	r2, [r3, #17]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 800c252:	2306      	movs	r3, #6
 800c254:	9301      	str	r3, [sp, #4]
 800c256:	2300      	movs	r3, #0
 800c258:	9300      	str	r3, [sp, #0]
 800c25a:	23ff      	movs	r3, #255	; 0xff
 800c25c:	683a      	ldr	r2, [r7, #0]
 800c25e:	6879      	ldr	r1, [r7, #4]
 800c260:	6978      	ldr	r0, [r7, #20]
 800c262:	f7fb f837 	bl	80072d4 <ip_output>
  pbuf_free(p);
 800c266:	6978      	ldr	r0, [r7, #20]
 800c268:	f7fc fa9f 	bl	80087aa <pbuf_free>
 800c26c:	e000      	b.n	800c270 <tcp_rst+0xec>
      return;
 800c26e:	bf00      	nop
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800c270:	371c      	adds	r7, #28
 800c272:	46bd      	mov	sp, r7
 800c274:	bd90      	pop	{r4, r7, pc}

0800c276 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 800c276:	b580      	push	{r7, lr}
 800c278:	b084      	sub	sp, #16
 800c27a:	af00      	add	r7, sp, #0
 800c27c:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 800c27e:	687b      	ldr	r3, [r7, #4]
 800c280:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c282:	2b00      	cmp	r3, #0
 800c284:	d024      	beq.n	800c2d0 <tcp_rexmit_rto+0x5a>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 800c286:	687b      	ldr	r3, [r7, #4]
 800c288:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c28a:	60fb      	str	r3, [r7, #12]
 800c28c:	e002      	b.n	800c294 <tcp_rexmit_rto+0x1e>
 800c28e:	68fb      	ldr	r3, [r7, #12]
 800c290:	681b      	ldr	r3, [r3, #0]
 800c292:	60fb      	str	r3, [r7, #12]
 800c294:	68fb      	ldr	r3, [r7, #12]
 800c296:	681b      	ldr	r3, [r3, #0]
 800c298:	2b00      	cmp	r3, #0
 800c29a:	d1f8      	bne.n	800c28e <tcp_rexmit_rto+0x18>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 800c29c:	687b      	ldr	r3, [r7, #4]
 800c29e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800c2a0:	68fb      	ldr	r3, [r7, #12]
 800c2a2:	601a      	str	r2, [r3, #0]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 800c2a4:	687b      	ldr	r3, [r7, #4]
 800c2a6:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800c2a8:	687b      	ldr	r3, [r7, #4]
 800c2aa:	675a      	str	r2, [r3, #116]	; 0x74
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 800c2ac:	687b      	ldr	r3, [r7, #4]
 800c2ae:	2200      	movs	r2, #0
 800c2b0:	679a      	str	r2, [r3, #120]	; 0x78

  /* increment number of retransmissions */
  ++pcb->nrtx;
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 800c2b8:	3301      	adds	r3, #1
 800c2ba:	b2da      	uxtb	r2, r3
 800c2bc:	687b      	ldr	r3, [r7, #4]
 800c2be:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 800c2c2:	687b      	ldr	r3, [r7, #4]
 800c2c4:	2200      	movs	r2, #0
 800c2c6:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Do the actual retransmission */
  tcp_output(pcb);
 800c2c8:	6878      	ldr	r0, [r7, #4]
 800c2ca:	f7ff fd3f 	bl	800bd4c <tcp_output>
 800c2ce:	e000      	b.n	800c2d2 <tcp_rexmit_rto+0x5c>
    return;
 800c2d0:	bf00      	nop
}
 800c2d2:	3710      	adds	r7, #16
 800c2d4:	46bd      	mov	sp, r7
 800c2d6:	bd80      	pop	{r7, pc}

0800c2d8 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 800c2d8:	b590      	push	{r4, r7, lr}
 800c2da:	b085      	sub	sp, #20
 800c2dc:	af00      	add	r7, sp, #0
 800c2de:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 800c2e0:	687b      	ldr	r3, [r7, #4]
 800c2e2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c2e4:	2b00      	cmp	r3, #0
 800c2e6:	d036      	beq.n	800c356 <tcp_rexmit+0x7e>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
 800c2e8:	687b      	ldr	r3, [r7, #4]
 800c2ea:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c2ec:	60bb      	str	r3, [r7, #8]
  pcb->unacked = seg->next;
 800c2ee:	68bb      	ldr	r3, [r7, #8]
 800c2f0:	681a      	ldr	r2, [r3, #0]
 800c2f2:	687b      	ldr	r3, [r7, #4]
 800c2f4:	679a      	str	r2, [r3, #120]	; 0x78

  cur_seg = &(pcb->unsent);
 800c2f6:	687b      	ldr	r3, [r7, #4]
 800c2f8:	3374      	adds	r3, #116	; 0x74
 800c2fa:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 800c2fc:	e002      	b.n	800c304 <tcp_rexmit+0x2c>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 800c2fe:	68fb      	ldr	r3, [r7, #12]
 800c300:	681b      	ldr	r3, [r3, #0]
 800c302:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 800c304:	68fb      	ldr	r3, [r7, #12]
 800c306:	681b      	ldr	r3, [r3, #0]
 800c308:	2b00      	cmp	r3, #0
 800c30a:	d011      	beq.n	800c330 <tcp_rexmit+0x58>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 800c30c:	68fb      	ldr	r3, [r7, #12]
 800c30e:	681b      	ldr	r3, [r3, #0]
 800c310:	691b      	ldr	r3, [r3, #16]
 800c312:	685b      	ldr	r3, [r3, #4]
 800c314:	4618      	mov	r0, r3
 800c316:	f7fa fce3 	bl	8006ce0 <ntohl>
 800c31a:	4604      	mov	r4, r0
 800c31c:	68bb      	ldr	r3, [r7, #8]
 800c31e:	691b      	ldr	r3, [r3, #16]
 800c320:	685b      	ldr	r3, [r3, #4]
 800c322:	4618      	mov	r0, r3
 800c324:	f7fa fcdc 	bl	8006ce0 <ntohl>
 800c328:	4603      	mov	r3, r0
 800c32a:	1ae3      	subs	r3, r4, r3
  while (*cur_seg &&
 800c32c:	2b00      	cmp	r3, #0
 800c32e:	dbe6      	blt.n	800c2fe <tcp_rexmit+0x26>
  }
  seg->next = *cur_seg;
 800c330:	68fb      	ldr	r3, [r7, #12]
 800c332:	681a      	ldr	r2, [r3, #0]
 800c334:	68bb      	ldr	r3, [r7, #8]
 800c336:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
 800c338:	68fb      	ldr	r3, [r7, #12]
 800c33a:	68ba      	ldr	r2, [r7, #8]
 800c33c:	601a      	str	r2, [r3, #0]

  ++pcb->nrtx;
 800c33e:	687b      	ldr	r3, [r7, #4]
 800c340:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 800c344:	3301      	adds	r3, #1
 800c346:	b2da      	uxtb	r2, r3
 800c348:	687b      	ldr	r3, [r7, #4]
 800c34a:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 800c34e:	687b      	ldr	r3, [r7, #4]
 800c350:	2200      	movs	r2, #0
 800c352:	63da      	str	r2, [r3, #60]	; 0x3c
 800c354:	e000      	b.n	800c358 <tcp_rexmit+0x80>
    return;
 800c356:	bf00      	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
 800c358:	3714      	adds	r7, #20
 800c35a:	46bd      	mov	sp, r7
 800c35c:	bd90      	pop	{r4, r7, pc}

0800c35e <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 800c35e:	b580      	push	{r7, lr}
 800c360:	b082      	sub	sp, #8
 800c362:	af00      	add	r7, sp, #0
 800c364:	6078      	str	r0, [r7, #4]
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 800c366:	687b      	ldr	r3, [r7, #4]
 800c368:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c36a:	2b00      	cmp	r3, #0
 800c36c:	d049      	beq.n	800c402 <tcp_rexmit_fast+0xa4>
 800c36e:	687b      	ldr	r3, [r7, #4]
 800c370:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800c374:	f003 0304 	and.w	r3, r3, #4
 800c378:	2b00      	cmp	r3, #0
 800c37a:	d142      	bne.n	800c402 <tcp_rexmit_fast+0xa4>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 800c37c:	6878      	ldr	r0, [r7, #4]
 800c37e:	f7ff ffab 	bl	800c2d8 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd)
 800c382:	687b      	ldr	r3, [r7, #4]
 800c384:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800c388:	687b      	ldr	r3, [r7, #4]
 800c38a:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800c38e:	429a      	cmp	r2, r3
 800c390:	d908      	bls.n	800c3a4 <tcp_rexmit_fast+0x46>
      pcb->ssthresh = pcb->snd_wnd / 2;
 800c392:	687b      	ldr	r3, [r7, #4]
 800c394:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800c398:	085b      	lsrs	r3, r3, #1
 800c39a:	b29a      	uxth	r2, r3
 800c39c:	687b      	ldr	r3, [r7, #4]
 800c39e:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
 800c3a2:	e007      	b.n	800c3b4 <tcp_rexmit_fast+0x56>
    else
      pcb->ssthresh = pcb->cwnd / 2;
 800c3a4:	687b      	ldr	r3, [r7, #4]
 800c3a6:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800c3aa:	085b      	lsrs	r3, r3, #1
 800c3ac:	b29a      	uxth	r2, r3
 800c3ae:	687b      	ldr	r3, [r7, #4]
 800c3b0:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 800c3b4:	687b      	ldr	r3, [r7, #4]
 800c3b6:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 800c3ba:	461a      	mov	r2, r3
 800c3bc:	687b      	ldr	r3, [r7, #4]
 800c3be:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800c3c0:	005b      	lsls	r3, r3, #1
 800c3c2:	429a      	cmp	r2, r3
 800c3c4:	da06      	bge.n	800c3d4 <tcp_rexmit_fast+0x76>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 800c3c6:	687b      	ldr	r3, [r7, #4]
 800c3c8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800c3ca:	005b      	lsls	r3, r3, #1
 800c3cc:	b29a      	uxth	r2, r3
 800c3ce:	687b      	ldr	r3, [r7, #4]
 800c3d0:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800c3d4:	687b      	ldr	r3, [r7, #4]
 800c3d6:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 800c3da:	687b      	ldr	r3, [r7, #4]
 800c3dc:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800c3de:	4619      	mov	r1, r3
 800c3e0:	0049      	lsls	r1, r1, #1
 800c3e2:	440b      	add	r3, r1
 800c3e4:	b29b      	uxth	r3, r3
 800c3e6:	4413      	add	r3, r2
 800c3e8:	b29a      	uxth	r2, r3
 800c3ea:	687b      	ldr	r3, [r7, #4]
 800c3ec:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    pcb->flags |= TF_INFR;
 800c3f0:	687b      	ldr	r3, [r7, #4]
 800c3f2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800c3f6:	f043 0304 	orr.w	r3, r3, #4
 800c3fa:	b2da      	uxtb	r2, r3
 800c3fc:	687b      	ldr	r3, [r7, #4]
 800c3fe:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  } 
}
 800c402:	bf00      	nop
 800c404:	3708      	adds	r7, #8
 800c406:	46bd      	mov	sp, r7
 800c408:	bd80      	pop	{r7, pc}

0800c40a <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 800c40a:	b580      	push	{r7, lr}
 800c40c:	b086      	sub	sp, #24
 800c40e:	af02      	add	r7, sp, #8
 800c410:	6078      	str	r0, [r7, #4]
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800c412:	2200      	movs	r2, #0
 800c414:	2114      	movs	r1, #20
 800c416:	2001      	movs	r0, #1
 800c418:	f7fb fffa 	bl	8008410 <pbuf_alloc>
 800c41c:	60f8      	str	r0, [r7, #12]
   
  if(p == NULL) {
 800c41e:	68fb      	ldr	r3, [r7, #12]
 800c420:	2b00      	cmp	r3, #0
 800c422:	d01d      	beq.n	800c460 <tcp_keepalive+0x56>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, htonl(pcb->snd_nxt - 1));
 800c424:	687b      	ldr	r3, [r7, #4]
 800c426:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c428:	3b01      	subs	r3, #1
 800c42a:	4618      	mov	r0, r3
 800c42c:	f7fa fc3f 	bl	8006cae <htonl>
 800c430:	4603      	mov	r3, r0
 800c432:	2200      	movs	r2, #0
 800c434:	68f9      	ldr	r1, [r7, #12]
 800c436:	6878      	ldr	r0, [r7, #4]
 800c438:	f7ff f8a4 	bl	800b584 <tcp_output_set_header>
 800c43c:	60b8      	str	r0, [r7, #8]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 800c43e:	6879      	ldr	r1, [r7, #4]
 800c440:	687b      	ldr	r3, [r7, #4]
 800c442:	1d1a      	adds	r2, r3, #4
 800c444:	687b      	ldr	r3, [r7, #4]
 800c446:	7ad8      	ldrb	r0, [r3, #11]
 800c448:	2306      	movs	r3, #6
 800c44a:	9301      	str	r3, [sp, #4]
 800c44c:	2300      	movs	r3, #0
 800c44e:	9300      	str	r3, [sp, #0]
 800c450:	4603      	mov	r3, r0
 800c452:	68f8      	ldr	r0, [r7, #12]
 800c454:	f7fa ff3e 	bl	80072d4 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800c458:	68f8      	ldr	r0, [r7, #12]
 800c45a:	f7fc f9a6 	bl	80087aa <pbuf_free>
 800c45e:	e000      	b.n	800c462 <tcp_keepalive+0x58>
    return;
 800c460:	bf00      	nop

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800c462:	3710      	adds	r7, #16
 800c464:	46bd      	mov	sp, r7
 800c466:	bd80      	pop	{r7, pc}

0800c468 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 800c468:	b590      	push	{r4, r7, lr}
 800c46a:	b089      	sub	sp, #36	; 0x24
 800c46c:	af02      	add	r7, sp, #8
 800c46e:	6078      	str	r0, [r7, #4]
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 800c470:	687b      	ldr	r3, [r7, #4]
 800c472:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c474:	617b      	str	r3, [r7, #20]

  if(seg == NULL)
 800c476:	697b      	ldr	r3, [r7, #20]
 800c478:	2b00      	cmp	r3, #0
 800c47a:	d102      	bne.n	800c482 <tcp_zero_window_probe+0x1a>
    seg = pcb->unsent;
 800c47c:	687b      	ldr	r3, [r7, #4]
 800c47e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c480:	617b      	str	r3, [r7, #20]

  if(seg == NULL)
 800c482:	697b      	ldr	r3, [r7, #20]
 800c484:	2b00      	cmp	r3, #0
 800c486:	d05b      	beq.n	800c540 <tcp_zero_window_probe+0xd8>
    return;

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800c488:	697b      	ldr	r3, [r7, #20]
 800c48a:	691b      	ldr	r3, [r3, #16]
 800c48c:	899b      	ldrh	r3, [r3, #12]
 800c48e:	b29b      	uxth	r3, r3
 800c490:	4618      	mov	r0, r3
 800c492:	f7fa fbfe 	bl	8006c92 <ntohs>
 800c496:	4603      	mov	r3, r0
 800c498:	f003 0301 	and.w	r3, r3, #1
 800c49c:	2b00      	cmp	r3, #0
 800c49e:	d005      	beq.n	800c4ac <tcp_zero_window_probe+0x44>
 800c4a0:	697b      	ldr	r3, [r7, #20]
 800c4a2:	899b      	ldrh	r3, [r3, #12]
 800c4a4:	2b00      	cmp	r3, #0
 800c4a6:	d101      	bne.n	800c4ac <tcp_zero_window_probe+0x44>
 800c4a8:	2301      	movs	r3, #1
 800c4aa:	e000      	b.n	800c4ae <tcp_zero_window_probe+0x46>
 800c4ac:	2300      	movs	r3, #0
 800c4ae:	74fb      	strb	r3, [r7, #19]
  len = is_fin ? TCP_HLEN : TCP_HLEN + 1;
 800c4b0:	7cfb      	ldrb	r3, [r7, #19]
 800c4b2:	2b00      	cmp	r3, #0
 800c4b4:	d001      	beq.n	800c4ba <tcp_zero_window_probe+0x52>
 800c4b6:	2314      	movs	r3, #20
 800c4b8:	e000      	b.n	800c4bc <tcp_zero_window_probe+0x54>
 800c4ba:	2315      	movs	r3, #21
 800c4bc:	823b      	strh	r3, [r7, #16]

  p = pbuf_alloc(PBUF_IP, len, PBUF_RAM);
 800c4be:	8a3b      	ldrh	r3, [r7, #16]
 800c4c0:	2200      	movs	r2, #0
 800c4c2:	4619      	mov	r1, r3
 800c4c4:	2001      	movs	r0, #1
 800c4c6:	f7fb ffa3 	bl	8008410 <pbuf_alloc>
 800c4ca:	60f8      	str	r0, [r7, #12]
  if(p == NULL) {
 800c4cc:	68fb      	ldr	r3, [r7, #12]
 800c4ce:	2b00      	cmp	r3, #0
 800c4d0:	d038      	beq.n	800c544 <tcp_zero_window_probe+0xdc>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, seg->tcphdr->seqno);
 800c4d2:	697b      	ldr	r3, [r7, #20]
 800c4d4:	691b      	ldr	r3, [r3, #16]
 800c4d6:	685b      	ldr	r3, [r3, #4]
 800c4d8:	2200      	movs	r2, #0
 800c4da:	68f9      	ldr	r1, [r7, #12]
 800c4dc:	6878      	ldr	r0, [r7, #4]
 800c4de:	f7ff f851 	bl	800b584 <tcp_output_set_header>
 800c4e2:	60b8      	str	r0, [r7, #8]

  if (is_fin) {
 800c4e4:	7cfb      	ldrb	r3, [r7, #19]
 800c4e6:	2b00      	cmp	r3, #0
 800c4e8:	d012      	beq.n	800c510 <tcp_zero_window_probe+0xa8>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 800c4ea:	68bb      	ldr	r3, [r7, #8]
 800c4ec:	899b      	ldrh	r3, [r3, #12]
 800c4ee:	b29c      	uxth	r4, r3
 800c4f0:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 800c4f4:	f7fa fbb8 	bl	8006c68 <htons>
 800c4f8:	4603      	mov	r3, r0
 800c4fa:	4023      	ands	r3, r4
 800c4fc:	b29c      	uxth	r4, r3
 800c4fe:	2011      	movs	r0, #17
 800c500:	f7fa fbb2 	bl	8006c68 <htons>
 800c504:	4603      	mov	r3, r0
 800c506:	4323      	orrs	r3, r4
 800c508:	b29a      	uxth	r2, r3
 800c50a:	68bb      	ldr	r3, [r7, #8]
 800c50c:	819a      	strh	r2, [r3, #12]
 800c50e:	e006      	b.n	800c51e <tcp_zero_window_probe+0xb6>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
 800c510:	68fb      	ldr	r3, [r7, #12]
 800c512:	685b      	ldr	r3, [r3, #4]
 800c514:	3314      	adds	r3, #20
 800c516:	697a      	ldr	r2, [r7, #20]
 800c518:	6892      	ldr	r2, [r2, #8]
 800c51a:	7812      	ldrb	r2, [r2, #0]
 800c51c:	701a      	strb	r2, [r3, #0]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 800c51e:	6879      	ldr	r1, [r7, #4]
 800c520:	687b      	ldr	r3, [r7, #4]
 800c522:	1d1a      	adds	r2, r3, #4
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	7ad8      	ldrb	r0, [r3, #11]
 800c528:	2306      	movs	r3, #6
 800c52a:	9301      	str	r3, [sp, #4]
 800c52c:	2300      	movs	r3, #0
 800c52e:	9300      	str	r3, [sp, #0]
 800c530:	4603      	mov	r3, r0
 800c532:	68f8      	ldr	r0, [r7, #12]
 800c534:	f7fa fece 	bl	80072d4 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800c538:	68f8      	ldr	r0, [r7, #12]
 800c53a:	f7fc f936 	bl	80087aa <pbuf_free>
 800c53e:	e002      	b.n	800c546 <tcp_zero_window_probe+0xde>
    return;
 800c540:	bf00      	nop
 800c542:	e000      	b.n	800c546 <tcp_zero_window_probe+0xde>
    return;
 800c544:	bf00      	nop

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800c546:	371c      	adds	r7, #28
 800c548:	46bd      	mov	sp, r7
 800c54a:	bd90      	pop	{r4, r7, pc}

0800c54c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 800c54c:	b590      	push	{r4, r7, lr}
 800c54e:	b08d      	sub	sp, #52	; 0x34
 800c550:	af02      	add	r7, sp, #8
 800c552:	6078      	str	r0, [r7, #4]
 800c554:	6039      	str	r1, [r7, #0]

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
 800c556:	687b      	ldr	r3, [r7, #4]
 800c558:	685b      	ldr	r3, [r3, #4]
 800c55a:	617b      	str	r3, [r7, #20]

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 800c55c:	687b      	ldr	r3, [r7, #4]
 800c55e:	891b      	ldrh	r3, [r3, #8]
 800c560:	461c      	mov	r4, r3
 800c562:	697b      	ldr	r3, [r7, #20]
 800c564:	881b      	ldrh	r3, [r3, #0]
 800c566:	b29b      	uxth	r3, r3
 800c568:	4618      	mov	r0, r3
 800c56a:	f7fa fb92 	bl	8006c92 <ntohs>
 800c56e:	4603      	mov	r3, r0
 800c570:	0a1b      	lsrs	r3, r3, #8
 800c572:	b29b      	uxth	r3, r3
 800c574:	f003 030f 	and.w	r3, r3, #15
 800c578:	3302      	adds	r3, #2
 800c57a:	009b      	lsls	r3, r3, #2
 800c57c:	429c      	cmp	r4, r3
 800c57e:	db17      	blt.n	800c5b0 <udp_input+0x64>
 800c580:	697b      	ldr	r3, [r7, #20]
 800c582:	881b      	ldrh	r3, [r3, #0]
 800c584:	b29b      	uxth	r3, r3
 800c586:	4618      	mov	r0, r3
 800c588:	f7fa fb83 	bl	8006c92 <ntohs>
 800c58c:	4603      	mov	r3, r0
 800c58e:	0a1b      	lsrs	r3, r3, #8
 800c590:	b29b      	uxth	r3, r3
 800c592:	f003 030f 	and.w	r3, r3, #15
 800c596:	b29b      	uxth	r3, r3
 800c598:	009b      	lsls	r3, r3, #2
 800c59a:	b29b      	uxth	r3, r3
 800c59c:	425b      	negs	r3, r3
 800c59e:	b29b      	uxth	r3, r3
 800c5a0:	b21b      	sxth	r3, r3
 800c5a2:	4619      	mov	r1, r3
 800c5a4:	6878      	ldr	r0, [r7, #4]
 800c5a6:	f7fc f891 	bl	80086cc <pbuf_header>
 800c5aa:	4603      	mov	r3, r0
 800c5ac:	2b00      	cmp	r3, #0
 800c5ae:	d003      	beq.n	800c5b8 <udp_input+0x6c>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
 800c5b0:	6878      	ldr	r0, [r7, #4]
 800c5b2:	f7fc f8fa 	bl	80087aa <pbuf_free>
    goto end;
 800c5b6:	e10d      	b.n	800c7d4 <udp_input+0x288>
  }

  udphdr = (struct udp_hdr *)p->payload;
 800c5b8:	687b      	ldr	r3, [r7, #4]
 800c5ba:	685b      	ldr	r3, [r3, #4]
 800c5bc:	613b      	str	r3, [r7, #16]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&(iphdr->dest), inp);
 800c5be:	697b      	ldr	r3, [r7, #20]
 800c5c0:	3310      	adds	r3, #16
 800c5c2:	6839      	ldr	r1, [r7, #0]
 800c5c4:	4618      	mov	r0, r3
 800c5c6:	f7fa feba 	bl	800733e <ip_addr_isbroadcast>
 800c5ca:	4603      	mov	r3, r0
 800c5cc:	73fb      	strb	r3, [r7, #15]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 800c5ce:	693b      	ldr	r3, [r7, #16]
 800c5d0:	881b      	ldrh	r3, [r3, #0]
 800c5d2:	b29b      	uxth	r3, r3
 800c5d4:	4618      	mov	r0, r3
 800c5d6:	f7fa fb5c 	bl	8006c92 <ntohs>
 800c5da:	4603      	mov	r3, r0
 800c5dc:	81bb      	strh	r3, [r7, #12]
  dest = ntohs(udphdr->dest);
 800c5de:	693b      	ldr	r3, [r7, #16]
 800c5e0:	885b      	ldrh	r3, [r3, #2]
 800c5e2:	b29b      	uxth	r3, r3
 800c5e4:	4618      	mov	r0, r3
 800c5e6:	f7fa fb54 	bl	8006c92 <ntohs>
 800c5ea:	4603      	mov	r3, r0
 800c5ec:	817b      	strh	r3, [r7, #10]

  udp_debug_print(udphdr);
 800c5ee:	6938      	ldr	r0, [r7, #16]
 800c5f0:	f000 faad 	bl	800cb4e <udp_debug_print>
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
 800c5f4:	2300      	movs	r3, #0
 800c5f6:	627b      	str	r3, [r7, #36]	; 0x24
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
 800c5f8:	897b      	ldrh	r3, [r7, #10]
 800c5fa:	2b44      	cmp	r3, #68	; 0x44
 800c5fc:	d126      	bne.n	800c64c <udp_input+0x100>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
 800c5fe:	89bb      	ldrh	r3, [r7, #12]
 800c600:	2b43      	cmp	r3, #67	; 0x43
 800c602:	f040 8088 	bne.w	800c716 <udp_input+0x1ca>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
 800c606:	683b      	ldr	r3, [r7, #0]
 800c608:	6a1b      	ldr	r3, [r3, #32]
 800c60a:	2b00      	cmp	r3, #0
 800c60c:	f000 8083 	beq.w	800c716 <udp_input+0x1ca>
 800c610:	683b      	ldr	r3, [r7, #0]
 800c612:	6a1b      	ldr	r3, [r3, #32]
 800c614:	685b      	ldr	r3, [r3, #4]
 800c616:	2b00      	cmp	r3, #0
 800c618:	d07d      	beq.n	800c716 <udp_input+0x1ca>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 800c61a:	683b      	ldr	r3, [r7, #0]
 800c61c:	6a1b      	ldr	r3, [r3, #32]
 800c61e:	685b      	ldr	r3, [r3, #4]
 800c620:	3304      	adds	r3, #4
 800c622:	2b00      	cmp	r3, #0
 800c624:	d00d      	beq.n	800c642 <udp_input+0xf6>
 800c626:	683b      	ldr	r3, [r7, #0]
 800c628:	6a1b      	ldr	r3, [r3, #32]
 800c62a:	685b      	ldr	r3, [r3, #4]
 800c62c:	685b      	ldr	r3, [r3, #4]
 800c62e:	2b00      	cmp	r3, #0
 800c630:	d007      	beq.n	800c642 <udp_input+0xf6>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
 800c632:	683b      	ldr	r3, [r7, #0]
 800c634:	6a1b      	ldr	r3, [r3, #32]
 800c636:	685b      	ldr	r3, [r3, #4]
 800c638:	685a      	ldr	r2, [r3, #4]
 800c63a:	697b      	ldr	r3, [r7, #20]
 800c63c:	68db      	ldr	r3, [r3, #12]
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 800c63e:	429a      	cmp	r2, r3
 800c640:	d169      	bne.n	800c716 <udp_input+0x1ca>
          pcb = inp->dhcp->pcb;
 800c642:	683b      	ldr	r3, [r7, #0]
 800c644:	6a1b      	ldr	r3, [r3, #32]
 800c646:	685b      	ldr	r3, [r3, #4]
 800c648:	627b      	str	r3, [r7, #36]	; 0x24
 800c64a:	e064      	b.n	800c716 <udp_input+0x1ca>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
 800c64c:	2300      	movs	r3, #0
 800c64e:	623b      	str	r3, [r7, #32]
    local_match = 0;
 800c650:	2300      	movs	r3, #0
 800c652:	76fb      	strb	r3, [r7, #27]
    uncon_pcb = NULL;
 800c654:	2300      	movs	r3, #0
 800c656:	61fb      	str	r3, [r7, #28]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800c658:	4b60      	ldr	r3, [pc, #384]	; (800c7dc <udp_input+0x290>)
 800c65a:	681b      	ldr	r3, [r3, #0]
 800c65c:	627b      	str	r3, [r7, #36]	; 0x24
 800c65e:	e050      	b.n	800c702 <udp_input+0x1b6>
      local_match = 0;
 800c660:	2300      	movs	r3, #0
 800c662:	76fb      	strb	r3, [r7, #27]
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
 800c664:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c666:	8a5b      	ldrh	r3, [r3, #18]
 800c668:	897a      	ldrh	r2, [r7, #10]
 800c66a:	429a      	cmp	r2, r3
 800c66c:	d11f      	bne.n	800c6ae <udp_input+0x162>
 800c66e:	7bfb      	ldrb	r3, [r7, #15]
 800c670:	2b00      	cmp	r3, #0
 800c672:	d106      	bne.n	800c682 <udp_input+0x136>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800c674:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c676:	2b00      	cmp	r3, #0
 800c678:	d00c      	beq.n	800c694 <udp_input+0x148>
 800c67a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c67c:	681b      	ldr	r3, [r3, #0]
 800c67e:	2b00      	cmp	r3, #0
 800c680:	d008      	beq.n	800c694 <udp_input+0x148>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
 800c682:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c684:	681a      	ldr	r2, [r3, #0]
 800c686:	697b      	ldr	r3, [r7, #20]
 800c688:	691b      	ldr	r3, [r3, #16]
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800c68a:	429a      	cmp	r2, r3
 800c68c:	d002      	beq.n	800c694 <udp_input+0x148>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
 800c68e:	7bfb      	ldrb	r3, [r7, #15]
 800c690:	2b00      	cmp	r3, #0
 800c692:	d00c      	beq.n	800c6ae <udp_input+0x162>
#if IP_SOF_BROADCAST_RECV
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
 800c694:	2301      	movs	r3, #1
 800c696:	76fb      	strb	r3, [r7, #27]
        if ((uncon_pcb == NULL) && 
 800c698:	69fb      	ldr	r3, [r7, #28]
 800c69a:	2b00      	cmp	r3, #0
 800c69c:	d107      	bne.n	800c6ae <udp_input+0x162>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
 800c69e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6a0:	7c1b      	ldrb	r3, [r3, #16]
 800c6a2:	f003 0304 	and.w	r3, r3, #4
        if ((uncon_pcb == NULL) && 
 800c6a6:	2b00      	cmp	r3, #0
 800c6a8:	d101      	bne.n	800c6ae <udp_input+0x162>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 800c6aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6ac:	61fb      	str	r3, [r7, #28]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 800c6ae:	7efb      	ldrb	r3, [r7, #27]
 800c6b0:	2b00      	cmp	r3, #0
 800c6b2:	d021      	beq.n	800c6f8 <udp_input+0x1ac>
          (pcb->remote_port == src) &&
 800c6b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6b6:	8a9b      	ldrh	r3, [r3, #20]
      if ((local_match != 0) &&
 800c6b8:	89ba      	ldrh	r2, [r7, #12]
 800c6ba:	429a      	cmp	r2, r3
 800c6bc:	d11c      	bne.n	800c6f8 <udp_input+0x1ac>
          (ip_addr_isany(&pcb->remote_ip) ||
 800c6be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6c0:	3304      	adds	r3, #4
          (pcb->remote_port == src) &&
 800c6c2:	2b00      	cmp	r3, #0
 800c6c4:	d009      	beq.n	800c6da <udp_input+0x18e>
          (ip_addr_isany(&pcb->remote_ip) ||
 800c6c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6c8:	685b      	ldr	r3, [r3, #4]
 800c6ca:	2b00      	cmp	r3, #0
 800c6cc:	d005      	beq.n	800c6da <udp_input+0x18e>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
 800c6ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6d0:	685a      	ldr	r2, [r3, #4]
 800c6d2:	697b      	ldr	r3, [r7, #20]
 800c6d4:	68db      	ldr	r3, [r3, #12]
          (ip_addr_isany(&pcb->remote_ip) ||
 800c6d6:	429a      	cmp	r2, r3
 800c6d8:	d10e      	bne.n	800c6f8 <udp_input+0x1ac>
        /* the first fully matching PCB */
        if (prev != NULL) {
 800c6da:	6a3b      	ldr	r3, [r7, #32]
 800c6dc:	2b00      	cmp	r3, #0
 800c6de:	d014      	beq.n	800c70a <udp_input+0x1be>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 800c6e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6e2:	68da      	ldr	r2, [r3, #12]
 800c6e4:	6a3b      	ldr	r3, [r7, #32]
 800c6e6:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
 800c6e8:	4b3c      	ldr	r3, [pc, #240]	; (800c7dc <udp_input+0x290>)
 800c6ea:	681a      	ldr	r2, [r3, #0]
 800c6ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6ee:	60da      	str	r2, [r3, #12]
          udp_pcbs = pcb;
 800c6f0:	4a3a      	ldr	r2, [pc, #232]	; (800c7dc <udp_input+0x290>)
 800c6f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6f4:	6013      	str	r3, [r2, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 800c6f6:	e008      	b.n	800c70a <udp_input+0x1be>
#if LWIP_UPNP
      if((local_match != 0) && (dest == 1900)) {
        break;
      }
#endif /* LWIP_UPNP */
      prev = pcb;
 800c6f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6fa:	623b      	str	r3, [r7, #32]
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800c6fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6fe:	68db      	ldr	r3, [r3, #12]
 800c700:	627b      	str	r3, [r7, #36]	; 0x24
 800c702:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c704:	2b00      	cmp	r3, #0
 800c706:	d1ab      	bne.n	800c660 <udp_input+0x114>
 800c708:	e000      	b.n	800c70c <udp_input+0x1c0>
        break;
 800c70a:	bf00      	nop
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
 800c70c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c70e:	2b00      	cmp	r3, #0
 800c710:	d101      	bne.n	800c716 <udp_input+0x1ca>
      pcb = uncon_pcb;
 800c712:	69fb      	ldr	r3, [r7, #28]
 800c714:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
 800c716:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c718:	2b00      	cmp	r3, #0
 800c71a:	d105      	bne.n	800c728 <udp_input+0x1dc>
 800c71c:	683b      	ldr	r3, [r7, #0]
 800c71e:	685a      	ldr	r2, [r3, #4]
 800c720:	697b      	ldr	r3, [r7, #20]
 800c722:	691b      	ldr	r3, [r3, #16]
 800c724:	429a      	cmp	r2, r3
 800c726:	d152      	bne.n	800c7ce <udp_input+0x282>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 800c728:	f06f 0107 	mvn.w	r1, #7
 800c72c:	6878      	ldr	r0, [r7, #4]
 800c72e:	f7fb ffcd 	bl	80086cc <pbuf_header>
 800c732:	4603      	mov	r3, r0
 800c734:	2b00      	cmp	r3, #0
 800c736:	d003      	beq.n	800c740 <udp_input+0x1f4>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
 800c738:	6878      	ldr	r0, [r7, #4]
 800c73a:	f7fc f836 	bl	80087aa <pbuf_free>
      goto end;
 800c73e:	e049      	b.n	800c7d4 <udp_input+0x288>
    }
    if (pcb != NULL) {
 800c740:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c742:	2b00      	cmp	r3, #0
 800c744:	d015      	beq.n	800c772 <udp_input+0x226>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
 800c746:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c748:	699b      	ldr	r3, [r3, #24]
 800c74a:	2b00      	cmp	r3, #0
 800c74c:	d00d      	beq.n	800c76a <udp_input+0x21e>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &iphdr->src, src);
 800c74e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c750:	699c      	ldr	r4, [r3, #24]
 800c752:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c754:	69d8      	ldr	r0, [r3, #28]
 800c756:	697b      	ldr	r3, [r7, #20]
 800c758:	f103 020c 	add.w	r2, r3, #12
 800c75c:	89bb      	ldrh	r3, [r7, #12]
 800c75e:	9300      	str	r3, [sp, #0]
 800c760:	4613      	mov	r3, r2
 800c762:	687a      	ldr	r2, [r7, #4]
 800c764:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800c766:	47a0      	blx	r4
    if (pcb != NULL) {
 800c768:	e034      	b.n	800c7d4 <udp_input+0x288>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
 800c76a:	6878      	ldr	r0, [r7, #4]
 800c76c:	f7fc f81d 	bl	80087aa <pbuf_free>
        goto end;
 800c770:	e030      	b.n	800c7d4 <udp_input+0x288>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 800c772:	7bfb      	ldrb	r3, [r7, #15]
 800c774:	2b00      	cmp	r3, #0
 800c776:	d126      	bne.n	800c7c6 <udp_input+0x27a>
          !ip_addr_ismulticast(&iphdr->dest)) {
 800c778:	697b      	ldr	r3, [r7, #20]
 800c77a:	691c      	ldr	r4, [r3, #16]
 800c77c:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 800c780:	f7fa faae 	bl	8006ce0 <ntohl>
 800c784:	4603      	mov	r3, r0
 800c786:	401c      	ands	r4, r3
 800c788:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 800c78c:	f7fa faa8 	bl	8006ce0 <ntohl>
 800c790:	4603      	mov	r3, r0
      if (!broadcast &&
 800c792:	429c      	cmp	r4, r3
 800c794:	d017      	beq.n	800c7c6 <udp_input+0x27a>
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 800c796:	697b      	ldr	r3, [r7, #20]
 800c798:	881b      	ldrh	r3, [r3, #0]
 800c79a:	b29b      	uxth	r3, r3
 800c79c:	4618      	mov	r0, r3
 800c79e:	f7fa fa78 	bl	8006c92 <ntohs>
 800c7a2:	4603      	mov	r3, r0
 800c7a4:	0a1b      	lsrs	r3, r3, #8
 800c7a6:	b29b      	uxth	r3, r3
 800c7a8:	f003 030f 	and.w	r3, r3, #15
 800c7ac:	3302      	adds	r3, #2
 800c7ae:	b29b      	uxth	r3, r3
 800c7b0:	009b      	lsls	r3, r3, #2
 800c7b2:	b29b      	uxth	r3, r3
 800c7b4:	b21b      	sxth	r3, r3
 800c7b6:	4619      	mov	r1, r3
 800c7b8:	6878      	ldr	r0, [r7, #4]
 800c7ba:	f7fb ff87 	bl	80086cc <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 800c7be:	2103      	movs	r1, #3
 800c7c0:	6878      	ldr	r0, [r7, #4]
 800c7c2:	f7fa f9dd 	bl	8006b80 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
 800c7c6:	6878      	ldr	r0, [r7, #4]
 800c7c8:	f7fb ffef 	bl	80087aa <pbuf_free>
    if (pcb != NULL) {
 800c7cc:	e002      	b.n	800c7d4 <udp_input+0x288>
    }
  } else {
    pbuf_free(p);
 800c7ce:	6878      	ldr	r0, [r7, #4]
 800c7d0:	f7fb ffeb 	bl	80087aa <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
 800c7d4:	bf00      	nop
 800c7d6:	372c      	adds	r7, #44	; 0x2c
 800c7d8:	46bd      	mov	sp, r7
 800c7da:	bd90      	pop	{r4, r7, pc}
 800c7dc:	2000a340 	.word	0x2000a340

0800c7e0 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
 800c7e0:	b580      	push	{r7, lr}
 800c7e2:	b082      	sub	sp, #8
 800c7e4:	af00      	add	r7, sp, #0
 800c7e6:	6078      	str	r0, [r7, #4]
 800c7e8:	6039      	str	r1, [r7, #0]
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 800c7ea:	687b      	ldr	r3, [r7, #4]
 800c7ec:	1d1a      	adds	r2, r3, #4
 800c7ee:	687b      	ldr	r3, [r7, #4]
 800c7f0:	8a9b      	ldrh	r3, [r3, #20]
 800c7f2:	6839      	ldr	r1, [r7, #0]
 800c7f4:	6878      	ldr	r0, [r7, #4]
 800c7f6:	f000 f805 	bl	800c804 <udp_sendto>
 800c7fa:	4603      	mov	r3, r0
}
 800c7fc:	4618      	mov	r0, r3
 800c7fe:	3708      	adds	r7, #8
 800c800:	46bd      	mov	sp, r7
 800c802:	bd80      	pop	{r7, pc}

0800c804 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
 800c804:	b580      	push	{r7, lr}
 800c806:	b088      	sub	sp, #32
 800c808:	af02      	add	r7, sp, #8
 800c80a:	60f8      	str	r0, [r7, #12]
 800c80c:	60b9      	str	r1, [r7, #8]
 800c80e:	607a      	str	r2, [r7, #4]
 800c810:	807b      	strh	r3, [r7, #2]

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
 800c812:	6878      	ldr	r0, [r7, #4]
 800c814:	f7fa fb1a 	bl	8006e4c <ip_route>
 800c818:	6178      	str	r0, [r7, #20]
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 800c81a:	697b      	ldr	r3, [r7, #20]
 800c81c:	2b00      	cmp	r3, #0
 800c81e:	d102      	bne.n	800c826 <udp_sendto+0x22>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 800c820:	f06f 0303 	mvn.w	r3, #3
 800c824:	e009      	b.n	800c83a <udp_sendto+0x36>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 800c826:	887a      	ldrh	r2, [r7, #2]
 800c828:	697b      	ldr	r3, [r7, #20]
 800c82a:	9300      	str	r3, [sp, #0]
 800c82c:	4613      	mov	r3, r2
 800c82e:	687a      	ldr	r2, [r7, #4]
 800c830:	68b9      	ldr	r1, [r7, #8]
 800c832:	68f8      	ldr	r0, [r7, #12]
 800c834:	f000 f805 	bl	800c842 <udp_sendto_if>
 800c838:	4603      	mov	r3, r0
}
 800c83a:	4618      	mov	r0, r3
 800c83c:	3718      	adds	r7, #24
 800c83e:	46bd      	mov	sp, r7
 800c840:	bd80      	pop	{r7, pc}

0800c842 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
 800c842:	b580      	push	{r7, lr}
 800c844:	b08c      	sub	sp, #48	; 0x30
 800c846:	af04      	add	r7, sp, #16
 800c848:	60f8      	str	r0, [r7, #12]
 800c84a:	60b9      	str	r1, [r7, #8]
 800c84c:	607a      	str	r2, [r7, #4]
 800c84e:	807b      	strh	r3, [r7, #2]
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 800c850:	68fb      	ldr	r3, [r7, #12]
 800c852:	8a5b      	ldrh	r3, [r3, #18]
 800c854:	2b00      	cmp	r3, #0
 800c856:	d10f      	bne.n	800c878 <udp_sendto_if+0x36>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 800c858:	68f9      	ldr	r1, [r7, #12]
 800c85a:	68fb      	ldr	r3, [r7, #12]
 800c85c:	8a5b      	ldrh	r3, [r3, #18]
 800c85e:	461a      	mov	r2, r3
 800c860:	68f8      	ldr	r0, [r7, #12]
 800c862:	f000 f885 	bl	800c970 <udp_bind>
 800c866:	4603      	mov	r3, r0
 800c868:	75fb      	strb	r3, [r7, #23]
    if (err != ERR_OK) {
 800c86a:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800c86e:	2b00      	cmp	r3, #0
 800c870:	d002      	beq.n	800c878 <udp_sendto_if+0x36>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 800c872:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800c876:	e076      	b.n	800c966 <udp_sendto_if+0x124>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
 800c878:	2108      	movs	r1, #8
 800c87a:	68b8      	ldr	r0, [r7, #8]
 800c87c:	f7fb ff26 	bl	80086cc <pbuf_header>
 800c880:	4603      	mov	r3, r0
 800c882:	2b00      	cmp	r3, #0
 800c884:	d010      	beq.n	800c8a8 <udp_sendto_if+0x66>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 800c886:	2200      	movs	r2, #0
 800c888:	2108      	movs	r1, #8
 800c88a:	2001      	movs	r0, #1
 800c88c:	f7fb fdc0 	bl	8008410 <pbuf_alloc>
 800c890:	61b8      	str	r0, [r7, #24]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 800c892:	69bb      	ldr	r3, [r7, #24]
 800c894:	2b00      	cmp	r3, #0
 800c896:	d102      	bne.n	800c89e <udp_sendto_if+0x5c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 800c898:	f04f 33ff 	mov.w	r3, #4294967295
 800c89c:	e063      	b.n	800c966 <udp_sendto_if+0x124>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
 800c89e:	68b9      	ldr	r1, [r7, #8]
 800c8a0:	69b8      	ldr	r0, [r7, #24]
 800c8a2:	f7fc f82a 	bl	80088fa <pbuf_chain>
 800c8a6:	e001      	b.n	800c8ac <udp_sendto_if+0x6a>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 800c8a8:	68bb      	ldr	r3, [r7, #8]
 800c8aa:	61bb      	str	r3, [r7, #24]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
 800c8ac:	69bb      	ldr	r3, [r7, #24]
 800c8ae:	685b      	ldr	r3, [r3, #4]
 800c8b0:	613b      	str	r3, [r7, #16]
  udphdr->src = htons(pcb->local_port);
 800c8b2:	68fb      	ldr	r3, [r7, #12]
 800c8b4:	8a5b      	ldrh	r3, [r3, #18]
 800c8b6:	4618      	mov	r0, r3
 800c8b8:	f7fa f9d6 	bl	8006c68 <htons>
 800c8bc:	4603      	mov	r3, r0
 800c8be:	461a      	mov	r2, r3
 800c8c0:	693b      	ldr	r3, [r7, #16]
 800c8c2:	801a      	strh	r2, [r3, #0]
  udphdr->dest = htons(dst_port);
 800c8c4:	887b      	ldrh	r3, [r7, #2]
 800c8c6:	4618      	mov	r0, r3
 800c8c8:	f7fa f9ce 	bl	8006c68 <htons>
 800c8cc:	4603      	mov	r3, r0
 800c8ce:	461a      	mov	r2, r3
 800c8d0:	693b      	ldr	r3, [r7, #16]
 800c8d2:	805a      	strh	r2, [r3, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 800c8d4:	693b      	ldr	r3, [r7, #16]
 800c8d6:	2200      	movs	r2, #0
 800c8d8:	719a      	strb	r2, [r3, #6]
 800c8da:	2200      	movs	r2, #0
 800c8dc:	71da      	strb	r2, [r3, #7]

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 800c8de:	68fb      	ldr	r3, [r7, #12]
 800c8e0:	2b00      	cmp	r3, #0
 800c8e2:	d003      	beq.n	800c8ec <udp_sendto_if+0xaa>
 800c8e4:	68fb      	ldr	r3, [r7, #12]
 800c8e6:	681b      	ldr	r3, [r3, #0]
 800c8e8:	2b00      	cmp	r3, #0
 800c8ea:	d103      	bne.n	800c8f4 <udp_sendto_if+0xb2>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 800c8ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c8ee:	3304      	adds	r3, #4
 800c8f0:	61fb      	str	r3, [r7, #28]
 800c8f2:	e013      	b.n	800c91c <udp_sendto_if+0xda>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 800c8f4:	68fb      	ldr	r3, [r7, #12]
 800c8f6:	681a      	ldr	r2, [r3, #0]
 800c8f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c8fa:	685b      	ldr	r3, [r3, #4]
 800c8fc:	429a      	cmp	r2, r3
 800c8fe:	d00b      	beq.n	800c918 <udp_sendto_if+0xd6>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
 800c900:	69ba      	ldr	r2, [r7, #24]
 800c902:	68bb      	ldr	r3, [r7, #8]
 800c904:	429a      	cmp	r2, r3
 800c906:	d004      	beq.n	800c912 <udp_sendto_if+0xd0>
        /* free the header pbuf */
        pbuf_free(q);
 800c908:	69b8      	ldr	r0, [r7, #24]
 800c90a:	f7fb ff4e 	bl	80087aa <pbuf_free>
        q = NULL;
 800c90e:	2300      	movs	r3, #0
 800c910:	61bb      	str	r3, [r7, #24]
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 800c912:	f06f 0308 	mvn.w	r3, #8
 800c916:	e026      	b.n	800c966 <udp_sendto_if+0x124>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 800c918:	68fb      	ldr	r3, [r7, #12]
 800c91a:	61fb      	str	r3, [r7, #28]
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
 800c91c:	69bb      	ldr	r3, [r7, #24]
 800c91e:	891b      	ldrh	r3, [r3, #8]
 800c920:	4618      	mov	r0, r3
 800c922:	f7fa f9a1 	bl	8006c68 <htons>
 800c926:	4603      	mov	r3, r0
 800c928:	461a      	mov	r2, r3
 800c92a:	693b      	ldr	r3, [r7, #16]
 800c92c:	809a      	strh	r2, [r3, #4]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 800c92e:	68fb      	ldr	r3, [r7, #12]
 800c930:	7ad9      	ldrb	r1, [r3, #11]
 800c932:	68fb      	ldr	r3, [r7, #12]
 800c934:	7a9b      	ldrb	r3, [r3, #10]
 800c936:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c938:	9202      	str	r2, [sp, #8]
 800c93a:	2211      	movs	r2, #17
 800c93c:	9201      	str	r2, [sp, #4]
 800c93e:	9300      	str	r3, [sp, #0]
 800c940:	460b      	mov	r3, r1
 800c942:	687a      	ldr	r2, [r7, #4]
 800c944:	69f9      	ldr	r1, [r7, #28]
 800c946:	69b8      	ldr	r0, [r7, #24]
 800c948:	f7fa fbf8 	bl	800713c <ip_output_if>
 800c94c:	4603      	mov	r3, r0
 800c94e:	75fb      	strb	r3, [r7, #23]
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 800c950:	69ba      	ldr	r2, [r7, #24]
 800c952:	68bb      	ldr	r3, [r7, #8]
 800c954:	429a      	cmp	r2, r3
 800c956:	d004      	beq.n	800c962 <udp_sendto_if+0x120>
    /* free the header pbuf */
    pbuf_free(q);
 800c958:	69b8      	ldr	r0, [r7, #24]
 800c95a:	f7fb ff26 	bl	80087aa <pbuf_free>
    q = NULL;
 800c95e:	2300      	movs	r3, #0
 800c960:	61bb      	str	r3, [r7, #24]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 800c962:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 800c966:	4618      	mov	r0, r3
 800c968:	3720      	adds	r7, #32
 800c96a:	46bd      	mov	sp, r7
 800c96c:	bd80      	pop	{r7, pc}
	...

0800c970 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
 800c970:	b480      	push	{r7}
 800c972:	b087      	sub	sp, #28
 800c974:	af00      	add	r7, sp, #0
 800c976:	60f8      	str	r0, [r7, #12]
 800c978:	60b9      	str	r1, [r7, #8]
 800c97a:	4613      	mov	r3, r2
 800c97c:	80fb      	strh	r3, [r7, #6]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 800c97e:	2300      	movs	r3, #0
 800c980:	74fb      	strb	r3, [r7, #19]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800c982:	4b2a      	ldr	r3, [pc, #168]	; (800ca2c <udp_bind+0xbc>)
 800c984:	681b      	ldr	r3, [r3, #0]
 800c986:	617b      	str	r3, [r7, #20]
 800c988:	e008      	b.n	800c99c <udp_bind+0x2c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 800c98a:	68fa      	ldr	r2, [r7, #12]
 800c98c:	697b      	ldr	r3, [r7, #20]
 800c98e:	429a      	cmp	r2, r3
 800c990:	d101      	bne.n	800c996 <udp_bind+0x26>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 800c992:	2301      	movs	r3, #1
 800c994:	74fb      	strb	r3, [r7, #19]
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800c996:	697b      	ldr	r3, [r7, #20]
 800c998:	68db      	ldr	r3, [r3, #12]
 800c99a:	617b      	str	r3, [r7, #20]
 800c99c:	697b      	ldr	r3, [r7, #20]
 800c99e:	2b00      	cmp	r3, #0
 800c9a0:	d1f3      	bne.n	800c98a <udp_bind+0x1a>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 800c9a2:	68bb      	ldr	r3, [r7, #8]
 800c9a4:	2b00      	cmp	r3, #0
 800c9a6:	d002      	beq.n	800c9ae <udp_bind+0x3e>
 800c9a8:	68bb      	ldr	r3, [r7, #8]
 800c9aa:	681b      	ldr	r3, [r3, #0]
 800c9ac:	e000      	b.n	800c9b0 <udp_bind+0x40>
 800c9ae:	2300      	movs	r3, #0
 800c9b0:	68fa      	ldr	r2, [r7, #12]
 800c9b2:	6013      	str	r3, [r2, #0]

  /* no port specified? */
  if (port == 0) {
 800c9b4:	88fb      	ldrh	r3, [r7, #6]
 800c9b6:	2b00      	cmp	r3, #0
 800c9b8:	d123      	bne.n	800ca02 <udp_bind+0x92>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
 800c9ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800c9be:	80fb      	strh	r3, [r7, #6]
    ipcb = udp_pcbs;
 800c9c0:	4b1a      	ldr	r3, [pc, #104]	; (800ca2c <udp_bind+0xbc>)
 800c9c2:	681b      	ldr	r3, [r3, #0]
 800c9c4:	617b      	str	r3, [r7, #20]
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
 800c9c6:	e00e      	b.n	800c9e6 <udp_bind+0x76>
      if (ipcb->local_port == port) {
 800c9c8:	697b      	ldr	r3, [r7, #20]
 800c9ca:	8a5b      	ldrh	r3, [r3, #18]
 800c9cc:	88fa      	ldrh	r2, [r7, #6]
 800c9ce:	429a      	cmp	r2, r3
 800c9d0:	d106      	bne.n	800c9e0 <udp_bind+0x70>
        /* port is already used by another udp_pcb */
        port++;
 800c9d2:	88fb      	ldrh	r3, [r7, #6]
 800c9d4:	3301      	adds	r3, #1
 800c9d6:	80fb      	strh	r3, [r7, #6]
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
 800c9d8:	4b14      	ldr	r3, [pc, #80]	; (800ca2c <udp_bind+0xbc>)
 800c9da:	681b      	ldr	r3, [r3, #0]
 800c9dc:	617b      	str	r3, [r7, #20]
 800c9de:	e002      	b.n	800c9e6 <udp_bind+0x76>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
 800c9e0:	697b      	ldr	r3, [r7, #20]
 800c9e2:	68db      	ldr	r3, [r3, #12]
 800c9e4:	617b      	str	r3, [r7, #20]
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
 800c9e6:	697b      	ldr	r3, [r7, #20]
 800c9e8:	2b00      	cmp	r3, #0
 800c9ea:	d004      	beq.n	800c9f6 <udp_bind+0x86>
 800c9ec:	88fb      	ldrh	r3, [r7, #6]
 800c9ee:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800c9f2:	4293      	cmp	r3, r2
 800c9f4:	d1e8      	bne.n	800c9c8 <udp_bind+0x58>
    }
    if (ipcb != NULL) {
 800c9f6:	697b      	ldr	r3, [r7, #20]
 800c9f8:	2b00      	cmp	r3, #0
 800c9fa:	d002      	beq.n	800ca02 <udp_bind+0x92>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 800c9fc:	f06f 030a 	mvn.w	r3, #10
 800ca00:	e00d      	b.n	800ca1e <udp_bind+0xae>
    }
  }
  pcb->local_port = port;
 800ca02:	68fb      	ldr	r3, [r7, #12]
 800ca04:	88fa      	ldrh	r2, [r7, #6]
 800ca06:	825a      	strh	r2, [r3, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 800ca08:	7cfb      	ldrb	r3, [r7, #19]
 800ca0a:	2b00      	cmp	r3, #0
 800ca0c:	d106      	bne.n	800ca1c <udp_bind+0xac>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 800ca0e:	4b07      	ldr	r3, [pc, #28]	; (800ca2c <udp_bind+0xbc>)
 800ca10:	681a      	ldr	r2, [r3, #0]
 800ca12:	68fb      	ldr	r3, [r7, #12]
 800ca14:	60da      	str	r2, [r3, #12]
    udp_pcbs = pcb;
 800ca16:	4a05      	ldr	r2, [pc, #20]	; (800ca2c <udp_bind+0xbc>)
 800ca18:	68fb      	ldr	r3, [r7, #12]
 800ca1a:	6013      	str	r3, [r2, #0]
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)((ntohl(pcb->local_ip.addr) >> 24) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
 800ca1c:	2300      	movs	r3, #0
}
 800ca1e:	4618      	mov	r0, r3
 800ca20:	371c      	adds	r7, #28
 800ca22:	46bd      	mov	sp, r7
 800ca24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca28:	4770      	bx	lr
 800ca2a:	bf00      	nop
 800ca2c:	2000a340 	.word	0x2000a340

0800ca30 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
 800ca30:	b580      	push	{r7, lr}
 800ca32:	b086      	sub	sp, #24
 800ca34:	af00      	add	r7, sp, #0
 800ca36:	60f8      	str	r0, [r7, #12]
 800ca38:	60b9      	str	r1, [r7, #8]
 800ca3a:	4613      	mov	r3, r2
 800ca3c:	80fb      	strh	r3, [r7, #6]
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 800ca3e:	68fb      	ldr	r3, [r7, #12]
 800ca40:	8a5b      	ldrh	r3, [r3, #18]
 800ca42:	2b00      	cmp	r3, #0
 800ca44:	d10f      	bne.n	800ca66 <udp_connect+0x36>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 800ca46:	68f9      	ldr	r1, [r7, #12]
 800ca48:	68fb      	ldr	r3, [r7, #12]
 800ca4a:	8a5b      	ldrh	r3, [r3, #18]
 800ca4c:	461a      	mov	r2, r3
 800ca4e:	68f8      	ldr	r0, [r7, #12]
 800ca50:	f7ff ff8e 	bl	800c970 <udp_bind>
 800ca54:	4603      	mov	r3, r0
 800ca56:	74fb      	strb	r3, [r7, #19]
    if (err != ERR_OK)
 800ca58:	f997 3013 	ldrsb.w	r3, [r7, #19]
 800ca5c:	2b00      	cmp	r3, #0
 800ca5e:	d002      	beq.n	800ca66 <udp_connect+0x36>
      return err;
 800ca60:	f997 3013 	ldrsb.w	r3, [r7, #19]
 800ca64:	e02a      	b.n	800cabc <udp_connect+0x8c>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 800ca66:	68bb      	ldr	r3, [r7, #8]
 800ca68:	2b00      	cmp	r3, #0
 800ca6a:	d002      	beq.n	800ca72 <udp_connect+0x42>
 800ca6c:	68bb      	ldr	r3, [r7, #8]
 800ca6e:	681b      	ldr	r3, [r3, #0]
 800ca70:	e000      	b.n	800ca74 <udp_connect+0x44>
 800ca72:	2300      	movs	r3, #0
 800ca74:	68fa      	ldr	r2, [r7, #12]
 800ca76:	6053      	str	r3, [r2, #4]
  pcb->remote_port = port;
 800ca78:	68fb      	ldr	r3, [r7, #12]
 800ca7a:	88fa      	ldrh	r2, [r7, #6]
 800ca7c:	829a      	strh	r2, [r3, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 800ca7e:	68fb      	ldr	r3, [r7, #12]
 800ca80:	7c1b      	ldrb	r3, [r3, #16]
 800ca82:	f043 0304 	orr.w	r3, r3, #4
 800ca86:	b2da      	uxtb	r2, r3
 800ca88:	68fb      	ldr	r3, [r7, #12]
 800ca8a:	741a      	strb	r2, [r3, #16]
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800ca8c:	4b0d      	ldr	r3, [pc, #52]	; (800cac4 <udp_connect+0x94>)
 800ca8e:	681b      	ldr	r3, [r3, #0]
 800ca90:	617b      	str	r3, [r7, #20]
 800ca92:	e008      	b.n	800caa6 <udp_connect+0x76>
    if (pcb == ipcb) {
 800ca94:	68fa      	ldr	r2, [r7, #12]
 800ca96:	697b      	ldr	r3, [r7, #20]
 800ca98:	429a      	cmp	r2, r3
 800ca9a:	d101      	bne.n	800caa0 <udp_connect+0x70>
      /* already on the list, just return */
      return ERR_OK;
 800ca9c:	2300      	movs	r3, #0
 800ca9e:	e00d      	b.n	800cabc <udp_connect+0x8c>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800caa0:	697b      	ldr	r3, [r7, #20]
 800caa2:	68db      	ldr	r3, [r3, #12]
 800caa4:	617b      	str	r3, [r7, #20]
 800caa6:	697b      	ldr	r3, [r7, #20]
 800caa8:	2b00      	cmp	r3, #0
 800caaa:	d1f3      	bne.n	800ca94 <udp_connect+0x64>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 800caac:	4b05      	ldr	r3, [pc, #20]	; (800cac4 <udp_connect+0x94>)
 800caae:	681a      	ldr	r2, [r3, #0]
 800cab0:	68fb      	ldr	r3, [r7, #12]
 800cab2:	60da      	str	r2, [r3, #12]
  udp_pcbs = pcb;
 800cab4:	4a03      	ldr	r2, [pc, #12]	; (800cac4 <udp_connect+0x94>)
 800cab6:	68fb      	ldr	r3, [r7, #12]
 800cab8:	6013      	str	r3, [r2, #0]
  return ERR_OK;
 800caba:	2300      	movs	r3, #0
}
 800cabc:	4618      	mov	r0, r3
 800cabe:	3718      	adds	r7, #24
 800cac0:	46bd      	mov	sp, r7
 800cac2:	bd80      	pop	{r7, pc}
 800cac4:	2000a340 	.word	0x2000a340

0800cac8 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
 800cac8:	b480      	push	{r7}
 800caca:	b083      	sub	sp, #12
 800cacc:	af00      	add	r7, sp, #0
 800cace:	6078      	str	r0, [r7, #4]
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
 800cad0:	4b09      	ldr	r3, [pc, #36]	; (800caf8 <udp_disconnect+0x30>)
 800cad2:	681a      	ldr	r2, [r3, #0]
 800cad4:	687b      	ldr	r3, [r7, #4]
 800cad6:	605a      	str	r2, [r3, #4]
  pcb->remote_port = 0;
 800cad8:	687b      	ldr	r3, [r7, #4]
 800cada:	2200      	movs	r2, #0
 800cadc:	829a      	strh	r2, [r3, #20]
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 800cade:	687b      	ldr	r3, [r7, #4]
 800cae0:	7c1b      	ldrb	r3, [r3, #16]
 800cae2:	f023 0304 	bic.w	r3, r3, #4
 800cae6:	b2da      	uxtb	r2, r3
 800cae8:	687b      	ldr	r3, [r7, #4]
 800caea:	741a      	strb	r2, [r3, #16]
}
 800caec:	bf00      	nop
 800caee:	370c      	adds	r7, #12
 800caf0:	46bd      	mov	sp, r7
 800caf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800caf6:	4770      	bx	lr
 800caf8:	0801b568 	.word	0x0801b568

0800cafc <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
 800cafc:	b480      	push	{r7}
 800cafe:	b085      	sub	sp, #20
 800cb00:	af00      	add	r7, sp, #0
 800cb02:	60f8      	str	r0, [r7, #12]
 800cb04:	60b9      	str	r1, [r7, #8]
 800cb06:	607a      	str	r2, [r7, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
 800cb08:	68fb      	ldr	r3, [r7, #12]
 800cb0a:	68ba      	ldr	r2, [r7, #8]
 800cb0c:	619a      	str	r2, [r3, #24]
  pcb->recv_arg = recv_arg;
 800cb0e:	68fb      	ldr	r3, [r7, #12]
 800cb10:	687a      	ldr	r2, [r7, #4]
 800cb12:	61da      	str	r2, [r3, #28]
}
 800cb14:	bf00      	nop
 800cb16:	3714      	adds	r7, #20
 800cb18:	46bd      	mov	sp, r7
 800cb1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb1e:	4770      	bx	lr

0800cb20 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 800cb20:	b580      	push	{r7, lr}
 800cb22:	b082      	sub	sp, #8
 800cb24:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
 800cb26:	2001      	movs	r0, #1
 800cb28:	f7fb faee 	bl	8008108 <memp_malloc>
 800cb2c:	6078      	str	r0, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 800cb2e:	687b      	ldr	r3, [r7, #4]
 800cb30:	2b00      	cmp	r3, #0
 800cb32:	d007      	beq.n	800cb44 <udp_new+0x24>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 800cb34:	2220      	movs	r2, #32
 800cb36:	2100      	movs	r1, #0
 800cb38:	6878      	ldr	r0, [r7, #4]
 800cb3a:	f001 fd9f 	bl	800e67c <memset>
    pcb->ttl = UDP_TTL;
 800cb3e:	687b      	ldr	r3, [r7, #4]
 800cb40:	22ff      	movs	r2, #255	; 0xff
 800cb42:	72da      	strb	r2, [r3, #11]
  }
  return pcb;
 800cb44:	687b      	ldr	r3, [r7, #4]
}
 800cb46:	4618      	mov	r0, r3
 800cb48:	3708      	adds	r7, #8
 800cb4a:	46bd      	mov	sp, r7
 800cb4c:	bd80      	pop	{r7, pc}

0800cb4e <udp_debug_print>:
 *
 * @param udphdr pointer to the udp header in memory.
 */
void
udp_debug_print(struct udp_hdr *udphdr)
{
 800cb4e:	b480      	push	{r7}
 800cb50:	b083      	sub	sp, #12
 800cb52:	af00      	add	r7, sp, #0
 800cb54:	6078      	str	r0, [r7, #4]
                          ntohs(udphdr->src), ntohs(udphdr->dest)));
  LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
  LWIP_DEBUGF(UDP_DEBUG, ("|     %5"U16_F"     |     0x%04"X16_F"    | (len, chksum)\n",
                          ntohs(udphdr->len), ntohs(udphdr->chksum)));
  LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
}
 800cb56:	bf00      	nop
 800cb58:	370c      	adds	r7, #12
 800cb5a:	46bd      	mov	sp, r7
 800cb5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb60:	4770      	bx	lr
	...

0800cb64 <low_level_init>:
 *
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void low_level_init(struct netif *netif)
{
 800cb64:	b580      	push	{r7, lr}
 800cb66:	b084      	sub	sp, #16
 800cb68:	af00      	add	r7, sp, #0
 800cb6a:	6078      	str	r0, [r7, #4]
#ifdef CHECKSUM_BY_HARDWARE
  int i; 
#endif
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 800cb6c:	687b      	ldr	r3, [r7, #4]
 800cb6e:	2206      	movs	r2, #6
 800cb70:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a

  /* set MAC hardware address */
  netif->hwaddr[0] =  MAC_ADDR0;
 800cb74:	687b      	ldr	r3, [r7, #4]
 800cb76:	2202      	movs	r2, #2
 800cb78:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  netif->hwaddr[1] =  MAC_ADDR1;
 800cb7c:	687b      	ldr	r3, [r7, #4]
 800cb7e:	2203      	movs	r2, #3
 800cb80:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  netif->hwaddr[2] =  MAC_ADDR2;
 800cb84:	687b      	ldr	r3, [r7, #4]
 800cb86:	2204      	movs	r2, #4
 800cb88:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  netif->hwaddr[3] =  MAC_ADDR3;
 800cb8c:	687b      	ldr	r3, [r7, #4]
 800cb8e:	2205      	movs	r2, #5
 800cb90:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
  netif->hwaddr[4] =  MAC_ADDR4;
 800cb94:	687b      	ldr	r3, [r7, #4]
 800cb96:	2206      	movs	r2, #6
 800cb98:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  netif->hwaddr[5] =  MAC_ADDR5;
 800cb9c:	687b      	ldr	r3, [r7, #4]
 800cb9e:	2207      	movs	r2, #7
 800cba0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  
  /* initialize MAC address in ethernet MAC */ 
  ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); 
 800cba4:	687b      	ldr	r3, [r7, #4]
 800cba6:	332b      	adds	r3, #43	; 0x2b
 800cba8:	4619      	mov	r1, r3
 800cbaa:	2000      	movs	r0, #0
 800cbac:	f7f6 fbf4 	bl	8003398 <ETH_MACAddressConfig>

  /* maximum transfer unit */
  netif->mtu = 1500;
 800cbb0:	687b      	ldr	r3, [r7, #4]
 800cbb2:	f240 52dc 	movw	r2, #1500	; 0x5dc
 800cbb6:	851a      	strh	r2, [r3, #40]	; 0x28

  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
 800cbb8:	687b      	ldr	r3, [r7, #4]
 800cbba:	2232      	movs	r2, #50	; 0x32
 800cbbc:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31

  /* Initialize Tx Descriptors list: Chain Mode */
  ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 800cbc0:	2202      	movs	r2, #2
 800cbc2:	4910      	ldr	r1, [pc, #64]	; (800cc04 <low_level_init+0xa0>)
 800cbc4:	4810      	ldr	r0, [pc, #64]	; (800cc08 <low_level_init+0xa4>)
 800cbc6:	f7f6 fdd1 	bl	800376c <ETH_DMATxDescChainInit>
  /* Initialize Rx Descriptors list: Chain Mode  */
  ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 800cbca:	2204      	movs	r2, #4
 800cbcc:	490f      	ldr	r1, [pc, #60]	; (800cc0c <low_level_init+0xa8>)
 800cbce:	4810      	ldr	r0, [pc, #64]	; (800cc10 <low_level_init+0xac>)
 800cbd0:	f7f6 fd0e 	bl	80035f0 <ETH_DMARxDescChainInit>
  
#ifdef CHECKSUM_BY_HARDWARE
  /* Enable the TCP, UDP and ICMP checksum insertion for the Tx frames */
  for(i=0; i<ETH_TXBUFNB; i++)
 800cbd4:	2300      	movs	r3, #0
 800cbd6:	60fb      	str	r3, [r7, #12]
 800cbd8:	e00b      	b.n	800cbf2 <low_level_init+0x8e>
    {
      ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
 800cbda:	68fb      	ldr	r3, [r7, #12]
 800cbdc:	015b      	lsls	r3, r3, #5
 800cbde:	4a0a      	ldr	r2, [pc, #40]	; (800cc08 <low_level_init+0xa4>)
 800cbe0:	4413      	add	r3, r2
 800cbe2:	f44f 0140 	mov.w	r1, #12582912	; 0xc00000
 800cbe6:	4618      	mov	r0, r3
 800cbe8:	f7f6 fe0a 	bl	8003800 <ETH_DMATxDescChecksumInsertionConfig>
  for(i=0; i<ETH_TXBUFNB; i++)
 800cbec:	68fb      	ldr	r3, [r7, #12]
 800cbee:	3301      	adds	r3, #1
 800cbf0:	60fb      	str	r3, [r7, #12]
 800cbf2:	68fb      	ldr	r3, [r7, #12]
 800cbf4:	2b01      	cmp	r3, #1
 800cbf6:	ddf0      	ble.n	800cbda <low_level_init+0x76>
#endif

   /* Note: TCP, UDP, ICMP checksum checking for received frame are enabled in DMA config */

  /* Enable MAC and DMA transmission and reception */
  ETH_Start();
 800cbf8:	f7f6 fb80 	bl	80032fc <ETH_Start>

}
 800cbfc:	bf00      	nop
 800cbfe:	3710      	adds	r7, #16
 800cc00:	46bd      	mov	sp, r7
 800cc02:	bd80      	pop	{r7, pc}
 800cc04:	20009630 	.word	0x20009630
 800cc08:	20007d98 	.word	0x20007d98
 800cc0c:	20007dd8 	.word	0x20007dd8
 800cc10:	200095b0 	.word	0x200095b0

0800cc14 <low_level_output>:
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
 800cc14:	b580      	push	{r7, lr}
 800cc16:	b086      	sub	sp, #24
 800cc18:	af00      	add	r7, sp, #0
 800cc1a:	6078      	str	r0, [r7, #4]
 800cc1c:	6039      	str	r1, [r7, #0]
  struct pbuf *q;
  int framelength = 0;
 800cc1e:	2300      	movs	r3, #0
 800cc20:	613b      	str	r3, [r7, #16]
  u8 *buffer =  (u8 *)(DMATxDescToSet->Buffer1Addr);
 800cc22:	4b13      	ldr	r3, [pc, #76]	; (800cc70 <low_level_output+0x5c>)
 800cc24:	681b      	ldr	r3, [r3, #0]
 800cc26:	689b      	ldr	r3, [r3, #8]
 800cc28:	60fb      	str	r3, [r7, #12]
  
  /* copy frame from pbufs to driver buffers */
  for(q = p; q != NULL; q = q->next) 
 800cc2a:	683b      	ldr	r3, [r7, #0]
 800cc2c:	617b      	str	r3, [r7, #20]
 800cc2e:	e012      	b.n	800cc56 <low_level_output+0x42>
  {
    memcpy((u8_t*)&buffer[framelength], q->payload, q->len);
 800cc30:	693b      	ldr	r3, [r7, #16]
 800cc32:	68fa      	ldr	r2, [r7, #12]
 800cc34:	18d0      	adds	r0, r2, r3
 800cc36:	697b      	ldr	r3, [r7, #20]
 800cc38:	6859      	ldr	r1, [r3, #4]
 800cc3a:	697b      	ldr	r3, [r7, #20]
 800cc3c:	895b      	ldrh	r3, [r3, #10]
 800cc3e:	461a      	mov	r2, r3
 800cc40:	f001 fd11 	bl	800e666 <memcpy>
	framelength = framelength + q->len;
 800cc44:	697b      	ldr	r3, [r7, #20]
 800cc46:	895b      	ldrh	r3, [r3, #10]
 800cc48:	461a      	mov	r2, r3
 800cc4a:	693b      	ldr	r3, [r7, #16]
 800cc4c:	4413      	add	r3, r2
 800cc4e:	613b      	str	r3, [r7, #16]
  for(q = p; q != NULL; q = q->next) 
 800cc50:	697b      	ldr	r3, [r7, #20]
 800cc52:	681b      	ldr	r3, [r3, #0]
 800cc54:	617b      	str	r3, [r7, #20]
 800cc56:	697b      	ldr	r3, [r7, #20]
 800cc58:	2b00      	cmp	r3, #0
 800cc5a:	d1e9      	bne.n	800cc30 <low_level_output+0x1c>
  
  /* Note: padding and CRC for transmitted frame 
     are automatically inserted by DMA */

  /* Prepare transmit descriptors to give to DMA*/ 
  ETH_Prepare_Transmit_Descriptors(framelength);
 800cc5c:	693b      	ldr	r3, [r7, #16]
 800cc5e:	b29b      	uxth	r3, r3
 800cc60:	4618      	mov	r0, r3
 800cc62:	f7f6 fc0f 	bl	8003484 <ETH_Prepare_Transmit_Descriptors>

  return ERR_OK;
 800cc66:	2300      	movs	r3, #0
}
 800cc68:	4618      	mov	r0, r3
 800cc6a:	3718      	adds	r7, #24
 800cc6c:	46bd      	mov	sp, r7
 800cc6e:	bd80      	pop	{r7, pc}
 800cc70:	20007d94 	.word	0x20007d94

0800cc74 <low_level_input>:
 * @param netif the lwip network interface structure for this ethernetif
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf * low_level_input(struct netif *netif)
{
 800cc74:	b580      	push	{r7, lr}
 800cc76:	b08c      	sub	sp, #48	; 0x30
 800cc78:	af00      	add	r7, sp, #0
 800cc7a:	6078      	str	r0, [r7, #4]
  struct pbuf *p, *q;
  u16_t len;
  int l =0;
 800cc7c:	2300      	movs	r3, #0
 800cc7e:	62bb      	str	r3, [r7, #40]	; 0x28
  FrameTypeDef frame;
  u8 *buffer;
  uint32_t i=0;
 800cc80:	2300      	movs	r3, #0
 800cc82:	627b      	str	r3, [r7, #36]	; 0x24
  __IO ETH_DMADESCTypeDef *DMARxNextDesc;
  
  
  p = NULL;
 800cc84:	2300      	movs	r3, #0
 800cc86:	61fb      	str	r3, [r7, #28]
  
  /* get received frame */
  frame = ETH_Get_Received_Frame();
 800cc88:	f107 0308 	add.w	r3, r7, #8
 800cc8c:	4618      	mov	r0, r3
 800cc8e:	f7f6 fbb9 	bl	8003404 <ETH_Get_Received_Frame>
  
  /* Obtain the size of the packet and put it into the "len" variable. */
  len = frame.length;
 800cc92:	68bb      	ldr	r3, [r7, #8]
 800cc94:	837b      	strh	r3, [r7, #26]
  buffer = (u8 *)frame.buffer;
 800cc96:	68fb      	ldr	r3, [r7, #12]
 800cc98:	617b      	str	r3, [r7, #20]
  
  /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 800cc9a:	8b7b      	ldrh	r3, [r7, #26]
 800cc9c:	2203      	movs	r2, #3
 800cc9e:	4619      	mov	r1, r3
 800cca0:	2003      	movs	r0, #3
 800cca2:	f7fb fbb5 	bl	8008410 <pbuf_alloc>
 800cca6:	61f8      	str	r0, [r7, #28]
  
  /* copy received frame to pbuf chain */
  if (p != NULL)
 800cca8:	69fb      	ldr	r3, [r7, #28]
 800ccaa:	2b00      	cmp	r3, #0
 800ccac:	d018      	beq.n	800cce0 <low_level_input+0x6c>
  {
    for (q = p; q != NULL; q = q->next)
 800ccae:	69fb      	ldr	r3, [r7, #28]
 800ccb0:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ccb2:	e012      	b.n	800ccda <low_level_input+0x66>
    {
      memcpy((u8_t*)q->payload, (u8_t*)&buffer[l], q->len);
 800ccb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ccb6:	6858      	ldr	r0, [r3, #4]
 800ccb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccba:	697a      	ldr	r2, [r7, #20]
 800ccbc:	18d1      	adds	r1, r2, r3
 800ccbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ccc0:	895b      	ldrh	r3, [r3, #10]
 800ccc2:	461a      	mov	r2, r3
 800ccc4:	f001 fccf 	bl	800e666 <memcpy>
      l = l + q->len;
 800ccc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ccca:	895b      	ldrh	r3, [r3, #10]
 800cccc:	461a      	mov	r2, r3
 800ccce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccd0:	4413      	add	r3, r2
 800ccd2:	62bb      	str	r3, [r7, #40]	; 0x28
    for (q = p; q != NULL; q = q->next)
 800ccd4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ccd6:	681b      	ldr	r3, [r3, #0]
 800ccd8:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ccda:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ccdc:	2b00      	cmp	r3, #0
 800ccde:	d1e9      	bne.n	800ccb4 <low_level_input+0x40>
    }    
  }
  
  /* Release descriptors to DMA */
  /* Check if frame with multiple DMA buffer segments */
  if (DMA_RX_FRAME_infos->Seg_Count > 1)
 800cce0:	4b1e      	ldr	r3, [pc, #120]	; (800cd5c <low_level_input+0xe8>)
 800cce2:	681b      	ldr	r3, [r3, #0]
 800cce4:	689b      	ldr	r3, [r3, #8]
 800cce6:	2b01      	cmp	r3, #1
 800cce8:	d904      	bls.n	800ccf4 <low_level_input+0x80>
  {
    DMARxNextDesc = DMA_RX_FRAME_infos->FS_Rx_Desc;
 800ccea:	4b1c      	ldr	r3, [pc, #112]	; (800cd5c <low_level_input+0xe8>)
 800ccec:	681b      	ldr	r3, [r3, #0]
 800ccee:	681b      	ldr	r3, [r3, #0]
 800ccf0:	623b      	str	r3, [r7, #32]
 800ccf2:	e001      	b.n	800ccf8 <low_level_input+0x84>
  }
  else
  {
    DMARxNextDesc = frame.descriptor;
 800ccf4:	693b      	ldr	r3, [r7, #16]
 800ccf6:	623b      	str	r3, [r7, #32]
  }
  
  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
  for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
 800ccf8:	2300      	movs	r3, #0
 800ccfa:	627b      	str	r3, [r7, #36]	; 0x24
 800ccfc:	e009      	b.n	800cd12 <low_level_input+0x9e>
  {  
    DMARxNextDesc->Status = ETH_DMARxDesc_OWN;
 800ccfe:	6a3b      	ldr	r3, [r7, #32]
 800cd00:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800cd04:	601a      	str	r2, [r3, #0]
    DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
 800cd06:	6a3b      	ldr	r3, [r7, #32]
 800cd08:	68db      	ldr	r3, [r3, #12]
 800cd0a:	623b      	str	r3, [r7, #32]
  for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
 800cd0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cd0e:	3301      	adds	r3, #1
 800cd10:	627b      	str	r3, [r7, #36]	; 0x24
 800cd12:	4b12      	ldr	r3, [pc, #72]	; (800cd5c <low_level_input+0xe8>)
 800cd14:	681b      	ldr	r3, [r3, #0]
 800cd16:	689a      	ldr	r2, [r3, #8]
 800cd18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cd1a:	429a      	cmp	r2, r3
 800cd1c:	d8ef      	bhi.n	800ccfe <low_level_input+0x8a>
  }
  
  /* Clear Segment_Count */
  DMA_RX_FRAME_infos->Seg_Count =0;
 800cd1e:	4b0f      	ldr	r3, [pc, #60]	; (800cd5c <low_level_input+0xe8>)
 800cd20:	681b      	ldr	r3, [r3, #0]
 800cd22:	2200      	movs	r2, #0
 800cd24:	609a      	str	r2, [r3, #8]
  
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
 800cd26:	4b0e      	ldr	r3, [pc, #56]	; (800cd60 <low_level_input+0xec>)
 800cd28:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800cd2c:	3314      	adds	r3, #20
 800cd2e:	681b      	ldr	r3, [r3, #0]
 800cd30:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800cd34:	2b00      	cmp	r3, #0
 800cd36:	d00b      	beq.n	800cd50 <low_level_input+0xdc>
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
 800cd38:	4b09      	ldr	r3, [pc, #36]	; (800cd60 <low_level_input+0xec>)
 800cd3a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800cd3e:	3314      	adds	r3, #20
 800cd40:	2280      	movs	r2, #128	; 0x80
 800cd42:	601a      	str	r2, [r3, #0]
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
 800cd44:	4b06      	ldr	r3, [pc, #24]	; (800cd60 <low_level_input+0xec>)
 800cd46:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800cd4a:	3308      	adds	r3, #8
 800cd4c:	2200      	movs	r2, #0
 800cd4e:	601a      	str	r2, [r3, #0]
  }
  return p;
 800cd50:	69fb      	ldr	r3, [r7, #28]
}
 800cd52:	4618      	mov	r0, r3
 800cd54:	3730      	adds	r7, #48	; 0x30
 800cd56:	46bd      	mov	sp, r7
 800cd58:	bd80      	pop	{r7, pc}
 800cd5a:	bf00      	nop
 800cd5c:	200095ac 	.word	0x200095ac
 800cd60:	40028000 	.word	0x40028000

0800cd64 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
err_t ethernetif_input(struct netif *netif)
{
 800cd64:	b580      	push	{r7, lr}
 800cd66:	b084      	sub	sp, #16
 800cd68:	af00      	add	r7, sp, #0
 800cd6a:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
 800cd6c:	6878      	ldr	r0, [r7, #4]
 800cd6e:	f7ff ff81 	bl	800cc74 <low_level_input>
 800cd72:	60f8      	str	r0, [r7, #12]

  /* no packet could be read, silently ignore this */
  if (p == NULL) return ERR_MEM;
 800cd74:	68fb      	ldr	r3, [r7, #12]
 800cd76:	2b00      	cmp	r3, #0
 800cd78:	d102      	bne.n	800cd80 <ethernetif_input+0x1c>
 800cd7a:	f04f 33ff 	mov.w	r3, #4294967295
 800cd7e:	e011      	b.n	800cda4 <ethernetif_input+0x40>

  /* entry point to the LwIP stack */
  err = netif->input(p, netif);
 800cd80:	687b      	ldr	r3, [r7, #4]
 800cd82:	691b      	ldr	r3, [r3, #16]
 800cd84:	6879      	ldr	r1, [r7, #4]
 800cd86:	68f8      	ldr	r0, [r7, #12]
 800cd88:	4798      	blx	r3
 800cd8a:	4603      	mov	r3, r0
 800cd8c:	72fb      	strb	r3, [r7, #11]
  
  if (err != ERR_OK)
 800cd8e:	f997 300b 	ldrsb.w	r3, [r7, #11]
 800cd92:	2b00      	cmp	r3, #0
 800cd94:	d004      	beq.n	800cda0 <ethernetif_input+0x3c>
  {
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
    pbuf_free(p);
 800cd96:	68f8      	ldr	r0, [r7, #12]
 800cd98:	f7fb fd07 	bl	80087aa <pbuf_free>
    p = NULL;
 800cd9c:	2300      	movs	r3, #0
 800cd9e:	60fb      	str	r3, [r7, #12]
  }
  return err;
 800cda0:	f997 300b 	ldrsb.w	r3, [r7, #11]
}
 800cda4:	4618      	mov	r0, r3
 800cda6:	3710      	adds	r7, #16
 800cda8:	46bd      	mov	sp, r7
 800cdaa:	bd80      	pop	{r7, pc}

0800cdac <ethernetif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ethernetif_init(struct netif *netif)
{
 800cdac:	b580      	push	{r7, lr}
 800cdae:	b082      	sub	sp, #8
 800cdb0:	af00      	add	r7, sp, #0
 800cdb2:	6078      	str	r0, [r7, #4]
#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
 800cdb4:	687b      	ldr	r3, [r7, #4]
 800cdb6:	2273      	movs	r2, #115	; 0x73
 800cdb8:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
  netif->name[1] = IFNAME1;
 800cdbc:	687b      	ldr	r3, [r7, #4]
 800cdbe:	2274      	movs	r2, #116	; 0x74
 800cdc0:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
 800cdc4:	687b      	ldr	r3, [r7, #4]
 800cdc6:	4a06      	ldr	r2, [pc, #24]	; (800cde0 <ethernetif_init+0x34>)
 800cdc8:	615a      	str	r2, [r3, #20]
  netif->linkoutput = low_level_output;
 800cdca:	687b      	ldr	r3, [r7, #4]
 800cdcc:	4a05      	ldr	r2, [pc, #20]	; (800cde4 <ethernetif_init+0x38>)
 800cdce:	619a      	str	r2, [r3, #24]

  /* initialize the hardware */
  low_level_init(netif);
 800cdd0:	6878      	ldr	r0, [r7, #4]
 800cdd2:	f7ff fec7 	bl	800cb64 <low_level_init>

  return ERR_OK;
 800cdd6:	2300      	movs	r3, #0
}
 800cdd8:	4618      	mov	r0, r3
 800cdda:	3708      	adds	r7, #8
 800cddc:	46bd      	mov	sp, r7
 800cdde:	bd80      	pop	{r7, pc}
 800cde0:	0800d6c5 	.word	0x0800d6c5
 800cde4:	0800cc15 	.word	0x0800cc15

0800cde8 <LwIP_Init>:
  * @brief  Initializes the lwIP stack
  * @param  None
  * @retval None
  */
void LwIP_Init(void)
{
 800cde8:	b580      	push	{r7, lr}
 800cdea:	b08e      	sub	sp, #56	; 0x38
 800cdec:	af04      	add	r7, sp, #16
  uint8_t iptab[4];
  uint8_t iptxt[20];
#endif

  /* Initializes the dynamic memory heap defined by MEM_SIZE.*/
  mem_init();
 800cdee:	f7fa ff63 	bl	8007cb8 <mem_init>

  /* Initializes the memory pools defined by MEMP_NUM_x.*/
  memp_init();
 800cdf2:	f7fb f93b 	bl	800806c <memp_init>
#ifdef USE_DHCP
  ipaddr.addr = 0;
  netmask.addr = 0;
  gw.addr = 0;
#else
  IP4_ADDR(&ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3);
 800cdf6:	4815      	ldr	r0, [pc, #84]	; (800ce4c <LwIP_Init+0x64>)
 800cdf8:	f7f9 ff59 	bl	8006cae <htonl>
 800cdfc:	4603      	mov	r3, r0
 800cdfe:	627b      	str	r3, [r7, #36]	; 0x24
  IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3);
 800ce00:	f06f 00ff 	mvn.w	r0, #255	; 0xff
 800ce04:	f7f9 ff53 	bl	8006cae <htonl>
 800ce08:	4603      	mov	r3, r0
 800ce0a:	623b      	str	r3, [r7, #32]
  IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
 800ce0c:	4810      	ldr	r0, [pc, #64]	; (800ce50 <LwIP_Init+0x68>)
 800ce0e:	f7f9 ff4e 	bl	8006cae <htonl>
 800ce12:	4603      	mov	r3, r0
 800ce14:	61fb      	str	r3, [r7, #28]
  Give pointers to cleared ip_addr structures when using DHCP,
  or fill them with sane numbers otherwise. The state pointer may be NULL.

  The init function pointer must point to a initialization function for
  your ethernet netif interface. The following code illustrates it's use.*/
  netif_add(&netif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 800ce16:	f107 001c 	add.w	r0, r7, #28
 800ce1a:	f107 0220 	add.w	r2, r7, #32
 800ce1e:	f107 0124 	add.w	r1, r7, #36	; 0x24
 800ce22:	4b0c      	ldr	r3, [pc, #48]	; (800ce54 <LwIP_Init+0x6c>)
 800ce24:	9302      	str	r3, [sp, #8]
 800ce26:	4b0c      	ldr	r3, [pc, #48]	; (800ce58 <LwIP_Init+0x70>)
 800ce28:	9301      	str	r3, [sp, #4]
 800ce2a:	2300      	movs	r3, #0
 800ce2c:	9300      	str	r3, [sp, #0]
 800ce2e:	4603      	mov	r3, r0
 800ce30:	480a      	ldr	r0, [pc, #40]	; (800ce5c <LwIP_Init+0x74>)
 800ce32:	f7fb f9ab 	bl	800818c <netif_add>

  /*  Registers the default network interface.*/
  netif_set_default(&netif);
 800ce36:	4809      	ldr	r0, [pc, #36]	; (800ce5c <LwIP_Init+0x74>)
 800ce38:	f7fb fa86 	bl	8008348 <netif_set_default>

  /*  When the netif is fully configured this function must be called.*/
  netif_set_up(&netif);
 800ce3c:	4807      	ldr	r0, [pc, #28]	; (800ce5c <LwIP_Init+0x74>)
 800ce3e:	f7fb fa93 	bl	8008368 <netif_set_up>
}
 800ce42:	bf00      	nop
 800ce44:	3728      	adds	r7, #40	; 0x28
 800ce46:	46bd      	mov	sp, r7
 800ce48:	bd80      	pop	{r7, pc}
 800ce4a:	bf00      	nop
 800ce4c:	c0a8010b 	.word	0xc0a8010b
 800ce50:	c0a80101 	.word	0xc0a80101
 800ce54:	0800db9d 	.word	0x0800db9d
 800ce58:	0800cdad 	.word	0x0800cdad
 800ce5c:	2000a344 	.word	0x2000a344

0800ce60 <LwIP_Pkt_Handle>:
  * @brief  Called when a frame is received
  * @param  None
  * @retval None
  */
void LwIP_Pkt_Handle(void)
{
 800ce60:	b580      	push	{r7, lr}
 800ce62:	af00      	add	r7, sp, #0
  /* Read a received packet from the Ethernet buffers and send it to the lwIP for handling */
  ethernetif_input(&netif);
 800ce64:	4802      	ldr	r0, [pc, #8]	; (800ce70 <LwIP_Pkt_Handle+0x10>)
 800ce66:	f7ff ff7d 	bl	800cd64 <ethernetif_input>
}
 800ce6a:	bf00      	nop
 800ce6c:	bd80      	pop	{r7, pc}
 800ce6e:	bf00      	nop
 800ce70:	2000a344 	.word	0x2000a344

0800ce74 <LwIP_Periodic_Handle>:
  * @brief  LwIP periodic tasks
  * @param  localtime the current LocalTime value
  * @retval None
  */
void LwIP_Periodic_Handle(__IO uint32_t localtime)
{
 800ce74:	b580      	push	{r7, lr}
 800ce76:	b082      	sub	sp, #8
 800ce78:	af00      	add	r7, sp, #0
 800ce7a:	6078      	str	r0, [r7, #4]
#if LWIP_TCP
  /* TCP periodic process every 250 ms */
  if (localtime - TCPTimer >= TCP_TMR_INTERVAL)
 800ce7c:	687a      	ldr	r2, [r7, #4]
 800ce7e:	4b0d      	ldr	r3, [pc, #52]	; (800ceb4 <LwIP_Periodic_Handle+0x40>)
 800ce80:	681b      	ldr	r3, [r3, #0]
 800ce82:	1ad3      	subs	r3, r2, r3
 800ce84:	2bf9      	cmp	r3, #249	; 0xf9
 800ce86:	d904      	bls.n	800ce92 <LwIP_Periodic_Handle+0x1e>
  {
    TCPTimer =  localtime;
 800ce88:	687b      	ldr	r3, [r7, #4]
 800ce8a:	4a0a      	ldr	r2, [pc, #40]	; (800ceb4 <LwIP_Periodic_Handle+0x40>)
 800ce8c:	6013      	str	r3, [r2, #0]
    tcp_tmr();
 800ce8e:	f7fb fe7d 	bl	8008b8c <tcp_tmr>
  }
#endif
  
  /* ARP periodic process every 5s */
  if ((localtime - ARPTimer) >= ARP_TMR_INTERVAL)
 800ce92:	687a      	ldr	r2, [r7, #4]
 800ce94:	4b08      	ldr	r3, [pc, #32]	; (800ceb8 <LwIP_Periodic_Handle+0x44>)
 800ce96:	681b      	ldr	r3, [r3, #0]
 800ce98:	1ad3      	subs	r3, r2, r3
 800ce9a:	f241 3287 	movw	r2, #4999	; 0x1387
 800ce9e:	4293      	cmp	r3, r2
 800cea0:	d904      	bls.n	800ceac <LwIP_Periodic_Handle+0x38>
  {
    ARPTimer =  localtime;
 800cea2:	687b      	ldr	r3, [r7, #4]
 800cea4:	4a04      	ldr	r2, [pc, #16]	; (800ceb8 <LwIP_Periodic_Handle+0x44>)
 800cea6:	6013      	str	r3, [r2, #0]
    etharp_tmr();
 800cea8:	f000 f822 	bl	800cef0 <etharp_tmr>
    DHCPcoarseTimer =  localtime;
    dhcp_coarse_tmr();
  }
  
#endif
}
 800ceac:	bf00      	nop
 800ceae:	3708      	adds	r7, #8
 800ceb0:	46bd      	mov	sp, r7
 800ceb2:	bd80      	pop	{r7, pc}
 800ceb4:	20007c68 	.word	0x20007c68
 800ceb8:	20007c6c 	.word	0x20007c6c

0800cebc <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
 800cebc:	b580      	push	{r7, lr}
 800cebe:	b084      	sub	sp, #16
 800cec0:	af00      	add	r7, sp, #0
 800cec2:	6078      	str	r0, [r7, #4]
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 800cec4:	e00d      	b.n	800cee2 <free_etharp_q+0x26>
    r = q;
 800cec6:	687b      	ldr	r3, [r7, #4]
 800cec8:	60fb      	str	r3, [r7, #12]
    q = q->next;
 800ceca:	687b      	ldr	r3, [r7, #4]
 800cecc:	681b      	ldr	r3, [r3, #0]
 800cece:	607b      	str	r3, [r7, #4]
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
 800ced0:	68fb      	ldr	r3, [r7, #12]
 800ced2:	685b      	ldr	r3, [r3, #4]
 800ced4:	4618      	mov	r0, r3
 800ced6:	f7fb fc68 	bl	80087aa <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
 800ceda:	68f9      	ldr	r1, [r7, #12]
 800cedc:	2006      	movs	r0, #6
 800cede:	f7fb f935 	bl	800814c <memp_free>
  while (q) {
 800cee2:	687b      	ldr	r3, [r7, #4]
 800cee4:	2b00      	cmp	r3, #0
 800cee6:	d1ee      	bne.n	800cec6 <free_etharp_q+0xa>
  }
}
 800cee8:	bf00      	nop
 800ceea:	3710      	adds	r7, #16
 800ceec:	46bd      	mov	sp, r7
 800ceee:	bd80      	pop	{r7, pc}

0800cef0 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 800cef0:	b580      	push	{r7, lr}
 800cef2:	b082      	sub	sp, #8
 800cef4:	af00      	add	r7, sp, #0
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800cef6:	2300      	movs	r3, #0
 800cef8:	71fb      	strb	r3, [r7, #7]
 800cefa:	e06f      	b.n	800cfdc <etharp_tmr+0xec>
    arp_table[i].ctime++;
 800cefc:	79fa      	ldrb	r2, [r7, #7]
 800cefe:	493b      	ldr	r1, [pc, #236]	; (800cfec <etharp_tmr+0xfc>)
 800cf00:	4613      	mov	r3, r2
 800cf02:	009b      	lsls	r3, r3, #2
 800cf04:	4413      	add	r3, r2
 800cf06:	009b      	lsls	r3, r3, #2
 800cf08:	440b      	add	r3, r1
 800cf0a:	330f      	adds	r3, #15
 800cf0c:	781b      	ldrb	r3, [r3, #0]
 800cf0e:	3301      	adds	r3, #1
 800cf10:	b2d8      	uxtb	r0, r3
 800cf12:	4936      	ldr	r1, [pc, #216]	; (800cfec <etharp_tmr+0xfc>)
 800cf14:	4613      	mov	r3, r2
 800cf16:	009b      	lsls	r3, r3, #2
 800cf18:	4413      	add	r3, r2
 800cf1a:	009b      	lsls	r3, r3, #2
 800cf1c:	440b      	add	r3, r1
 800cf1e:	330f      	adds	r3, #15
 800cf20:	4602      	mov	r2, r0
 800cf22:	701a      	strb	r2, [r3, #0]
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
 800cf24:	79fa      	ldrb	r2, [r7, #7]
 800cf26:	4931      	ldr	r1, [pc, #196]	; (800cfec <etharp_tmr+0xfc>)
 800cf28:	4613      	mov	r3, r2
 800cf2a:	009b      	lsls	r3, r3, #2
 800cf2c:	4413      	add	r3, r2
 800cf2e:	009b      	lsls	r3, r3, #2
 800cf30:	440b      	add	r3, r1
 800cf32:	330e      	adds	r3, #14
 800cf34:	781b      	ldrb	r3, [r3, #0]
 800cf36:	2b02      	cmp	r3, #2
 800cf38:	d10a      	bne.n	800cf50 <etharp_tmr+0x60>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
 800cf3a:	79fa      	ldrb	r2, [r7, #7]
 800cf3c:	492b      	ldr	r1, [pc, #172]	; (800cfec <etharp_tmr+0xfc>)
 800cf3e:	4613      	mov	r3, r2
 800cf40:	009b      	lsls	r3, r3, #2
 800cf42:	4413      	add	r3, r2
 800cf44:	009b      	lsls	r3, r3, #2
 800cf46:	440b      	add	r3, r1
 800cf48:	330f      	adds	r3, #15
 800cf4a:	781b      	ldrb	r3, [r3, #0]
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
 800cf4c:	2bef      	cmp	r3, #239	; 0xef
 800cf4e:	d815      	bhi.n	800cf7c <etharp_tmr+0x8c>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 800cf50:	79fa      	ldrb	r2, [r7, #7]
 800cf52:	4926      	ldr	r1, [pc, #152]	; (800cfec <etharp_tmr+0xfc>)
 800cf54:	4613      	mov	r3, r2
 800cf56:	009b      	lsls	r3, r3, #2
 800cf58:	4413      	add	r3, r2
 800cf5a:	009b      	lsls	r3, r3, #2
 800cf5c:	440b      	add	r3, r1
 800cf5e:	330e      	adds	r3, #14
 800cf60:	781b      	ldrb	r3, [r3, #0]
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
 800cf62:	2b01      	cmp	r3, #1
 800cf64:	d132      	bne.n	800cfcc <etharp_tmr+0xdc>
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
 800cf66:	79fa      	ldrb	r2, [r7, #7]
 800cf68:	4920      	ldr	r1, [pc, #128]	; (800cfec <etharp_tmr+0xfc>)
 800cf6a:	4613      	mov	r3, r2
 800cf6c:	009b      	lsls	r3, r3, #2
 800cf6e:	4413      	add	r3, r2
 800cf70:	009b      	lsls	r3, r3, #2
 800cf72:	440b      	add	r3, r1
 800cf74:	330f      	adds	r3, #15
 800cf76:	781b      	ldrb	r3, [r3, #0]
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 800cf78:	2b01      	cmp	r3, #1
 800cf7a:	d927      	bls.n	800cfcc <etharp_tmr+0xdc>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
 800cf7c:	79fa      	ldrb	r2, [r7, #7]
 800cf7e:	491b      	ldr	r1, [pc, #108]	; (800cfec <etharp_tmr+0xfc>)
 800cf80:	4613      	mov	r3, r2
 800cf82:	009b      	lsls	r3, r3, #2
 800cf84:	4413      	add	r3, r2
 800cf86:	009b      	lsls	r3, r3, #2
 800cf88:	440b      	add	r3, r1
 800cf8a:	681b      	ldr	r3, [r3, #0]
 800cf8c:	2b00      	cmp	r3, #0
 800cf8e:	d013      	beq.n	800cfb8 <etharp_tmr+0xc8>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
 800cf90:	79fa      	ldrb	r2, [r7, #7]
 800cf92:	4916      	ldr	r1, [pc, #88]	; (800cfec <etharp_tmr+0xfc>)
 800cf94:	4613      	mov	r3, r2
 800cf96:	009b      	lsls	r3, r3, #2
 800cf98:	4413      	add	r3, r2
 800cf9a:	009b      	lsls	r3, r3, #2
 800cf9c:	440b      	add	r3, r1
 800cf9e:	681b      	ldr	r3, [r3, #0]
 800cfa0:	4618      	mov	r0, r3
 800cfa2:	f7ff ff8b 	bl	800cebc <free_etharp_q>
        arp_table[i].q = NULL;
 800cfa6:	79fa      	ldrb	r2, [r7, #7]
 800cfa8:	4910      	ldr	r1, [pc, #64]	; (800cfec <etharp_tmr+0xfc>)
 800cfaa:	4613      	mov	r3, r2
 800cfac:	009b      	lsls	r3, r3, #2
 800cfae:	4413      	add	r3, r2
 800cfb0:	009b      	lsls	r3, r3, #2
 800cfb2:	440b      	add	r3, r1
 800cfb4:	2200      	movs	r2, #0
 800cfb6:	601a      	str	r2, [r3, #0]
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
 800cfb8:	79fa      	ldrb	r2, [r7, #7]
 800cfba:	490c      	ldr	r1, [pc, #48]	; (800cfec <etharp_tmr+0xfc>)
 800cfbc:	4613      	mov	r3, r2
 800cfbe:	009b      	lsls	r3, r3, #2
 800cfc0:	4413      	add	r3, r2
 800cfc2:	009b      	lsls	r3, r3, #2
 800cfc4:	440b      	add	r3, r1
 800cfc6:	330e      	adds	r3, #14
 800cfc8:	2200      	movs	r2, #0
 800cfca:	701a      	strb	r2, [r3, #0]
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
 800cfcc:	79fa      	ldrb	r2, [r7, #7]
 800cfce:	4613      	mov	r3, r2
 800cfd0:	009b      	lsls	r3, r3, #2
 800cfd2:	4413      	add	r3, r2
 800cfd4:	009b      	lsls	r3, r3, #2
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800cfd6:	79fb      	ldrb	r3, [r7, #7]
 800cfd8:	3301      	adds	r3, #1
 800cfda:	71fb      	strb	r3, [r7, #7]
 800cfdc:	79fb      	ldrb	r3, [r7, #7]
 800cfde:	2b09      	cmp	r3, #9
 800cfe0:	d98c      	bls.n	800cefc <etharp_tmr+0xc>
        /* resend an ARP query here? */
    }
#endif
  }
}
 800cfe2:	bf00      	nop
 800cfe4:	3708      	adds	r7, #8
 800cfe6:	46bd      	mov	sp, r7
 800cfe8:	bd80      	pop	{r7, pc}
 800cfea:	bf00      	nop
 800cfec:	20007c70 	.word	0x20007c70

0800cff0 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
 800cff0:	b580      	push	{r7, lr}
 800cff2:	b084      	sub	sp, #16
 800cff4:	af00      	add	r7, sp, #0
 800cff6:	6078      	str	r0, [r7, #4]
 800cff8:	460b      	mov	r3, r1
 800cffa:	70fb      	strb	r3, [r7, #3]
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 800cffc:	230a      	movs	r3, #10
 800cffe:	73fb      	strb	r3, [r7, #15]
 800d000:	230a      	movs	r3, #10
 800d002:	73bb      	strb	r3, [r7, #14]
  s8_t empty = ARP_TABLE_SIZE;
 800d004:	230a      	movs	r3, #10
 800d006:	737b      	strb	r3, [r7, #13]
  u8_t i = 0, age_pending = 0, age_stable = 0;
 800d008:	2300      	movs	r3, #0
 800d00a:	733b      	strb	r3, [r7, #12]
 800d00c:	2300      	movs	r3, #0
 800d00e:	72fb      	strb	r3, [r7, #11]
 800d010:	2300      	movs	r3, #0
 800d012:	72bb      	strb	r3, [r7, #10]
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 800d014:	230a      	movs	r3, #10
 800d016:	727b      	strb	r3, [r7, #9]
  /* its age */
  u8_t age_queue = 0;
 800d018:	2300      	movs	r3, #0
 800d01a:	723b      	strb	r3, [r7, #8]
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
 800d01c:	687b      	ldr	r3, [r7, #4]
 800d01e:	2b00      	cmp	r3, #0
 800d020:	d01f      	beq.n	800d062 <find_entry+0x72>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
 800d022:	4ba8      	ldr	r3, [pc, #672]	; (800d2c4 <find_entry+0x2d4>)
 800d024:	781b      	ldrb	r3, [r3, #0]
 800d026:	4619      	mov	r1, r3
 800d028:	4aa7      	ldr	r2, [pc, #668]	; (800d2c8 <find_entry+0x2d8>)
 800d02a:	460b      	mov	r3, r1
 800d02c:	009b      	lsls	r3, r3, #2
 800d02e:	440b      	add	r3, r1
 800d030:	009b      	lsls	r3, r3, #2
 800d032:	4413      	add	r3, r2
 800d034:	330e      	adds	r3, #14
 800d036:	781b      	ldrb	r3, [r3, #0]
 800d038:	2b02      	cmp	r3, #2
 800d03a:	d112      	bne.n	800d062 <find_entry+0x72>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
 800d03c:	687b      	ldr	r3, [r7, #4]
 800d03e:	681a      	ldr	r2, [r3, #0]
 800d040:	4ba0      	ldr	r3, [pc, #640]	; (800d2c4 <find_entry+0x2d4>)
 800d042:	781b      	ldrb	r3, [r3, #0]
 800d044:	4618      	mov	r0, r3
 800d046:	49a0      	ldr	r1, [pc, #640]	; (800d2c8 <find_entry+0x2d8>)
 800d048:	4603      	mov	r3, r0
 800d04a:	009b      	lsls	r3, r3, #2
 800d04c:	4403      	add	r3, r0
 800d04e:	009b      	lsls	r3, r3, #2
 800d050:	440b      	add	r3, r1
 800d052:	3304      	adds	r3, #4
 800d054:	681b      	ldr	r3, [r3, #0]
 800d056:	429a      	cmp	r2, r3
 800d058:	d103      	bne.n	800d062 <find_entry+0x72>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
 800d05a:	4b9a      	ldr	r3, [pc, #616]	; (800d2c4 <find_entry+0x2d4>)
 800d05c:	781b      	ldrb	r3, [r3, #0]
 800d05e:	b25b      	sxtb	r3, r3
 800d060:	e12b      	b.n	800d2ba <find_entry+0x2ca>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800d062:	2300      	movs	r3, #0
 800d064:	733b      	strb	r3, [r7, #12]
 800d066:	e0aa      	b.n	800d1be <find_entry+0x1ce>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
 800d068:	f997 300d 	ldrsb.w	r3, [r7, #13]
 800d06c:	2b0a      	cmp	r3, #10
 800d06e:	d10d      	bne.n	800d08c <find_entry+0x9c>
 800d070:	7b3a      	ldrb	r2, [r7, #12]
 800d072:	4995      	ldr	r1, [pc, #596]	; (800d2c8 <find_entry+0x2d8>)
 800d074:	4613      	mov	r3, r2
 800d076:	009b      	lsls	r3, r3, #2
 800d078:	4413      	add	r3, r2
 800d07a:	009b      	lsls	r3, r3, #2
 800d07c:	440b      	add	r3, r1
 800d07e:	330e      	adds	r3, #14
 800d080:	781b      	ldrb	r3, [r3, #0]
 800d082:	2b00      	cmp	r3, #0
 800d084:	d102      	bne.n	800d08c <find_entry+0x9c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800d086:	7b3b      	ldrb	r3, [r7, #12]
 800d088:	737b      	strb	r3, [r7, #13]
 800d08a:	e095      	b.n	800d1b8 <find_entry+0x1c8>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 800d08c:	7b3a      	ldrb	r2, [r7, #12]
 800d08e:	498e      	ldr	r1, [pc, #568]	; (800d2c8 <find_entry+0x2d8>)
 800d090:	4613      	mov	r3, r2
 800d092:	009b      	lsls	r3, r3, #2
 800d094:	4413      	add	r3, r2
 800d096:	009b      	lsls	r3, r3, #2
 800d098:	440b      	add	r3, r1
 800d09a:	330e      	adds	r3, #14
 800d09c:	781b      	ldrb	r3, [r3, #0]
 800d09e:	2b01      	cmp	r3, #1
 800d0a0:	d151      	bne.n	800d146 <find_entry+0x156>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 800d0a2:	687b      	ldr	r3, [r7, #4]
 800d0a4:	2b00      	cmp	r3, #0
 800d0a6:	d012      	beq.n	800d0ce <find_entry+0xde>
 800d0a8:	687b      	ldr	r3, [r7, #4]
 800d0aa:	6819      	ldr	r1, [r3, #0]
 800d0ac:	7b3a      	ldrb	r2, [r7, #12]
 800d0ae:	4886      	ldr	r0, [pc, #536]	; (800d2c8 <find_entry+0x2d8>)
 800d0b0:	4613      	mov	r3, r2
 800d0b2:	009b      	lsls	r3, r3, #2
 800d0b4:	4413      	add	r3, r2
 800d0b6:	009b      	lsls	r3, r3, #2
 800d0b8:	4403      	add	r3, r0
 800d0ba:	3304      	adds	r3, #4
 800d0bc:	681b      	ldr	r3, [r3, #0]
 800d0be:	4299      	cmp	r1, r3
 800d0c0:	d105      	bne.n	800d0ce <find_entry+0xde>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
 800d0c2:	4a80      	ldr	r2, [pc, #512]	; (800d2c4 <find_entry+0x2d4>)
 800d0c4:	7b3b      	ldrb	r3, [r7, #12]
 800d0c6:	7013      	strb	r3, [r2, #0]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
 800d0c8:	f997 300c 	ldrsb.w	r3, [r7, #12]
 800d0cc:	e0f5      	b.n	800d2ba <find_entry+0x2ca>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
 800d0ce:	7b3a      	ldrb	r2, [r7, #12]
 800d0d0:	497d      	ldr	r1, [pc, #500]	; (800d2c8 <find_entry+0x2d8>)
 800d0d2:	4613      	mov	r3, r2
 800d0d4:	009b      	lsls	r3, r3, #2
 800d0d6:	4413      	add	r3, r2
 800d0d8:	009b      	lsls	r3, r3, #2
 800d0da:	440b      	add	r3, r1
 800d0dc:	681b      	ldr	r3, [r3, #0]
 800d0de:	2b00      	cmp	r3, #0
 800d0e0:	d018      	beq.n	800d114 <find_entry+0x124>
        if (arp_table[i].ctime >= age_queue) {
 800d0e2:	7b3a      	ldrb	r2, [r7, #12]
 800d0e4:	4978      	ldr	r1, [pc, #480]	; (800d2c8 <find_entry+0x2d8>)
 800d0e6:	4613      	mov	r3, r2
 800d0e8:	009b      	lsls	r3, r3, #2
 800d0ea:	4413      	add	r3, r2
 800d0ec:	009b      	lsls	r3, r3, #2
 800d0ee:	440b      	add	r3, r1
 800d0f0:	330f      	adds	r3, #15
 800d0f2:	781b      	ldrb	r3, [r3, #0]
 800d0f4:	7a3a      	ldrb	r2, [r7, #8]
 800d0f6:	429a      	cmp	r2, r3
 800d0f8:	d85e      	bhi.n	800d1b8 <find_entry+0x1c8>
          old_queue = i;
 800d0fa:	7b3b      	ldrb	r3, [r7, #12]
 800d0fc:	727b      	strb	r3, [r7, #9]
          age_queue = arp_table[i].ctime;
 800d0fe:	7b3a      	ldrb	r2, [r7, #12]
 800d100:	4971      	ldr	r1, [pc, #452]	; (800d2c8 <find_entry+0x2d8>)
 800d102:	4613      	mov	r3, r2
 800d104:	009b      	lsls	r3, r3, #2
 800d106:	4413      	add	r3, r2
 800d108:	009b      	lsls	r3, r3, #2
 800d10a:	440b      	add	r3, r1
 800d10c:	330f      	adds	r3, #15
 800d10e:	781b      	ldrb	r3, [r3, #0]
 800d110:	723b      	strb	r3, [r7, #8]
 800d112:	e051      	b.n	800d1b8 <find_entry+0x1c8>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
 800d114:	7b3a      	ldrb	r2, [r7, #12]
 800d116:	496c      	ldr	r1, [pc, #432]	; (800d2c8 <find_entry+0x2d8>)
 800d118:	4613      	mov	r3, r2
 800d11a:	009b      	lsls	r3, r3, #2
 800d11c:	4413      	add	r3, r2
 800d11e:	009b      	lsls	r3, r3, #2
 800d120:	440b      	add	r3, r1
 800d122:	330f      	adds	r3, #15
 800d124:	781b      	ldrb	r3, [r3, #0]
 800d126:	7afa      	ldrb	r2, [r7, #11]
 800d128:	429a      	cmp	r2, r3
 800d12a:	d845      	bhi.n	800d1b8 <find_entry+0x1c8>
          old_pending = i;
 800d12c:	7b3b      	ldrb	r3, [r7, #12]
 800d12e:	73fb      	strb	r3, [r7, #15]
          age_pending = arp_table[i].ctime;
 800d130:	7b3a      	ldrb	r2, [r7, #12]
 800d132:	4965      	ldr	r1, [pc, #404]	; (800d2c8 <find_entry+0x2d8>)
 800d134:	4613      	mov	r3, r2
 800d136:	009b      	lsls	r3, r3, #2
 800d138:	4413      	add	r3, r2
 800d13a:	009b      	lsls	r3, r3, #2
 800d13c:	440b      	add	r3, r1
 800d13e:	330f      	adds	r3, #15
 800d140:	781b      	ldrb	r3, [r3, #0]
 800d142:	72fb      	strb	r3, [r7, #11]
 800d144:	e038      	b.n	800d1b8 <find_entry+0x1c8>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
 800d146:	7b3a      	ldrb	r2, [r7, #12]
 800d148:	495f      	ldr	r1, [pc, #380]	; (800d2c8 <find_entry+0x2d8>)
 800d14a:	4613      	mov	r3, r2
 800d14c:	009b      	lsls	r3, r3, #2
 800d14e:	4413      	add	r3, r2
 800d150:	009b      	lsls	r3, r3, #2
 800d152:	440b      	add	r3, r1
 800d154:	330e      	adds	r3, #14
 800d156:	781b      	ldrb	r3, [r3, #0]
 800d158:	2b02      	cmp	r3, #2
 800d15a:	d12d      	bne.n	800d1b8 <find_entry+0x1c8>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 800d15c:	687b      	ldr	r3, [r7, #4]
 800d15e:	2b00      	cmp	r3, #0
 800d160:	d012      	beq.n	800d188 <find_entry+0x198>
 800d162:	687b      	ldr	r3, [r7, #4]
 800d164:	6819      	ldr	r1, [r3, #0]
 800d166:	7b3a      	ldrb	r2, [r7, #12]
 800d168:	4857      	ldr	r0, [pc, #348]	; (800d2c8 <find_entry+0x2d8>)
 800d16a:	4613      	mov	r3, r2
 800d16c:	009b      	lsls	r3, r3, #2
 800d16e:	4413      	add	r3, r2
 800d170:	009b      	lsls	r3, r3, #2
 800d172:	4403      	add	r3, r0
 800d174:	3304      	adds	r3, #4
 800d176:	681b      	ldr	r3, [r3, #0]
 800d178:	4299      	cmp	r1, r3
 800d17a:	d105      	bne.n	800d188 <find_entry+0x198>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
 800d17c:	4a51      	ldr	r2, [pc, #324]	; (800d2c4 <find_entry+0x2d4>)
 800d17e:	7b3b      	ldrb	r3, [r7, #12]
 800d180:	7013      	strb	r3, [r2, #0]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
 800d182:	f997 300c 	ldrsb.w	r3, [r7, #12]
 800d186:	e098      	b.n	800d2ba <find_entry+0x2ca>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
 800d188:	7b3a      	ldrb	r2, [r7, #12]
 800d18a:	494f      	ldr	r1, [pc, #316]	; (800d2c8 <find_entry+0x2d8>)
 800d18c:	4613      	mov	r3, r2
 800d18e:	009b      	lsls	r3, r3, #2
 800d190:	4413      	add	r3, r2
 800d192:	009b      	lsls	r3, r3, #2
 800d194:	440b      	add	r3, r1
 800d196:	330f      	adds	r3, #15
 800d198:	781b      	ldrb	r3, [r3, #0]
 800d19a:	7aba      	ldrb	r2, [r7, #10]
 800d19c:	429a      	cmp	r2, r3
 800d19e:	d80b      	bhi.n	800d1b8 <find_entry+0x1c8>
        old_stable = i;
 800d1a0:	7b3b      	ldrb	r3, [r7, #12]
 800d1a2:	73bb      	strb	r3, [r7, #14]
        age_stable = arp_table[i].ctime;
 800d1a4:	7b3a      	ldrb	r2, [r7, #12]
 800d1a6:	4948      	ldr	r1, [pc, #288]	; (800d2c8 <find_entry+0x2d8>)
 800d1a8:	4613      	mov	r3, r2
 800d1aa:	009b      	lsls	r3, r3, #2
 800d1ac:	4413      	add	r3, r2
 800d1ae:	009b      	lsls	r3, r3, #2
 800d1b0:	440b      	add	r3, r1
 800d1b2:	330f      	adds	r3, #15
 800d1b4:	781b      	ldrb	r3, [r3, #0]
 800d1b6:	72bb      	strb	r3, [r7, #10]
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800d1b8:	7b3b      	ldrb	r3, [r7, #12]
 800d1ba:	3301      	adds	r3, #1
 800d1bc:	733b      	strb	r3, [r7, #12]
 800d1be:	7b3b      	ldrb	r3, [r7, #12]
 800d1c0:	2b09      	cmp	r3, #9
 800d1c2:	f67f af51 	bls.w	800d068 <find_entry+0x78>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
 800d1c6:	f997 300d 	ldrsb.w	r3, [r7, #13]
 800d1ca:	2b0a      	cmp	r3, #10
 800d1cc:	d104      	bne.n	800d1d8 <find_entry+0x1e8>
 800d1ce:	78fb      	ldrb	r3, [r7, #3]
 800d1d0:	f003 0301 	and.w	r3, r3, #1
 800d1d4:	2b00      	cmp	r3, #0
 800d1d6:	d004      	beq.n	800d1e2 <find_entry+0x1f2>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
 800d1d8:	78fb      	ldrb	r3, [r7, #3]
 800d1da:	f003 0302 	and.w	r3, r3, #2
 800d1de:	2b00      	cmp	r3, #0
 800d1e0:	d002      	beq.n	800d1e8 <find_entry+0x1f8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
 800d1e2:	f04f 33ff 	mov.w	r3, #4294967295
 800d1e6:	e068      	b.n	800d2ba <find_entry+0x2ca>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 800d1e8:	f997 300d 	ldrsb.w	r3, [r7, #13]
 800d1ec:	2b09      	cmp	r3, #9
 800d1ee:	dc02      	bgt.n	800d1f6 <find_entry+0x206>
    i = empty;
 800d1f0:	7b7b      	ldrb	r3, [r7, #13]
 800d1f2:	733b      	strb	r3, [r7, #12]
 800d1f4:	e030      	b.n	800d258 <find_entry+0x268>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
 800d1f6:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800d1fa:	2b09      	cmp	r3, #9
 800d1fc:	dc07      	bgt.n	800d20e <find_entry+0x21e>
    /* recycle oldest stable*/
    i = old_stable;
 800d1fe:	7bbb      	ldrb	r3, [r7, #14]
 800d200:	733b      	strb	r3, [r7, #12]
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 800d202:	7b3a      	ldrb	r2, [r7, #12]
 800d204:	4613      	mov	r3, r2
 800d206:	009b      	lsls	r3, r3, #2
 800d208:	4413      	add	r3, r2
 800d20a:	009b      	lsls	r3, r3, #2
 800d20c:	e024      	b.n	800d258 <find_entry+0x268>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
 800d20e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800d212:	2b09      	cmp	r3, #9
 800d214:	dc02      	bgt.n	800d21c <find_entry+0x22c>
    /* recycle oldest pending */
    i = old_pending;
 800d216:	7bfb      	ldrb	r3, [r7, #15]
 800d218:	733b      	strb	r3, [r7, #12]
 800d21a:	e01d      	b.n	800d258 <find_entry+0x268>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
 800d21c:	f997 3009 	ldrsb.w	r3, [r7, #9]
 800d220:	2b09      	cmp	r3, #9
 800d222:	dc16      	bgt.n	800d252 <find_entry+0x262>
    /* recycle oldest pending */
    i = old_queue;
 800d224:	7a7b      	ldrb	r3, [r7, #9]
 800d226:	733b      	strb	r3, [r7, #12]
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 800d228:	7b3a      	ldrb	r2, [r7, #12]
 800d22a:	4927      	ldr	r1, [pc, #156]	; (800d2c8 <find_entry+0x2d8>)
 800d22c:	4613      	mov	r3, r2
 800d22e:	009b      	lsls	r3, r3, #2
 800d230:	4413      	add	r3, r2
 800d232:	009b      	lsls	r3, r3, #2
 800d234:	440b      	add	r3, r1
 800d236:	681b      	ldr	r3, [r3, #0]
 800d238:	4618      	mov	r0, r3
 800d23a:	f7ff fe3f 	bl	800cebc <free_etharp_q>
    arp_table[i].q = NULL;
 800d23e:	7b3a      	ldrb	r2, [r7, #12]
 800d240:	4921      	ldr	r1, [pc, #132]	; (800d2c8 <find_entry+0x2d8>)
 800d242:	4613      	mov	r3, r2
 800d244:	009b      	lsls	r3, r3, #2
 800d246:	4413      	add	r3, r2
 800d248:	009b      	lsls	r3, r3, #2
 800d24a:	440b      	add	r3, r1
 800d24c:	2200      	movs	r2, #0
 800d24e:	601a      	str	r2, [r3, #0]
 800d250:	e002      	b.n	800d258 <find_entry+0x268>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
 800d252:	f04f 33ff 	mov.w	r3, #4294967295
 800d256:	e030      	b.n	800d2ba <find_entry+0x2ca>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
 800d258:	7b3a      	ldrb	r2, [r7, #12]
 800d25a:	4613      	mov	r3, r2
 800d25c:	009b      	lsls	r3, r3, #2
 800d25e:	4413      	add	r3, r2
 800d260:	009b      	lsls	r3, r3, #2
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800d262:	7b3a      	ldrb	r2, [r7, #12]
 800d264:	4918      	ldr	r1, [pc, #96]	; (800d2c8 <find_entry+0x2d8>)
 800d266:	4613      	mov	r3, r2
 800d268:	009b      	lsls	r3, r3, #2
 800d26a:	4413      	add	r3, r2
 800d26c:	009b      	lsls	r3, r3, #2
 800d26e:	440b      	add	r3, r1
 800d270:	330e      	adds	r3, #14
 800d272:	2200      	movs	r2, #0
 800d274:	701a      	strb	r2, [r3, #0]

  /* IP address given? */
  if (ipaddr != NULL) {
 800d276:	687b      	ldr	r3, [r7, #4]
 800d278:	2b00      	cmp	r3, #0
 800d27a:	d00f      	beq.n	800d29c <find_entry+0x2ac>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
 800d27c:	7b39      	ldrb	r1, [r7, #12]
 800d27e:	687b      	ldr	r3, [r7, #4]
 800d280:	2b00      	cmp	r3, #0
 800d282:	d002      	beq.n	800d28a <find_entry+0x29a>
 800d284:	687b      	ldr	r3, [r7, #4]
 800d286:	681a      	ldr	r2, [r3, #0]
 800d288:	e000      	b.n	800d28c <find_entry+0x29c>
 800d28a:	2200      	movs	r2, #0
 800d28c:	480e      	ldr	r0, [pc, #56]	; (800d2c8 <find_entry+0x2d8>)
 800d28e:	460b      	mov	r3, r1
 800d290:	009b      	lsls	r3, r3, #2
 800d292:	440b      	add	r3, r1
 800d294:	009b      	lsls	r3, r3, #2
 800d296:	4403      	add	r3, r0
 800d298:	3304      	adds	r3, #4
 800d29a:	601a      	str	r2, [r3, #0]
  }
  arp_table[i].ctime = 0;
 800d29c:	7b3a      	ldrb	r2, [r7, #12]
 800d29e:	490a      	ldr	r1, [pc, #40]	; (800d2c8 <find_entry+0x2d8>)
 800d2a0:	4613      	mov	r3, r2
 800d2a2:	009b      	lsls	r3, r3, #2
 800d2a4:	4413      	add	r3, r2
 800d2a6:	009b      	lsls	r3, r3, #2
 800d2a8:	440b      	add	r3, r1
 800d2aa:	330f      	adds	r3, #15
 800d2ac:	2200      	movs	r2, #0
 800d2ae:	701a      	strb	r2, [r3, #0]
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
 800d2b0:	4a04      	ldr	r2, [pc, #16]	; (800d2c4 <find_entry+0x2d4>)
 800d2b2:	7b3b      	ldrb	r3, [r7, #12]
 800d2b4:	7013      	strb	r3, [r2, #0]
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
 800d2b6:	f997 300c 	ldrsb.w	r3, [r7, #12]
}
 800d2ba:	4618      	mov	r0, r3
 800d2bc:	3710      	adds	r7, #16
 800d2be:	46bd      	mov	sp, r7
 800d2c0:	bd80      	pop	{r7, pc}
 800d2c2:	bf00      	nop
 800d2c4:	20007d38 	.word	0x20007d38
 800d2c8:	20007c70 	.word	0x20007c70

0800d2cc <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 800d2cc:	b580      	push	{r7, lr}
 800d2ce:	b086      	sub	sp, #24
 800d2d0:	af00      	add	r7, sp, #0
 800d2d2:	60f8      	str	r0, [r7, #12]
 800d2d4:	60b9      	str	r1, [r7, #8]
 800d2d6:	607a      	str	r2, [r7, #4]
 800d2d8:	603b      	str	r3, [r7, #0]
  struct eth_hdr *ethhdr = p->payload;
 800d2da:	68bb      	ldr	r3, [r7, #8]
 800d2dc:	685b      	ldr	r3, [r3, #4]
 800d2de:	613b      	str	r3, [r7, #16]
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
 800d2e0:	2306      	movs	r3, #6
 800d2e2:	75fb      	strb	r3, [r7, #23]
  while(k > 0) {
 800d2e4:	e010      	b.n	800d308 <etharp_send_ip+0x3c>
    k--;
 800d2e6:	7dfb      	ldrb	r3, [r7, #23]
 800d2e8:	3b01      	subs	r3, #1
 800d2ea:	75fb      	strb	r3, [r7, #23]
    ethhdr->dest.addr[k] = dst->addr[k];
 800d2ec:	7dfb      	ldrb	r3, [r7, #23]
 800d2ee:	7dfa      	ldrb	r2, [r7, #23]
 800d2f0:	6839      	ldr	r1, [r7, #0]
 800d2f2:	5c89      	ldrb	r1, [r1, r2]
 800d2f4:	693a      	ldr	r2, [r7, #16]
 800d2f6:	54d1      	strb	r1, [r2, r3]
    ethhdr->src.addr[k]  = src->addr[k];
 800d2f8:	7dfb      	ldrb	r3, [r7, #23]
 800d2fa:	7dfa      	ldrb	r2, [r7, #23]
 800d2fc:	6879      	ldr	r1, [r7, #4]
 800d2fe:	5c89      	ldrb	r1, [r1, r2]
 800d300:	693a      	ldr	r2, [r7, #16]
 800d302:	4413      	add	r3, r2
 800d304:	460a      	mov	r2, r1
 800d306:	719a      	strb	r2, [r3, #6]
  while(k > 0) {
 800d308:	7dfb      	ldrb	r3, [r7, #23]
 800d30a:	2b00      	cmp	r3, #0
 800d30c:	d1eb      	bne.n	800d2e6 <etharp_send_ip+0x1a>
  }
  ethhdr->type = htons(ETHTYPE_IP);
 800d30e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800d312:	f7f9 fca9 	bl	8006c68 <htons>
 800d316:	4603      	mov	r3, r0
 800d318:	461a      	mov	r2, r3
 800d31a:	693b      	ldr	r3, [r7, #16]
 800d31c:	819a      	strh	r2, [r3, #12]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 800d31e:	68fb      	ldr	r3, [r7, #12]
 800d320:	699b      	ldr	r3, [r3, #24]
 800d322:	68b9      	ldr	r1, [r7, #8]
 800d324:	68f8      	ldr	r0, [r7, #12]
 800d326:	4798      	blx	r3
 800d328:	4603      	mov	r3, r0
}
 800d32a:	4618      	mov	r0, r3
 800d32c:	3718      	adds	r7, #24
 800d32e:	46bd      	mov	sp, r7
 800d330:	bd80      	pop	{r7, pc}
	...

0800d334 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 800d334:	b590      	push	{r4, r7, lr}
 800d336:	b089      	sub	sp, #36	; 0x24
 800d338:	af00      	add	r7, sp, #0
 800d33a:	60f8      	str	r0, [r7, #12]
 800d33c:	60b9      	str	r1, [r7, #8]
 800d33e:	607a      	str	r2, [r7, #4]
 800d340:	70fb      	strb	r3, [r7, #3]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 800d342:	68bb      	ldr	r3, [r7, #8]
 800d344:	2b00      	cmp	r3, #0
 800d346:	d019      	beq.n	800d37c <update_arp_entry+0x48>
 800d348:	68bb      	ldr	r3, [r7, #8]
 800d34a:	681b      	ldr	r3, [r3, #0]
 800d34c:	2b00      	cmp	r3, #0
 800d34e:	d015      	beq.n	800d37c <update_arp_entry+0x48>
      ip_addr_isbroadcast(ipaddr, netif) ||
 800d350:	68f9      	ldr	r1, [r7, #12]
 800d352:	68b8      	ldr	r0, [r7, #8]
 800d354:	f7f9 fff3 	bl	800733e <ip_addr_isbroadcast>
 800d358:	4603      	mov	r3, r0
  if (ip_addr_isany(ipaddr) ||
 800d35a:	2b00      	cmp	r3, #0
 800d35c:	d10e      	bne.n	800d37c <update_arp_entry+0x48>
      ip_addr_ismulticast(ipaddr)) {
 800d35e:	68bb      	ldr	r3, [r7, #8]
 800d360:	681c      	ldr	r4, [r3, #0]
 800d362:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 800d366:	f7f9 fcbb 	bl	8006ce0 <ntohl>
 800d36a:	4603      	mov	r3, r0
 800d36c:	401c      	ands	r4, r3
 800d36e:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 800d372:	f7f9 fcb5 	bl	8006ce0 <ntohl>
 800d376:	4603      	mov	r3, r0
      ip_addr_isbroadcast(ipaddr, netif) ||
 800d378:	429c      	cmp	r4, r3
 800d37a:	d102      	bne.n	800d382 <update_arp_entry+0x4e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 800d37c:	f06f 0309 	mvn.w	r3, #9
 800d380:	e07b      	b.n	800d47a <update_arp_entry+0x146>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
 800d382:	78fb      	ldrb	r3, [r7, #3]
 800d384:	4619      	mov	r1, r3
 800d386:	68b8      	ldr	r0, [r7, #8]
 800d388:	f7ff fe32 	bl	800cff0 <find_entry>
 800d38c:	4603      	mov	r3, r0
 800d38e:	77bb      	strb	r3, [r7, #30]
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
 800d390:	f997 301e 	ldrsb.w	r3, [r7, #30]
 800d394:	2b00      	cmp	r3, #0
 800d396:	da02      	bge.n	800d39e <update_arp_entry+0x6a>
    return (err_t)i;
 800d398:	f997 301e 	ldrsb.w	r3, [r7, #30]
 800d39c:	e06d      	b.n	800d47a <update_arp_entry+0x146>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
 800d39e:	f997 201e 	ldrsb.w	r2, [r7, #30]
 800d3a2:	4938      	ldr	r1, [pc, #224]	; (800d484 <update_arp_entry+0x150>)
 800d3a4:	4613      	mov	r3, r2
 800d3a6:	009b      	lsls	r3, r3, #2
 800d3a8:	4413      	add	r3, r2
 800d3aa:	009b      	lsls	r3, r3, #2
 800d3ac:	440b      	add	r3, r1
 800d3ae:	330e      	adds	r3, #14
 800d3b0:	2202      	movs	r2, #2
 800d3b2:	701a      	strb	r2, [r3, #0]
  /* record network interface */
  arp_table[i].netif = netif;
 800d3b4:	f997 201e 	ldrsb.w	r2, [r7, #30]
 800d3b8:	4932      	ldr	r1, [pc, #200]	; (800d484 <update_arp_entry+0x150>)
 800d3ba:	4613      	mov	r3, r2
 800d3bc:	009b      	lsls	r3, r3, #2
 800d3be:	4413      	add	r3, r2
 800d3c0:	009b      	lsls	r3, r3, #2
 800d3c2:	440b      	add	r3, r1
 800d3c4:	3310      	adds	r3, #16
 800d3c6:	68fa      	ldr	r2, [r7, #12]
 800d3c8:	601a      	str	r2, [r3, #0]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
 800d3ca:	2306      	movs	r3, #6
 800d3cc:	77fb      	strb	r3, [r7, #31]
  while (k > 0) {
 800d3ce:	e012      	b.n	800d3f6 <update_arp_entry+0xc2>
    k--;
 800d3d0:	7ffb      	ldrb	r3, [r7, #31]
 800d3d2:	3b01      	subs	r3, #1
 800d3d4:	77fb      	strb	r3, [r7, #31]
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
 800d3d6:	f997 201e 	ldrsb.w	r2, [r7, #30]
 800d3da:	7ff9      	ldrb	r1, [r7, #31]
 800d3dc:	7ffb      	ldrb	r3, [r7, #31]
 800d3de:	6878      	ldr	r0, [r7, #4]
 800d3e0:	5cc4      	ldrb	r4, [r0, r3]
 800d3e2:	4828      	ldr	r0, [pc, #160]	; (800d484 <update_arp_entry+0x150>)
 800d3e4:	4613      	mov	r3, r2
 800d3e6:	009b      	lsls	r3, r3, #2
 800d3e8:	4413      	add	r3, r2
 800d3ea:	009b      	lsls	r3, r3, #2
 800d3ec:	4403      	add	r3, r0
 800d3ee:	440b      	add	r3, r1
 800d3f0:	3308      	adds	r3, #8
 800d3f2:	4622      	mov	r2, r4
 800d3f4:	701a      	strb	r2, [r3, #0]
  while (k > 0) {
 800d3f6:	7ffb      	ldrb	r3, [r7, #31]
 800d3f8:	2b00      	cmp	r3, #0
 800d3fa:	d1e9      	bne.n	800d3d0 <update_arp_entry+0x9c>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
 800d3fc:	f997 201e 	ldrsb.w	r2, [r7, #30]
 800d400:	4920      	ldr	r1, [pc, #128]	; (800d484 <update_arp_entry+0x150>)
 800d402:	4613      	mov	r3, r2
 800d404:	009b      	lsls	r3, r3, #2
 800d406:	4413      	add	r3, r2
 800d408:	009b      	lsls	r3, r3, #2
 800d40a:	440b      	add	r3, r1
 800d40c:	330f      	adds	r3, #15
 800d40e:	2200      	movs	r2, #0
 800d410:	701a      	strb	r2, [r3, #0]
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
 800d412:	e026      	b.n	800d462 <update_arp_entry+0x12e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
 800d414:	f997 201e 	ldrsb.w	r2, [r7, #30]
 800d418:	491a      	ldr	r1, [pc, #104]	; (800d484 <update_arp_entry+0x150>)
 800d41a:	4613      	mov	r3, r2
 800d41c:	009b      	lsls	r3, r3, #2
 800d41e:	4413      	add	r3, r2
 800d420:	009b      	lsls	r3, r3, #2
 800d422:	440b      	add	r3, r1
 800d424:	681b      	ldr	r3, [r3, #0]
 800d426:	61bb      	str	r3, [r7, #24]
    /* pop first item off the queue */
    arp_table[i].q = q->next;
 800d428:	f997 201e 	ldrsb.w	r2, [r7, #30]
 800d42c:	69bb      	ldr	r3, [r7, #24]
 800d42e:	6819      	ldr	r1, [r3, #0]
 800d430:	4814      	ldr	r0, [pc, #80]	; (800d484 <update_arp_entry+0x150>)
 800d432:	4613      	mov	r3, r2
 800d434:	009b      	lsls	r3, r3, #2
 800d436:	4413      	add	r3, r2
 800d438:	009b      	lsls	r3, r3, #2
 800d43a:	4403      	add	r3, r0
 800d43c:	6019      	str	r1, [r3, #0]
    /* get the packet pointer */
    p = q->p;
 800d43e:	69bb      	ldr	r3, [r7, #24]
 800d440:	685b      	ldr	r3, [r3, #4]
 800d442:	617b      	str	r3, [r7, #20]
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
 800d444:	69b9      	ldr	r1, [r7, #24]
 800d446:	2006      	movs	r0, #6
 800d448:	f7fa fe80 	bl	800814c <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 800d44c:	68fb      	ldr	r3, [r7, #12]
 800d44e:	f103 022b 	add.w	r2, r3, #43	; 0x2b
 800d452:	687b      	ldr	r3, [r7, #4]
 800d454:	6979      	ldr	r1, [r7, #20]
 800d456:	68f8      	ldr	r0, [r7, #12]
 800d458:	f7ff ff38 	bl	800d2cc <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 800d45c:	6978      	ldr	r0, [r7, #20]
 800d45e:	f7fb f9a4 	bl	80087aa <pbuf_free>
  while (arp_table[i].q != NULL) {
 800d462:	f997 201e 	ldrsb.w	r2, [r7, #30]
 800d466:	4907      	ldr	r1, [pc, #28]	; (800d484 <update_arp_entry+0x150>)
 800d468:	4613      	mov	r3, r2
 800d46a:	009b      	lsls	r3, r3, #2
 800d46c:	4413      	add	r3, r2
 800d46e:	009b      	lsls	r3, r3, #2
 800d470:	440b      	add	r3, r1
 800d472:	681b      	ldr	r3, [r3, #0]
 800d474:	2b00      	cmp	r3, #0
 800d476:	d1cd      	bne.n	800d414 <update_arp_entry+0xe0>
  }
#endif
  return ERR_OK;
 800d478:	2300      	movs	r3, #0
}
 800d47a:	4618      	mov	r0, r3
 800d47c:	3724      	adds	r7, #36	; 0x24
 800d47e:	46bd      	mov	sp, r7
 800d480:	bd90      	pop	{r4, r7, pc}
 800d482:	bf00      	nop
 800d484:	20007c70 	.word	0x20007c70

0800d488 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
 800d488:	b580      	push	{r7, lr}
 800d48a:	b084      	sub	sp, #16
 800d48c:	af00      	add	r7, sp, #0
 800d48e:	6078      	str	r0, [r7, #4]
 800d490:	6039      	str	r1, [r7, #0]
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 800d492:	687b      	ldr	r3, [r7, #4]
 800d494:	2b00      	cmp	r3, #0
 800d496:	d019      	beq.n	800d4cc <etharp_ip_input+0x44>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = p->payload;
 800d498:	683b      	ldr	r3, [r7, #0]
 800d49a:	685b      	ldr	r3, [r3, #4]
 800d49c:	60fb      	str	r3, [r7, #12]
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 800d49e:	68fb      	ldr	r3, [r7, #12]
 800d4a0:	330e      	adds	r3, #14
 800d4a2:	60bb      	str	r3, [r7, #8]
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(iphdr->src), &(netif->ip_addr), &(netif->netmask))) {
 800d4a4:	68bb      	ldr	r3, [r7, #8]
 800d4a6:	68da      	ldr	r2, [r3, #12]
 800d4a8:	687b      	ldr	r3, [r7, #4]
 800d4aa:	685b      	ldr	r3, [r3, #4]
 800d4ac:	405a      	eors	r2, r3
 800d4ae:	687b      	ldr	r3, [r7, #4]
 800d4b0:	689b      	ldr	r3, [r3, #8]
 800d4b2:	4013      	ands	r3, r2
 800d4b4:	2b00      	cmp	r3, #0
 800d4b6:	d10b      	bne.n	800d4d0 <etharp_ip_input+0x48>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(iphdr->src), &(ethhdr->src), 0);
 800d4b8:	68bb      	ldr	r3, [r7, #8]
 800d4ba:	f103 010c 	add.w	r1, r3, #12
 800d4be:	68fb      	ldr	r3, [r7, #12]
 800d4c0:	1d9a      	adds	r2, r3, #6
 800d4c2:	2300      	movs	r3, #0
 800d4c4:	6878      	ldr	r0, [r7, #4]
 800d4c6:	f7ff ff35 	bl	800d334 <update_arp_entry>
 800d4ca:	e002      	b.n	800d4d2 <etharp_ip_input+0x4a>
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 800d4cc:	bf00      	nop
 800d4ce:	e000      	b.n	800d4d2 <etharp_ip_input+0x4a>
    return;
 800d4d0:	bf00      	nop
}
 800d4d2:	3710      	adds	r7, #16
 800d4d4:	46bd      	mov	sp, r7
 800d4d6:	bd80      	pop	{r7, pc}

0800d4d8 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
 800d4d8:	b590      	push	{r4, r7, lr}
 800d4da:	b08b      	sub	sp, #44	; 0x2c
 800d4dc:	af00      	add	r7, sp, #0
 800d4de:	60f8      	str	r0, [r7, #12]
 800d4e0:	60b9      	str	r1, [r7, #8]
 800d4e2:	607a      	str	r2, [r7, #4]
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 800d4e4:	68fb      	ldr	r3, [r7, #12]
 800d4e6:	2b00      	cmp	r3, #0
 800d4e8:	f000 80e6 	beq.w	800d6b8 <etharp_arp_input+0x1e0>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
 800d4ec:	687b      	ldr	r3, [r7, #4]
 800d4ee:	895b      	ldrh	r3, [r3, #10]
 800d4f0:	2b29      	cmp	r3, #41	; 0x29
 800d4f2:	d803      	bhi.n	800d4fc <etharp_arp_input+0x24>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
 800d4f4:	6878      	ldr	r0, [r7, #4]
 800d4f6:	f7fb f958 	bl	80087aa <pbuf_free>
    return;
 800d4fa:	e0de      	b.n	800d6ba <etharp_arp_input+0x1e2>
  }

  ethhdr = p->payload;
 800d4fc:	687b      	ldr	r3, [r7, #4]
 800d4fe:	685b      	ldr	r3, [r3, #4]
 800d500:	623b      	str	r3, [r7, #32]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 800d502:	6a3b      	ldr	r3, [r7, #32]
 800d504:	330e      	adds	r3, #14
 800d506:	61fb      	str	r3, [r7, #28]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
 800d508:	69fb      	ldr	r3, [r7, #28]
 800d50a:	881b      	ldrh	r3, [r3, #0]
 800d50c:	b29c      	uxth	r4, r3
 800d50e:	2001      	movs	r0, #1
 800d510:	f7f9 fbaa 	bl	8006c68 <htons>
 800d514:	4603      	mov	r3, r0
 800d516:	429c      	cmp	r4, r3
 800d518:	d11d      	bne.n	800d556 <etharp_arp_input+0x7e>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
 800d51a:	69fb      	ldr	r3, [r7, #28]
 800d51c:	889b      	ldrh	r3, [r3, #4]
 800d51e:	b29c      	uxth	r4, r3
 800d520:	f240 6004 	movw	r0, #1540	; 0x604
 800d524:	f7f9 fba0 	bl	8006c68 <htons>
 800d528:	4603      	mov	r3, r0
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
 800d52a:	429c      	cmp	r4, r3
 800d52c:	d113      	bne.n	800d556 <etharp_arp_input+0x7e>
      (hdr->proto != htons(ETHTYPE_IP)) ||
 800d52e:	69fb      	ldr	r3, [r7, #28]
 800d530:	885b      	ldrh	r3, [r3, #2]
 800d532:	b29c      	uxth	r4, r3
 800d534:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800d538:	f7f9 fb96 	bl	8006c68 <htons>
 800d53c:	4603      	mov	r3, r0
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
 800d53e:	429c      	cmp	r4, r3
 800d540:	d109      	bne.n	800d556 <etharp_arp_input+0x7e>
      (ethhdr->type != htons(ETHTYPE_ARP)))  {
 800d542:	6a3b      	ldr	r3, [r7, #32]
 800d544:	899b      	ldrh	r3, [r3, #12]
 800d546:	b29c      	uxth	r4, r3
 800d548:	f640 0006 	movw	r0, #2054	; 0x806
 800d54c:	f7f9 fb8c 	bl	8006c68 <htons>
 800d550:	4603      	mov	r3, r0
      (hdr->proto != htons(ETHTYPE_IP)) ||
 800d552:	429c      	cmp	r4, r3
 800d554:	d003      	beq.n	800d55e <etharp_arp_input+0x86>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), ethhdr->type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
 800d556:	6878      	ldr	r0, [r7, #4]
 800d558:	f7fb f927 	bl	80087aa <pbuf_free>
    return;
 800d55c:	e0ad      	b.n	800d6ba <etharp_arp_input+0x1e2>

#if LWIP_AUTOIP
  /* We have to check if a host already has configured our random
   * created link local address and continously check if there is
   * a host with this IP-address so we can detect collisions */
  autoip_arp_reply(netif, hdr);
 800d55e:	69f9      	ldr	r1, [r7, #28]
 800d560:	68f8      	ldr	r0, [r7, #12]
 800d562:	f7f9 f993 	bl	800688c <autoip_arp_reply>
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
 800d566:	69fb      	ldr	r3, [r7, #28]
 800d568:	330e      	adds	r3, #14
 800d56a:	681b      	ldr	r3, [r3, #0]
 800d56c:	617b      	str	r3, [r7, #20]
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
 800d56e:	69fb      	ldr	r3, [r7, #28]
 800d570:	3318      	adds	r3, #24
 800d572:	681b      	ldr	r3, [r3, #0]
 800d574:	613b      	str	r3, [r7, #16]

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
 800d576:	68fb      	ldr	r3, [r7, #12]
 800d578:	685b      	ldr	r3, [r3, #4]
 800d57a:	2b00      	cmp	r3, #0
 800d57c:	d103      	bne.n	800d586 <etharp_arp_input+0xae>
    for_us = 0;
 800d57e:	2300      	movs	r3, #0
 800d580:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 800d584:	e009      	b.n	800d59a <etharp_arp_input+0xc2>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 800d586:	693a      	ldr	r2, [r7, #16]
 800d588:	68fb      	ldr	r3, [r7, #12]
 800d58a:	685b      	ldr	r3, [r3, #4]
 800d58c:	429a      	cmp	r2, r3
 800d58e:	bf0c      	ite	eq
 800d590:	2301      	moveq	r3, #1
 800d592:	2300      	movne	r3, #0
 800d594:	b2db      	uxtb	r3, r3
 800d596:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  }

  /* ARP message directed to us? */
  if (for_us) {
 800d59a:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800d59e:	2b00      	cmp	r3, #0
 800d5a0:	d009      	beq.n	800d5b6 <etharp_arp_input+0xde>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
 800d5a2:	69fb      	ldr	r3, [r7, #28]
 800d5a4:	f103 0208 	add.w	r2, r3, #8
 800d5a8:	f107 0114 	add.w	r1, r7, #20
 800d5ac:	2301      	movs	r3, #1
 800d5ae:	68f8      	ldr	r0, [r7, #12]
 800d5b0:	f7ff fec0 	bl	800d334 <update_arp_entry>
 800d5b4:	e008      	b.n	800d5c8 <etharp_arp_input+0xf0>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
 800d5b6:	69fb      	ldr	r3, [r7, #28]
 800d5b8:	f103 0208 	add.w	r2, r3, #8
 800d5bc:	f107 0114 	add.w	r1, r7, #20
 800d5c0:	2300      	movs	r3, #0
 800d5c2:	68f8      	ldr	r0, [r7, #12]
 800d5c4:	f7ff feb6 	bl	800d334 <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
 800d5c8:	69fb      	ldr	r3, [r7, #28]
 800d5ca:	88db      	ldrh	r3, [r3, #6]
 800d5cc:	b29b      	uxth	r3, r3
 800d5ce:	4618      	mov	r0, r3
 800d5d0:	f7f9 fb4a 	bl	8006c68 <htons>
 800d5d4:	4603      	mov	r3, r0
 800d5d6:	2b01      	cmp	r3, #1
 800d5d8:	d002      	beq.n	800d5e0 <etharp_arp_input+0x108>
 800d5da:	2b02      	cmp	r3, #2
 800d5dc:	d060      	beq.n	800d6a0 <etharp_arp_input+0x1c8>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
 800d5de:	e067      	b.n	800d6b0 <etharp_arp_input+0x1d8>
    if (for_us) {
 800d5e0:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800d5e4:	2b00      	cmp	r3, #0
 800d5e6:	d062      	beq.n	800d6ae <etharp_arp_input+0x1d6>
      hdr->opcode = htons(ARP_REPLY);
 800d5e8:	2002      	movs	r0, #2
 800d5ea:	f7f9 fb3d 	bl	8006c68 <htons>
 800d5ee:	4603      	mov	r3, r0
 800d5f0:	461a      	mov	r2, r3
 800d5f2:	69fb      	ldr	r3, [r7, #28]
 800d5f4:	80da      	strh	r2, [r3, #6]
      hdr->dipaddr = hdr->sipaddr;
 800d5f6:	69fb      	ldr	r3, [r7, #28]
 800d5f8:	69fa      	ldr	r2, [r7, #28]
 800d5fa:	3318      	adds	r3, #24
 800d5fc:	320e      	adds	r2, #14
 800d5fe:	6812      	ldr	r2, [r2, #0]
 800d600:	601a      	str	r2, [r3, #0]
      SMEMCPY(&hdr->sipaddr, &netif->ip_addr, sizeof(hdr->sipaddr));
 800d602:	69fb      	ldr	r3, [r7, #28]
 800d604:	330e      	adds	r3, #14
 800d606:	68fa      	ldr	r2, [r7, #12]
 800d608:	3204      	adds	r2, #4
 800d60a:	6812      	ldr	r2, [r2, #0]
 800d60c:	601a      	str	r2, [r3, #0]
      i = ETHARP_HWADDR_LEN;
 800d60e:	2306      	movs	r3, #6
 800d610:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
 800d614:	68fb      	ldr	r3, [r7, #12]
 800d616:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d618:	2b00      	cmp	r3, #0
 800d61a:	d004      	beq.n	800d626 <etharp_arp_input+0x14e>
 800d61c:	68fb      	ldr	r3, [r7, #12]
 800d61e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d620:	791b      	ldrb	r3, [r3, #4]
 800d622:	2b00      	cmp	r3, #0
 800d624:	d102      	bne.n	800d62c <etharp_arp_input+0x154>
 800d626:	69fb      	ldr	r3, [r7, #28]
 800d628:	3308      	adds	r3, #8
 800d62a:	e000      	b.n	800d62e <etharp_arp_input+0x156>
 800d62c:	4b24      	ldr	r3, [pc, #144]	; (800d6c0 <etharp_arp_input+0x1e8>)
 800d62e:	61bb      	str	r3, [r7, #24]
      while(i > 0) {
 800d630:	e02c      	b.n	800d68c <etharp_arp_input+0x1b4>
        i--;
 800d632:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d636:	3b01      	subs	r3, #1
 800d638:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
 800d63c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d640:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800d644:	69f9      	ldr	r1, [r7, #28]
 800d646:	440a      	add	r2, r1
 800d648:	7a11      	ldrb	r1, [r2, #8]
 800d64a:	69fa      	ldr	r2, [r7, #28]
 800d64c:	4413      	add	r3, r2
 800d64e:	460a      	mov	r2, r1
 800d650:	749a      	strb	r2, [r3, #18]
        ethhdr->dest.addr[i] = ethdst_hwaddr[i];
 800d652:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d656:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800d65a:	69b9      	ldr	r1, [r7, #24]
 800d65c:	440a      	add	r2, r1
 800d65e:	7811      	ldrb	r1, [r2, #0]
 800d660:	6a3a      	ldr	r2, [r7, #32]
 800d662:	54d1      	strb	r1, [r2, r3]
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
 800d664:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d668:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800d66c:	68b9      	ldr	r1, [r7, #8]
 800d66e:	5c89      	ldrb	r1, [r1, r2]
 800d670:	69fa      	ldr	r2, [r7, #28]
 800d672:	4413      	add	r3, r2
 800d674:	460a      	mov	r2, r1
 800d676:	721a      	strb	r2, [r3, #8]
        ethhdr->src.addr[i] = ethaddr->addr[i];
 800d678:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d67c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800d680:	68b9      	ldr	r1, [r7, #8]
 800d682:	5c89      	ldrb	r1, [r1, r2]
 800d684:	6a3a      	ldr	r2, [r7, #32]
 800d686:	4413      	add	r3, r2
 800d688:	460a      	mov	r2, r1
 800d68a:	719a      	strb	r2, [r3, #6]
      while(i > 0) {
 800d68c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d690:	2b00      	cmp	r3, #0
 800d692:	d1ce      	bne.n	800d632 <etharp_arp_input+0x15a>
      netif->linkoutput(netif, p);
 800d694:	68fb      	ldr	r3, [r7, #12]
 800d696:	699b      	ldr	r3, [r3, #24]
 800d698:	6879      	ldr	r1, [r7, #4]
 800d69a:	68f8      	ldr	r0, [r7, #12]
 800d69c:	4798      	blx	r3
    break;
 800d69e:	e006      	b.n	800d6ae <etharp_arp_input+0x1d6>
    dhcp_arp_reply(netif, &sipaddr);
 800d6a0:	f107 0314 	add.w	r3, r7, #20
 800d6a4:	4619      	mov	r1, r3
 800d6a6:	68f8      	ldr	r0, [r7, #12]
 800d6a8:	f7f8 fd56 	bl	8006158 <dhcp_arp_reply>
    break;
 800d6ac:	e000      	b.n	800d6b0 <etharp_arp_input+0x1d8>
    break;
 800d6ae:	bf00      	nop
  }
  /* free ARP packet */
  pbuf_free(p);
 800d6b0:	6878      	ldr	r0, [r7, #4]
 800d6b2:	f7fb f87a 	bl	80087aa <pbuf_free>
 800d6b6:	e000      	b.n	800d6ba <etharp_arp_input+0x1e2>
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 800d6b8:	bf00      	nop
}
 800d6ba:	372c      	adds	r7, #44	; 0x2c
 800d6bc:	46bd      	mov	sp, r7
 800d6be:	bd90      	pop	{r4, r7, pc}
 800d6c0:	0801b5b0 	.word	0x0801b5b0

0800d6c4 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
 800d6c4:	b590      	push	{r4, r7, lr}
 800d6c6:	b089      	sub	sp, #36	; 0x24
 800d6c8:	af00      	add	r7, sp, #0
 800d6ca:	60f8      	str	r0, [r7, #12]
 800d6cc:	60b9      	str	r1, [r7, #8]
 800d6ce:	607a      	str	r2, [r7, #4]
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 800d6d0:	210e      	movs	r1, #14
 800d6d2:	68b8      	ldr	r0, [r7, #8]
 800d6d4:	f7fa fffa 	bl	80086cc <pbuf_header>
 800d6d8:	4603      	mov	r3, r0
 800d6da:	2b00      	cmp	r3, #0
 800d6dc:	d002      	beq.n	800d6e4 <etharp_output+0x20>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
 800d6de:	f06f 0301 	mvn.w	r3, #1
 800d6e2:	e066      	b.n	800d7b2 <etharp_output+0xee>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
 800d6e4:	2300      	movs	r3, #0
 800d6e6:	61fb      	str	r3, [r7, #28]
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 800d6e8:	68f9      	ldr	r1, [r7, #12]
 800d6ea:	6878      	ldr	r0, [r7, #4]
 800d6ec:	f7f9 fe27 	bl	800733e <ip_addr_isbroadcast>
 800d6f0:	4603      	mov	r3, r0
 800d6f2:	2b00      	cmp	r3, #0
 800d6f4:	d002      	beq.n	800d6fc <etharp_output+0x38>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
 800d6f6:	4b31      	ldr	r3, [pc, #196]	; (800d7bc <etharp_output+0xf8>)
 800d6f8:	61fb      	str	r3, [r7, #28]
 800d6fa:	e051      	b.n	800d7a0 <etharp_output+0xdc>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
 800d6fc:	687b      	ldr	r3, [r7, #4]
 800d6fe:	681c      	ldr	r4, [r3, #0]
 800d700:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 800d704:	f7f9 faec 	bl	8006ce0 <ntohl>
 800d708:	4603      	mov	r3, r0
 800d70a:	401c      	ands	r4, r3
 800d70c:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 800d710:	f7f9 fae6 	bl	8006ce0 <ntohl>
 800d714:	4603      	mov	r3, r0
 800d716:	429c      	cmp	r4, r3
 800d718:	d126      	bne.n	800d768 <etharp_output+0xa4>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
 800d71a:	2301      	movs	r3, #1
 800d71c:	753b      	strb	r3, [r7, #20]
    mcastaddr.addr[1] = 0x00;
 800d71e:	2300      	movs	r3, #0
 800d720:	757b      	strb	r3, [r7, #21]
    mcastaddr.addr[2] = 0x5e;
 800d722:	235e      	movs	r3, #94	; 0x5e
 800d724:	75bb      	strb	r3, [r7, #22]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800d726:	687b      	ldr	r3, [r7, #4]
 800d728:	681b      	ldr	r3, [r3, #0]
 800d72a:	4618      	mov	r0, r3
 800d72c:	f7f9 fad8 	bl	8006ce0 <ntohl>
 800d730:	4603      	mov	r3, r0
 800d732:	0c1b      	lsrs	r3, r3, #16
 800d734:	b2db      	uxtb	r3, r3
 800d736:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800d73a:	b2db      	uxtb	r3, r3
 800d73c:	75fb      	strb	r3, [r7, #23]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 800d73e:	687b      	ldr	r3, [r7, #4]
 800d740:	681b      	ldr	r3, [r3, #0]
 800d742:	4618      	mov	r0, r3
 800d744:	f7f9 facc 	bl	8006ce0 <ntohl>
 800d748:	4603      	mov	r3, r0
 800d74a:	0a1b      	lsrs	r3, r3, #8
 800d74c:	b2db      	uxtb	r3, r3
 800d74e:	763b      	strb	r3, [r7, #24]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 800d750:	687b      	ldr	r3, [r7, #4]
 800d752:	681b      	ldr	r3, [r3, #0]
 800d754:	4618      	mov	r0, r3
 800d756:	f7f9 fac3 	bl	8006ce0 <ntohl>
 800d75a:	4603      	mov	r3, r0
 800d75c:	b2db      	uxtb	r3, r3
 800d75e:	767b      	strb	r3, [r7, #25]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 800d760:	f107 0314 	add.w	r3, r7, #20
 800d764:	61fb      	str	r3, [r7, #28]
 800d766:	e01b      	b.n	800d7a0 <etharp_output+0xdc>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
 800d768:	687b      	ldr	r3, [r7, #4]
 800d76a:	681a      	ldr	r2, [r3, #0]
 800d76c:	68fb      	ldr	r3, [r7, #12]
 800d76e:	685b      	ldr	r3, [r3, #4]
 800d770:	405a      	eors	r2, r3
 800d772:	68fb      	ldr	r3, [r7, #12]
 800d774:	689b      	ldr	r3, [r3, #8]
 800d776:	4013      	ands	r3, r2
 800d778:	2b00      	cmp	r3, #0
 800d77a:	d00a      	beq.n	800d792 <etharp_output+0xce>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
 800d77c:	68fb      	ldr	r3, [r7, #12]
 800d77e:	68db      	ldr	r3, [r3, #12]
 800d780:	2b00      	cmp	r3, #0
 800d782:	d003      	beq.n	800d78c <etharp_output+0xc8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
 800d784:	68fb      	ldr	r3, [r7, #12]
 800d786:	330c      	adds	r3, #12
 800d788:	607b      	str	r3, [r7, #4]
 800d78a:	e002      	b.n	800d792 <etharp_output+0xce>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
 800d78c:	f06f 0303 	mvn.w	r3, #3
 800d790:	e00f      	b.n	800d7b2 <etharp_output+0xee>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
 800d792:	68ba      	ldr	r2, [r7, #8]
 800d794:	6879      	ldr	r1, [r7, #4]
 800d796:	68f8      	ldr	r0, [r7, #12]
 800d798:	f000 f812 	bl	800d7c0 <etharp_query>
 800d79c:	4603      	mov	r3, r0
 800d79e:	e008      	b.n	800d7b2 <etharp_output+0xee>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 800d7a0:	68fb      	ldr	r3, [r7, #12]
 800d7a2:	f103 022b 	add.w	r2, r3, #43	; 0x2b
 800d7a6:	69fb      	ldr	r3, [r7, #28]
 800d7a8:	68b9      	ldr	r1, [r7, #8]
 800d7aa:	68f8      	ldr	r0, [r7, #12]
 800d7ac:	f7ff fd8e 	bl	800d2cc <etharp_send_ip>
 800d7b0:	4603      	mov	r3, r0
}
 800d7b2:	4618      	mov	r0, r3
 800d7b4:	3724      	adds	r7, #36	; 0x24
 800d7b6:	46bd      	mov	sp, r7
 800d7b8:	bd90      	pop	{r4, r7, pc}
 800d7ba:	bf00      	nop
 800d7bc:	0801b5b0 	.word	0x0801b5b0

0800d7c0 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
 800d7c0:	b590      	push	{r4, r7, lr}
 800d7c2:	b08d      	sub	sp, #52	; 0x34
 800d7c4:	af00      	add	r7, sp, #0
 800d7c6:	60f8      	str	r0, [r7, #12]
 800d7c8:	60b9      	str	r1, [r7, #8]
 800d7ca:	607a      	str	r2, [r7, #4]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 800d7cc:	68fb      	ldr	r3, [r7, #12]
 800d7ce:	332b      	adds	r3, #43	; 0x2b
 800d7d0:	61fb      	str	r3, [r7, #28]
  err_t result = ERR_MEM;
 800d7d2:	23ff      	movs	r3, #255	; 0xff
 800d7d4:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800d7d8:	68f9      	ldr	r1, [r7, #12]
 800d7da:	68b8      	ldr	r0, [r7, #8]
 800d7dc:	f7f9 fdaf 	bl	800733e <ip_addr_isbroadcast>
 800d7e0:	4603      	mov	r3, r0
 800d7e2:	2b00      	cmp	r3, #0
 800d7e4:	d115      	bne.n	800d812 <etharp_query+0x52>
      ip_addr_ismulticast(ipaddr) ||
 800d7e6:	68bb      	ldr	r3, [r7, #8]
 800d7e8:	681c      	ldr	r4, [r3, #0]
 800d7ea:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 800d7ee:	f7f9 fa77 	bl	8006ce0 <ntohl>
 800d7f2:	4603      	mov	r3, r0
 800d7f4:	401c      	ands	r4, r3
 800d7f6:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 800d7fa:	f7f9 fa71 	bl	8006ce0 <ntohl>
 800d7fe:	4603      	mov	r3, r0
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800d800:	429c      	cmp	r4, r3
 800d802:	d006      	beq.n	800d812 <etharp_query+0x52>
      ip_addr_ismulticast(ipaddr) ||
 800d804:	68bb      	ldr	r3, [r7, #8]
 800d806:	2b00      	cmp	r3, #0
 800d808:	d003      	beq.n	800d812 <etharp_query+0x52>
      ip_addr_isany(ipaddr)) {
 800d80a:	68bb      	ldr	r3, [r7, #8]
 800d80c:	681b      	ldr	r3, [r3, #0]
 800d80e:	2b00      	cmp	r3, #0
 800d810:	d102      	bne.n	800d818 <etharp_query+0x58>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 800d812:	f06f 0309 	mvn.w	r3, #9
 800d816:	e0f4      	b.n	800da02 <etharp_query+0x242>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
 800d818:	2101      	movs	r1, #1
 800d81a:	68b8      	ldr	r0, [r7, #8]
 800d81c:	f7ff fbe8 	bl	800cff0 <find_entry>
 800d820:	4603      	mov	r3, r0
 800d822:	76fb      	strb	r3, [r7, #27]
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
 800d824:	f997 301b 	ldrsb.w	r3, [r7, #27]
 800d828:	2b00      	cmp	r3, #0
 800d82a:	da02      	bge.n	800d832 <etharp_query+0x72>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
 800d82c:	f997 301b 	ldrsb.w	r3, [r7, #27]
 800d830:	e0e7      	b.n	800da02 <etharp_query+0x242>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 800d832:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d836:	4975      	ldr	r1, [pc, #468]	; (800da0c <etharp_query+0x24c>)
 800d838:	4613      	mov	r3, r2
 800d83a:	009b      	lsls	r3, r3, #2
 800d83c:	4413      	add	r3, r2
 800d83e:	009b      	lsls	r3, r3, #2
 800d840:	440b      	add	r3, r1
 800d842:	330e      	adds	r3, #14
 800d844:	781b      	ldrb	r3, [r3, #0]
 800d846:	2b00      	cmp	r3, #0
 800d848:	d10a      	bne.n	800d860 <etharp_query+0xa0>
    arp_table[i].state = ETHARP_STATE_PENDING;
 800d84a:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d84e:	496f      	ldr	r1, [pc, #444]	; (800da0c <etharp_query+0x24c>)
 800d850:	4613      	mov	r3, r2
 800d852:	009b      	lsls	r3, r3, #2
 800d854:	4413      	add	r3, r2
 800d856:	009b      	lsls	r3, r3, #2
 800d858:	440b      	add	r3, r1
 800d85a:	330e      	adds	r3, #14
 800d85c:	2201      	movs	r2, #1
 800d85e:	701a      	strb	r2, [r3, #0]
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 800d860:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d864:	4969      	ldr	r1, [pc, #420]	; (800da0c <etharp_query+0x24c>)
 800d866:	4613      	mov	r3, r2
 800d868:	009b      	lsls	r3, r3, #2
 800d86a:	4413      	add	r3, r2
 800d86c:	009b      	lsls	r3, r3, #2
 800d86e:	440b      	add	r3, r1
 800d870:	330e      	adds	r3, #14
 800d872:	781b      	ldrb	r3, [r3, #0]
 800d874:	2b01      	cmp	r3, #1
 800d876:	d005      	beq.n	800d884 <etharp_query+0xc4>
 800d878:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d87c:	4613      	mov	r3, r2
 800d87e:	009b      	lsls	r3, r3, #2
 800d880:	4413      	add	r3, r2
 800d882:	009b      	lsls	r3, r3, #2
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 800d884:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d888:	4960      	ldr	r1, [pc, #384]	; (800da0c <etharp_query+0x24c>)
 800d88a:	4613      	mov	r3, r2
 800d88c:	009b      	lsls	r3, r3, #2
 800d88e:	4413      	add	r3, r2
 800d890:	009b      	lsls	r3, r3, #2
 800d892:	440b      	add	r3, r1
 800d894:	330e      	adds	r3, #14
 800d896:	781b      	ldrb	r3, [r3, #0]
 800d898:	2b01      	cmp	r3, #1
 800d89a:	d002      	beq.n	800d8a2 <etharp_query+0xe2>
 800d89c:	687b      	ldr	r3, [r7, #4]
 800d89e:	2b00      	cmp	r3, #0
 800d8a0:	d106      	bne.n	800d8b0 <etharp_query+0xf0>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 800d8a2:	68b9      	ldr	r1, [r7, #8]
 800d8a4:	68f8      	ldr	r0, [r7, #12]
 800d8a6:	f000 f957 	bl	800db58 <etharp_request>
 800d8aa:	4603      	mov	r3, r0
 800d8ac:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
 800d8b0:	687b      	ldr	r3, [r7, #4]
 800d8b2:	2b00      	cmp	r3, #0
 800d8b4:	f000 80a3 	beq.w	800d9fe <etharp_query+0x23e>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
 800d8b8:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d8bc:	4953      	ldr	r1, [pc, #332]	; (800da0c <etharp_query+0x24c>)
 800d8be:	4613      	mov	r3, r2
 800d8c0:	009b      	lsls	r3, r3, #2
 800d8c2:	4413      	add	r3, r2
 800d8c4:	009b      	lsls	r3, r3, #2
 800d8c6:	440b      	add	r3, r1
 800d8c8:	330e      	adds	r3, #14
 800d8ca:	781b      	ldrb	r3, [r3, #0]
 800d8cc:	2b02      	cmp	r3, #2
 800d8ce:	d111      	bne.n	800d8f4 <etharp_query+0x134>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 800d8d0:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d8d4:	4613      	mov	r3, r2
 800d8d6:	009b      	lsls	r3, r3, #2
 800d8d8:	4413      	add	r3, r2
 800d8da:	009b      	lsls	r3, r3, #2
 800d8dc:	3308      	adds	r3, #8
 800d8de:	4a4b      	ldr	r2, [pc, #300]	; (800da0c <etharp_query+0x24c>)
 800d8e0:	4413      	add	r3, r2
 800d8e2:	69fa      	ldr	r2, [r7, #28]
 800d8e4:	6879      	ldr	r1, [r7, #4]
 800d8e6:	68f8      	ldr	r0, [r7, #12]
 800d8e8:	f7ff fcf0 	bl	800d2cc <etharp_send_ip>
 800d8ec:	4603      	mov	r3, r0
 800d8ee:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800d8f2:	e084      	b.n	800d9fe <etharp_query+0x23e>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 800d8f4:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d8f8:	4944      	ldr	r1, [pc, #272]	; (800da0c <etharp_query+0x24c>)
 800d8fa:	4613      	mov	r3, r2
 800d8fc:	009b      	lsls	r3, r3, #2
 800d8fe:	4413      	add	r3, r2
 800d900:	009b      	lsls	r3, r3, #2
 800d902:	440b      	add	r3, r1
 800d904:	330e      	adds	r3, #14
 800d906:	781b      	ldrb	r3, [r3, #0]
 800d908:	2b01      	cmp	r3, #1
 800d90a:	d178      	bne.n	800d9fe <etharp_query+0x23e>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
 800d90c:	2300      	movs	r3, #0
 800d90e:	627b      	str	r3, [r7, #36]	; 0x24
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
 800d910:	687b      	ldr	r3, [r7, #4]
 800d912:	62bb      	str	r3, [r7, #40]	; 0x28
      while (p) {
 800d914:	e00e      	b.n	800d934 <etharp_query+0x174>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 800d916:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d918:	895a      	ldrh	r2, [r3, #10]
 800d91a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d91c:	891b      	ldrh	r3, [r3, #8]
 800d91e:	429a      	cmp	r2, r3
        if(p->type != PBUF_ROM) {
 800d920:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d922:	7b1b      	ldrb	r3, [r3, #12]
 800d924:	2b01      	cmp	r3, #1
 800d926:	d002      	beq.n	800d92e <etharp_query+0x16e>
          copy_needed = 1;
 800d928:	2301      	movs	r3, #1
 800d92a:	627b      	str	r3, [r7, #36]	; 0x24
          break;
 800d92c:	e005      	b.n	800d93a <etharp_query+0x17a>
        }
        p = p->next;
 800d92e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d930:	681b      	ldr	r3, [r3, #0]
 800d932:	62bb      	str	r3, [r7, #40]	; 0x28
      while (p) {
 800d934:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d936:	2b00      	cmp	r3, #0
 800d938:	d1ed      	bne.n	800d916 <etharp_query+0x156>
      }
      if(copy_needed) {
 800d93a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d93c:	2b00      	cmp	r3, #0
 800d93e:	d017      	beq.n	800d970 <etharp_query+0x1b0>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 800d940:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d942:	891b      	ldrh	r3, [r3, #8]
 800d944:	2200      	movs	r2, #0
 800d946:	4619      	mov	r1, r3
 800d948:	2003      	movs	r0, #3
 800d94a:	f7fa fd61 	bl	8008410 <pbuf_alloc>
 800d94e:	62b8      	str	r0, [r7, #40]	; 0x28
        if(p != NULL) {
 800d950:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d952:	2b00      	cmp	r3, #0
 800d954:	d011      	beq.n	800d97a <etharp_query+0x1ba>
          if (pbuf_copy(p, q) != ERR_OK) {
 800d956:	6879      	ldr	r1, [r7, #4]
 800d958:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d95a:	f7fa ffde 	bl	800891a <pbuf_copy>
 800d95e:	4603      	mov	r3, r0
 800d960:	2b00      	cmp	r3, #0
 800d962:	d00a      	beq.n	800d97a <etharp_query+0x1ba>
            pbuf_free(p);
 800d964:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d966:	f7fa ff20 	bl	80087aa <pbuf_free>
            p = NULL;
 800d96a:	2300      	movs	r3, #0
 800d96c:	62bb      	str	r3, [r7, #40]	; 0x28
 800d96e:	e004      	b.n	800d97a <etharp_query+0x1ba>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
 800d970:	687b      	ldr	r3, [r7, #4]
 800d972:	62bb      	str	r3, [r7, #40]	; 0x28
        pbuf_ref(p);
 800d974:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d976:	f7fa ff7e 	bl	8008876 <pbuf_ref>
      }
      /* packet could be taken over? */
      if (p != NULL) {
 800d97a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d97c:	2b00      	cmp	r3, #0
 800d97e:	d03e      	beq.n	800d9fe <etharp_query+0x23e>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
 800d980:	2006      	movs	r0, #6
 800d982:	f7fa fbc1 	bl	8008108 <memp_malloc>
 800d986:	6178      	str	r0, [r7, #20]
        if (new_entry != NULL) {
 800d988:	697b      	ldr	r3, [r7, #20]
 800d98a:	2b00      	cmp	r3, #0
 800d98c:	d034      	beq.n	800d9f8 <etharp_query+0x238>
          new_entry->next = 0;
 800d98e:	697b      	ldr	r3, [r7, #20]
 800d990:	2200      	movs	r2, #0
 800d992:	601a      	str	r2, [r3, #0]
          new_entry->p = p;
 800d994:	697b      	ldr	r3, [r7, #20]
 800d996:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d998:	605a      	str	r2, [r3, #4]
          if(arp_table[i].q != NULL) {
 800d99a:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d99e:	491b      	ldr	r1, [pc, #108]	; (800da0c <etharp_query+0x24c>)
 800d9a0:	4613      	mov	r3, r2
 800d9a2:	009b      	lsls	r3, r3, #2
 800d9a4:	4413      	add	r3, r2
 800d9a6:	009b      	lsls	r3, r3, #2
 800d9a8:	440b      	add	r3, r1
 800d9aa:	681b      	ldr	r3, [r3, #0]
 800d9ac:	2b00      	cmp	r3, #0
 800d9ae:	d015      	beq.n	800d9dc <etharp_query+0x21c>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
 800d9b0:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d9b4:	4915      	ldr	r1, [pc, #84]	; (800da0c <etharp_query+0x24c>)
 800d9b6:	4613      	mov	r3, r2
 800d9b8:	009b      	lsls	r3, r3, #2
 800d9ba:	4413      	add	r3, r2
 800d9bc:	009b      	lsls	r3, r3, #2
 800d9be:	440b      	add	r3, r1
 800d9c0:	681b      	ldr	r3, [r3, #0]
 800d9c2:	623b      	str	r3, [r7, #32]
            while (r->next != NULL) {
 800d9c4:	e002      	b.n	800d9cc <etharp_query+0x20c>
              r = r->next;
 800d9c6:	6a3b      	ldr	r3, [r7, #32]
 800d9c8:	681b      	ldr	r3, [r3, #0]
 800d9ca:	623b      	str	r3, [r7, #32]
            while (r->next != NULL) {
 800d9cc:	6a3b      	ldr	r3, [r7, #32]
 800d9ce:	681b      	ldr	r3, [r3, #0]
 800d9d0:	2b00      	cmp	r3, #0
 800d9d2:	d1f8      	bne.n	800d9c6 <etharp_query+0x206>
            }
            r->next = new_entry;
 800d9d4:	6a3b      	ldr	r3, [r7, #32]
 800d9d6:	697a      	ldr	r2, [r7, #20]
 800d9d8:	601a      	str	r2, [r3, #0]
 800d9da:	e009      	b.n	800d9f0 <etharp_query+0x230>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
 800d9dc:	f997 201b 	ldrsb.w	r2, [r7, #27]
 800d9e0:	490a      	ldr	r1, [pc, #40]	; (800da0c <etharp_query+0x24c>)
 800d9e2:	4613      	mov	r3, r2
 800d9e4:	009b      	lsls	r3, r3, #2
 800d9e6:	4413      	add	r3, r2
 800d9e8:	009b      	lsls	r3, r3, #2
 800d9ea:	440b      	add	r3, r1
 800d9ec:	697a      	ldr	r2, [r7, #20]
 800d9ee:	601a      	str	r2, [r3, #0]
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
 800d9f0:	2300      	movs	r3, #0
 800d9f2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800d9f6:	e002      	b.n	800d9fe <etharp_query+0x23e>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
 800d9f8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d9fa:	f7fa fed6 	bl	80087aa <pbuf_free>
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
 800d9fe:	f997 302f 	ldrsb.w	r3, [r7, #47]	; 0x2f
}
 800da02:	4618      	mov	r0, r3
 800da04:	3734      	adds	r7, #52	; 0x34
 800da06:	46bd      	mov	sp, r7
 800da08:	bd90      	pop	{r4, r7, pc}
 800da0a:	bf00      	nop
 800da0c:	20007c70 	.word	0x20007c70

0800da10 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
 800da10:	b580      	push	{r7, lr}
 800da12:	b08a      	sub	sp, #40	; 0x28
 800da14:	af00      	add	r7, sp, #0
 800da16:	60f8      	str	r0, [r7, #12]
 800da18:	60b9      	str	r1, [r7, #8]
 800da1a:	607a      	str	r2, [r7, #4]
 800da1c:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  err_t result = ERR_OK;
 800da1e:	2300      	movs	r3, #0
 800da20:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 800da24:	2200      	movs	r2, #0
 800da26:	212a      	movs	r1, #42	; 0x2a
 800da28:	2003      	movs	r0, #3
 800da2a:	f7fa fcf1 	bl	8008410 <pbuf_alloc>
 800da2e:	6238      	str	r0, [r7, #32]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 800da30:	6a3b      	ldr	r3, [r7, #32]
 800da32:	2b00      	cmp	r3, #0
 800da34:	d102      	bne.n	800da3c <etharp_raw+0x2c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
 800da36:	f04f 33ff 	mov.w	r3, #4294967295
 800da3a:	e086      	b.n	800db4a <etharp_raw+0x13a>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = p->payload;
 800da3c:	6a3b      	ldr	r3, [r7, #32]
 800da3e:	685b      	ldr	r3, [r3, #4]
 800da40:	61fb      	str	r3, [r7, #28]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 800da42:	69fb      	ldr	r3, [r7, #28]
 800da44:	330e      	adds	r3, #14
 800da46:	61bb      	str	r3, [r7, #24]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 800da48:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 800da4a:	4618      	mov	r0, r3
 800da4c:	f7f9 f90c 	bl	8006c68 <htons>
 800da50:	4603      	mov	r3, r0
 800da52:	461a      	mov	r2, r3
 800da54:	69bb      	ldr	r3, [r7, #24]
 800da56:	80da      	strh	r2, [r3, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
 800da58:	2306      	movs	r3, #6
 800da5a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
#if LWIP_AUTOIP
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
 800da5e:	68fb      	ldr	r3, [r7, #12]
 800da60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800da62:	2b00      	cmp	r3, #0
 800da64:	d004      	beq.n	800da70 <etharp_raw+0x60>
 800da66:	68fb      	ldr	r3, [r7, #12]
 800da68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800da6a:	791b      	ldrb	r3, [r3, #4]
 800da6c:	2b00      	cmp	r3, #0
 800da6e:	d101      	bne.n	800da74 <etharp_raw+0x64>
 800da70:	687b      	ldr	r3, [r7, #4]
 800da72:	e000      	b.n	800da76 <etharp_raw+0x66>
 800da74:	4b37      	ldr	r3, [pc, #220]	; (800db54 <etharp_raw+0x144>)
 800da76:	617b      	str	r3, [r7, #20]
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
 800da78:	e02b      	b.n	800dad2 <etharp_raw+0xc2>
    k--;
 800da7a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800da7e:	3b01      	subs	r3, #1
 800da80:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
 800da84:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800da88:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800da8c:	6839      	ldr	r1, [r7, #0]
 800da8e:	5c89      	ldrb	r1, [r1, r2]
 800da90:	69ba      	ldr	r2, [r7, #24]
 800da92:	4413      	add	r3, r2
 800da94:	460a      	mov	r2, r1
 800da96:	721a      	strb	r2, [r3, #8]
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
 800da98:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800da9c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800daa0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800daa2:	5c89      	ldrb	r1, [r1, r2]
 800daa4:	69ba      	ldr	r2, [r7, #24]
 800daa6:	4413      	add	r3, r2
 800daa8:	460a      	mov	r2, r1
 800daaa:	749a      	strb	r2, [r3, #18]
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    ethhdr->dest.addr[k] = ethdst_hwaddr[k];
 800daac:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800dab0:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800dab4:	6979      	ldr	r1, [r7, #20]
 800dab6:	440a      	add	r2, r1
 800dab8:	7811      	ldrb	r1, [r2, #0]
 800daba:	69fa      	ldr	r2, [r7, #28]
 800dabc:	54d1      	strb	r1, [r2, r3]
#else  /* LWIP_AUTOIP */
    ethhdr->dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    ethhdr->src.addr[k]  = ethsrc_addr->addr[k];
 800dabe:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800dac2:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800dac6:	68b9      	ldr	r1, [r7, #8]
 800dac8:	5c89      	ldrb	r1, [r1, r2]
 800daca:	69fa      	ldr	r2, [r7, #28]
 800dacc:	4413      	add	r3, r2
 800dace:	460a      	mov	r2, r1
 800dad0:	719a      	strb	r2, [r3, #6]
  while(k > 0) {
 800dad2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800dad6:	2b00      	cmp	r3, #0
 800dad8:	d1cf      	bne.n	800da7a <etharp_raw+0x6a>
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
 800dada:	69bb      	ldr	r3, [r7, #24]
 800dadc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800dade:	330e      	adds	r3, #14
 800dae0:	6812      	ldr	r2, [r2, #0]
 800dae2:	601a      	str	r2, [r3, #0]
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
 800dae4:	69bb      	ldr	r3, [r7, #24]
 800dae6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800dae8:	3318      	adds	r3, #24
 800daea:	6812      	ldr	r2, [r2, #0]
 800daec:	601a      	str	r2, [r3, #0]

  hdr->hwtype = htons(HWTYPE_ETHERNET);
 800daee:	2001      	movs	r0, #1
 800daf0:	f7f9 f8ba 	bl	8006c68 <htons>
 800daf4:	4603      	mov	r3, r0
 800daf6:	461a      	mov	r2, r3
 800daf8:	69bb      	ldr	r3, [r7, #24]
 800dafa:	801a      	strh	r2, [r3, #0]
  hdr->proto = htons(ETHTYPE_IP);
 800dafc:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800db00:	f7f9 f8b2 	bl	8006c68 <htons>
 800db04:	4603      	mov	r3, r0
 800db06:	461a      	mov	r2, r3
 800db08:	69bb      	ldr	r3, [r7, #24]
 800db0a:	805a      	strh	r2, [r3, #2]
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
 800db0c:	f240 6004 	movw	r0, #1540	; 0x604
 800db10:	f7f9 f8aa 	bl	8006c68 <htons>
 800db14:	4603      	mov	r3, r0
 800db16:	461a      	mov	r2, r3
 800db18:	69bb      	ldr	r3, [r7, #24]
 800db1a:	809a      	strh	r2, [r3, #4]

  ethhdr->type = htons(ETHTYPE_ARP);
 800db1c:	f640 0006 	movw	r0, #2054	; 0x806
 800db20:	f7f9 f8a2 	bl	8006c68 <htons>
 800db24:	4603      	mov	r3, r0
 800db26:	461a      	mov	r2, r3
 800db28:	69fb      	ldr	r3, [r7, #28]
 800db2a:	819a      	strh	r2, [r3, #12]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 800db2c:	68fb      	ldr	r3, [r7, #12]
 800db2e:	699b      	ldr	r3, [r3, #24]
 800db30:	6a39      	ldr	r1, [r7, #32]
 800db32:	68f8      	ldr	r0, [r7, #12]
 800db34:	4798      	blx	r3
 800db36:	4603      	mov	r3, r0
 800db38:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 800db3c:	6a38      	ldr	r0, [r7, #32]
 800db3e:	f7fa fe34 	bl	80087aa <pbuf_free>
  p = NULL;
 800db42:	2300      	movs	r3, #0
 800db44:	623b      	str	r3, [r7, #32]
  /* could not allocate pbuf for ARP request */

  return result;
 800db46:	f997 3026 	ldrsb.w	r3, [r7, #38]	; 0x26
}
 800db4a:	4618      	mov	r0, r3
 800db4c:	3728      	adds	r7, #40	; 0x28
 800db4e:	46bd      	mov	sp, r7
 800db50:	bd80      	pop	{r7, pc}
 800db52:	bf00      	nop
 800db54:	0801b5b0 	.word	0x0801b5b0

0800db58 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
 800db58:	b580      	push	{r7, lr}
 800db5a:	b086      	sub	sp, #24
 800db5c:	af04      	add	r7, sp, #16
 800db5e:	6078      	str	r0, [r7, #4]
 800db60:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800db62:	687b      	ldr	r3, [r7, #4]
 800db64:	f103 012b 	add.w	r1, r3, #43	; 0x2b
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 800db68:	687b      	ldr	r3, [r7, #4]
 800db6a:	f103 002b 	add.w	r0, r3, #43	; 0x2b
 800db6e:	687b      	ldr	r3, [r7, #4]
 800db70:	3304      	adds	r3, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800db72:	2201      	movs	r2, #1
 800db74:	9203      	str	r2, [sp, #12]
 800db76:	683a      	ldr	r2, [r7, #0]
 800db78:	9202      	str	r2, [sp, #8]
 800db7a:	4a06      	ldr	r2, [pc, #24]	; (800db94 <etharp_request+0x3c>)
 800db7c:	9201      	str	r2, [sp, #4]
 800db7e:	9300      	str	r3, [sp, #0]
 800db80:	4603      	mov	r3, r0
 800db82:	4a05      	ldr	r2, [pc, #20]	; (800db98 <etharp_request+0x40>)
 800db84:	6878      	ldr	r0, [r7, #4]
 800db86:	f7ff ff43 	bl	800da10 <etharp_raw>
 800db8a:	4603      	mov	r3, r0
                    ipaddr, ARP_REQUEST);
}
 800db8c:	4618      	mov	r0, r3
 800db8e:	3708      	adds	r7, #8
 800db90:	46bd      	mov	sp, r7
 800db92:	bd80      	pop	{r7, pc}
 800db94:	0801b5b8 	.word	0x0801b5b8
 800db98:	0801b5b0 	.word	0x0801b5b0

0800db9c <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 800db9c:	b580      	push	{r7, lr}
 800db9e:	b084      	sub	sp, #16
 800dba0:	af00      	add	r7, sp, #0
 800dba2:	6078      	str	r0, [r7, #4]
 800dba4:	6039      	str	r1, [r7, #0]
  struct eth_hdr* ethhdr;
  u16_t type;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
 800dba6:	687b      	ldr	r3, [r7, #4]
 800dba8:	685b      	ldr	r3, [r3, #4]
 800dbaa:	60fb      	str	r3, [r7, #12]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = htons(ethhdr->type);
 800dbac:	68fb      	ldr	r3, [r7, #12]
 800dbae:	899b      	ldrh	r3, [r3, #12]
 800dbb0:	b29b      	uxth	r3, r3
 800dbb2:	4618      	mov	r0, r3
 800dbb4:	f7f9 f858 	bl	8006c68 <htons>
 800dbb8:	4603      	mov	r3, r0
 800dbba:	817b      	strh	r3, [r7, #10]
#endif /* ETHARP_VLAN_CHECK */
    type = htons(vlan->tpid);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  switch (type) {
 800dbbc:	897b      	ldrh	r3, [r7, #10]
 800dbbe:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800dbc2:	d004      	beq.n	800dbce <ethernet_input+0x32>
 800dbc4:	f640 0206 	movw	r2, #2054	; 0x806
 800dbc8:	4293      	cmp	r3, r2
 800dbca:	d017      	beq.n	800dbfc <ethernet_input+0x60>
 800dbcc:	e01e      	b.n	800dc0c <ethernet_input+0x70>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
 800dbce:	6879      	ldr	r1, [r7, #4]
 800dbd0:	6838      	ldr	r0, [r7, #0]
 800dbd2:	f7ff fc59 	bl	800d488 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)SIZEOF_ETH_HDR)) {
 800dbd6:	f06f 010d 	mvn.w	r1, #13
 800dbda:	6878      	ldr	r0, [r7, #4]
 800dbdc:	f7fa fd76 	bl	80086cc <pbuf_header>
 800dbe0:	4603      	mov	r3, r0
 800dbe2:	2b00      	cmp	r3, #0
 800dbe4:	d005      	beq.n	800dbf2 <ethernet_input+0x56>
        LWIP_ASSERT("Can't move over header in packet", 0);
        pbuf_free(p);
 800dbe6:	6878      	ldr	r0, [r7, #4]
 800dbe8:	f7fa fddf 	bl	80087aa <pbuf_free>
        p = NULL;
 800dbec:	2300      	movs	r3, #0
 800dbee:	607b      	str	r3, [r7, #4]
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
      }
      break;
 800dbf0:	e012      	b.n	800dc18 <ethernet_input+0x7c>
        ip_input(p, netif);
 800dbf2:	6839      	ldr	r1, [r7, #0]
 800dbf4:	6878      	ldr	r0, [r7, #4]
 800dbf6:	f7f9 f961 	bl	8006ebc <ip_input>
      break;
 800dbfa:	e00d      	b.n	800dc18 <ethernet_input+0x7c>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 800dbfc:	683b      	ldr	r3, [r7, #0]
 800dbfe:	332b      	adds	r3, #43	; 0x2b
 800dc00:	687a      	ldr	r2, [r7, #4]
 800dc02:	4619      	mov	r1, r3
 800dc04:	6838      	ldr	r0, [r7, #0]
 800dc06:	f7ff fc67 	bl	800d4d8 <etharp_arp_input>
      break;
 800dc0a:	e005      	b.n	800dc18 <ethernet_input+0x7c>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
 800dc0c:	6878      	ldr	r0, [r7, #4]
 800dc0e:	f7fa fdcc 	bl	80087aa <pbuf_free>
      p = NULL;
 800dc12:	2300      	movs	r3, #0
 800dc14:	607b      	str	r3, [r7, #4]
      break;
 800dc16:	bf00      	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
 800dc18:	2300      	movs	r3, #0
}
 800dc1a:	4618      	mov	r0, r3
 800dc1c:	3710      	adds	r7, #16
 800dc1e:	46bd      	mov	sp, r7
 800dc20:	bd80      	pop	{r7, pc}
	...

0800dc24 <NVIC_SetPriorityGrouping>:
{
 800dc24:	b480      	push	{r7}
 800dc26:	b085      	sub	sp, #20
 800dc28:	af00      	add	r7, sp, #0
 800dc2a:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
 800dc2c:	687b      	ldr	r3, [r7, #4]
 800dc2e:	f003 0307 	and.w	r3, r3, #7
 800dc32:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800dc34:	4b0c      	ldr	r3, [pc, #48]	; (800dc68 <NVIC_SetPriorityGrouping+0x44>)
 800dc36:	68db      	ldr	r3, [r3, #12]
 800dc38:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 800dc3a:	68ba      	ldr	r2, [r7, #8]
 800dc3c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800dc40:	4013      	ands	r3, r2
 800dc42:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 800dc44:	68fb      	ldr	r3, [r7, #12]
 800dc46:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
 800dc48:	68bb      	ldr	r3, [r7, #8]
 800dc4a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                 |
 800dc4c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800dc50:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800dc54:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800dc56:	4a04      	ldr	r2, [pc, #16]	; (800dc68 <NVIC_SetPriorityGrouping+0x44>)
 800dc58:	68bb      	ldr	r3, [r7, #8]
 800dc5a:	60d3      	str	r3, [r2, #12]
}
 800dc5c:	bf00      	nop
 800dc5e:	3714      	adds	r7, #20
 800dc60:	46bd      	mov	sp, r7
 800dc62:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc66:	4770      	bx	lr
 800dc68:	e000ed00 	.word	0xe000ed00

0800dc6c <main>:
 * @brief  Main program.
 * @param  None
 * @retval None
 */
int main(void)
{
 800dc6c:	b580      	push	{r7, lr}
 800dc6e:	b082      	sub	sp, #8
 800dc70:	af02      	add	r7, sp, #8
	 168 MHz, this is done through SystemInit() function which is called from
	 startup file (startup_stm32f4xx.s) before to branch to application main.
	 To reconfigure the default setting of SystemInit() function, refer to
	 system_stm32f4xx.c file
	 */
	prvSetupHardware();
 800dc72:	f000 f88d 	bl	800dd90 <prvSetupHardware>

	RCC_GetClocksFreq(&RCC_Clocks);
 800dc76:	481f      	ldr	r0, [pc, #124]	; (800dcf4 <main+0x88>)
 800dc78:	f7f6 fda4 	bl	80047c4 <RCC_GetClocksFreq>
	DebugComPort_Init();
	printf("STM32DISCOVERY is booting...\r\n");
#endif

	/*Initialize LCD and Leds */
	LCD_LED_Init();
 800dc7c:	f000 f8d8 	bl	800de30 <LCD_LED_Init>

	/*Initialize User push button */
	STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_GPIO);
 800dc80:	2100      	movs	r1, #0
 800dc82:	2000      	movs	r0, #0
 800dc84:	f000 f960 	bl	800df48 <STM_EVAL_PBInit>

	/* configure ethernet (GPIOs, clocks, MAC, DMA) */
	ETH_BSP_Config();
 800dc88:	f7f5 ff54 	bl	8003b34 <ETH_BSP_Config>

	/* Initilaize the LwIP stack */
	LwIP_Init();
 800dc8c:	f7ff f8ac 	bl	800cde8 <LwIP_Init>

	/* Http webserver Init */
	httpd_init();
 800dc90:	f7f8 f880 	bl	8005d94 <httpd_init>

    /* udp echo server Init */
    udp_echoserver_init();
 800dc94:	f000 fbbc 	bl	800e410 <udp_echoserver_init>
    udp_client_init();
 800dc98:	f000 fc2c 	bl	800e4f4 <udp_client_init>

  //--------------------------- Creacion de las tareas del FreeRTOS ---------------------------
	xTaskCreate(BlinkRED, (char *) "BlinkyRED", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
 800dc9c:	2300      	movs	r3, #0
 800dc9e:	9301      	str	r3, [sp, #4]
 800dca0:	2301      	movs	r3, #1
 800dca2:	9300      	str	r3, [sp, #0]
 800dca4:	2300      	movs	r3, #0
 800dca6:	2282      	movs	r2, #130	; 0x82
 800dca8:	4913      	ldr	r1, [pc, #76]	; (800dcf8 <main+0x8c>)
 800dcaa:	4814      	ldr	r0, [pc, #80]	; (800dcfc <main+0x90>)
 800dcac:	f7f3 fe92 	bl	80019d4 <xTaskCreate>
	xTaskCreate(BlinkBLUE, (char *) "BlinkyBLUE", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
 800dcb0:	2300      	movs	r3, #0
 800dcb2:	9301      	str	r3, [sp, #4]
 800dcb4:	2301      	movs	r3, #1
 800dcb6:	9300      	str	r3, [sp, #0]
 800dcb8:	2300      	movs	r3, #0
 800dcba:	2282      	movs	r2, #130	; 0x82
 800dcbc:	4910      	ldr	r1, [pc, #64]	; (800dd00 <main+0x94>)
 800dcbe:	4811      	ldr	r0, [pc, #68]	; (800dd04 <main+0x98>)
 800dcc0:	f7f3 fe88 	bl	80019d4 <xTaskCreate>
	xTaskCreate(BlinkORANGE, (char *) "BlinkyORANGE", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
 800dcc4:	2300      	movs	r3, #0
 800dcc6:	9301      	str	r3, [sp, #4]
 800dcc8:	2301      	movs	r3, #1
 800dcca:	9300      	str	r3, [sp, #0]
 800dccc:	2300      	movs	r3, #0
 800dcce:	2282      	movs	r2, #130	; 0x82
 800dcd0:	490d      	ldr	r1, [pc, #52]	; (800dd08 <main+0x9c>)
 800dcd2:	480e      	ldr	r0, [pc, #56]	; (800dd0c <main+0xa0>)
 800dcd4:	f7f3 fe7e 	bl	80019d4 <xTaskCreate>
	xTaskCreate(Lee_DP, (char *) "Lee_DP", 2 * configMINIMAL_STACK_SIZE, NULL, 1, NULL);
 800dcd8:	2300      	movs	r3, #0
 800dcda:	9301      	str	r3, [sp, #4]
 800dcdc:	2301      	movs	r3, #1
 800dcde:	9300      	str	r3, [sp, #0]
 800dce0:	2300      	movs	r3, #0
 800dce2:	f44f 7282 	mov.w	r2, #260	; 0x104
 800dce6:	490a      	ldr	r1, [pc, #40]	; (800dd10 <main+0xa4>)
 800dce8:	480a      	ldr	r0, [pc, #40]	; (800dd14 <main+0xa8>)
 800dcea:	f7f3 fe73 	bl	80019d4 <xTaskCreate>

//    //Inicia FreeRTOS
	vTaskStartScheduler();
 800dcee:	f7f3 ffcf 	bl	8001c90 <vTaskStartScheduler>
	//-------------------------------------------------------------------------------------------

	for (;;);
 800dcf2:	e7fe      	b.n	800dcf2 <main+0x86>
 800dcf4:	2000a37c 	.word	0x2000a37c
 800dcf8:	0800e844 	.word	0x0800e844
 800dcfc:	0800dd9f 	.word	0x0800dd9f
 800dd00:	0800e850 	.word	0x0800e850
 800dd04:	0800ddb7 	.word	0x0800ddb7
 800dd08:	0800e85c 	.word	0x0800e85c
 800dd0c:	0800ddcf 	.word	0x0800ddcf
 800dd10:	0800e86c 	.word	0x0800e86c
 800dd14:	0800dd19 	.word	0x0800dd19

0800dd18 <Lee_DP>:
}

/* Chequea frames recibidos */
void Lee_DP(void *pvParameters)
{
 800dd18:	b580      	push	{r7, lr}
 800dd1a:	b084      	sub	sp, #16
 800dd1c:	af00      	add	r7, sp, #0
 800dd1e:	6078      	str	r0, [r7, #4]
	uint8_t rx=0, but=0;
 800dd20:	2300      	movs	r3, #0
 800dd22:	73bb      	strb	r3, [r7, #14]
 800dd24:	2300      	movs	r3, #0
 800dd26:	73fb      	strb	r3, [r7, #15]
	struct ip_addr dest_addr;

	while (1)
	{
		/* check if any packet received */
		if( (rx=ETH_CheckFrameReceived()) != 0 )
 800dd28:	f7f5 fcb6 	bl	8003698 <ETH_CheckFrameReceived>
 800dd2c:	4603      	mov	r3, r0
 800dd2e:	73bb      	strb	r3, [r7, #14]
 800dd30:	7bbb      	ldrb	r3, [r7, #14]
 800dd32:	2b00      	cmp	r3, #0
 800dd34:	d001      	beq.n	800dd3a <Lee_DP+0x22>
		{
			/* process received ethernet packet */
			LwIP_Pkt_Handle();
 800dd36:	f7ff f893 	bl	800ce60 <LwIP_Pkt_Handle>
		}
		/* handle periodic timers for LwIP */
		LwIP_Periodic_Handle(LocalTime);
 800dd3a:	4b12      	ldr	r3, [pc, #72]	; (800dd84 <Lee_DP+0x6c>)
 800dd3c:	681b      	ldr	r3, [r3, #0]
 800dd3e:	4618      	mov	r0, r3
 800dd40:	f7ff f898 	bl	800ce74 <LwIP_Periodic_Handle>

		if(!rx)
 800dd44:	7bbb      	ldrb	r3, [r7, #14]
 800dd46:	2b00      	cmp	r3, #0
 800dd48:	d102      	bne.n	800dd50 <Lee_DP+0x38>
		{
			vTaskDelay(DelayDP/portTICK_RATE_MS);		//Delay de 10mseg
 800dd4a:	200a      	movs	r0, #10
 800dd4c:	f7f3 ff6c 	bl	8001c28 <vTaskDelay>
		}

		if( STM_EVAL_PBGetState(BUTTON_USER) == 1 )
 800dd50:	2000      	movs	r0, #0
 800dd52:	f000 f945 	bl	800dfe0 <STM_EVAL_PBGetState>
 800dd56:	4603      	mov	r3, r0
 800dd58:	2b01      	cmp	r3, #1
 800dd5a:	d10f      	bne.n	800dd7c <Lee_DP+0x64>
		{
			if(but==0)
 800dd5c:	7bfb      	ldrb	r3, [r7, #15]
 800dd5e:	2b00      	cmp	r3, #0
 800dd60:	d1e2      	bne.n	800dd28 <Lee_DP+0x10>
			{
				but = 1;
 800dd62:	2301      	movs	r3, #1
 800dd64:	73fb      	strb	r3, [r7, #15]
				dest_addr.addr = IPV4_ADDR(192,168,1,109);		//Direccin IP de mi PC para pruebas del Ciente UDP
 800dd66:	4b08      	ldr	r3, [pc, #32]	; (800dd88 <Lee_DP+0x70>)
 800dd68:	60bb      	str	r3, [r7, #8]

				udp_client(&dest_addr, 8000,"HELLO WORLD!");
 800dd6a:	f107 0308 	add.w	r3, r7, #8
 800dd6e:	4a07      	ldr	r2, [pc, #28]	; (800dd8c <Lee_DP+0x74>)
 800dd70:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
 800dd74:	4618      	mov	r0, r3
 800dd76:	f000 fbf5 	bl	800e564 <udp_client>
 800dd7a:	e7d5      	b.n	800dd28 <Lee_DP+0x10>
			}
		}else{
			but = 0;
 800dd7c:	2300      	movs	r3, #0
 800dd7e:	73fb      	strb	r3, [r7, #15]
		if( (rx=ETH_CheckFrameReceived()) != 0 )
 800dd80:	e7d2      	b.n	800dd28 <Lee_DP+0x10>
 800dd82:	bf00      	nop
 800dd84:	20007d3c 	.word	0x20007d3c
 800dd88:	6d01a8c0 	.word	0x6d01a8c0
 800dd8c:	0800e874 	.word	0x0800e874

0800dd90 <prvSetupHardware>:
		}
	}
}

static void prvSetupHardware(void)
{
 800dd90:	b580      	push	{r7, lr}
 800dd92:	af00      	add	r7, sp, #0
	/* Ensure all priority bits are assigned as preemption priority bits.
	 http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	NVIC_SetPriorityGrouping(0);
 800dd94:	2000      	movs	r0, #0
 800dd96:	f7ff ff45 	bl	800dc24 <NVIC_SetPriorityGrouping>

	/* TODO: Setup the clocks, etc. here, if they were not configured before
	 main() was called. */
}
 800dd9a:	bf00      	nop
 800dd9c:	bd80      	pop	{r7, pc}

0800dd9e <BlinkRED>:

//--------------------------------------------------------------
// FreeRTOS-Task "BlinkRED"
//--------------------------------------------------------------
void BlinkRED(void *pvParameters)
{
 800dd9e:	b580      	push	{r7, lr}
 800dda0:	b082      	sub	sp, #8
 800dda2:	af00      	add	r7, sp, #0
 800dda4:	6078      	str	r0, [r7, #4]
	while (1)
	{
		STM_EVAL_LEDToggle(LED5);						//Togglea led Rojo
 800dda6:	2002      	movs	r0, #2
 800dda8:	f000 f8b0 	bl	800df0c <STM_EVAL_LEDToggle>

		vTaskDelay(DelayRED / portTICK_RATE_MS);		//Delay de 1seg
 800ddac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800ddb0:	f7f3 ff3a 	bl	8001c28 <vTaskDelay>
		STM_EVAL_LEDToggle(LED5);						//Togglea led Rojo
 800ddb4:	e7f7      	b.n	800dda6 <BlinkRED+0x8>

0800ddb6 <BlinkBLUE>:

//--------------------------------------------------------------
// FreeRTOS-Task "BlinkBLUE"
//--------------------------------------------------------------
void BlinkBLUE(void *pvParameters)
{
 800ddb6:	b580      	push	{r7, lr}
 800ddb8:	b082      	sub	sp, #8
 800ddba:	af00      	add	r7, sp, #0
 800ddbc:	6078      	str	r0, [r7, #4]
	while (1)
	{
		STM_EVAL_LEDToggle(LED6);						//Togglea led Azul
 800ddbe:	2003      	movs	r0, #3
 800ddc0:	f000 f8a4 	bl	800df0c <STM_EVAL_LEDToggle>

		vTaskDelay(DelayBLUE / portTICK_RATE_MS);		//Delay de 500mseg
 800ddc4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800ddc8:	f7f3 ff2e 	bl	8001c28 <vTaskDelay>
		STM_EVAL_LEDToggle(LED6);						//Togglea led Azul
 800ddcc:	e7f7      	b.n	800ddbe <BlinkBLUE+0x8>

0800ddce <BlinkORANGE>:

//--------------------------------------------------------------
// FreeRTOS-Task "BlinkORANGE"
//--------------------------------------------------------------
void BlinkORANGE(void *pvParameters)
{
 800ddce:	b580      	push	{r7, lr}
 800ddd0:	b082      	sub	sp, #8
 800ddd2:	af00      	add	r7, sp, #0
 800ddd4:	6078      	str	r0, [r7, #4]
	while (1)
	{
		STM_EVAL_LEDToggle(LED3);					//Togglea led Naranja
 800ddd6:	2001      	movs	r0, #1
 800ddd8:	f000 f898 	bl	800df0c <STM_EVAL_LEDToggle>

		vTaskDelay(DelayORANGE / portTICK_RATE_MS);		//Delay de 200mseg
 800dddc:	20c8      	movs	r0, #200	; 0xc8
 800ddde:	f7f3 ff23 	bl	8001c28 <vTaskDelay>
		STM_EVAL_LEDToggle(LED3);					//Togglea led Naranja
 800dde2:	e7f8      	b.n	800ddd6 <BlinkORANGE+0x8>

0800dde4 <vApplicationTickHook>:
	}
}

void vApplicationTickHook(void)
{
 800dde4:	b480      	push	{r7}
 800dde6:	af00      	add	r7, sp, #0
	/* Esta funcion se habilita poniendo en 1 configUSE_TICK_HOOK en
	 * el archivo FreeRTOSConfig.h.*/

}
 800dde8:	bf00      	nop
 800ddea:	46bd      	mov	sp, r7
 800ddec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddf0:	4770      	bx	lr
	...

0800ddf4 <Time_Update>:
 * @brief  Updates the system local time
 * @param  None
 * @retval None
 */
void Time_Update(void)									//llamada desde SysTick_Handler en port.c cada 10mSeg
{
 800ddf4:	b580      	push	{r7, lr}
 800ddf6:	af00      	add	r7, sp, #0
	LocalTime += SYSTEMTICK_PERIOD_MS;
 800ddf8:	4b0b      	ldr	r3, [pc, #44]	; (800de28 <Time_Update+0x34>)
 800ddfa:	681b      	ldr	r3, [r3, #0]
 800ddfc:	330a      	adds	r3, #10
 800ddfe:	4a0a      	ldr	r2, [pc, #40]	; (800de28 <Time_Update+0x34>)
 800de00:	6013      	str	r3, [r2, #0]
	static int i = 0;
	if (i == 1000)
 800de02:	4b0a      	ldr	r3, [pc, #40]	; (800de2c <Time_Update+0x38>)
 800de04:	681b      	ldr	r3, [r3, #0]
 800de06:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800de0a:	d105      	bne.n	800de18 <Time_Update+0x24>
	{
		STM_EVAL_LEDToggle(LED4);						//Togglea led Verde cada 10 seg
 800de0c:	2000      	movs	r0, #0
 800de0e:	f000 f87d 	bl	800df0c <STM_EVAL_LEDToggle>
		i = 0;
 800de12:	4b06      	ldr	r3, [pc, #24]	; (800de2c <Time_Update+0x38>)
 800de14:	2200      	movs	r2, #0
 800de16:	601a      	str	r2, [r3, #0]
	}
	++i;
 800de18:	4b04      	ldr	r3, [pc, #16]	; (800de2c <Time_Update+0x38>)
 800de1a:	681b      	ldr	r3, [r3, #0]
 800de1c:	3301      	adds	r3, #1
 800de1e:	4a03      	ldr	r2, [pc, #12]	; (800de2c <Time_Update+0x38>)
 800de20:	6013      	str	r3, [r2, #0]
}
 800de22:	bf00      	nop
 800de24:	bd80      	pop	{r7, pc}
 800de26:	bf00      	nop
 800de28:	20007d3c 	.word	0x20007d3c
 800de2c:	20007d40 	.word	0x20007d40

0800de30 <LCD_LED_Init>:
 * @brief  Initializes the STM324xG-EVAL's LCD and LEDs resources.
 * @param  None
 * @retval None
 */
void LCD_LED_Init(void)
{
 800de30:	b580      	push	{r7, lr}
 800de32:	af00      	add	r7, sp, #0
	/* Initialize the STM324xG-EVAL's LCD */
	STM324xG_LCD_Init();
#endif

	/* Initialize STM324xG-EVAL's LEDs */
	STM_EVAL_LEDInit(LED5);
 800de34:	2002      	movs	r0, #2
 800de36:	f000 f80b 	bl	800de50 <STM_EVAL_LEDInit>
	STM_EVAL_LEDInit(LED6);
 800de3a:	2003      	movs	r0, #3
 800de3c:	f000 f808 	bl	800de50 <STM_EVAL_LEDInit>
	STM_EVAL_LEDInit(LED3);
 800de40:	2001      	movs	r0, #1
 800de42:	f000 f805 	bl	800de50 <STM_EVAL_LEDInit>
	STM_EVAL_LEDInit(LED4);
 800de46:	2000      	movs	r0, #0
 800de48:	f000 f802 	bl	800de50 <STM_EVAL_LEDInit>
	LCD_DisplayStringLine(Line0, (uint8_t*)MESSAGE1);
	LCD_DisplayStringLine(Line1, (uint8_t*)MESSAGE2);
	LCD_DisplayStringLine(Line2, (uint8_t*)MESSAGE3);
	LCD_DisplayStringLine(Line3, (uint8_t*)MESSAGE4);
#endif
}
 800de4c:	bf00      	nop
 800de4e:	bd80      	pop	{r7, pc}

0800de50 <STM_EVAL_LEDInit>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 800de50:	b580      	push	{r7, lr}
 800de52:	b084      	sub	sp, #16
 800de54:	af00      	add	r7, sp, #0
 800de56:	4603      	mov	r3, r0
 800de58:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 800de5a:	79fb      	ldrb	r3, [r7, #7]
 800de5c:	4a10      	ldr	r2, [pc, #64]	; (800dea0 <STM_EVAL_LEDInit+0x50>)
 800de5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800de62:	2101      	movs	r1, #1
 800de64:	4618      	mov	r0, r3
 800de66:	f7f6 fd55 	bl	8004914 <RCC_AHB1PeriphClockCmd>

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 800de6a:	79fb      	ldrb	r3, [r7, #7]
 800de6c:	4a0d      	ldr	r2, [pc, #52]	; (800dea4 <STM_EVAL_LEDInit+0x54>)
 800de6e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800de72:	60bb      	str	r3, [r7, #8]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800de74:	2301      	movs	r3, #1
 800de76:	733b      	strb	r3, [r7, #12]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800de78:	2300      	movs	r3, #0
 800de7a:	73bb      	strb	r3, [r7, #14]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800de7c:	2301      	movs	r3, #1
 800de7e:	73fb      	strb	r3, [r7, #15]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800de80:	2302      	movs	r3, #2
 800de82:	737b      	strb	r3, [r7, #13]
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 800de84:	79fb      	ldrb	r3, [r7, #7]
 800de86:	4a08      	ldr	r2, [pc, #32]	; (800dea8 <STM_EVAL_LEDInit+0x58>)
 800de88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800de8c:	f107 0208 	add.w	r2, r7, #8
 800de90:	4611      	mov	r1, r2
 800de92:	4618      	mov	r0, r3
 800de94:	f7f6 fba4 	bl	80045e0 <GPIO_Init>
}
 800de98:	bf00      	nop
 800de9a:	3710      	adds	r7, #16
 800de9c:	46bd      	mov	sp, r7
 800de9e:	bd80      	pop	{r7, pc}
 800dea0:	0801b5c8 	.word	0x0801b5c8
 800dea4:	0801b5c0 	.word	0x0801b5c0
 800dea8:	20000048 	.word	0x20000048

0800deac <STM_EVAL_LEDOn>:
  *     @arg LED5
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDOn(Led_TypeDef Led)
{
 800deac:	b480      	push	{r7}
 800deae:	b083      	sub	sp, #12
 800deb0:	af00      	add	r7, sp, #0
 800deb2:	4603      	mov	r3, r0
 800deb4:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->BSRRL = GPIO_PIN[Led];
 800deb6:	79fb      	ldrb	r3, [r7, #7]
 800deb8:	4a06      	ldr	r2, [pc, #24]	; (800ded4 <STM_EVAL_LEDOn+0x28>)
 800deba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800debe:	79fa      	ldrb	r2, [r7, #7]
 800dec0:	4905      	ldr	r1, [pc, #20]	; (800ded8 <STM_EVAL_LEDOn+0x2c>)
 800dec2:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 800dec6:	831a      	strh	r2, [r3, #24]
}
 800dec8:	bf00      	nop
 800deca:	370c      	adds	r7, #12
 800decc:	46bd      	mov	sp, r7
 800dece:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ded2:	4770      	bx	lr
 800ded4:	20000048 	.word	0x20000048
 800ded8:	0801b5c0 	.word	0x0801b5c0

0800dedc <STM_EVAL_LEDOff>:
  *     @arg LED5
  *     @arg LED6 
  * @retval None
  */
void STM_EVAL_LEDOff(Led_TypeDef Led)
{
 800dedc:	b480      	push	{r7}
 800dede:	b083      	sub	sp, #12
 800dee0:	af00      	add	r7, sp, #0
 800dee2:	4603      	mov	r3, r0
 800dee4:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->BSRRH = GPIO_PIN[Led];  
 800dee6:	79fb      	ldrb	r3, [r7, #7]
 800dee8:	4a06      	ldr	r2, [pc, #24]	; (800df04 <STM_EVAL_LEDOff+0x28>)
 800deea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800deee:	79fa      	ldrb	r2, [r7, #7]
 800def0:	4905      	ldr	r1, [pc, #20]	; (800df08 <STM_EVAL_LEDOff+0x2c>)
 800def2:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 800def6:	835a      	strh	r2, [r3, #26]
}
 800def8:	bf00      	nop
 800defa:	370c      	adds	r7, #12
 800defc:	46bd      	mov	sp, r7
 800defe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df02:	4770      	bx	lr
 800df04:	20000048 	.word	0x20000048
 800df08:	0801b5c0 	.word	0x0801b5c0

0800df0c <STM_EVAL_LEDToggle>:
  *     @arg LED5
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDToggle(Led_TypeDef Led)
{
 800df0c:	b480      	push	{r7}
 800df0e:	b083      	sub	sp, #12
 800df10:	af00      	add	r7, sp, #0
 800df12:	4603      	mov	r3, r0
 800df14:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
 800df16:	79fb      	ldrb	r3, [r7, #7]
 800df18:	4a09      	ldr	r2, [pc, #36]	; (800df40 <STM_EVAL_LEDToggle+0x34>)
 800df1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800df1e:	79fa      	ldrb	r2, [r7, #7]
 800df20:	4907      	ldr	r1, [pc, #28]	; (800df40 <STM_EVAL_LEDToggle+0x34>)
 800df22:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800df26:	6952      	ldr	r2, [r2, #20]
 800df28:	79f9      	ldrb	r1, [r7, #7]
 800df2a:	4806      	ldr	r0, [pc, #24]	; (800df44 <STM_EVAL_LEDToggle+0x38>)
 800df2c:	f830 1011 	ldrh.w	r1, [r0, r1, lsl #1]
 800df30:	404a      	eors	r2, r1
 800df32:	615a      	str	r2, [r3, #20]
}
 800df34:	bf00      	nop
 800df36:	370c      	adds	r7, #12
 800df38:	46bd      	mov	sp, r7
 800df3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df3e:	4770      	bx	lr
 800df40:	20000048 	.word	0x20000048
 800df44:	0801b5c0 	.word	0x0801b5c0

0800df48 <STM_EVAL_PBInit>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval None
  */
void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 800df48:	b580      	push	{r7, lr}
 800df4a:	b088      	sub	sp, #32
 800df4c:	af00      	add	r7, sp, #0
 800df4e:	4603      	mov	r3, r0
 800df50:	460a      	mov	r2, r1
 800df52:	71fb      	strb	r3, [r7, #7]
 800df54:	4613      	mov	r3, r2
 800df56:	71bb      	strb	r3, [r7, #6]
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the BUTTON Clock */
  RCC_AHB1PeriphClockCmd(BUTTON_CLK[Button], ENABLE);
 800df58:	2301      	movs	r3, #1
 800df5a:	2101      	movs	r1, #1
 800df5c:	4618      	mov	r0, r3
 800df5e:	f7f6 fcd9 	bl	8004914 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800df62:	2101      	movs	r1, #1
 800df64:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800df68:	f7f6 fcf4 	bl	8004954 <RCC_APB2PeriphClockCmd>

  /* Configure Button pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800df6c:	2300      	movs	r3, #0
 800df6e:	773b      	strb	r3, [r7, #28]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800df70:	2300      	movs	r3, #0
 800df72:	77fb      	strb	r3, [r7, #31]
  GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
 800df74:	2301      	movs	r3, #1
 800df76:	61bb      	str	r3, [r7, #24]
  GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 800df78:	79fb      	ldrb	r3, [r7, #7]
 800df7a:	4a18      	ldr	r2, [pc, #96]	; (800dfdc <STM_EVAL_PBInit+0x94>)
 800df7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800df80:	f107 0218 	add.w	r2, r7, #24
 800df84:	4611      	mov	r1, r2
 800df86:	4618      	mov	r0, r3
 800df88:	f7f6 fb2a 	bl	80045e0 <GPIO_Init>

  if (Button_Mode == BUTTON_MODE_EXTI)
 800df8c:	79bb      	ldrb	r3, [r7, #6]
 800df8e:	2b01      	cmp	r3, #1
 800df90:	d11f      	bne.n	800dfd2 <STM_EVAL_PBInit+0x8a>
  {
    /* Connect Button EXTI Line to Button GPIO Pin */
    SYSCFG_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);
 800df92:	2300      	movs	r3, #0
 800df94:	2200      	movs	r2, #0
 800df96:	4611      	mov	r1, r2
 800df98:	4618      	mov	r0, r3
 800df9a:	f7f6 fd1b 	bl	80049d4 <SYSCFG_EXTILineConfig>

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
 800df9e:	2301      	movs	r3, #1
 800dfa0:	613b      	str	r3, [r7, #16]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 800dfa2:	2300      	movs	r3, #0
 800dfa4:	753b      	strb	r3, [r7, #20]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
 800dfa6:	2308      	movs	r3, #8
 800dfa8:	757b      	strb	r3, [r7, #21]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800dfaa:	2301      	movs	r3, #1
 800dfac:	75bb      	strb	r3, [r7, #22]
    EXTI_Init(&EXTI_InitStructure);
 800dfae:	f107 0310 	add.w	r3, r7, #16
 800dfb2:	4618      	mov	r0, r3
 800dfb4:	f7f6 fa6e 	bl	8004494 <EXTI_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
 800dfb8:	2306      	movs	r3, #6
 800dfba:	733b      	strb	r3, [r7, #12]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
 800dfbc:	230f      	movs	r3, #15
 800dfbe:	737b      	strb	r3, [r7, #13]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
 800dfc0:	230f      	movs	r3, #15
 800dfc2:	73bb      	strb	r3, [r7, #14]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800dfc4:	2301      	movs	r3, #1
 800dfc6:	73fb      	strb	r3, [r7, #15]

    NVIC_Init(&NVIC_InitStructure); 
 800dfc8:	f107 030c 	add.w	r3, r7, #12
 800dfcc:	4618      	mov	r0, r3
 800dfce:	f7f6 f841 	bl	8004054 <NVIC_Init>
  }
}
 800dfd2:	bf00      	nop
 800dfd4:	3720      	adds	r7, #32
 800dfd6:	46bd      	mov	sp, r7
 800dfd8:	bd80      	pop	{r7, pc}
 800dfda:	bf00      	nop
 800dfdc:	20000058 	.word	0x20000058

0800dfe0 <STM_EVAL_PBGetState>:
  * @param  Button: Specifies the Button to be checked.
  *   This parameter should be: BUTTON_USER  
  * @retval The Button GPIO pin value.
  */
uint32_t STM_EVAL_PBGetState(Button_TypeDef Button)
{
 800dfe0:	b580      	push	{r7, lr}
 800dfe2:	b082      	sub	sp, #8
 800dfe4:	af00      	add	r7, sp, #0
 800dfe6:	4603      	mov	r3, r0
 800dfe8:	71fb      	strb	r3, [r7, #7]
  return GPIO_ReadInputDataBit(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 800dfea:	79fb      	ldrb	r3, [r7, #7]
 800dfec:	4a06      	ldr	r2, [pc, #24]	; (800e008 <STM_EVAL_PBGetState+0x28>)
 800dfee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800dff2:	2201      	movs	r2, #1
 800dff4:	4611      	mov	r1, r2
 800dff6:	4618      	mov	r0, r3
 800dff8:	f7f6 fb80 	bl	80046fc <GPIO_ReadInputDataBit>
 800dffc:	4603      	mov	r3, r0
}
 800dffe:	4618      	mov	r0, r3
 800e000:	3708      	adds	r7, #8
 800e002:	46bd      	mov	sp, r7
 800e004:	bd80      	pop	{r7, pc}
 800e006:	bf00      	nop
 800e008:	20000058 	.word	0x20000058

0800e00c <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 800e00c:	b480      	push	{r7}
 800e00e:	af00      	add	r7, sp, #0
}
 800e010:	bf00      	nop
 800e012:	46bd      	mov	sp, r7
 800e014:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e018:	4770      	bx	lr

0800e01a <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800e01a:	b480      	push	{r7}
 800e01c:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
 800e01e:	e7fe      	b.n	800e01e <HardFault_Handler+0x4>

0800e020 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 800e020:	b480      	push	{r7}
 800e022:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
 800e024:	e7fe      	b.n	800e024 <MemManage_Handler+0x4>

0800e026 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800e026:	b480      	push	{r7}
 800e028:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
 800e02a:	e7fe      	b.n	800e02a <BusFault_Handler+0x4>

0800e02c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 800e02c:	b480      	push	{r7}
 800e02e:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
 800e030:	e7fe      	b.n	800e030 <UsageFault_Handler+0x4>

0800e032 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800e032:	b480      	push	{r7}
 800e034:	af00      	add	r7, sp, #0
}
 800e036:	bf00      	nop
 800e038:	46bd      	mov	sp, r7
 800e03a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e03e:	4770      	bx	lr

0800e040 <EXTI15_10_IRQHandler>:
  * @brief  This function handles External line 10 interrupt request.
  * @param  None
  * @retval None
  */
void EXTI15_10_IRQHandler(void)
{
 800e040:	b580      	push	{r7, lr}
 800e042:	af00      	add	r7, sp, #0
  if(EXTI_GetITStatus(ETH_LINK_EXTI_LINE) != RESET)
 800e044:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800e048:	f7f6 fa96 	bl	8004578 <EXTI_GetITStatus>
 800e04c:	4603      	mov	r3, r0
 800e04e:	2b00      	cmp	r3, #0
 800e050:	d006      	beq.n	800e060 <EXTI15_10_IRQHandler+0x20>
  {
    Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
 800e052:	2001      	movs	r0, #1
 800e054:	f7f5 ff1c 	bl	8003e90 <Eth_Link_ITHandler>
    /* Clear interrupt pending bit */
    EXTI_ClearITPendingBit(ETH_LINK_EXTI_LINE);
 800e058:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800e05c:	f7f6 fab0 	bl	80045c0 <EXTI_ClearITPendingBit>
  }
}
 800e060:	bf00      	nop
 800e062:	bd80      	pop	{r7, pc}

0800e064 <ts_itoa>:
**  Abstract: Convert integer to ascii
**  Returns:  void
**---------------------------------------------------------------------------
*/
void ts_itoa(char **buf, unsigned int d, int base)
{
 800e064:	b480      	push	{r7}
 800e066:	b087      	sub	sp, #28
 800e068:	af00      	add	r7, sp, #0
 800e06a:	60f8      	str	r0, [r7, #12]
 800e06c:	60b9      	str	r1, [r7, #8]
 800e06e:	607a      	str	r2, [r7, #4]
	int div = 1;
 800e070:	2301      	movs	r3, #1
 800e072:	617b      	str	r3, [r7, #20]
	while (d/div >= base)
 800e074:	e004      	b.n	800e080 <ts_itoa+0x1c>
		div *= base;
 800e076:	697b      	ldr	r3, [r7, #20]
 800e078:	687a      	ldr	r2, [r7, #4]
 800e07a:	fb02 f303 	mul.w	r3, r2, r3
 800e07e:	617b      	str	r3, [r7, #20]
	while (d/div >= base)
 800e080:	697b      	ldr	r3, [r7, #20]
 800e082:	68ba      	ldr	r2, [r7, #8]
 800e084:	fbb2 f2f3 	udiv	r2, r2, r3
 800e088:	687b      	ldr	r3, [r7, #4]
 800e08a:	429a      	cmp	r2, r3
 800e08c:	d2f3      	bcs.n	800e076 <ts_itoa+0x12>

	while (div != 0)
 800e08e:	e029      	b.n	800e0e4 <ts_itoa+0x80>
	{
		int num = d/div;
 800e090:	697b      	ldr	r3, [r7, #20]
 800e092:	68ba      	ldr	r2, [r7, #8]
 800e094:	fbb2 f3f3 	udiv	r3, r2, r3
 800e098:	613b      	str	r3, [r7, #16]
		d = d%div;
 800e09a:	697a      	ldr	r2, [r7, #20]
 800e09c:	68bb      	ldr	r3, [r7, #8]
 800e09e:	fbb3 f1f2 	udiv	r1, r3, r2
 800e0a2:	fb02 f201 	mul.w	r2, r2, r1
 800e0a6:	1a9b      	subs	r3, r3, r2
 800e0a8:	60bb      	str	r3, [r7, #8]
		div /= base;
 800e0aa:	697a      	ldr	r2, [r7, #20]
 800e0ac:	687b      	ldr	r3, [r7, #4]
 800e0ae:	fb92 f3f3 	sdiv	r3, r2, r3
 800e0b2:	617b      	str	r3, [r7, #20]
		if (num > 9)
 800e0b4:	693b      	ldr	r3, [r7, #16]
 800e0b6:	2b09      	cmp	r3, #9
 800e0b8:	dd0a      	ble.n	800e0d0 <ts_itoa+0x6c>
			*((*buf)++) = (num-10) + 'A';
 800e0ba:	68fb      	ldr	r3, [r7, #12]
 800e0bc:	681b      	ldr	r3, [r3, #0]
 800e0be:	1c59      	adds	r1, r3, #1
 800e0c0:	68fa      	ldr	r2, [r7, #12]
 800e0c2:	6011      	str	r1, [r2, #0]
 800e0c4:	693a      	ldr	r2, [r7, #16]
 800e0c6:	b2d2      	uxtb	r2, r2
 800e0c8:	3237      	adds	r2, #55	; 0x37
 800e0ca:	b2d2      	uxtb	r2, r2
 800e0cc:	701a      	strb	r2, [r3, #0]
 800e0ce:	e009      	b.n	800e0e4 <ts_itoa+0x80>
		else
			*((*buf)++) = num + '0';
 800e0d0:	68fb      	ldr	r3, [r7, #12]
 800e0d2:	681b      	ldr	r3, [r3, #0]
 800e0d4:	1c59      	adds	r1, r3, #1
 800e0d6:	68fa      	ldr	r2, [r7, #12]
 800e0d8:	6011      	str	r1, [r2, #0]
 800e0da:	693a      	ldr	r2, [r7, #16]
 800e0dc:	b2d2      	uxtb	r2, r2
 800e0de:	3230      	adds	r2, #48	; 0x30
 800e0e0:	b2d2      	uxtb	r2, r2
 800e0e2:	701a      	strb	r2, [r3, #0]
	while (div != 0)
 800e0e4:	697b      	ldr	r3, [r7, #20]
 800e0e6:	2b00      	cmp	r3, #0
 800e0e8:	d1d2      	bne.n	800e090 <ts_itoa+0x2c>
	}
}
 800e0ea:	bf00      	nop
 800e0ec:	371c      	adds	r7, #28
 800e0ee:	46bd      	mov	sp, r7
 800e0f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e0f4:	4770      	bx	lr

0800e0f6 <ts_formatstring>:
**  Abstract: Writes arguments va to buffer buf according to format fmt
**  Returns:  Length of string
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
{
 800e0f6:	b580      	push	{r7, lr}
 800e0f8:	b088      	sub	sp, #32
 800e0fa:	af00      	add	r7, sp, #0
 800e0fc:	60f8      	str	r0, [r7, #12]
 800e0fe:	60b9      	str	r1, [r7, #8]
 800e100:	607a      	str	r2, [r7, #4]
	char *start_buf = buf;
 800e102:	68fb      	ldr	r3, [r7, #12]
 800e104:	617b      	str	r3, [r7, #20]
	while(*fmt)
 800e106:	e07d      	b.n	800e204 <ts_formatstring+0x10e>
	{
		/* Character needs formating? */
		if (*fmt == '%')
 800e108:	68bb      	ldr	r3, [r7, #8]
 800e10a:	781b      	ldrb	r3, [r3, #0]
 800e10c:	2b25      	cmp	r3, #37	; 0x25
 800e10e:	d171      	bne.n	800e1f4 <ts_formatstring+0xfe>
		{
			switch (*(++fmt))
 800e110:	68bb      	ldr	r3, [r7, #8]
 800e112:	3301      	adds	r3, #1
 800e114:	60bb      	str	r3, [r7, #8]
 800e116:	68bb      	ldr	r3, [r7, #8]
 800e118:	781b      	ldrb	r3, [r3, #0]
 800e11a:	2b64      	cmp	r3, #100	; 0x64
 800e11c:	d01e      	beq.n	800e15c <ts_formatstring+0x66>
 800e11e:	2b64      	cmp	r3, #100	; 0x64
 800e120:	dc06      	bgt.n	800e130 <ts_formatstring+0x3a>
 800e122:	2b58      	cmp	r3, #88	; 0x58
 800e124:	d050      	beq.n	800e1c8 <ts_formatstring+0xd2>
 800e126:	2b63      	cmp	r3, #99	; 0x63
 800e128:	d00e      	beq.n	800e148 <ts_formatstring+0x52>
 800e12a:	2b25      	cmp	r3, #37	; 0x25
 800e12c:	d058      	beq.n	800e1e0 <ts_formatstring+0xea>
 800e12e:	e05d      	b.n	800e1ec <ts_formatstring+0xf6>
 800e130:	2b73      	cmp	r3, #115	; 0x73
 800e132:	d02b      	beq.n	800e18c <ts_formatstring+0x96>
 800e134:	2b73      	cmp	r3, #115	; 0x73
 800e136:	dc02      	bgt.n	800e13e <ts_formatstring+0x48>
 800e138:	2b69      	cmp	r3, #105	; 0x69
 800e13a:	d00f      	beq.n	800e15c <ts_formatstring+0x66>
 800e13c:	e056      	b.n	800e1ec <ts_formatstring+0xf6>
 800e13e:	2b75      	cmp	r3, #117	; 0x75
 800e140:	d037      	beq.n	800e1b2 <ts_formatstring+0xbc>
 800e142:	2b78      	cmp	r3, #120	; 0x78
 800e144:	d040      	beq.n	800e1c8 <ts_formatstring+0xd2>
 800e146:	e051      	b.n	800e1ec <ts_formatstring+0xf6>
			{
			  case 'c':
				*buf++ = va_arg(va, int);
 800e148:	68fb      	ldr	r3, [r7, #12]
 800e14a:	1c5a      	adds	r2, r3, #1
 800e14c:	60fa      	str	r2, [r7, #12]
 800e14e:	687a      	ldr	r2, [r7, #4]
 800e150:	1d11      	adds	r1, r2, #4
 800e152:	6079      	str	r1, [r7, #4]
 800e154:	6812      	ldr	r2, [r2, #0]
 800e156:	b2d2      	uxtb	r2, r2
 800e158:	701a      	strb	r2, [r3, #0]
				break;
 800e15a:	e047      	b.n	800e1ec <ts_formatstring+0xf6>
			  case 'd':
			  case 'i':
				{
					signed int val = va_arg(va, signed int);
 800e15c:	687b      	ldr	r3, [r7, #4]
 800e15e:	1d1a      	adds	r2, r3, #4
 800e160:	607a      	str	r2, [r7, #4]
 800e162:	681b      	ldr	r3, [r3, #0]
 800e164:	61fb      	str	r3, [r7, #28]
					if (val < 0)
 800e166:	69fb      	ldr	r3, [r7, #28]
 800e168:	2b00      	cmp	r3, #0
 800e16a:	da07      	bge.n	800e17c <ts_formatstring+0x86>
					{
						val *= -1;
 800e16c:	69fb      	ldr	r3, [r7, #28]
 800e16e:	425b      	negs	r3, r3
 800e170:	61fb      	str	r3, [r7, #28]
						*buf++ = '-';
 800e172:	68fb      	ldr	r3, [r7, #12]
 800e174:	1c5a      	adds	r2, r3, #1
 800e176:	60fa      	str	r2, [r7, #12]
 800e178:	222d      	movs	r2, #45	; 0x2d
 800e17a:	701a      	strb	r2, [r3, #0]
					}
					ts_itoa(&buf, val, 10);
 800e17c:	69f9      	ldr	r1, [r7, #28]
 800e17e:	f107 030c 	add.w	r3, r7, #12
 800e182:	220a      	movs	r2, #10
 800e184:	4618      	mov	r0, r3
 800e186:	f7ff ff6d 	bl	800e064 <ts_itoa>
				}
				break;
 800e18a:	e02f      	b.n	800e1ec <ts_formatstring+0xf6>
			  case 's':
				{
					char * arg = va_arg(va, char *);
 800e18c:	687b      	ldr	r3, [r7, #4]
 800e18e:	1d1a      	adds	r2, r3, #4
 800e190:	607a      	str	r2, [r7, #4]
 800e192:	681b      	ldr	r3, [r3, #0]
 800e194:	61bb      	str	r3, [r7, #24]
					while (*arg)
 800e196:	e007      	b.n	800e1a8 <ts_formatstring+0xb2>
					{
						*buf++ = *arg++;
 800e198:	68fb      	ldr	r3, [r7, #12]
 800e19a:	1c5a      	adds	r2, r3, #1
 800e19c:	60fa      	str	r2, [r7, #12]
 800e19e:	69ba      	ldr	r2, [r7, #24]
 800e1a0:	1c51      	adds	r1, r2, #1
 800e1a2:	61b9      	str	r1, [r7, #24]
 800e1a4:	7812      	ldrb	r2, [r2, #0]
 800e1a6:	701a      	strb	r2, [r3, #0]
					while (*arg)
 800e1a8:	69bb      	ldr	r3, [r7, #24]
 800e1aa:	781b      	ldrb	r3, [r3, #0]
 800e1ac:	2b00      	cmp	r3, #0
 800e1ae:	d1f3      	bne.n	800e198 <ts_formatstring+0xa2>
					}
				}
				break;
 800e1b0:	e01c      	b.n	800e1ec <ts_formatstring+0xf6>
			  case 'u':
					ts_itoa(&buf, va_arg(va, unsigned int), 10);
 800e1b2:	687b      	ldr	r3, [r7, #4]
 800e1b4:	1d1a      	adds	r2, r3, #4
 800e1b6:	607a      	str	r2, [r7, #4]
 800e1b8:	6819      	ldr	r1, [r3, #0]
 800e1ba:	f107 030c 	add.w	r3, r7, #12
 800e1be:	220a      	movs	r2, #10
 800e1c0:	4618      	mov	r0, r3
 800e1c2:	f7ff ff4f 	bl	800e064 <ts_itoa>
				break;
 800e1c6:	e011      	b.n	800e1ec <ts_formatstring+0xf6>
			  case 'x':
			  case 'X':
					ts_itoa(&buf, va_arg(va, int), 16);
 800e1c8:	687b      	ldr	r3, [r7, #4]
 800e1ca:	1d1a      	adds	r2, r3, #4
 800e1cc:	607a      	str	r2, [r7, #4]
 800e1ce:	681b      	ldr	r3, [r3, #0]
 800e1d0:	4619      	mov	r1, r3
 800e1d2:	f107 030c 	add.w	r3, r7, #12
 800e1d6:	2210      	movs	r2, #16
 800e1d8:	4618      	mov	r0, r3
 800e1da:	f7ff ff43 	bl	800e064 <ts_itoa>
				break;
 800e1de:	e005      	b.n	800e1ec <ts_formatstring+0xf6>
			  case '%':
				  *buf++ = '%';
 800e1e0:	68fb      	ldr	r3, [r7, #12]
 800e1e2:	1c5a      	adds	r2, r3, #1
 800e1e4:	60fa      	str	r2, [r7, #12]
 800e1e6:	2225      	movs	r2, #37	; 0x25
 800e1e8:	701a      	strb	r2, [r3, #0]
				  break;
 800e1ea:	bf00      	nop
			}
			fmt++;
 800e1ec:	68bb      	ldr	r3, [r7, #8]
 800e1ee:	3301      	adds	r3, #1
 800e1f0:	60bb      	str	r3, [r7, #8]
 800e1f2:	e007      	b.n	800e204 <ts_formatstring+0x10e>
		}
		/* Else just copy */
		else
		{
			*buf++ = *fmt++;
 800e1f4:	68fb      	ldr	r3, [r7, #12]
 800e1f6:	1c5a      	adds	r2, r3, #1
 800e1f8:	60fa      	str	r2, [r7, #12]
 800e1fa:	68ba      	ldr	r2, [r7, #8]
 800e1fc:	1c51      	adds	r1, r2, #1
 800e1fe:	60b9      	str	r1, [r7, #8]
 800e200:	7812      	ldrb	r2, [r2, #0]
 800e202:	701a      	strb	r2, [r3, #0]
	while(*fmt)
 800e204:	68bb      	ldr	r3, [r7, #8]
 800e206:	781b      	ldrb	r3, [r3, #0]
 800e208:	2b00      	cmp	r3, #0
 800e20a:	f47f af7d 	bne.w	800e108 <ts_formatstring+0x12>
		}
	}
	*buf = 0;
 800e20e:	68fb      	ldr	r3, [r7, #12]
 800e210:	2200      	movs	r2, #0
 800e212:	701a      	strb	r2, [r3, #0]

	return (int)(buf - start_buf);
 800e214:	68fb      	ldr	r3, [r7, #12]
 800e216:	461a      	mov	r2, r3
 800e218:	697b      	ldr	r3, [r7, #20]
 800e21a:	1ad3      	subs	r3, r2, r3
}
 800e21c:	4618      	mov	r0, r3
 800e21e:	3720      	adds	r7, #32
 800e220:	46bd      	mov	sp, r7
 800e222:	bd80      	pop	{r7, pc}

0800e224 <ts_formatlength>:
**            format string and va_list va
**  Returns:  Maximum length
**---------------------------------------------------------------------------
*/
int ts_formatlength(const char *fmt, va_list va)
{
 800e224:	b480      	push	{r7}
 800e226:	b085      	sub	sp, #20
 800e228:	af00      	add	r7, sp, #0
 800e22a:	6078      	str	r0, [r7, #4]
 800e22c:	6039      	str	r1, [r7, #0]
	int length = 0;
 800e22e:	2300      	movs	r3, #0
 800e230:	60fb      	str	r3, [r7, #12]
	while (*fmt)
 800e232:	e081      	b.n	800e338 <ts_formatlength+0x114>
	{
		if (*fmt == '%')
 800e234:	687b      	ldr	r3, [r7, #4]
 800e236:	781b      	ldrb	r3, [r3, #0]
 800e238:	2b25      	cmp	r3, #37	; 0x25
 800e23a:	d177      	bne.n	800e32c <ts_formatlength+0x108>
		{
			++fmt;
 800e23c:	687b      	ldr	r3, [r7, #4]
 800e23e:	3301      	adds	r3, #1
 800e240:	607b      	str	r3, [r7, #4]
			switch (*fmt)
 800e242:	687b      	ldr	r3, [r7, #4]
 800e244:	781b      	ldrb	r3, [r3, #0]
 800e246:	3b58      	subs	r3, #88	; 0x58
 800e248:	2b20      	cmp	r3, #32
 800e24a:	d86a      	bhi.n	800e322 <ts_formatlength+0xfe>
 800e24c:	a201      	add	r2, pc, #4	; (adr r2, 800e254 <ts_formatlength+0x30>)
 800e24e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e252:	bf00      	nop
 800e254:	0800e315 	.word	0x0800e315
 800e258:	0800e323 	.word	0x0800e323
 800e25c:	0800e323 	.word	0x0800e323
 800e260:	0800e323 	.word	0x0800e323
 800e264:	0800e323 	.word	0x0800e323
 800e268:	0800e323 	.word	0x0800e323
 800e26c:	0800e323 	.word	0x0800e323
 800e270:	0800e323 	.word	0x0800e323
 800e274:	0800e323 	.word	0x0800e323
 800e278:	0800e323 	.word	0x0800e323
 800e27c:	0800e323 	.word	0x0800e323
 800e280:	0800e2d9 	.word	0x0800e2d9
 800e284:	0800e2e7 	.word	0x0800e2e7
 800e288:	0800e323 	.word	0x0800e323
 800e28c:	0800e323 	.word	0x0800e323
 800e290:	0800e323 	.word	0x0800e323
 800e294:	0800e323 	.word	0x0800e323
 800e298:	0800e2e7 	.word	0x0800e2e7
 800e29c:	0800e323 	.word	0x0800e323
 800e2a0:	0800e323 	.word	0x0800e323
 800e2a4:	0800e323 	.word	0x0800e323
 800e2a8:	0800e323 	.word	0x0800e323
 800e2ac:	0800e323 	.word	0x0800e323
 800e2b0:	0800e323 	.word	0x0800e323
 800e2b4:	0800e323 	.word	0x0800e323
 800e2b8:	0800e323 	.word	0x0800e323
 800e2bc:	0800e323 	.word	0x0800e323
 800e2c0:	0800e2f5 	.word	0x0800e2f5
 800e2c4:	0800e323 	.word	0x0800e323
 800e2c8:	0800e2e7 	.word	0x0800e2e7
 800e2cc:	0800e323 	.word	0x0800e323
 800e2d0:	0800e323 	.word	0x0800e323
 800e2d4:	0800e315 	.word	0x0800e315
			{
			  case 'c':
		  		  va_arg(va, int);
 800e2d8:	683b      	ldr	r3, [r7, #0]
 800e2da:	3304      	adds	r3, #4
 800e2dc:	603b      	str	r3, [r7, #0]
				  ++length;
 800e2de:	68fb      	ldr	r3, [r7, #12]
 800e2e0:	3301      	adds	r3, #1
 800e2e2:	60fb      	str	r3, [r7, #12]
				  break;
 800e2e4:	e025      	b.n	800e332 <ts_formatlength+0x10e>
			  case 'd':
			  case 'i':
			  case 'u':
				  /* 32 bits integer is max 11 characters with minus sign */
				  length += 11;
 800e2e6:	68fb      	ldr	r3, [r7, #12]
 800e2e8:	330b      	adds	r3, #11
 800e2ea:	60fb      	str	r3, [r7, #12]
				  va_arg(va, int);
 800e2ec:	683b      	ldr	r3, [r7, #0]
 800e2ee:	3304      	adds	r3, #4
 800e2f0:	603b      	str	r3, [r7, #0]
				  break;
 800e2f2:	e01e      	b.n	800e332 <ts_formatlength+0x10e>
			  case 's':
			  	  {
			  		  char * str = va_arg(va, char *);
 800e2f4:	683b      	ldr	r3, [r7, #0]
 800e2f6:	1d1a      	adds	r2, r3, #4
 800e2f8:	603a      	str	r2, [r7, #0]
 800e2fa:	681b      	ldr	r3, [r3, #0]
 800e2fc:	60bb      	str	r3, [r7, #8]
			  		  while (*str++)
 800e2fe:	e002      	b.n	800e306 <ts_formatlength+0xe2>
			  			  ++length;
 800e300:	68fb      	ldr	r3, [r7, #12]
 800e302:	3301      	adds	r3, #1
 800e304:	60fb      	str	r3, [r7, #12]
			  		  while (*str++)
 800e306:	68bb      	ldr	r3, [r7, #8]
 800e308:	1c5a      	adds	r2, r3, #1
 800e30a:	60ba      	str	r2, [r7, #8]
 800e30c:	781b      	ldrb	r3, [r3, #0]
 800e30e:	2b00      	cmp	r3, #0
 800e310:	d1f6      	bne.n	800e300 <ts_formatlength+0xdc>
			  	  }
				  break;
 800e312:	e00e      	b.n	800e332 <ts_formatlength+0x10e>
			  case 'x':
			  case 'X':
				  /* 32 bits integer as hex is max 8 characters */
				  length += 8;
 800e314:	68fb      	ldr	r3, [r7, #12]
 800e316:	3308      	adds	r3, #8
 800e318:	60fb      	str	r3, [r7, #12]
				  va_arg(va, unsigned int);
 800e31a:	683b      	ldr	r3, [r7, #0]
 800e31c:	3304      	adds	r3, #4
 800e31e:	603b      	str	r3, [r7, #0]
				  break;
 800e320:	e007      	b.n	800e332 <ts_formatlength+0x10e>
			  default:
				  ++length;
 800e322:	68fb      	ldr	r3, [r7, #12]
 800e324:	3301      	adds	r3, #1
 800e326:	60fb      	str	r3, [r7, #12]
				  break;
 800e328:	bf00      	nop
 800e32a:	e002      	b.n	800e332 <ts_formatlength+0x10e>
			}
		}
		else
		{
			++length;
 800e32c:	68fb      	ldr	r3, [r7, #12]
 800e32e:	3301      	adds	r3, #1
 800e330:	60fb      	str	r3, [r7, #12]
		}
		++fmt;
 800e332:	687b      	ldr	r3, [r7, #4]
 800e334:	3301      	adds	r3, #1
 800e336:	607b      	str	r3, [r7, #4]
	while (*fmt)
 800e338:	687b      	ldr	r3, [r7, #4]
 800e33a:	781b      	ldrb	r3, [r3, #0]
 800e33c:	2b00      	cmp	r3, #0
 800e33e:	f47f af79 	bne.w	800e234 <ts_formatlength+0x10>
	}
	return length;
 800e342:	68fb      	ldr	r3, [r7, #12]
}
 800e344:	4618      	mov	r0, r3
 800e346:	3714      	adds	r7, #20
 800e348:	46bd      	mov	sp, r7
 800e34a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e34e:	4770      	bx	lr

0800e350 <sprintf>:
**            given character string according to the format parameter.
**  Returns:  Number of bytes written
**===========================================================================
*/
int sprintf(char *buf, const char *fmt, ...)
{
 800e350:	b40e      	push	{r1, r2, r3}
 800e352:	b580      	push	{r7, lr}
 800e354:	b085      	sub	sp, #20
 800e356:	af00      	add	r7, sp, #0
 800e358:	6078      	str	r0, [r7, #4]
	int length;
	va_list va;
	va_start(va, fmt);
 800e35a:	f107 0320 	add.w	r3, r7, #32
 800e35e:	60bb      	str	r3, [r7, #8]
	length = ts_formatstring(buf, fmt, va);
 800e360:	68ba      	ldr	r2, [r7, #8]
 800e362:	69f9      	ldr	r1, [r7, #28]
 800e364:	6878      	ldr	r0, [r7, #4]
 800e366:	f7ff fec6 	bl	800e0f6 <ts_formatstring>
 800e36a:	60f8      	str	r0, [r7, #12]
	va_end(va);
	return length;
 800e36c:	68fb      	ldr	r3, [r7, #12]
}
 800e36e:	4618      	mov	r0, r3
 800e370:	3714      	adds	r7, #20
 800e372:	46bd      	mov	sp, r7
 800e374:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800e378:	b003      	add	sp, #12
 800e37a:	4770      	bx	lr

0800e37c <printf>:
**  Returns:  Number of bytes written
**
**===========================================================================
*/
int printf(const char *fmt, ...)
{
 800e37c:	b40f      	push	{r0, r1, r2, r3}
 800e37e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800e382:	b085      	sub	sp, #20
 800e384:	af00      	add	r7, sp, #0
	int length = 0;
 800e386:	2300      	movs	r3, #0
 800e388:	60fb      	str	r3, [r7, #12]
	va_list va;
	va_start(va, fmt);
 800e38a:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800e38e:	603b      	str	r3, [r7, #0]
	length = ts_formatlength(fmt, va);
 800e390:	6839      	ldr	r1, [r7, #0]
 800e392:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800e394:	f7ff ff46 	bl	800e224 <ts_formatlength>
 800e398:	60f8      	str	r0, [r7, #12]
	va_end(va);
	{
 800e39a:	466b      	mov	r3, sp
 800e39c:	461e      	mov	r6, r3
		char buf[length];
 800e39e:	68f9      	ldr	r1, [r7, #12]
 800e3a0:	1e4b      	subs	r3, r1, #1
 800e3a2:	60bb      	str	r3, [r7, #8]
 800e3a4:	460b      	mov	r3, r1
 800e3a6:	461a      	mov	r2, r3
 800e3a8:	f04f 0300 	mov.w	r3, #0
 800e3ac:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 800e3b0:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
 800e3b4:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 800e3b8:	460b      	mov	r3, r1
 800e3ba:	461a      	mov	r2, r3
 800e3bc:	f04f 0300 	mov.w	r3, #0
 800e3c0:	00dd      	lsls	r5, r3, #3
 800e3c2:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 800e3c6:	00d4      	lsls	r4, r2, #3
 800e3c8:	460b      	mov	r3, r1
 800e3ca:	3307      	adds	r3, #7
 800e3cc:	08db      	lsrs	r3, r3, #3
 800e3ce:	00db      	lsls	r3, r3, #3
 800e3d0:	ebad 0d03 	sub.w	sp, sp, r3
 800e3d4:	466b      	mov	r3, sp
 800e3d6:	3300      	adds	r3, #0
 800e3d8:	607b      	str	r3, [r7, #4]
		va_start(va, fmt);
 800e3da:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800e3de:	603b      	str	r3, [r7, #0]
		length = ts_formatstring(buf, fmt, va);
 800e3e0:	687b      	ldr	r3, [r7, #4]
 800e3e2:	683a      	ldr	r2, [r7, #0]
 800e3e4:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800e3e6:	4618      	mov	r0, r3
 800e3e8:	f7ff fe85 	bl	800e0f6 <ts_formatstring>
 800e3ec:	60f8      	str	r0, [r7, #12]
		length = _write(1, buf, length);
 800e3ee:	687b      	ldr	r3, [r7, #4]
 800e3f0:	68fa      	ldr	r2, [r7, #12]
 800e3f2:	4619      	mov	r1, r3
 800e3f4:	2001      	movs	r0, #1
 800e3f6:	f000 f91a 	bl	800e62e <_write>
 800e3fa:	60f8      	str	r0, [r7, #12]
 800e3fc:	46b5      	mov	sp, r6
		va_end(va);
	}
	return length;
 800e3fe:	68fb      	ldr	r3, [r7, #12]
}
 800e400:	4618      	mov	r0, r3
 800e402:	3714      	adds	r7, #20
 800e404:	46bd      	mov	sp, r7
 800e406:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800e40a:	b004      	add	sp, #16
 800e40c:	4770      	bx	lr
	...

0800e410 <udp_echoserver_init>:
  * @brief  Initialize the server application.
  * @param  None
  * @retval None
  */
void udp_echoserver_init(void)
{
 800e410:	b580      	push	{r7, lr}
 800e412:	b082      	sub	sp, #8
 800e414:	af00      	add	r7, sp, #0
   struct udp_pcb *upcb;
   err_t err;
   
   /* Create a new UDP control block  */
   upcb = udp_new();
 800e416:	f7fe fb83 	bl	800cb20 <udp_new>
 800e41a:	6078      	str	r0, [r7, #4]
   
   if (upcb)
 800e41c:	687b      	ldr	r3, [r7, #4]
 800e41e:	2b00      	cmp	r3, #0
 800e420:	d015      	beq.n	800e44e <udp_echoserver_init+0x3e>
   {
     /* Bind the upcb to the UDP_PORT port */
     /* Using IP_ADDR_ANY allow the upcb to be used by any local interface */
      err = udp_bind(upcb, IP_ADDR_ANY, UDP_SERVER_PORT);
 800e422:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 800e426:	490d      	ldr	r1, [pc, #52]	; (800e45c <udp_echoserver_init+0x4c>)
 800e428:	6878      	ldr	r0, [r7, #4]
 800e42a:	f7fe faa1 	bl	800c970 <udp_bind>
 800e42e:	4603      	mov	r3, r0
 800e430:	70fb      	strb	r3, [r7, #3]
      
      if(err == ERR_OK)
 800e432:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e436:	2b00      	cmp	r3, #0
 800e438:	d105      	bne.n	800e446 <udp_echoserver_init+0x36>
      {
        /* Set a receive callback for the upcb */
        udp_recv(upcb, udp_echoserver_receive_callback, NULL);
 800e43a:	2200      	movs	r2, #0
 800e43c:	4908      	ldr	r1, [pc, #32]	; (800e460 <udp_echoserver_init+0x50>)
 800e43e:	6878      	ldr	r0, [r7, #4]
 800e440:	f7fe fb5c 	bl	800cafc <udp_recv>
   }
   else
   {
     printf("can not create pcb");
   } 
}
 800e444:	e006      	b.n	800e454 <udp_echoserver_init+0x44>
        printf("can not bind pcb");
 800e446:	4807      	ldr	r0, [pc, #28]	; (800e464 <udp_echoserver_init+0x54>)
 800e448:	f7ff ff98 	bl	800e37c <printf>
}
 800e44c:	e002      	b.n	800e454 <udp_echoserver_init+0x44>
     printf("can not create pcb");
 800e44e:	4806      	ldr	r0, [pc, #24]	; (800e468 <udp_echoserver_init+0x58>)
 800e450:	f7ff ff94 	bl	800e37c <printf>
}
 800e454:	bf00      	nop
 800e456:	3708      	adds	r7, #8
 800e458:	46bd      	mov	sp, r7
 800e45a:	bd80      	pop	{r7, pc}
 800e45c:	0801b568 	.word	0x0801b568
 800e460:	0800e46d 	.word	0x0800e46d
 800e464:	0800e884 	.word	0x0800e884
 800e468:	0800e898 	.word	0x0800e898

0800e46c <udp_echoserver_receive_callback>:
  * @param addr the remote IP address from which the packet was received
  * @param port the remote port from which the packet was received
  * @retval None
  */
void udp_echoserver_receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
 800e46c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e46e:	b08b      	sub	sp, #44	; 0x2c
 800e470:	af04      	add	r7, sp, #16
 800e472:	60f8      	str	r0, [r7, #12]
 800e474:	60b9      	str	r1, [r7, #8]
 800e476:	607a      	str	r2, [r7, #4]
 800e478:	603b      	str	r3, [r7, #0]
	struct pbuf *rsp;

	rsp = pbuf_alloc(PBUF_TRANSPORT,80,PBUF_POOL);
 800e47a:	2203      	movs	r2, #3
 800e47c:	2150      	movs	r1, #80	; 0x50
 800e47e:	2000      	movs	r0, #0
 800e480:	f7f9 ffc6 	bl	8008410 <pbuf_alloc>
 800e484:	6178      	str	r0, [r7, #20]

	sprintf(rsp->payload,"%u.%u.%u.%u : %u msg: %s",addr->addr&255,(addr->addr>>8)&255,(addr->addr>>16)&255,(addr->addr>>24)&255,port,(char *)p->payload);
 800e486:	697b      	ldr	r3, [r7, #20]
 800e488:	685c      	ldr	r4, [r3, #4]
 800e48a:	683b      	ldr	r3, [r7, #0]
 800e48c:	681b      	ldr	r3, [r3, #0]
 800e48e:	b2dd      	uxtb	r5, r3
 800e490:	683b      	ldr	r3, [r7, #0]
 800e492:	681b      	ldr	r3, [r3, #0]
 800e494:	0a1b      	lsrs	r3, r3, #8
 800e496:	b2de      	uxtb	r6, r3
 800e498:	683b      	ldr	r3, [r7, #0]
 800e49a:	681b      	ldr	r3, [r3, #0]
 800e49c:	0c1b      	lsrs	r3, r3, #16
 800e49e:	b2db      	uxtb	r3, r3
 800e4a0:	683a      	ldr	r2, [r7, #0]
 800e4a2:	6812      	ldr	r2, [r2, #0]
 800e4a4:	0e12      	lsrs	r2, r2, #24
 800e4a6:	8e39      	ldrh	r1, [r7, #48]	; 0x30
 800e4a8:	6878      	ldr	r0, [r7, #4]
 800e4aa:	6840      	ldr	r0, [r0, #4]
 800e4ac:	9003      	str	r0, [sp, #12]
 800e4ae:	9102      	str	r1, [sp, #8]
 800e4b0:	9201      	str	r2, [sp, #4]
 800e4b2:	9300      	str	r3, [sp, #0]
 800e4b4:	4633      	mov	r3, r6
 800e4b6:	462a      	mov	r2, r5
 800e4b8:	490d      	ldr	r1, [pc, #52]	; (800e4f0 <udp_echoserver_receive_callback+0x84>)
 800e4ba:	4620      	mov	r0, r4
 800e4bc:	f7ff ff48 	bl	800e350 <sprintf>

  /* Connect to the remote client */
  udp_connect(upcb, addr, port); //UDP_CLIENT_PORT);
 800e4c0:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800e4c2:	461a      	mov	r2, r3
 800e4c4:	6839      	ldr	r1, [r7, #0]
 800e4c6:	68b8      	ldr	r0, [r7, #8]
 800e4c8:	f7fe fab2 	bl	800ca30 <udp_connect>

  /* Tell the client that we have accepted it */
  udp_send(upcb, rsp);
 800e4cc:	6979      	ldr	r1, [r7, #20]
 800e4ce:	68b8      	ldr	r0, [r7, #8]
 800e4d0:	f7fe f986 	bl	800c7e0 <udp_send>

  /* free the UDP connection, so we can accept new clients */
  udp_disconnect(upcb);
 800e4d4:	68b8      	ldr	r0, [r7, #8]
 800e4d6:	f7fe faf7 	bl	800cac8 <udp_disconnect>
	
  /* Free the p buffer */
  pbuf_free(p);
 800e4da:	6878      	ldr	r0, [r7, #4]
 800e4dc:	f7fa f965 	bl	80087aa <pbuf_free>
  pbuf_free(rsp);
 800e4e0:	6978      	ldr	r0, [r7, #20]
 800e4e2:	f7fa f962 	bl	80087aa <pbuf_free>
}
 800e4e6:	bf00      	nop
 800e4e8:	371c      	adds	r7, #28
 800e4ea:	46bd      	mov	sp, r7
 800e4ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e4ee:	bf00      	nop
 800e4f0:	0800e8ac 	.word	0x0800e8ac

0800e4f4 <udp_client_init>:
  * @param None
  * @retval None
  */

void udp_client_init()
{
 800e4f4:	b580      	push	{r7, lr}
 800e4f6:	b082      	sub	sp, #8
 800e4f8:	af00      	add	r7, sp, #0
  err_t err;

  /* Create a new UDP control block  */
  client_upcb = udp_new();
 800e4fa:	f7fe fb11 	bl	800cb20 <udp_new>
 800e4fe:	4602      	mov	r2, r0
 800e500:	4b13      	ldr	r3, [pc, #76]	; (800e550 <udp_client_init+0x5c>)
 800e502:	601a      	str	r2, [r3, #0]

  if (client_upcb)
 800e504:	4b12      	ldr	r3, [pc, #72]	; (800e550 <udp_client_init+0x5c>)
 800e506:	681b      	ldr	r3, [r3, #0]
 800e508:	2b00      	cmp	r3, #0
 800e50a:	d019      	beq.n	800e540 <udp_client_init+0x4c>
  {
    /* Bind the upcb to the UDP_PORT port */
    /* Using IP_ADDR_ANY allow the upcb to be used by any local interface */
     err = udp_bind(client_upcb, IP_ADDR_ANY, UDP_CLIENT_PORT);
 800e50c:	4b10      	ldr	r3, [pc, #64]	; (800e550 <udp_client_init+0x5c>)
 800e50e:	681b      	ldr	r3, [r3, #0]
 800e510:	f641 7241 	movw	r2, #8001	; 0x1f41
 800e514:	490f      	ldr	r1, [pc, #60]	; (800e554 <udp_client_init+0x60>)
 800e516:	4618      	mov	r0, r3
 800e518:	f7fe fa2a 	bl	800c970 <udp_bind>
 800e51c:	4603      	mov	r3, r0
 800e51e:	71fb      	strb	r3, [r7, #7]

     if(err == ERR_OK)
 800e520:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800e524:	2b00      	cmp	r3, #0
 800e526:	d107      	bne.n	800e538 <udp_client_init+0x44>
     {
       /* Set a receive callback for the upcb */
       udp_recv(client_upcb, udp_echoserver_receive_callback, NULL);
 800e528:	4b09      	ldr	r3, [pc, #36]	; (800e550 <udp_client_init+0x5c>)
 800e52a:	681b      	ldr	r3, [r3, #0]
 800e52c:	2200      	movs	r2, #0
 800e52e:	490a      	ldr	r1, [pc, #40]	; (800e558 <udp_client_init+0x64>)
 800e530:	4618      	mov	r0, r3
 800e532:	f7fe fae3 	bl	800cafc <udp_recv>
  }
  else
  {
    printf("can not create pcb");
  }
}
 800e536:	e006      	b.n	800e546 <udp_client_init+0x52>
       printf("can not bind pcb");
 800e538:	4808      	ldr	r0, [pc, #32]	; (800e55c <udp_client_init+0x68>)
 800e53a:	f7ff ff1f 	bl	800e37c <printf>
}
 800e53e:	e002      	b.n	800e546 <udp_client_init+0x52>
    printf("can not create pcb");
 800e540:	4807      	ldr	r0, [pc, #28]	; (800e560 <udp_client_init+0x6c>)
 800e542:	f7ff ff1b 	bl	800e37c <printf>
}
 800e546:	bf00      	nop
 800e548:	3708      	adds	r7, #8
 800e54a:	46bd      	mov	sp, r7
 800e54c:	bd80      	pop	{r7, pc}
 800e54e:	bf00      	nop
 800e550:	2000a390 	.word	0x2000a390
 800e554:	0801b568 	.word	0x0801b568
 800e558:	0800e46d 	.word	0x0800e46d
 800e55c:	0800e884 	.word	0x0800e884
 800e560:	0800e898 	.word	0x0800e898

0800e564 <udp_client>:
  * @param Mensaje a enviar (debe ser texto terminado en \0
  * @retval None
  */

void udp_client(struct ip_addr * addr, uint16_t port, char *txt)
{
 800e564:	b580      	push	{r7, lr}
 800e566:	b086      	sub	sp, #24
 800e568:	af00      	add	r7, sp, #0
 800e56a:	60f8      	str	r0, [r7, #12]
 800e56c:	460b      	mov	r3, r1
 800e56e:	607a      	str	r2, [r7, #4]
 800e570:	817b      	strh	r3, [r7, #10]
	struct pbuf *msg;

	if (client_upcb)
 800e572:	4b14      	ldr	r3, [pc, #80]	; (800e5c4 <udp_client+0x60>)
 800e574:	681b      	ldr	r3, [r3, #0]
 800e576:	2b00      	cmp	r3, #0
 800e578:	d020      	beq.n	800e5bc <udp_client+0x58>
	{
		msg = pbuf_alloc(PBUF_TRANSPORT, 80, PBUF_POOL);
 800e57a:	2203      	movs	r2, #3
 800e57c:	2150      	movs	r1, #80	; 0x50
 800e57e:	2000      	movs	r0, #0
 800e580:	f7f9 ff46 	bl	8008410 <pbuf_alloc>
 800e584:	6178      	str	r0, [r7, #20]
				(client_upcb->local_ip.addr >> 16) & 255,
				(client_upcb->local_ip.addr >> 24) & 255,
				client_upcb->local_port, txt);
*/

		sprintf(msg->payload, "%s", txt);
 800e586:	697b      	ldr	r3, [r7, #20]
 800e588:	685b      	ldr	r3, [r3, #4]
 800e58a:	6879      	ldr	r1, [r7, #4]
 800e58c:	4618      	mov	r0, r3
 800e58e:	f000 f88b 	bl	800e6a8 <strcpy>

		/* Connect to the remote client */
		udp_connect(client_upcb, addr, port);
 800e592:	4b0c      	ldr	r3, [pc, #48]	; (800e5c4 <udp_client+0x60>)
 800e594:	681b      	ldr	r3, [r3, #0]
 800e596:	897a      	ldrh	r2, [r7, #10]
 800e598:	68f9      	ldr	r1, [r7, #12]
 800e59a:	4618      	mov	r0, r3
 800e59c:	f7fe fa48 	bl	800ca30 <udp_connect>

		/* Tell the client that we have accepted it */
		udp_send(client_upcb, msg);
 800e5a0:	4b08      	ldr	r3, [pc, #32]	; (800e5c4 <udp_client+0x60>)
 800e5a2:	681b      	ldr	r3, [r3, #0]
 800e5a4:	6979      	ldr	r1, [r7, #20]
 800e5a6:	4618      	mov	r0, r3
 800e5a8:	f7fe f91a 	bl	800c7e0 <udp_send>

		/* free the UDP connection, so we can accept new clients */
		udp_disconnect(client_upcb);
 800e5ac:	4b05      	ldr	r3, [pc, #20]	; (800e5c4 <udp_client+0x60>)
 800e5ae:	681b      	ldr	r3, [r3, #0]
 800e5b0:	4618      	mov	r0, r3
 800e5b2:	f7fe fa89 	bl	800cac8 <udp_disconnect>

		/* Free the msg buffer */
		pbuf_free(msg);
 800e5b6:	6978      	ldr	r0, [r7, #20]
 800e5b8:	f7fa f8f7 	bl	80087aa <pbuf_free>
	}
}
 800e5bc:	bf00      	nop
 800e5be:	3718      	adds	r7, #24
 800e5c0:	46bd      	mov	sp, r7
 800e5c2:	bd80      	pop	{r7, pc}
 800e5c4:	2000a390 	.word	0x2000a390

0800e5c8 <Default_Reset_Handler>:
  *         supplied main() routine is called.
  * @param  None
  * @retval None
  */
void Default_Reset_Handler(void)
{
 800e5c8:	b580      	push	{r7, lr}
 800e5ca:	b082      	sub	sp, #8
 800e5cc:	af00      	add	r7, sp, #0
  /* Initialize data and bss */
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;
 800e5ce:	4b11      	ldr	r3, [pc, #68]	; (800e614 <zero_loop+0x1c>)
 800e5d0:	607b      	str	r3, [r7, #4]

  for(pulDest = &_sdata; pulDest < &_edata; )
 800e5d2:	4b11      	ldr	r3, [pc, #68]	; (800e618 <zero_loop+0x20>)
 800e5d4:	603b      	str	r3, [r7, #0]
 800e5d6:	e007      	b.n	800e5e8 <Default_Reset_Handler+0x20>
  {
    *(pulDest++) = *(pulSrc++);
 800e5d8:	683b      	ldr	r3, [r7, #0]
 800e5da:	1d1a      	adds	r2, r3, #4
 800e5dc:	603a      	str	r2, [r7, #0]
 800e5de:	687a      	ldr	r2, [r7, #4]
 800e5e0:	1d11      	adds	r1, r2, #4
 800e5e2:	6079      	str	r1, [r7, #4]
 800e5e4:	6812      	ldr	r2, [r2, #0]
 800e5e6:	601a      	str	r2, [r3, #0]
  for(pulDest = &_sdata; pulDest < &_edata; )
 800e5e8:	683b      	ldr	r3, [r7, #0]
 800e5ea:	4a0c      	ldr	r2, [pc, #48]	; (800e61c <zero_loop+0x24>)
 800e5ec:	4293      	cmp	r3, r2
 800e5ee:	d3f3      	bcc.n	800e5d8 <Default_Reset_Handler+0x10>
  }
  
  /* Zero fill the bss segment.  This is done with inline assembly since this
     will clear the value of pulDest if it is not kept in a register. */
  __asm("  ldr     r0, =_sbss\n"
 800e5f0:	480b      	ldr	r0, [pc, #44]	; (800e620 <zero_loop+0x28>)
 800e5f2:	490c      	ldr	r1, [pc, #48]	; (800e624 <zero_loop+0x2c>)
 800e5f4:	f04f 0200 	mov.w	r2, #0

0800e5f8 <zero_loop>:
 800e5f8:	4288      	cmp	r0, r1
 800e5fa:	bfb8      	it	lt
 800e5fc:	f840 2b04 	strlt.w	r2, [r0], #4
 800e600:	dbfa      	blt.n	800e5f8 <zero_loop>
        "    cmp     r0, r1\n"
        "    it      lt\n"
        "    strlt   r2, [r0], #4\n"
        "    blt     zero_loop");

  SystemInit();
 800e602:	f7f5 fc61 	bl	8003ec8 <SystemInit>

  /* Call the application's entry point.*/
  main();
 800e606:	f7ff fb31 	bl	800dc6c <main>
}
 800e60a:	bf00      	nop
 800e60c:	3708      	adds	r7, #8
 800e60e:	46bd      	mov	sp, r7
 800e610:	bd80      	pop	{r7, pc}
 800e612:	bf00      	nop
 800e614:	0801b5e0 	.word	0x0801b5e0
 800e618:	20000000 	.word	0x20000000
 800e61c:	2000005c 	.word	0x2000005c
 800e620:	2000085c 	.word	0x2000085c
 800e624:	2000a394 	.word	0x2000a394

0800e628 <ADC_IRQHandler>:
  *         preserving the system state for examination by a debugger.
  * @param  None
  * @retval None
  */
static void Default_Handler(void)
{
 800e628:	b480      	push	{r7}
 800e62a:	af00      	add	r7, sp, #0
	/* Go into an infinite loop. */
	while (1)
 800e62c:	e7fe      	b.n	800e62c <ADC_IRQHandler+0x4>

0800e62e <_write>:
{
  return 0;
}

int _write(int file, char *ptr, int len)
{
 800e62e:	b480      	push	{r7}
 800e630:	b085      	sub	sp, #20
 800e632:	af00      	add	r7, sp, #0
 800e634:	60f8      	str	r0, [r7, #12]
 800e636:	60b9      	str	r1, [r7, #8]
 800e638:	607a      	str	r2, [r7, #4]
  return len;
 800e63a:	687b      	ldr	r3, [r7, #4]
}
 800e63c:	4618      	mov	r0, r3
 800e63e:	3714      	adds	r7, #20
 800e640:	46bd      	mov	sp, r7
 800e642:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e646:	4770      	bx	lr

0800e648 <memcmp>:
 800e648:	b510      	push	{r4, lr}
 800e64a:	3901      	subs	r1, #1
 800e64c:	4402      	add	r2, r0
 800e64e:	4290      	cmp	r0, r2
 800e650:	d101      	bne.n	800e656 <memcmp+0xe>
 800e652:	2000      	movs	r0, #0
 800e654:	bd10      	pop	{r4, pc}
 800e656:	f810 3b01 	ldrb.w	r3, [r0], #1
 800e65a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800e65e:	42a3      	cmp	r3, r4
 800e660:	d0f5      	beq.n	800e64e <memcmp+0x6>
 800e662:	1b18      	subs	r0, r3, r4
 800e664:	bd10      	pop	{r4, pc}

0800e666 <memcpy>:
 800e666:	b510      	push	{r4, lr}
 800e668:	1e43      	subs	r3, r0, #1
 800e66a:	440a      	add	r2, r1
 800e66c:	4291      	cmp	r1, r2
 800e66e:	d100      	bne.n	800e672 <memcpy+0xc>
 800e670:	bd10      	pop	{r4, pc}
 800e672:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e676:	f803 4f01 	strb.w	r4, [r3, #1]!
 800e67a:	e7f7      	b.n	800e66c <memcpy+0x6>

0800e67c <memset>:
 800e67c:	4402      	add	r2, r0
 800e67e:	4603      	mov	r3, r0
 800e680:	4293      	cmp	r3, r2
 800e682:	d100      	bne.n	800e686 <memset+0xa>
 800e684:	4770      	bx	lr
 800e686:	f803 1b01 	strb.w	r1, [r3], #1
 800e68a:	e7f9      	b.n	800e680 <memset+0x4>

0800e68c <strchr>:
 800e68c:	b2c9      	uxtb	r1, r1
 800e68e:	4603      	mov	r3, r0
 800e690:	f810 2b01 	ldrb.w	r2, [r0], #1
 800e694:	b11a      	cbz	r2, 800e69e <strchr+0x12>
 800e696:	4291      	cmp	r1, r2
 800e698:	d1f9      	bne.n	800e68e <strchr+0x2>
 800e69a:	4618      	mov	r0, r3
 800e69c:	4770      	bx	lr
 800e69e:	2900      	cmp	r1, #0
 800e6a0:	bf0c      	ite	eq
 800e6a2:	4618      	moveq	r0, r3
 800e6a4:	2000      	movne	r0, #0
 800e6a6:	4770      	bx	lr

0800e6a8 <strcpy>:
 800e6a8:	4603      	mov	r3, r0
 800e6aa:	f811 2b01 	ldrb.w	r2, [r1], #1
 800e6ae:	f803 2b01 	strb.w	r2, [r3], #1
 800e6b2:	2a00      	cmp	r2, #0
 800e6b4:	d1f9      	bne.n	800e6aa <strcpy+0x2>
 800e6b6:	4770      	bx	lr

0800e6b8 <strncmp>:
 800e6b8:	b510      	push	{r4, lr}
 800e6ba:	b16a      	cbz	r2, 800e6d8 <strncmp+0x20>
 800e6bc:	3901      	subs	r1, #1
 800e6be:	1884      	adds	r4, r0, r2
 800e6c0:	f810 3b01 	ldrb.w	r3, [r0], #1
 800e6c4:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800e6c8:	4293      	cmp	r3, r2
 800e6ca:	d103      	bne.n	800e6d4 <strncmp+0x1c>
 800e6cc:	42a0      	cmp	r0, r4
 800e6ce:	d001      	beq.n	800e6d4 <strncmp+0x1c>
 800e6d0:	2b00      	cmp	r3, #0
 800e6d2:	d1f5      	bne.n	800e6c0 <strncmp+0x8>
 800e6d4:	1a98      	subs	r0, r3, r2
 800e6d6:	bd10      	pop	{r4, pc}
 800e6d8:	4610      	mov	r0, r2
 800e6da:	bd10      	pop	{r4, pc}

0800e6dc <strstr>:
 800e6dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e6de:	7803      	ldrb	r3, [r0, #0]
 800e6e0:	b133      	cbz	r3, 800e6f0 <strstr+0x14>
 800e6e2:	4603      	mov	r3, r0
 800e6e4:	4618      	mov	r0, r3
 800e6e6:	1c5e      	adds	r6, r3, #1
 800e6e8:	781b      	ldrb	r3, [r3, #0]
 800e6ea:	b933      	cbnz	r3, 800e6fa <strstr+0x1e>
 800e6ec:	4618      	mov	r0, r3
 800e6ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e6f0:	780b      	ldrb	r3, [r1, #0]
 800e6f2:	2b00      	cmp	r3, #0
 800e6f4:	bf18      	it	ne
 800e6f6:	2000      	movne	r0, #0
 800e6f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e6fa:	1e4d      	subs	r5, r1, #1
 800e6fc:	1e44      	subs	r4, r0, #1
 800e6fe:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 800e702:	2a00      	cmp	r2, #0
 800e704:	d0f3      	beq.n	800e6ee <strstr+0x12>
 800e706:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 800e70a:	4297      	cmp	r7, r2
 800e70c:	4633      	mov	r3, r6
 800e70e:	d0f6      	beq.n	800e6fe <strstr+0x22>
 800e710:	e7e8      	b.n	800e6e4 <strstr+0x8>
	...

0800e714 <_init>:
 800e714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e716:	bf00      	nop
 800e718:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e71a:	bc08      	pop	{r3}
 800e71c:	469e      	mov	lr, r3
 800e71e:	4770      	bx	lr

0800e720 <_fini>:
 800e720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e722:	bf00      	nop
 800e724:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e726:	bc08      	pop	{r3}
 800e728:	469e      	mov	lr, r3
 800e72a:	4770      	bx	lr
